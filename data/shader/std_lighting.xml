<?xml version="1.0" encoding="utf-8" ?> 
<shader compiler="xmlshader" name="std_lighting">

  <?Include /shader/snippets/shaderframework-cg.inc ?>

  <?Include /shader/surface/cg-surface-classic.cginc ?>
  <?Include /shader/lighting/cg-light-classic.cginc ?>
  <?Include /shader/fog/cg-fog-sector.cginc ?>
  <?Include /shader/surface/cg-parallax.cginc ?>

  <?CgUseSharedCond texCoord "vars.\"tex glow\".texture" ?>
  <?CgUseSharedCond texCoordV2F "vars.\"tex glow\".texture" ?>

  <?Template CgProgram?>
  /* For a shader, information needs to flow from the application to the vertex
     program, the application to the fragment program and the vertex program
     to the fragment program:
       +-----+       +------------------+
       | App |------>|  Vertex Program  |
       +-----+\      +------------------+
	       \		    |
		\		    v
		 \   +------------------+
		  \->| Fragment Program |
		     +------------------+
    
    Currently, the VP->FP direction is realized with a structure returned from 
    the VP entry point (VertToFrag) and the app->FP and app->VP directions by 
    global variables of the snippets (they are mapped invisibly to the user).
   */
  
  /* This structure contains the information passed from the VP to the FP.
   */
  struct VertToFrag
  {
    // The projected vertex position.
    float4 Hposition : POSITION;
    
    VertToFrag_Framework framework;
    
    SurfaceClassic surfClassic;
    LightingClassic lightClassic;
    FogSector fog;
    Parallax parallax;
  };
  
  // The vertex program.
  VertToFrag VertexMain (float4 Position : POSITION,
			 /* The matrices are bound with the state.matrix.... semantics.
			  * For more info see the Cg and ARB_vertex_program docs.
			  */
			  uniform float4x4 ModelViewProj : state.matrix.mvp)
  {
    VertToFrag V2F;
  
    V2F.Hposition = mul (ModelViewProj, Position);
    V2F.surfClassic.SetupVert();
    V2F.lightClassic.SetupVert();
    V2F.fog.SetupVert();
    V2F.parallax.SetupVert();
  
    V2F.framework.SetupVert();
  
    return V2F;
  }
  
  // The fragment program.
  float4 FragmentMain (VertToFrag V2F, uniform sampler2D texGlow) : COLOR
  {
    V2F.framework.SetupFrag();
    
    float4 color = V2F.surfClassic.GetDiffuse (V2F.parallax.GetTCOffset()) * 
      float4 (V2F.lightClassic.IllumDiffuse(), 1);
    if (V2F.fog.HasFog())
    {
      color.rgb = lerp(color.rgb, V2F.fog.GetColor(), V2F.fog.GetIntensity());
    }
    <?if vars."tex glow".texture ?>
      color.rgb += tex2D (texGlow, texCoord).rgb;
    <?endif?>
    return color;
  }
  <?Endtemplate?>
  
  <?Template MyPass ?>
    <?if vars."tex glow".texture ?>
      <texture name="tex glow" destination="texGlow" />
    <?endif?>
  <?Endtemplate?>
  <?AddToList PassMappings MyPass?>
  
  <?Template CgVertexOptions?>
    <!-- We want position invariance here -->
    <compilerargs>-posinv</compilerargs>
  <?Endtemplate?>
  <?CgSetVertexFunc VertexMain ?>
  <?CgSetFragmentFunc FragmentMain ?>

  <?WriteShaderTechniques 150?>
  <?WriteShaderVars?>

  <!-- Last but not least, fall back to a fixed function version, for older
       hardware. -->
  <fallbackshader name="std_lighting_fixed" file="/shader/std_lighting_fixed.xml" />
</shader>
