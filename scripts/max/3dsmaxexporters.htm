<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0058)http://www.planeshift.it/download/temp/3dsMaxExporters.htm -->
<HTML><HEAD><TITLE>PlaneShift 3DSMax Exporters</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.2733.1800" name=GENERATOR></HEAD>
<BODY text=#000000 bgColor=#ffffff>
<H1>PlaneShift 3DSMax Exporters</H1>
<P>Author: Luca Pancallo (pancallo@netscape.net)</P>
<P>Disclaimer: Don't build a new game! Join the crew at http://www.planeshift.it 
to build THE game :)</P>
<P>Level Exporter Version 35<BR>Lights Exporter Version 03 (This script is for 
PS engine only, can't work in CS walktest)<BR>Sprite Exporter Version 05<BR>Fix 
Materials Version 04</P>
<P>3DSMax 5.0 (same scripts should still work on 3DSMax 4.0)</P>
<H2>Installation</H2>
<P>3DSMax exporters should arrive in a zip with this content:</P>
<UL>
  <LI>exportCSP.mcr (level exporter) 
  <LI>exportSprite.mcr (animated sprite exporter) 
  <LI>fixMaterials.mcr (used to fix the duplicate material generated by the 
  convertion between Maya and 3dsMax) 
  <LI>showMap.mcr (used to turn on/off the display of materials in the 
  viewports) 
  <LI>PSMaxMenus5.mnu (menus to show exporters in Max interface) </LI></UL>
<P>1) Copy all the *.mcr files to &lt;3dsMax Install Dir&gt;/ui/macroscripts</P>
<P>2) Copy PSMaxMenus5.mnu to &lt;3dsMax Install Dir&gt;/ui (if you have 3dsMax 
4.0 don't import this menu definition, but add them manually)</P>
<P>3) Launch 3dsmax, go to Customize-&gt;Customize User Interface. Select the 
"Menus" tab and click on "Load...". Select the PSMaxMenus5.mnu file.</P>
<P>4) Close 3dsmax and open it again. You should now have a PlaneShift menu in 
the main bar.</P>
<P>Note: The PSMaxMenus5.mnu is provided, but seems not to work on all 
installations if imported. If this happens perform these steps:</P>
<P>1) Copy all the *.mcr files to &lt;3dsMax Install Dir&gt;/ui/macroscripts</P>
<P>2) Launch 3ds Max, click on Customize -&gt; Customize GUI</P>
<P>3) Select the tab Menus, then create a new PlaneShift tab, then </P>
<H2>Modeling a level to be exported</H2>
<P>To be sure that the level you are modeling will be exported correctly, you 
must follow these guidelines.</P>
<H3>1. Room Properties</H3>
<P>Set the sector name by clicking on File&gt;File Properties. Select the Custom 
Tab, enter this data:</P>
<P>Name: roomname<BR>Type: Text<BR>Value: &lt;enter the roomname, e.g. 
laanxinside&gt;</P>
<P>Click on Add.</P>
<H3>2. Starting Position</H3>
<P>Every sector in CS has a starting position, this is where the player will 
appear. To set that we use the position of a 'Camera' object placed in the Max 
scene.</P>
<P>Click on Create-&gt;Cameras, select 'Target', place the camera where you want 
the starting position to be. If multiple cameras are present, the exporter uses 
the first one.</P>
<H3>3. Lights</H3>
<P>The converter supports:</P>
<UL>
  <LI>ambient light 
  <LI>positional lights </LI></UL>
<P>You can set the <B>ambient light</B> for your sector adding properties to the 
max level. Clicking on File&gt;File Properties. Select the Custom Tab, enter 
this data:</P>
<P>Name: red / Type: Text / Value: &lt;enter the value from 0 to 1&gt;<BR>Name: 
green / Type: Text / Value: &lt;enter the value from 0 to 1&gt;<BR>Name: blue / 
Type: Text / Value: &lt;enter the value from 0 to 1&gt;</P>
<P>If you do not specify these values, the engine will use it's default of 
red=0.2 green=0.2 blue=0.2</P>
<P>To add <B>positional lights</B> you should add 'Omni' lights. There are the 
only ones supported by the exporter. To place a new light click on 
Create-&gt;Lights-&gt;Omni.<BR></P>
<P>To have the same effect in PlaneShift and in 3DSMax you should define your 
omni light with these parameters:<BR>Under "General Parameters" you should 
have"Diffuse" and "Specular" checked, "Ambient Only" UNchecked.</P>
<P><B>Color:</B><BR>Colors can be defined in the RBG or HSV sections of the 
light.</P>
<P><B>Multiplier:</B><BR>Mutiplier is supported. Normal light intensity in 
PlaneShift can go from 0 to 1, if multiplier is used then it can go beyond 
1.</P>
<P></P>
<P><B>Range:</B><BR>The maximum range of the light is defined by the value of 
"Far Attenuation End" in Attenuation menu. This is considered also if you no 
attenuation is used (see below).</P>
<P><B>No Attenuation:</B><BR>If in section "Near Attenuation" the checkbox "Use" 
is NOT checked and in section "Far Attenuation" the checkbox "Use" is NOT 
checked, then the light will be defined in PlaneShift with parameter "No 
Attenuation", so light will be costant up to the maximum radius.<BR></P>
<P><B>Dynamic Lights:</B><BR>Lights can have a dynamically changing color. If 
this is the case, read the "Export Lights" chapter or more info on how to define 
hue changes.</P>
<P><B>Lightmap cell size:</B><BR>Every illuminated object has a lightmap 
associated. A pixel in the lightmap is created for every cellsize x cellsize 
pixels of texture size.<BR>Example: Using a size of 32, 1 pixel in the lightmap 
will be created every 32x32 pixel in the texture.<BR>Bigger cellsize means that 
less lumels are created to describe the illumination of an illuminated polygon 
this means less used ram but less defined shadows.</P>
<P>You can set the Lightmap cell size value with this procedure:</P>
<UL>
  <LI>
  <P>Clicking on File&gt;File Properties. Select the Custom Tab</P>
  <LI>
  <P>Enter this data:</P>
  <P>Name: lightmapsize<BR>Type: Text<BR>Value: &lt;enter the size, e.g. 16 or 
  32&gt;</P>
  <LI>
  <P>Click on Add.</P></LI></UL>
<P>If this entry is not specified the engine will use CS default (that is 
16).</P>
<P><B>Auto On/Off based on Threshold:<BR></B>Lights can be turned automatically 
on or off based on the value of another light (controller). This is used to turn 
on house/street lights at night and turn them off at sunrise. To enable this 
feature you must abide to these constraints:<BR>- the light that will turn 
on/off must <B>not</B> be dynamic, it should have a fixed light color during the 
day/night cycle.<BR>- the controller light must be named 'crystal' and should be 
dynamic. This light will be affected by other factors like rain. So depending on 
its intensity value will control the on/off of other lights.<BR>- there must be 
only one controller light for each sector.<BR>- All lights that should turn 
on/off must have these parameters set in the Custom Properties tab:</P>
<P>TURNONOFF_R=0.2<BR>TURNONOFF_G=0.2<BR>TURNONOFF_B=0.2<BR>TURNONOFF_FADE=1000</P>
<P>for RGB range is from 0 to 1, fade is expressed in msecs.</P>
<P>In the example above lights will turn off when the 'crystal' light is &gt;0.2 
and will turn on when the 'crystal' light is &lt;0.2</P>
<P>Lights with same RGB threshold values are packed in one event for the game, 
so performances will be better if you give lights same threshold values.</P>
<P><B>Lightning:</B> The engine now support a brief sequence that simulates a 
lightning, this sequence will be triggered randomly by the server in all the 
sectors with the lightining property set. To enable it :</P>
<UL>
  <LI>
  <P>Click on File&gt;File Properties. Select the Custom Tab</P>
  <LI>
  <P>Enter this data:</P>
  <P>Name: lightning<BR>Type: Text<BR>Value: yes</P>
  <LI>Click on Add. </LI></UL>
<P>&nbsp;</P>
<H3>4. Objects</H3>
<P>There are a number of supported CS properties that you can set in 3dsmax. 
Just select the object and right-click to open the object menu. Select 
"Properties...", then the tab "User Defined". In that window you can add the 
properties of the object. Be sure to use same case, properties are case 
sensitive.</P>
<P><B>Smooth</B>: changes lightmap so the object will appear more round, if the 
object is not exposed to a light, it will not look rounded.<BR>Default is no 
smooth. You can activate that with:</P>
<UL>
  <LI>SMOOTH=yes </LI></UL>
<P><B>Shadows</B>: sprites don't cast shadow. Static objects normally cast 
shadows. You can disable shadows on static objects using that setting. Default 
is casting shadows.<BR></P>
<UL>
  <LI>NOSHADOWS=yes </LI></UL>
<P><B>Lighting</B>: Static objects are normally lit by the surrounding lights. 
You can disable this and have the object shine by himself. Default is to be 
affected by external lighting.<BR></P>
<UL>
  <LI>LIGHTING=no </LI></UL>
<P><B>Collision Detection</B>: Normally you can't pass through objects, they 
will collide with other objects and stop them. You can disable collision 
detection so you can move through it. Default is collision detection 
yes.<BR></P>
<UL>
  <LI>COLLDET=no </LI></UL>
<P><B>Invisible faces:</B> You can set some faces to be invisible in CS. Imagine 
you have a box, but you want 1 face to be invisible. You can surely remove that 
face, but it seems that Dynavis works better if you keep that face and set it as 
invisible. So Dynavis will consider the object closed, and you will have the 
same visual effect. To set a face as invisible, create a new material with 
texture "csinvisible.tga" (this IS case-sensitive) and assign it to the faces 
you want to be invisible. Those faces will be flagged as LIGHTING=no and 
INVISIBLE=yes.</P>
<P><B>Trasparency:</B> If an object has a trasparent texture, CS must be aware 
of that. To give this information to CS you have to name all trasparent objects 
with a "_t_" prefix. Example: _t_glass01. This is the name of Max object. There 
is no problem in setting a different name for the texture.</P>
<P><B>Sky:</B> Sky objects must have a different rendering priority in CS, to 
set an object as a sky object (like the bounding box of your level) name it with 
prefix "_sky_". Example: _sky_box01.</P>
<P><B>VisCull</B>: If you set this property to off the object will not be 
considered for visibility culling purposes. Default is on.</P>
<UL>
  <LI>VISCULL=no </LI></UL>
<P><B>CullerOnly:</B> If you set this property the object will be used only for 
culling purposes, so the object will be invisible.</P>
<UL>
  <LI>CULLERONLY=yes </LI></UL>
<P>&nbsp;</P>
<H3>5. Textures</H3>
<P>Both Standard Materials and Multi/Sub Materials are supported. The name of 
the texture is NOT important, the exporter looks at the actual filename attached 
to the material.</P>
<P>See Invisible Faces in the previous chapter.</P>
<P>&nbsp;</P>
<H3>6. Portals</H3>
<P>CS uses portals to connect different sectors. To add a portal to a 3dsmax 
scene follow this guidelines:</P>
<UL>
  <LI>the object name must start with "_p_" . For example "_p_laanx1" is a valid 
  portal name. 
  <LI>it MUST be a mesh with 2 planar triangle polygons (a square similar to a 
  door is perfect). 
  <LI>add a property to the object (see 'Objects' chapter for details on how to 
  add a property) called "PORTAL" that points to the roomname of the sector 
  where that portal will lead to.<BR>Example: PORTAL=plaza </LI></UL>
<H3>&nbsp;</H3>
<H3>7. Emitters</H3>
<P>We currently support a number of particle emitters, those are listed below. 
To add an emitter to a 3dsmax scene select the "Create" tab (the one you use for 
creating Boxes) and click on the Helpers icon. Select "Point" helper and add 
that to the scene where you want to place the emitter. "Point" has a properties 
page like other objects.<BR><BR>All emitter use a default <B>texture</B>: 
raindrop.png. If you want to specify a different texture you can just add a 
property to the Point object called MATERIAL. ex.: MATERIAL=icedrop.png</P>
<P>All emitter use a default <B>mixmode</B>: add. If you want to specify a 
different mixmode you can just add a property to the Point object called 
MIXMODE. Available mixmodes are: add, copy, mult2, mult, alpha, transparent, 
keycolor, tiling. ex.: MIXMODE=copy</P>
<P><B>Fire</B>: Used for torches, campfires, etc... Add ALL those properties to 
the object</P>
<UL>
  <LI>TYPE=fire 
  <LI>NUMBER=25 
  <LI>DROPSIZE=0.1,0.1 
  <LI>LIGHTING=off 
  <LI>SWIRL=1.8 
  <LI>COLORSCALE=0.15 </LI></UL>
<P><B>Emit:</B> Can produce a great amount of effects because is highly 
customizable. Add those properties to the object. </P>
<UL>
  <LI>TYPE=emit 
  <LI>NUMBER=250<BR><BR>
  <LI>REGULARPARTICLES=4,0.1<BR>(where first parameter is sides and second is 
  radius) <BR>or <BR>RECTPARTICLES=4,0.1<BR>(where first parameter is width and 
  second is height) <BR><BR>
  <LI>LIGHTING=off 
  <LI>TOTALTIME=4000<BR><BR>
  <LI>STARTPOS1=EMITSPHERE<BR>STARTPOS2=0,0.1<BR>or<BR>STARTPOS1=EMITFIXED<BR>STARTPOS2=0,0 
  (in this case this parameter is not used, but must be 
  present)<BR>or<BR>STARTPOS1=EMITBOX<BR>STARTPOS2=-1,-1,-1,1,1,1 (the parameter 
  is NOT scaled! it must have final coords)<BR><BR>
  <LI>STARTSPEED=EMITBOX(-1,-1,-1,1,1,1) (the parameter is NOT scaled! it must 
  have final coords)<BR>or<BR>STARTSPEED=EMITFIXED(-1,-2,2)<BR><BR>
  <LI>STARTACCEL=EMITFIXED(0,0,0)<BR><BR>
  <LI>ATTRACTOR=Attractor02 
  <LI>ATTRACTORFORCE=0.5<BR><BR>
  <LI>AGING0=0,1.0,0.2,0.8,0.5,2.0,0.0,1.25<BR>AGING1=1000,1.0,0.8,0.2,1.0,1.5,0.0,0.75<BR>AGING2=2000,1.0,0.2,0.8,0.5,1.0,0.0,1.0<BR>AGING3=3000,1.0,0.8,0.2,1.0,0.5,0.0,0.5<BR>AGING4=4000,1.0,0.2,0.8,0.5,0.0,0.0,0.25 
  </LI></UL>
<P>The AGING part is really important, there you can set what happens to the 
emitter during time. Here is the meaning of the fields used in AGING line:</P>
<P>AGING0=&lt;time&gt;,&lt;color red&gt;,&lt;color green&gt;,&lt;color 
blue&gt;,&lt;alpha&gt;,&lt;swirl&gt;,&lt;rotspeed&gt;,&lt;scale&gt;</P>
<P>An Emit <B>MUST</B> have an attractor. This is where the particles will be 
attracted through the time cycle described in the AGING fields. In the ATTRACTOR 
field you have to set the 3dsmax Point Object that will use that.</P>
<P><B>Aging:</B> Aging is optional and can range from 0 to 5 entries.</P>
<P><B>Attractor:</B> Used in combination with the Emit, has only one property 
that tells the exporter that it must be not considered as a stand-alone 
emitter.</P>
<UL>
  <LI>TYPE=hidden </LI></UL>
<P>&nbsp;</P>
<H3>8. Genmeshes</H3>
<P>Genmeshes are used to reduce the amount of geometry CS will handle. You can 
define a "factory" object (example: a stone) and then copy it in several places 
of the level. If it's a genmesh the copies will have only the location and the 
rotation associated, all the geometry will be identical to the "factory" object. 
This saves a lot of memory.</P>
<P>To define a genmesh factory you should:</P>
<UL>
  <LI>Define a valid name 
  <UL>
    <LI>name it with a starting "_g_" prefix 
    <LI>name it with a unique identifier that will be used on copies. eg.: 
    "_g_stone01" 
    <LI>add a "_0" to the end of the name to tell the exporter that this is a 
    factory. 
    <LI>A valid factory name is: "_g_stone01_0". Invalid names are: 
    "_g_stone_big_0", in this case this will not be considered a factory. 
  </LI></UL>
  <LI>Move the factory object to 0,0,0. This will be used as a reference for the 
  position of all other instances 
  <LI>Reset the pivot of the object to be "Centered on Object" </LI></UL>
<P>Please note that the factory is NOT exported in the scene, so it will be 
invisible in CS.</P>
<P>To define a "clone" or "instance" of a factory you should:</P>
<UL>
  <LI>Copy it from the factory. This ensure that pivot is set in the right 
  position and geometry remains the same. 
  <LI>name it with a starting "_g_" prefix 
  <LI>name it with the unique identifier defined on his factory. eg.: 
  "_g_stone01" 
  <LI>add a number or any other character at the end, after a "_" symbol. 
</LI></UL>
<P>A valid instance name is: "_g_stone01_1" or "_g_stone01_01" or 
"_g_stone01_233_23ws". </P>
<P>All genmeshes have the tiling <B>mixmode</B>.</P>
<P><B>Shadows</B>: genmeshes can have the same settings Objects have for shadows 
(see above).</P>
<P>&nbsp;</P>
<H3>9. Thingmeshes</H3>
<P>Thingmeshes are used to reduce the amount of geometry CS will handle. You can 
define a "factory" object (example: a house) and then copy it in several places 
of the level. If it's a thingmesh the copies will have only the location, 
rotation and texture associated, all the geometry will be identical to the 
"factory" object. This saves a lot of memory. The difference with genmeshes is 
that thingmesh instances can have a different texture from the factory, that 
thingmesh support multiple textures and that those "can receive light (check 
with Jorrit)".</P>
<P>To define a thingmesh factory you should:</P>
<UL>
  <LI>Define a valid name 
  <UL>
    <LI>name it with a starting "_f_" prefix 
    <LI>name it with a unique identifier that will be used on copies. eg.: 
    "_f_house01" 
    <LI>add a "_0" to the end of the name to tell the exporter that this is a 
    factory. 
    <LI>A valid factory name is: "_f_house01_0". Invalid names are: 
    "_f_house_big_0", in this case this will not be considered a factory. 
  </LI></UL>
  <LI>Move the factory object to 0,0,0. This will be used as a reference for the 
  position of all other instances 
  <LI>Reset the pivot of the object to be "Centered on Object" </LI></UL>
<P>Please note that the factory is NOT exported in the scene, so it will be 
invisible in CS.</P>
<P>To define a "clone" or "instance" of a factory you should:</P>
<UL>
  <LI>Copy it from the factory. This ensure that pivot is set in the right 
  position and geometry remains the same. 
  <LI>name it with a starting "_f_" prefix 
  <LI>name it with the unique identifier defined on his factory. eg.: 
  "_f_house01" 
  <LI>add a number or any other character at the end, after a "_" symbol. 
</LI></UL>
<P>A valid instance name is: "_f_house01_1" or "_f_house01_01" or 
"_f_house01_233_23ws".</P>
<P><B></B></P>
<H2>Modeling a Character to be exported</H2>
<P>[TODO]</P>
<P>Just remember that:</P>
<P>you can't weld UVs of vertexes that are not in the same x,y,z coords</P>
<P>[TODO] Attach points</P>
<H2>Export Level</H2>
<P>Select PlaneShift-&gt;Export Level.</P>
<P>This is the export dialog:</P>
<P><IMG height=273 src="3dsmaxexporters_files/3dsMaxExporters_img1.gif" 
width=303></P>
<P><B>Export Level To:</B> In the first field you should specify the export 
filename including its full path. Ex.: d:\myStuff\CS\levels\level1\world.txt</P>
<P><B>Scale:</B> This indicates which is the scale to apply to the current scene 
while exporting, if you follow the guideline of "1 meter = 1 generic unit" you 
can place "1" in this field.</P>
<P><B>Export!</B>: This button starts the export.</P>
<P><B>Copy textures to dest dir:</B> If you check this option, a new dir will be 
created in the same dir of the output file and will be called 
&lt;filename&gt;textures. In this directory there will be copied all the 
textures files present in the scene (the ones used by objects). Multimaterials 
are supported.</P>
<P><B>Generate Fake lights for walktest:</B> If you check this option, the 
exporter will add to the world file generated also some animations used to test 
the day/night setting of all lights present in the level. If you check this 
option you must add a value in the next field.</P>
<P><B>Duration (msecs):</B> tells the exporter how much time each hour (1 
frame=1 hour in max) will last in the fake light simulation.</P>
<P>&nbsp;</P>
<H2>Export Lights</H2>
<P>This command allows you to export the light information that will be used by 
PS engine to render lights at different times in the day. </P>
<P>Select PlaneShift-&gt;Export Lights.</P>
<P>Please note that:</P>
<UL>
  <LI>You must set the total frame number to 24 (from 0 to 23) or to 48 (from 0 
  to 47) 
  <LI>Every frame represents a certain time of the day: 1 frame for each hour 
  starting from 0:00 am (midnight) 
  <LI>You can add an OmniLight called "ambient" that represent the ambient 
  light. This light will not be exported as a normal light, the coordinates it 
  has are not relevant. 
  <LI>The lights will be exported to a separate xml file, but those MUST be the 
  same ones present when you exported the level. </LI></UL>
<P>The first 24 frames are used to get the light colors when the sun shines and 
no rain is present. The frames from 25 to 48 are used to get the light colors 
when the is heavily raining so the sun will be obscured by clouds and rain. The 
engine uses those extreme values to find the good ones when it's raining at 20%, 
50%, etc...</P>
<P>If you set the animation length to be 24 frames, then shining sun condition 
and heavy rain condition will have the same light color values.</P>
<P>&nbsp;</P>
<H2>Export Character</H2>
<P>Select PlaneShift-&gt;Export Sprite.</P>[14:34] <TALAD>we have 2 ways to 
export our chars [14:34] <TALAD>an old one and a new one [14:50] <TALAD>the old 
one just takes a number of mseconds and use this info to switch from one frame 
to the other [14:50] <TALAD>so it renders the first frame, then wait 100 msec, 
then second frame, then 100 msec...etcc [14:51] <TALAD>the problem of that 
method is that the number of frames in the animation makes the difference on the 
speed of the char [14:51] <TALAD>also if a char has short legs or long legs if 
doesn't make difference [14:51] <TALAD>so we have the new method to fix that. 
<BR><BR>[14:52] <TALAD>the new method calculates the displacements of the feet 
of the char. 
<P>[14:17] "vertex on foot" is one vertex that moves with the character. [14:17] 
<TALAD>those vertexes will be used to calculate displacement from one frame to 
the other, so it can be one random vertex of the foot. We choosed the outermost 
one to the back of the foot. [14:52] <TALAD>so you provide 2 vertexes, one for 
each feet [14:52] <TALAD>and it calculates the real movement of the vertex 
[14:52] <TALAD>the "displacement" of the vertex [14:52] <TALAD>based on that it 
moves the char in game. first foot on air is "foot 1" [14:18] <TALAD>"frame with 
foot 2 on the ground" is the first frame where the second foot touches the 
ground [14:19] <TALAD>from that point on, the displacement is calculated on 
vertex 2 and not on vertex 1</P>
<P>&nbsp;</P>
<H2>Rendering Priorities</H2>
<P>In Crystal Space you can define rendering priorities for objects. Currently 
we assign priorities with these rules:</P>
<UL>
  <LI>all "_t_" objects have "alpha" priority 
  <LI>all "_sky_" objects have "sky" priority 
  <LI>all "_p_" objects have "wall" priority 
  <LI>all "_s_" objects have "object" priority 
  <LI>all others objects have "object" priority </LI></UL>
<P>CS renders objects in this sequence:</P>
<OL>
  <LI>sky 
  <LI>wall 
  <LI>object 
  <LI>alpha </LI></OL>
<P>&nbsp;</P></BODY></HTML>
