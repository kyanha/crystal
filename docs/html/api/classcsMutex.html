<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csMutex Class Reference (Crystal Space Public API Reference)</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr height="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr height="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>csMutex Class Reference</h1><!-- doxytag: class="csMutex" --><!-- doxytag: inherits="csRefCount" -->A mutual-exclusion object.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="thread_8h-source.html">csutil/thread.h</a>&gt;</code>
<p>
Inheritance diagram for csMutex:<p><center><img src="classcsMutex__inherit__graph.png" border="0" usemap="#csMutex__inherit__map" alt="Inheritance graph"></center>
<map name="csMutex__inherit__map">
<area href="classcsRefCount.html" shape="rect" coords="8,9,98,33" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classcsMutex-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsMutex.html#720d9d9ecb07f64aaf5e8168ddd11b42">GetLastError</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the last error description, else 0 if there was none.  <a href="#720d9d9ecb07f64aaf5e8168ddd11b42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsMutex.html#02e3f6227490351ea8df0362bf4f24a9">IsRecursive</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the mutex is recursive.  <a href="#02e3f6227490351ea8df0362bf4f24a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsMutex.html#ca97fc194aff82b7fbab424a03f2711c">LockTry</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the mutex if not already locked by some other entity.  <a href="#ca97fc194aff82b7fbab424a03f2711c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsMutex.html#9e037cca32b323f1a590d53db570b134">LockWait</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the mutex.  <a href="#9e037cca32b323f1a590d53db570b134"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsMutex.html#ad4921586c4d05e0f008251993a85d74">Release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the mutex.  <a href="#ad4921586c4d05e0f008251993a85d74"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcsRef.html">csRef</a>&lt; <a class="el" href="classcsMutex.html">csMutex</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsMutex.html#04a7f6e1dcc9ba82ab51cf66eefc787b">Create</a> (bool recursive=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a mutex.  <a href="#04a7f6e1dcc9ba82ab51cf66eefc787b"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A mutual-exclusion object. 
<p>
A thread-safe lock. Mutexes are often used to control access to one or more resources shared by multiple threads of execution. A thread should access the shared resource(s) only after it has successfully locked the mutex; and it should unlock the mutex when it is done accessing the shared resource so that other threads may access it. 
<p>

<p>
Definition at line <a class="el" href="thread_8h-source.html#l00171">171</a> of file <a class="el" href="thread_8h-source.html">thread.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="04a7f6e1dcc9ba82ab51cf66eefc787b"></a><!-- doxytag: member="csMutex::Create" ref="04a7f6e1dcc9ba82ab51cf66eefc787b" args="(bool recursive=false)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static <a class="el" href="classcsRef.html">csRef</a>&lt;<a class="el" href="classcsMutex.html">csMutex</a>&gt; csMutex::Create           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>recursive</em> = <code>false</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a mutex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>recursive</em>&nbsp;</td><td>If true, the same thread can lock the mutex even when it already holds the lock without deadlocking. If false, then recursive locking within the same thread is not supported, and will probably deadlock. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The new mutex. </dd></dl>
<dl compact><dt><b>Remarks:</b></dt><dd>On Windows, mutexes always exhibit recursive semantics, however, for best portability, you should still choose an appropriate value for <em>recursive</em>. On other platforms, such as GNU/Linux, non-recursive threads may be the default since they are can be implemented more efficiently. </dd></dl>

<p>
Referenced by <a class="el" href="queue_8h-source.html#l00100">CS::SndSys::Queue&lt; StreamNotificationEvent &gt;::Queue()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="720d9d9ecb07f64aaf5e8168ddd11b42"></a><!-- doxytag: member="csMutex::GetLastError" ref="720d9d9ecb07f64aaf5e8168ddd11b42" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual char const* csMutex::GetLastError           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the last error description, else 0 if there was none. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="02e3f6227490351ea8df0362bf4f24a9"></a><!-- doxytag: member="csMutex::IsRecursive" ref="02e3f6227490351ea8df0362bf4f24a9" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool csMutex::IsRecursive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true if the mutex is recursive. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ca97fc194aff82b7fbab424a03f2711c"></a><!-- doxytag: member="csMutex::LockTry" ref="ca97fc194aff82b7fbab424a03f2711c" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool csMutex::LockTry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lock the mutex if not already locked by some other entity. 
<p>
Does not suspend the thread waiting for the lock. If lock succeeded, returns true. If lock failed, immediately returns false. Each successful call to <a class="el" href="classcsMutex.html#ca97fc194aff82b7fbab424a03f2711c">LockTry()</a> must be balanced with a call to <a class="el" href="classcsMutex.html#ad4921586c4d05e0f008251993a85d74">Release()</a>.     </td>
  </tr>
</table>
<a class="anchor" name="9e037cca32b323f1a590d53db570b134"></a><!-- doxytag: member="csMutex::LockWait" ref="9e037cca32b323f1a590d53db570b134" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool csMutex::LockWait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lock the mutex. 
<p>
Suspends execution of the thread until the mutex can be locked. Each <a class="el" href="classcsMutex.html#9e037cca32b323f1a590d53db570b134">LockWait()</a> must be balanced by a call to <a class="el" href="classcsMutex.html#ad4921586c4d05e0f008251993a85d74">Release()</a>. Returns true if locking succeeded. Returns false if locking failed for some catastrophic reason; check <a class="el" href="classcsMutex.html#720d9d9ecb07f64aaf5e8168ddd11b42">GetLastError()</a>.     </td>
  </tr>
</table>
<a class="anchor" name="ad4921586c4d05e0f008251993a85d74"></a><!-- doxytag: member="csMutex::Release" ref="ad4921586c4d05e0f008251993a85d74" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool csMutex::Release           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock the mutex. 
<p>
Each successful call to <a class="el" href="classcsMutex.html#9e037cca32b323f1a590d53db570b134">LockWait()</a> or <a class="el" href="classcsMutex.html#ca97fc194aff82b7fbab424a03f2711c">LockTry()</a> must be balanced by a call to <a class="el" href="classcsMutex.html#ad4921586c4d05e0f008251993a85d74">Release()</a>. Returns true if unlocking succeeded. Returns false if unlocking failed for some catastrophic reason; check <a class="el" href="classcsMutex.html#720d9d9ecb07f64aaf5e8168ddd11b42">GetLastError()</a>.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>csutil/<a class="el" href="thread_8h-source.html">thread.h</a></ul>
<hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.6 
</small></address> </div></body> </html>
