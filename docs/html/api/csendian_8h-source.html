<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/csendian.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>csutil/csendian.h</h1><a href="csendian_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 1998 by Jorrit Tyberghein</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_CSENDIAN_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_CSENDIAN_H__</span>
00021 <span class="preprocessor"></span>
00031 <span class="preprocessor">#include &lt;math.h&gt;</span>
00032 <span class="preprocessor">#include "<a class="code" href="cstypes_8h.html">cstypes.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="code" href="csqint_8h.html">csqint.h</a>"</span>
00034 
00035 <span class="keyword">struct </span>swap_4
00036 {
00037   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b1, b2, b3, b4;
00038 };
00039 
00040 <span class="keyword">struct </span>swap_8
00041 {
00042   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b1, b2, b3, b4,
00043                 b5, b6, b7, b8;
00044 };
00045 
00046 <span class="preprocessor">#ifdef CS_BIG_ENDIAN</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_longlong(x) x</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_long(x)  x</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_short(x) x</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_float(x) x</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00052 <span class="preprocessor"></span>
<a name="l00054"></a><a class="code" href="group__util.html#a17">00054</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint64 <a class="code" href="group__util.html#a17">big_endian_longlong</a> (uint64 l)
00055 {
00056   uint64 r;
00057   swap_8 *p1 = (swap_8 *)&amp;l;
00058   swap_8 *p2 = (swap_8 *)&amp;r;
00059   p2-&gt;b1 = p1-&gt;b8;
00060   p2-&gt;b2 = p1-&gt;b7;
00061   p2-&gt;b3 = p1-&gt;b6;
00062   p2-&gt;b4 = p1-&gt;b5;
00063   p2-&gt;b5 = p1-&gt;b4;
00064   p2-&gt;b6 = p1-&gt;b3;
00065   p2-&gt;b7 = p1-&gt;b2;
00066   p2-&gt;b8 = p1-&gt;b1;
00067   <span class="keywordflow">return</span> r;
00068 }
00069 
00070 
<a name="l00072"></a><a class="code" href="group__util.html#a18">00072</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a18">big_endian_long</a> (uint32 l)
00073 { <span class="keywordflow">return</span> (l &gt;&gt; 24) | ((l &gt;&gt; 8) &amp; 0xff00) | ((l &lt;&lt; 8) &amp; 0xff0000) | (l &lt;&lt; 24); }
00074 
<a name="l00076"></a><a class="code" href="group__util.html#a19">00076</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a19">big_endian_short</a> (<a class="code" href="group__util.html#a2">uint16</a> s)
00077 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a2">uint16</a>((s &gt;&gt; 8) | (s &lt;&lt; 8)); }
00078 
00080 <span class="comment">//@@WARNING: Should be removed -- use float2long instead</span>
<a name="l00081"></a><a class="code" href="group__util.html#a20">00081</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a20">big_endian_float</a> (<span class="keywordtype">float</span> f)
00082 {
00083   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp;
00084   swap_4 *pf = (swap_4 *)&amp;f;
00085   tmp = pf-&gt;b1; pf-&gt;b1 = pf-&gt;b4; pf-&gt;b4 = tmp;
00086   tmp = pf-&gt;b2; pf-&gt;b2 = pf-&gt;b3; pf-&gt;b3 = tmp;
00087   <span class="keywordflow">return</span> f;
00088 }
00089 
00090 <span class="preprocessor">#endif // CS_BIG_ENDIAN</span>
00091 <span class="preprocessor"></span>
00092 <span class="preprocessor">#ifdef CS_LITTLE_ENDIAN</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_longlong(x) x</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_long(x)  x</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_short(x) x</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_float(x) x</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00098 <span class="preprocessor"></span>
<a name="l00100"></a><a class="code" href="group__util.html#a21">00100</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint64 <a class="code" href="group__util.html#a21">little_endian_longlong</a> (uint64 l)
00101 {
00102   uint64 r;
00103   swap_8 *p1 = (swap_8 *)&amp;l;
00104   swap_8 *p2 = (swap_8 *)&amp;r;
00105   p2-&gt;b1 = p1-&gt;b8;
00106   p2-&gt;b2 = p1-&gt;b7;
00107   p2-&gt;b3 = p1-&gt;b6;
00108   p2-&gt;b4 = p1-&gt;b5;
00109   p2-&gt;b5 = p1-&gt;b4;
00110   p2-&gt;b6 = p1-&gt;b3;
00111   p2-&gt;b7 = p1-&gt;b2;
00112   p2-&gt;b8 = p1-&gt;b1;
00113   <span class="keywordflow">return</span> r;
00114 }
00115 
<a name="l00117"></a><a class="code" href="group__util.html#a22">00117</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a22">little_endian_long</a> (uint32 l)
00118 { <span class="keywordflow">return</span> (l &gt;&gt; 24) | ((l &gt;&gt; 8) &amp; 0xff00) | ((l &lt;&lt; 8) &amp; 0xff0000) | (l &lt;&lt; 24); }
00119 
<a name="l00121"></a><a class="code" href="group__util.html#a23">00121</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a23">little_endian_short</a> (<a class="code" href="group__util.html#a2">uint16</a> s)
00122 { <span class="keywordflow">return</span> (s &gt;&gt; 8) | (s &lt;&lt; 8); }
00123 
<a name="l00125"></a><a class="code" href="group__util.html#a24">00125</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a24">little_endian_float</a> (<span class="keywordtype">float</span> f)
00126 {
00127   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp;
00128   swap_4 *pf = (swap_4 *)&amp;f;
00129   tmp = pf-&gt;b1; pf-&gt;b1 = pf-&gt;b4; pf-&gt;b4 = tmp;
00130   tmp = pf-&gt;b2; pf-&gt;b2 = pf-&gt;b3; pf-&gt;b3 = tmp;
00131   <span class="keywordflow">return</span> f;
00132 }
00133 
00134 <span class="preprocessor">#endif // CS_LITTLE_ENDIAN</span>
00135 <span class="preprocessor"></span>
00136 <span class="comment">/*</span>
00137 <span class="comment">    To be able to painlessly transfer files betwen platforms, we should</span>
00138 <span class="comment">    avoid using native floating-point format. Here are a couple of routines</span>
00139 <span class="comment">    that are guaranteed to work on all platforms.</span>
00140 <span class="comment"></span>
00141 <span class="comment">    The floating point is converted to a fixed 1.7.25 bits format</span>
00142 <span class="comment">    (one bit sign, 7 bits exponent, 25 bits mantissa) and back,</span>
00143 <span class="comment">    so that we can binary store floating-point number without</span>
00144 <span class="comment">    cross-platform problems. If you wonder why 1+7+25 = 33 while we</span>
00145 <span class="comment">    only have 32 bits, we'll ommit the most significant bit of mantissa</span>
00146 <span class="comment">    since it is always 1 (we use normalized numbers). This increases the</span>
00147 <span class="comment">    precision twice.</span>
00148 <span class="comment"></span>
00149 <span class="comment">    For double, we use one bit sign, 15 bits exponent, 49 bits mantissa.</span>
00150 <span class="comment">*/</span>
00151 
<a name="l00153"></a><a class="code" href="group__util.html#a25">00153</a> <span class="keyword">static</span> <span class="keyword">inline</span> int32 <a class="code" href="group__util.html#a25">float2long</a> (<span class="keywordtype">float</span> f)
00154 {
00155   <span class="keywordtype">int</span> exp;
00156   int32 mant = <a class="code" href="group__floating__point.html#a1">csQround</a> (frexp (f, &amp;exp) * 0x1000000);
00157   int32 sign = mant &amp; 0x80000000;
00158   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00159   <span class="keywordflow">if</span> (exp &gt; 63) exp = 63; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -64) exp = -64;
00160   <span class="keywordflow">return</span> sign | ((exp &amp; 0x7f) &lt;&lt; 24) | (mant &amp; 0xffffff);
00161 }
00162 
<a name="l00164"></a><a class="code" href="group__util.html#a26">00164</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a26">long2float</a> (int32 l)
00165 {
00166   <span class="keywordtype">int</span> exp = (l &gt;&gt; 24) &amp; 0x7f;
00167   <span class="keywordflow">if</span> (exp &amp; 0x40) exp = exp | ~0x7f;
00168   <span class="keywordtype">float</span> mant = float (l &amp; 0x00ffffff) / 0x1000000;
00169   <span class="keywordflow">if</span> (l &amp; 0x80000000) mant = -mant;
00170   <span class="keywordflow">return</span> (float) ldexp (mant, exp);
00171 }
00172 
<a name="l00174"></a><a class="code" href="group__util.html#a27">00174</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a7">int64</a> <a class="code" href="group__util.html#a27">double2longlong</a> (<span class="keywordtype">double</span> d)
00175 {
00176   <span class="keywordtype">int</span> exp;
00177   <a class="code" href="group__util.html#a7">int64</a> mant = (int64) (frexp (d, &amp;exp) * <a class="code" href="group__util.html#a87">CONST_INT64</a>(0x1000000000000));
00178   <a class="code" href="group__util.html#a7">int64</a> sign = mant &amp; <a class="code" href="group__util.html#a87">CONST_INT64</a>(0x800000000000000);
00179   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00180   <span class="keywordflow">if</span> (exp &gt; 32767) exp = 32767; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -32768) exp = -32768;
00181   <span class="keywordflow">return</span> sign | ((<a class="code" href="group__util.html#a7">int64</a> (exp) &amp; 0x7fff) &lt;&lt; 48) | (mant &amp; <a class="code" href="group__util.html#a87">CONST_INT64</a>(0xffffffffffff));
00182 }
00183 
<a name="l00185"></a><a class="code" href="group__util.html#a28">00185</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__util.html#a28">longlong2double</a> (<a class="code" href="group__util.html#a7">int64</a> i)
00186 {
00187   <span class="keywordtype">int</span> exp = (i &gt;&gt; 48) &amp; 0x7fff;
00188   <span class="keywordflow">if</span> (exp &amp; 0x4000) exp = exp | ~0x7fff;
00189   <span class="keywordtype">double</span> mant = double (i &amp; <a class="code" href="group__util.html#a87">CONST_INT64</a>(0xffffffffffff)) / <a class="code" href="group__util.html#a87">CONST_INT64</a>(0x1000000000000);
00190   <span class="keywordflow">if</span> (i &amp; <a class="code" href="group__util.html#a87">CONST_INT64</a>(0x8000000000000000)) mant = -mant;
00191   <span class="keywordflow">return</span> ldexp (mant, exp);
00192 }
00193 
00202 
<a name="l00203"></a><a class="code" href="group__util.html#a29">00203</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">short</span> <a class="code" href="group__util.html#a29">float2short</a> (<span class="keywordtype">float</span> f)
00204 {
00205   <span class="keywordtype">int</span> exp;
00206   <span class="keywordtype">long</span> mant = <a class="code" href="group__floating__point.html#a1">csQround</a> (frexp (f, &amp;exp) * 0x1000);
00207   <span class="keywordtype">long</span> sign = mant &amp; 0x8000;
00208   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00209   <span class="keywordflow">if</span> (exp &gt; 7) mant = 0x7ff, exp = 7; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -8) mant = 0, exp = -8;
00210   <span class="keywordflow">return</span> short(sign | ((exp &amp; 0xf) &lt;&lt; 11) | (mant &amp; 0x7ff));
00211 }
00212 
<a name="l00214"></a><a class="code" href="group__util.html#a30">00214</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a30">short2float</a> (<span class="keywordtype">short</span> s)
00215 {
00216   <span class="keywordtype">int</span> exp = (s &gt;&gt; 11) &amp; 0xf;
00217   <span class="keywordflow">if</span> (exp &amp; 0x8) exp = exp | ~0xf;
00218   <span class="keywordtype">float</span> mant = float ((s &amp; 0x07ff) | 0x0800) / 0x1000;
00219   <span class="keywordflow">if</span> (s &amp; 0x8000) mant = -mant;
00220   <span class="keywordflow">return</span> (float) ldexp (mant, exp);
00221 }
00222 
<a name="l00224"></a><a class="code" href="group__util.html#a31">00224</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint64 <a class="code" href="group__util.html#a37">convert_endian</a> (uint64 l)
00225 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a21">little_endian_longlong</a> (l); }
00226 
<a name="l00228"></a><a class="code" href="group__util.html#a32">00228</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a7">int64</a> <a class="code" href="group__util.html#a37">convert_endian</a> (<a class="code" href="group__util.html#a7">int64</a> l)
00229 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a21">little_endian_longlong</a> (l); }
00230 
<a name="l00232"></a><a class="code" href="group__util.html#a33">00232</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a37">convert_endian</a> (uint32 l)
00233 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a22">little_endian_long</a> (l); }
00234 
<a name="l00236"></a><a class="code" href="group__util.html#a34">00236</a> <span class="keyword">static</span> <span class="keyword">inline</span> int32 <a class="code" href="group__util.html#a37">convert_endian</a> (int32 l)
00237 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a22">little_endian_long</a> (l); }
00238 
<a name="l00240"></a><a class="code" href="group__util.html#a35">00240</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a3">int16</a> <a class="code" href="group__util.html#a37">convert_endian</a> (<a class="code" href="group__util.html#a3">int16</a> s)
00241 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a23">little_endian_short</a> (s); }
00242 
<a name="l00244"></a><a class="code" href="group__util.html#a36">00244</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a37">convert_endian</a> (<a class="code" href="group__util.html#a2">uint16</a> s)
00245 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a23">little_endian_short</a> (s); }
00246 
<a name="l00248"></a><a class="code" href="group__util.html#a37">00248</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a37">convert_endian</a> (<span class="keywordtype">float</span> f)
00249 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">little_endian_float</a> (f); }
00250 
<a name="l00252"></a><a class="code" href="group__util.html#a38">00252</a> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a38">get_le_short</a> (<span class="keywordtype">void</span> *buff)
00253 {
00254 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00255 <span class="preprocessor"></span>  <a class="code" href="group__util.html#a2">uint16</a> s; memcpy (&amp;s, buff, <span class="keyword">sizeof</span> (s));
00256   <span class="keywordflow">return</span> <a class="code" href="group__util.html#a23">little_endian_short</a> (s);
00257 <span class="preprocessor">#else</span>
00258 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="group__util.html#a23">little_endian_short</a> (*(<a class="code" href="group__util.html#a2">uint16</a> *)buff);
00259 <span class="preprocessor">#endif</span>
00260 <span class="preprocessor"></span>}
00261 
<a name="l00263"></a><a class="code" href="group__util.html#a39">00263</a> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a39">get_le_long</a> (<span class="keywordtype">void</span> *buff)
00264 {
00265 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00266 <span class="preprocessor"></span>  uint32 l; memcpy (&amp;l, buff, <span class="keyword">sizeof</span> (l));
00267   <span class="keywordflow">return</span> <a class="code" href="group__util.html#a22">little_endian_long</a> (l);
00268 <span class="preprocessor">#else</span>
00269 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="group__util.html#a22">little_endian_long</a> (*(uint32 *)buff);
00270 <span class="preprocessor">#endif</span>
00271 <span class="preprocessor"></span>}
00272 
<a name="l00274"></a><a class="code" href="group__util.html#a40">00274</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a40">get_le_float32</a> (<span class="keywordtype">void</span> *buff)
00275 { uint32 l = <a class="code" href="group__util.html#a39">get_le_long</a> (buff); <span class="keywordflow">return</span> <a class="code" href="group__util.html#a26">long2float</a> (l); }
00276 
<a name="l00278"></a><a class="code" href="group__util.html#a41">00278</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a41">get_le_float16</a> (<span class="keywordtype">void</span> *buff)
00279 { <a class="code" href="group__util.html#a2">uint16</a> s = <a class="code" href="group__util.html#a38">get_le_short</a> (buff); <span class="keywordflow">return</span> <a class="code" href="group__util.html#a30">short2float</a> (s); }
00280 
<a name="l00282"></a><a class="code" href="group__util.html#a42">00282</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a42">set_le_short</a> (<span class="keywordtype">void</span> *buff, <a class="code" href="group__util.html#a2">uint16</a> s)
00283 {
00284 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00285 <span class="preprocessor"></span>  s = <a class="code" href="group__util.html#a23">little_endian_short</a> (s);
00286   memcpy (buff, &amp;s, <span class="keyword">sizeof</span> (s));
00287 <span class="preprocessor">#else</span>
00288 <span class="preprocessor"></span>  *((<a class="code" href="group__util.html#a2">uint16</a> *)buff) = <a class="code" href="group__util.html#a23">little_endian_short</a> (s);
00289 <span class="preprocessor">#endif</span>
00290 <span class="preprocessor"></span>}
00291 
<a name="l00293"></a><a class="code" href="group__util.html#a43">00293</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a43">set_le_long</a> (<span class="keywordtype">void</span> *buff, uint32 l)
00294 {
00295 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00296 <span class="preprocessor"></span>  l = <a class="code" href="group__util.html#a22">little_endian_long</a> (l);
00297   memcpy (buff, &amp;l, <span class="keyword">sizeof</span> (l));
00298 <span class="preprocessor">#else</span>
00299 <span class="preprocessor"></span>  *((uint32 *)buff) = <a class="code" href="group__util.html#a22">little_endian_long</a> (l);
00300 <span class="preprocessor">#endif</span>
00301 <span class="preprocessor"></span>}
00302 
<a name="l00304"></a><a class="code" href="group__util.html#a44">00304</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a44">set_le_float32</a> (<span class="keywordtype">void</span> *buff, <span class="keywordtype">float</span> f)
00305 { <a class="code" href="group__util.html#a43">set_le_long</a> (buff, <a class="code" href="group__util.html#a25">float2long</a> (f)); }
00306 
<a name="l00308"></a><a class="code" href="group__util.html#a45">00308</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a45">set_le_float16</a> (<span class="keywordtype">void</span> *buff, <span class="keywordtype">float</span> f)
00309 { <a class="code" href="group__util.html#a42">set_le_short</a> (buff, <a class="code" href="group__util.html#a29">float2short</a> (f)); }
00310 
00315 <span class="preprocessor">#endif // __CS_CSENDIAN_H__</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
