<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/csendian.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>csutil/csendian.h</h1><a href="csendian_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 1998 by Jorrit Tyberghein</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_CSENDIAN_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_CSENDIAN_H__</span>
00021 <span class="preprocessor"></span>
00031 <span class="preprocessor">#include &lt;math.h&gt;</span>
00032 <span class="preprocessor">#include "<a class="code" href="cstypes_8h.html">cstypes.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="code" href="csqint_8h.html">csqint.h</a>"</span>
00034 
00035 <span class="preprocessor">#define csQroundSure(x) (int ((x) + ((x &lt; 0) ? -0.5 : +0.5)))</span>
00036 <span class="preprocessor"></span>
00037 <span class="keyword">struct </span>csEndianSwap4
00038 {
00039   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b1, b2, b3, b4;
00040 };
00041 
00042 <span class="keyword">struct </span>csEndianSwap8
00043 {
00044   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b1, b2, b3, b4,
00045                 b5, b6, b7, b8;
00046 };
00047 
00048 <span class="preprocessor">#ifdef CS_BIG_ENDIAN</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_longlong(x) x</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_long(x)  x</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_short(x) x</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_float(x) x</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00054 <span class="preprocessor"></span>
<a name="l00056"></a><a class="code" href="group__util.html#a19">00056</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint64 <a class="code" href="group__util.html#a19">big_endian_longlong</a> (uint64 l)
00057 {
00058   uint64 r;
00059   csEndianSwap8 *p1 = (csEndianSwap8 *)&amp;l;
00060   csEndianSwap8 *p2 = (csEndianSwap8 *)&amp;r;
00061   p2-&gt;b1 = p1-&gt;b8;
00062   p2-&gt;b2 = p1-&gt;b7;
00063   p2-&gt;b3 = p1-&gt;b6;
00064   p2-&gt;b4 = p1-&gt;b5;
00065   p2-&gt;b5 = p1-&gt;b4;
00066   p2-&gt;b6 = p1-&gt;b3;
00067   p2-&gt;b7 = p1-&gt;b2;
00068   p2-&gt;b8 = p1-&gt;b1;
00069   <span class="keywordflow">return</span> r;
00070 }
00071 
00072 
<a name="l00074"></a><a class="code" href="group__util.html#a20">00074</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a20">big_endian_long</a> (uint32 l)
00075 { <span class="keywordflow">return</span> (l &gt;&gt; 24) | ((l &gt;&gt; 8) &amp; 0xff00) | ((l &lt;&lt; 8) &amp; 0xff0000) | (l &lt;&lt; 24); }
00076 
<a name="l00078"></a><a class="code" href="group__util.html#a21">00078</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a21">big_endian_short</a> (<a class="code" href="group__util.html#a2">uint16</a> s)
00079 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a2">uint16</a>((s &gt;&gt; 8) | (s &lt;&lt; 8)); }
00080 
00082 <span class="comment">//@@WARNING: Should be removed -- use float2long instead</span>
<a name="l00083"></a><a class="code" href="group__util.html#a22">00083</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a22">big_endian_float</a> (<span class="keywordtype">float</span> f)
00084 {
00085   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp;
00086   csEndianSwap4 *pf = (csEndianSwap4 *)&amp;f;
00087   tmp = pf-&gt;b1; pf-&gt;b1 = pf-&gt;b4; pf-&gt;b4 = tmp;
00088   tmp = pf-&gt;b2; pf-&gt;b2 = pf-&gt;b3; pf-&gt;b3 = tmp;
00089   <span class="keywordflow">return</span> f;
00090 }
00091 
00092 <span class="preprocessor">#endif // CS_BIG_ENDIAN</span>
00093 <span class="preprocessor"></span>
00094 <span class="preprocessor">#ifdef CS_LITTLE_ENDIAN</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_longlong(x) x</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_long(x)  x</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_short(x) x</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_float(x) x</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00100 <span class="preprocessor"></span>
<a name="l00102"></a><a class="code" href="group__util.html#a23">00102</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint64 <a class="code" href="group__util.html#a23">little_endian_longlong</a> (uint64 l)
00103 {
00104   uint64 r;
00105   csEndianSwap8 *p1 = (csEndianSwap8 *)&amp;l;
00106   csEndianSwap8 *p2 = (csEndianSwap8 *)&amp;r;
00107   p2-&gt;b1 = p1-&gt;b8;
00108   p2-&gt;b2 = p1-&gt;b7;
00109   p2-&gt;b3 = p1-&gt;b6;
00110   p2-&gt;b4 = p1-&gt;b5;
00111   p2-&gt;b5 = p1-&gt;b4;
00112   p2-&gt;b6 = p1-&gt;b3;
00113   p2-&gt;b7 = p1-&gt;b2;
00114   p2-&gt;b8 = p1-&gt;b1;
00115   <span class="keywordflow">return</span> r;
00116 }
00117 
<a name="l00119"></a><a class="code" href="group__util.html#a24">00119</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a24">little_endian_long</a> (uint32 l)
00120 { <span class="keywordflow">return</span> (l &gt;&gt; 24) | ((l &gt;&gt; 8) &amp; 0xff00) | ((l &lt;&lt; 8) &amp; 0xff0000) | (l &lt;&lt; 24); }
00121 
<a name="l00123"></a><a class="code" href="group__util.html#a25">00123</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a25">little_endian_short</a> (<a class="code" href="group__util.html#a2">uint16</a> s)
00124 { <span class="keywordflow">return</span> (s &gt;&gt; 8) | (s &lt;&lt; 8); }
00125 
<a name="l00127"></a><a class="code" href="group__util.html#a26">00127</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a26">little_endian_float</a> (<span class="keywordtype">float</span> f)
00128 {
00129   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp;
00130   csEndianSwap4 *pf = (csEndianSwap4 *)&amp;f;
00131   tmp = pf-&gt;b1; pf-&gt;b1 = pf-&gt;b4; pf-&gt;b4 = tmp;
00132   tmp = pf-&gt;b2; pf-&gt;b2 = pf-&gt;b3; pf-&gt;b3 = tmp;
00133   <span class="keywordflow">return</span> f;
00134 }
00135 
00136 <span class="preprocessor">#endif // CS_LITTLE_ENDIAN</span>
00137 <span class="preprocessor"></span>
00138 <span class="comment">/*</span>
00139 <span class="comment">    To be able to painlessly transfer files betwen platforms, we should</span>
00140 <span class="comment">    avoid using native floating-point format. Here are a couple of routines</span>
00141 <span class="comment">    that are guaranteed to work on all platforms.</span>
00142 <span class="comment"></span>
00143 <span class="comment">    The floating point is converted to a fixed 1.7.25 bits format</span>
00144 <span class="comment">    (one bit sign, 7 bits exponent, 25 bits mantissa) and back,</span>
00145 <span class="comment">    so that we can binary store floating-point number without</span>
00146 <span class="comment">    cross-platform problems. If you wonder why 1+7+25 = 33 while we</span>
00147 <span class="comment">    only have 32 bits, we'll ommit the most significant bit of mantissa</span>
00148 <span class="comment">    since it is always 1 (we use normalized numbers). This increases the</span>
00149 <span class="comment">    precision twice.</span>
00150 <span class="comment"></span>
00151 <span class="comment">    For double, we use one bit sign, 15 bits exponent, 49 bits mantissa.</span>
00152 <span class="comment">*/</span>
00153 
<a name="l00155"></a><a class="code" href="group__util.html#a27">00155</a> <span class="keyword">static</span> <span class="keyword">inline</span> int32 <a class="code" href="group__util.html#a27">float2long</a> (<span class="keywordtype">float</span> f)
00156 {
00157   <span class="keywordtype">int</span> exp;
00158   int32 mant = csQroundSure (frexp (f, &amp;exp) * 0x1000000);
00159   int32 sign = mant &amp; 0x80000000;
00160   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00161   <span class="keywordflow">if</span> (exp &gt; 63) exp = 63; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -64) exp = -64;
00162   <span class="keywordflow">return</span> sign | ((exp &amp; 0x7f) &lt;&lt; 24) | (mant &amp; 0xffffff);
00163 }
00164 
<a name="l00166"></a><a class="code" href="group__util.html#a28">00166</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a28">long2float</a> (int32 l)
00167 {
00168   <span class="keywordtype">int</span> exp = (l &gt;&gt; 24) &amp; 0x7f;
00169   <span class="keywordflow">if</span> (exp &amp; 0x40) exp = exp | ~0x7f;
00170   <span class="keywordtype">float</span> mant = float (l &amp; 0x00ffffff) / 0x1000000;
00171   <span class="keywordflow">if</span> (l &amp; 0x80000000) mant = -mant;
00172   <span class="keywordflow">return</span> (float) ldexp (mant, exp);
00173 }
00174 
00175 <span class="comment">/* Implementation note: double2longlong() and longlong2double()</span>
00176 <span class="comment"> *</span>
00177 <span class="comment"> * We avoid use of CONST_INT64() because 64-bit constants are illegal with g++</span>
00178 <span class="comment"> * under -ansi -pedantic, and we want this header to be useful to external</span>
00179 <span class="comment"> * projects which use -ansi -pedantic.  Instead, we use bit shifts, such as (1</span>
00180 <span class="comment"> * &lt;&lt; 59), and construct `mask' manually.</span>
00181 <span class="comment"> */</span>
00182 
<a name="l00184"></a><a class="code" href="group__util.html#a29">00184</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a7">int64</a> <a class="code" href="group__util.html#a29">double2longlong</a> (<span class="keywordtype">double</span> d)
00185 {
00186   <span class="keywordtype">int</span> exp;
00187   <a class="code" href="group__util.html#a7">int64</a> mant = (int64) (frexp (d, &amp;exp) * ((int64)1 &lt;&lt; 48));
00188   <a class="code" href="group__util.html#a7">int64</a> sign = mant &amp; ((int64)1 &lt;&lt; 59);
00189   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00190   <span class="keywordflow">if</span> (exp &gt; 32767) exp = 32767; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -32768) exp = -32768;
00191   <a class="code" href="group__util.html#a7">int64</a> <span class="keyword">const</span> mask = ((uint64)0xffff &lt;&lt; 32) | (uint64)0xffffffff;
00192   <span class="keywordflow">return</span> sign | ((<a class="code" href="group__util.html#a7">int64</a> (exp) &amp; 0x7fff) &lt;&lt; 48) | (mant &amp; mask);
00193 }
00194 
<a name="l00196"></a><a class="code" href="group__util.html#a30">00196</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__util.html#a30">longlong2double</a> (<a class="code" href="group__util.html#a7">int64</a> i)
00197 {
00198   <span class="keywordtype">int</span> exp = (i &gt;&gt; 48) &amp; 0x7fff;
00199   <span class="keywordflow">if</span> (exp &amp; 0x4000) exp = exp | ~0x7fff;
00200   <a class="code" href="group__util.html#a7">int64</a> <span class="keyword">const</span> mask = ((uint64)0xffff &lt;&lt; 32) | (uint64)0xffffffff;
00201   <span class="keywordtype">double</span> mant = double (i &amp; mask) / ((int64)1 &lt;&lt; 48);
00202   <span class="keywordflow">if</span> (i &amp; ((int64)1 &lt;&lt; 59)) mant = -mant;
00203   <span class="keywordflow">return</span> ldexp (mant, exp);
00204 }
00205 
00214 
<a name="l00215"></a><a class="code" href="group__util.html#a31">00215</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">short</span> <a class="code" href="group__util.html#a31">float2short</a> (<span class="keywordtype">float</span> f)
00216 {
00217   <span class="keywordtype">int</span> exp;
00218   <span class="keywordtype">long</span> mant = csQroundSure (frexp (f, &amp;exp) * 0x1000);
00219   <span class="keywordtype">long</span> sign = mant &amp; 0x8000;
00220   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00221   <span class="keywordflow">if</span> (exp &gt; 7) mant = 0x7ff, exp = 7; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -8) mant = 0, exp = -8;
00222   <span class="keywordflow">return</span> short(sign | ((exp &amp; 0xf) &lt;&lt; 11) | (mant &amp; 0x7ff));
00223 }
00224 
<a name="l00226"></a><a class="code" href="group__util.html#a32">00226</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a32">short2float</a> (<span class="keywordtype">short</span> s)
00227 {
00228   <span class="keywordtype">int</span> exp = (s &gt;&gt; 11) &amp; 0xf;
00229   <span class="keywordflow">if</span> (exp &amp; 0x8) exp = exp | ~0xf;
00230   <span class="keywordtype">float</span> mant = float ((s &amp; 0x07ff) | 0x0800) / 0x1000;
00231   <span class="keywordflow">if</span> (s &amp; 0x8000) mant = -mant;
00232   <span class="keywordflow">return</span> (float) ldexp (mant, exp);
00233 }
00234 
00237 
<a name="l00238"></a><a class="code" href="group__util.html#a33">00238</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint64 <a class="code" href="group__util.html#a39">convert_endian</a> (uint64 l)
00239 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a23">little_endian_longlong</a> (l); }
00240 
<a name="l00242"></a><a class="code" href="group__util.html#a34">00242</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a7">int64</a> <a class="code" href="group__util.html#a39">convert_endian</a> (<a class="code" href="group__util.html#a7">int64</a> l)
00243 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a23">little_endian_longlong</a> (l); }
00244 
<a name="l00246"></a><a class="code" href="group__util.html#a35">00246</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a39">convert_endian</a> (uint32 l)
00247 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">little_endian_long</a> (l); }
00248 
<a name="l00250"></a><a class="code" href="group__util.html#a36">00250</a> <span class="keyword">static</span> <span class="keyword">inline</span> int32 <a class="code" href="group__util.html#a39">convert_endian</a> (int32 l)
00251 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">little_endian_long</a> (l); }
00252 
<a name="l00254"></a><a class="code" href="group__util.html#a37">00254</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a3">int16</a> <a class="code" href="group__util.html#a39">convert_endian</a> (<a class="code" href="group__util.html#a3">int16</a> s)
00255 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">little_endian_short</a> (s); }
00256 
<a name="l00258"></a><a class="code" href="group__util.html#a38">00258</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a39">convert_endian</a> (<a class="code" href="group__util.html#a2">uint16</a> s)
00259 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">little_endian_short</a> (s); }
00260 
<a name="l00262"></a><a class="code" href="group__util.html#a39">00262</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a39">convert_endian</a> (<span class="keywordtype">float</span> f)
00263 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a26">little_endian_float</a> (f); }
00264 
<a name="l00266"></a><a class="code" href="group__util.html#a40">00266</a> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a40">get_le_short</a> (<span class="keywordtype">void</span> *buff)
00267 {
00268 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00269 <span class="preprocessor"></span>  <a class="code" href="group__util.html#a2">uint16</a> s; memcpy (&amp;s, buff, <span class="keyword">sizeof</span> (s));
00270   <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">little_endian_short</a> (s);
00271 <span class="preprocessor">#else</span>
00272 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">little_endian_short</a> (*(<a class="code" href="group__util.html#a2">uint16</a> *)buff);
00273 <span class="preprocessor">#endif</span>
00274 <span class="preprocessor"></span>}
00275 
<a name="l00277"></a><a class="code" href="group__util.html#a41">00277</a> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a41">get_le_long</a> (<span class="keywordtype">void</span> *buff)
00278 {
00279 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00280 <span class="preprocessor"></span>  uint32 l; memcpy (&amp;l, buff, <span class="keyword">sizeof</span> (l));
00281   <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">little_endian_long</a> (l);
00282 <span class="preprocessor">#else</span>
00283 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">little_endian_long</a> (*(uint32 *)buff);
00284 <span class="preprocessor">#endif</span>
00285 <span class="preprocessor"></span>}
00286 
<a name="l00288"></a><a class="code" href="group__util.html#a42">00288</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a42">get_le_float32</a> (<span class="keywordtype">void</span> *buff)
00289 { uint32 l = <a class="code" href="group__util.html#a41">get_le_long</a> (buff); <span class="keywordflow">return</span> <a class="code" href="group__util.html#a28">long2float</a> (l); }
00290 
<a name="l00292"></a><a class="code" href="group__util.html#a43">00292</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a43">get_le_float16</a> (<span class="keywordtype">void</span> *buff)
00293 { <a class="code" href="group__util.html#a2">uint16</a> s = <a class="code" href="group__util.html#a40">get_le_short</a> (buff); <span class="keywordflow">return</span> <a class="code" href="group__util.html#a32">short2float</a> (s); }
00294 
<a name="l00296"></a><a class="code" href="group__util.html#a44">00296</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a44">set_le_short</a> (<span class="keywordtype">void</span> *buff, <a class="code" href="group__util.html#a2">uint16</a> s)
00297 {
00298 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00299 <span class="preprocessor"></span>  s = <a class="code" href="group__util.html#a25">little_endian_short</a> (s);
00300   memcpy (buff, &amp;s, <span class="keyword">sizeof</span> (s));
00301 <span class="preprocessor">#else</span>
00302 <span class="preprocessor"></span>  *((<a class="code" href="group__util.html#a2">uint16</a> *)buff) = <a class="code" href="group__util.html#a25">little_endian_short</a> (s);
00303 <span class="preprocessor">#endif</span>
00304 <span class="preprocessor"></span>}
00305 
<a name="l00307"></a><a class="code" href="group__util.html#a45">00307</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a45">set_le_long</a> (<span class="keywordtype">void</span> *buff, uint32 l)
00308 {
00309 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00310 <span class="preprocessor"></span>  l = <a class="code" href="group__util.html#a24">little_endian_long</a> (l);
00311   memcpy (buff, &amp;l, <span class="keyword">sizeof</span> (l));
00312 <span class="preprocessor">#else</span>
00313 <span class="preprocessor"></span>  *((uint32 *)buff) = <a class="code" href="group__util.html#a24">little_endian_long</a> (l);
00314 <span class="preprocessor">#endif</span>
00315 <span class="preprocessor"></span>}
00316 
<a name="l00318"></a><a class="code" href="group__util.html#a46">00318</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a46">set_le_float32</a> (<span class="keywordtype">void</span> *buff, <span class="keywordtype">float</span> f)
00319 { <a class="code" href="group__util.html#a45">set_le_long</a> (buff, <a class="code" href="group__util.html#a27">float2long</a> (f)); }
00320 
<a name="l00322"></a><a class="code" href="group__util.html#a47">00322</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a47">set_le_float16</a> (<span class="keywordtype">void</span> *buff, <span class="keywordtype">float</span> f)
00323 { <a class="code" href="group__util.html#a44">set_le_short</a> (buff, <a class="code" href="group__util.html#a31">float2short</a> (f)); }
00324 
00329 <span class="preprocessor">#endif // __CS_CSENDIAN_H__</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
