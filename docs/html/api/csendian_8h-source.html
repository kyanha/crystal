<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/csendian.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>csutil/csendian.h</h1><a href="csendian_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 1998 by Jorrit Tyberghein</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_CSENDIAN_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_CSENDIAN_H__</span>
00021 <span class="preprocessor"></span>
00029 <span class="preprocessor">#include &lt;math.h&gt;</span>
00030 <span class="preprocessor">#include "<a class="code" href="cstypes_8h.html">cstypes.h</a>"</span>
00031 <span class="preprocessor">#include "<a class="code" href="csqint_8h.html">csqint.h</a>"</span>
00032 
00033 <span class="preprocessor">#define csQroundSure(x) (int ((x) + ((x &lt; 0) ? -0.5 : +0.5)))</span>
00034 <span class="preprocessor"></span>
00035 <span class="keyword">struct </span>csEndianSwap4
00036 {
00037   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b1, b2, b3, b4;
00038 };
00039 
00040 <span class="keyword">struct </span>csEndianSwap8
00041 {
00042   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b1, b2, b3, b4,
00043                 b5, b6, b7, b8;
00044 };
00045 
00046 <span class="preprocessor">#ifdef CS_BIG_ENDIAN</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#  define csBigEndianLongLong(x) x</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#  define csBigEndianLong(x)  x</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#  define csBigEndianShort(x) x</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#  define csBigEndianFloat(x) x</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00052 <span class="preprocessor"></span>
<a name="l00054"></a><a class="code" href="group__util.html#a19">00054</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a6">uint64</a> <a class="code" href="group__util.html#a19">csBigEndianLongLong</a> (uint64 l)
00055 {
00056   <a class="code" href="group__util.html#a6">uint64</a> r;
00057   csEndianSwap8 *p1 = (csEndianSwap8 *)&amp;l;
00058   csEndianSwap8 *p2 = (csEndianSwap8 *)&amp;r;
00059   p2-&gt;b1 = p1-&gt;b8;
00060   p2-&gt;b2 = p1-&gt;b7;
00061   p2-&gt;b3 = p1-&gt;b6;
00062   p2-&gt;b4 = p1-&gt;b5;
00063   p2-&gt;b5 = p1-&gt;b4;
00064   p2-&gt;b6 = p1-&gt;b3;
00065   p2-&gt;b7 = p1-&gt;b2;
00066   p2-&gt;b8 = p1-&gt;b1;
00067   <span class="keywordflow">return</span> r;
00068 }
00069 
00070 
<a name="l00072"></a><a class="code" href="group__util.html#a20">00072</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a20">csBigEndianLong</a> (uint32 l)
00073 { <span class="keywordflow">return</span> (l &gt;&gt; 24) | ((l &gt;&gt; 8) &amp; 0xff00) | ((l &lt;&lt; 8) &amp; 0xff0000) | (l &lt;&lt; 24); }
00074 
<a name="l00076"></a><a class="code" href="group__util.html#a21">00076</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a21">csBigEndianShort</a> (uint16 s)
00077 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a2">uint16</a>((s &gt;&gt; 8) | (s &lt;&lt; 8)); }
00078 
<a name="l00080"></a><a class="code" href="group__util.html#a22">00080</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a22">csBigEndianFloat</a> (<span class="keywordtype">float</span> f)
00081 {
00082   <span class="comment">//@@WARNING: Should be removed -- use csFloatToLong instead</span>
00083   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp;
00084   csEndianSwap4 *pf = (csEndianSwap4 *)&amp;f;
00085   tmp = pf-&gt;b1; pf-&gt;b1 = pf-&gt;b4; pf-&gt;b4 = tmp;
00086   tmp = pf-&gt;b2; pf-&gt;b2 = pf-&gt;b3; pf-&gt;b3 = tmp;
00087   <span class="keywordflow">return</span> f;
00088 }
00089 
00090 <span class="preprocessor">#endif // CS_BIG_ENDIAN</span>
00091 <span class="preprocessor"></span>
00092 <span class="preprocessor">#ifdef CS_LITTLE_ENDIAN</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#  define csLittleEndianLongLong(x) x</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#  define csLittleEndianLong(x)  x</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#  define csLittleEndianShort(x) x</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#  define csLittleEndianFloat(x) x</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00098 <span class="preprocessor"></span>
<a name="l00100"></a><a class="code" href="group__util.html#a23">00100</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a6">uint64</a> <a class="code" href="group__util.html#a23">csLittleEndianLongLong</a> (uint64 l)
00101 {
00102   <a class="code" href="group__util.html#a6">uint64</a> r;
00103   csEndianSwap8 *p1 = (csEndianSwap8 *)&amp;l;
00104   csEndianSwap8 *p2 = (csEndianSwap8 *)&amp;r;
00105   p2-&gt;b1 = p1-&gt;b8;
00106   p2-&gt;b2 = p1-&gt;b7;
00107   p2-&gt;b3 = p1-&gt;b6;
00108   p2-&gt;b4 = p1-&gt;b5;
00109   p2-&gt;b5 = p1-&gt;b4;
00110   p2-&gt;b6 = p1-&gt;b3;
00111   p2-&gt;b7 = p1-&gt;b2;
00112   p2-&gt;b8 = p1-&gt;b1;
00113   <span class="keywordflow">return</span> r;
00114 }
00115 
<a name="l00117"></a><a class="code" href="group__util.html#a24">00117</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a24">csLittleEndianLong</a> (uint32 l)
00118 { <span class="keywordflow">return</span> (l &gt;&gt; 24) | ((l &gt;&gt; 8) &amp; 0xff00) | ((l &lt;&lt; 8) &amp; 0xff0000) | (l &lt;&lt; 24); }
00119 
<a name="l00121"></a><a class="code" href="group__util.html#a25">00121</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a25">csLittleEndianShort</a> (uint16 s)
00122 { <span class="keywordflow">return</span> (s &gt;&gt; 8) | (s &lt;&lt; 8); }
00123 
<a name="l00125"></a><a class="code" href="group__util.html#a26">00125</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a26">csLittleEndianFloat</a> (<span class="keywordtype">float</span> f)
00126 {
00127   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp;
00128   csEndianSwap4 *pf = (csEndianSwap4 *)&amp;f;
00129   tmp = pf-&gt;b1; pf-&gt;b1 = pf-&gt;b4; pf-&gt;b4 = tmp;
00130   tmp = pf-&gt;b2; pf-&gt;b2 = pf-&gt;b3; pf-&gt;b3 = tmp;
00131   <span class="keywordflow">return</span> f;
00132 }
00133 
00134 <span class="preprocessor">#endif // CS_LITTLE_ENDIAN</span>
00135 <span class="preprocessor"></span>
00136 <span class="comment">/*</span>
00137 <span class="comment">    To be able to painlessly transfer files betwen platforms, we should</span>
00138 <span class="comment">    avoid using native floating-point format. Here are a couple of routines</span>
00139 <span class="comment">    that are guaranteed to work on all platforms.</span>
00140 <span class="comment"></span>
00141 <span class="comment">    The floating point is converted to a fixed 1.7.25 bits format</span>
00142 <span class="comment">    (one bit sign, 7 bits exponent, 25 bits mantissa) and back,</span>
00143 <span class="comment">    so that we can binary store floating-point number without</span>
00144 <span class="comment">    cross-platform problems. If you wonder why 1+7+25 = 33 while we</span>
00145 <span class="comment">    only have 32 bits, we'll ommit the most significant bit of mantissa</span>
00146 <span class="comment">    since it is always 1 (we use normalized numbers). This increases the</span>
00147 <span class="comment">    precision twice.</span>
00148 <span class="comment"></span>
00149 <span class="comment">    For double, we use one bit sign, 15 bits exponent, 49 bits mantissa.</span>
00150 <span class="comment">*/</span>
00151 
<a name="l00156"></a><a class="code" href="group__util.html#a27">00156</a> <span class="keyword">static</span> <span class="keyword">inline</span> int32 <a class="code" href="group__util.html#a27">csFloatToLong</a> (<span class="keywordtype">float</span> f)
00157 {
00158   <span class="keywordtype">int</span> exp;
00159   int32 mant = csQroundSure (frexp (f, &amp;exp) * 0x1000000);
00160   int32 sign = mant &amp; 0x80000000;
00161   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00162   <span class="keywordflow">if</span> (exp &gt; 63) exp = 63; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -64) exp = -64;
00163   <span class="keywordflow">return</span> sign | ((exp &amp; 0x7f) &lt;&lt; 24) | (mant &amp; 0xffffff);
00164 }
00165 
<a name="l00167"></a><a class="code" href="group__util.html#a28">00167</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a28">csLongToFloat</a> (int32 l)
00168 {
00169   <span class="keywordtype">int</span> exp = (l &gt;&gt; 24) &amp; 0x7f;
00170   <span class="keywordflow">if</span> (exp &amp; 0x40) exp = exp | ~0x7f;
00171   <span class="keywordtype">float</span> mant = float (l &amp; 0x00ffffff) / 0x1000000;
00172   <span class="keywordflow">if</span> (l &amp; 0x80000000) mant = -mant;
00173   <span class="keywordflow">return</span> (<span class="keywordtype">float</span>) ldexp (mant, exp);
00174 }
00175 
00176 <span class="comment">/* Implementation note: csDoubleToLongLong() and csLongLongToDouble()</span>
00177 <span class="comment"> *</span>
00178 <span class="comment"> * We avoid use of CONST_INT64() because 64-bit constants are illegal with g++</span>
00179 <span class="comment"> * under -ansi -pedantic, and we want this header to be useful to external</span>
00180 <span class="comment"> * projects which use -ansi -pedantic.  Instead, we use bit shifts, such as (1</span>
00181 <span class="comment"> * &lt;&lt; 59), and construct `mask' manually.</span>
00182 <span class="comment"> */</span>
00183 
<a name="l00185"></a><a class="code" href="group__util.html#a29">00185</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a7">int64</a> <a class="code" href="group__util.html#a29">csDoubleToLongLong</a> (<span class="keywordtype">double</span> d)
00186 {
00187   <span class="keywordtype">int</span> exp;
00188   <a class="code" href="group__util.html#a7">int64</a> mant = (<a class="code" href="group__util.html#a7">int64</a>) (frexp (d, &amp;exp) * ((<a class="code" href="group__util.html#a7">int64</a>)1 &lt;&lt; 48));
00189   <a class="code" href="group__util.html#a7">int64</a> sign = mant &amp; ((<a class="code" href="group__util.html#a7">int64</a>)1 &lt;&lt; 59);
00190   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00191   <span class="keywordflow">if</span> (exp &gt; 32767) exp = 32767; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -32768) exp = -32768;
00192   <a class="code" href="group__util.html#a7">int64</a> <span class="keyword">const</span> mask = ((<a class="code" href="group__util.html#a6">uint64</a>)0xffff &lt;&lt; 32) | (<a class="code" href="group__util.html#a6">uint64</a>)0xffffffff;
00193   <span class="keywordflow">return</span> sign | ((<a class="code" href="group__util.html#a7">int64</a> (exp) &amp; 0x7fff) &lt;&lt; 48) | (mant &amp; mask);
00194 }
00195 
<a name="l00197"></a><a class="code" href="group__util.html#a30">00197</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__util.html#a30">csLongLongToDouble</a> (int64 i)
00198 {
00199   <span class="keywordtype">int</span> exp = (i &gt;&gt; 48) &amp; 0x7fff;
00200   <span class="keywordflow">if</span> (exp &amp; 0x4000) exp = exp | ~0x7fff;
00201   <a class="code" href="group__util.html#a7">int64</a> <span class="keyword">const</span> mask = ((<a class="code" href="group__util.html#a6">uint64</a>)0xffff &lt;&lt; 32) | (<a class="code" href="group__util.html#a6">uint64</a>)0xffffffff;
00202   <span class="keywordtype">double</span> mant = double (i &amp; mask) / ((<a class="code" href="group__util.html#a7">int64</a>)1 &lt;&lt; 48);
00203   <span class="keywordflow">if</span> (i &amp; ((<a class="code" href="group__util.html#a7">int64</a>)1 &lt;&lt; 59)) mant = -mant;
00204   <span class="keywordflow">return</span> ldexp (mant, exp);
00205 }
00206 
00216 
<a name="l00217"></a><a class="code" href="group__util.html#a31">00217</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">short</span> <a class="code" href="group__util.html#a31">csFloatToShort</a> (<span class="keywordtype">float</span> f)
00218 {
00219   <span class="keywordtype">int</span> exp;
00220   <span class="keywordtype">long</span> mant = csQroundSure (frexp (f, &amp;exp) * 0x1000);
00221   <span class="keywordtype">long</span> sign = mant &amp; 0x8000;
00222   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00223   <span class="keywordflow">if</span> (exp &gt; 7) mant = 0x7ff, exp = 7; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -8) mant = 0, exp = -8;
00224   <span class="keywordflow">return</span> short(sign | ((exp &amp; 0xf) &lt;&lt; 11) | (mant &amp; 0x7ff));
00225 }
00226 
<a name="l00228"></a><a class="code" href="group__util.html#a32">00228</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a32">csShortToFloat</a> (<span class="keywordtype">short</span> s)
00229 {
00230   <span class="keywordtype">int</span> exp = (s &gt;&gt; 11) &amp; 0xf;
00231   <span class="keywordflow">if</span> (exp &amp; 0x8) exp = exp | ~0xf;
00232   <span class="keywordtype">float</span> mant = float ((s &amp; 0x07ff) | 0x0800) / 0x1000;
00233   <span class="keywordflow">if</span> (s &amp; 0x8000) mant = -mant;
00234   <span class="keywordflow">return</span> (<span class="keywordtype">float</span>) ldexp (mant, exp);
00235 }
00236 
00239 
<a name="l00240"></a><a class="code" href="group__util.html#a33">00240</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a6">uint64</a> <a class="code" href="group__util.html#a39">csConvertEndian</a> (uint64 l)
00241 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a23">csLittleEndianLongLong</a> (l); }
00242 
<a name="l00244"></a><a class="code" href="group__util.html#a34">00244</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a7">int64</a> <a class="code" href="group__util.html#a39">csConvertEndian</a> (int64 l)
00245 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a23">csLittleEndianLongLong</a> (l); }
00246 
<a name="l00248"></a><a class="code" href="group__util.html#a35">00248</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a39">csConvertEndian</a> (uint32 l)
00249 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">csLittleEndianLong</a> (l); }
00250 
<a name="l00252"></a><a class="code" href="group__util.html#a36">00252</a> <span class="keyword">static</span> <span class="keyword">inline</span> int32 <a class="code" href="group__util.html#a39">csConvertEndian</a> (int32 l)
00253 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">csLittleEndianLong</a> (l); }
00254 
<a name="l00256"></a><a class="code" href="group__util.html#a37">00256</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a3">int16</a> <a class="code" href="group__util.html#a39">csConvertEndian</a> (int16 s)
00257 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">csLittleEndianShort</a> (s); }
00258 
<a name="l00260"></a><a class="code" href="group__util.html#a38">00260</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a39">csConvertEndian</a> (uint16 s)
00261 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">csLittleEndianShort</a> (s); }
00262 
<a name="l00264"></a><a class="code" href="group__util.html#a39">00264</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a39">csConvertEndian</a> (<span class="keywordtype">float</span> f)
00265 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a26">csLittleEndianFloat</a> (f); }
00266 
<a name="l00268"></a><a class="code" href="group__util.html#a40">00268</a> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a40">csGetLittleEndianShort</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff)
00269 {
00270 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00271 <span class="preprocessor"></span>  <a class="code" href="group__util.html#a2">uint16</a> s; memcpy (&amp;s, buff, <span class="keyword">sizeof</span> (s));
00272   <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">csLittleEndianShort</a> (s);
00273 <span class="preprocessor">#else</span>
00274 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">csLittleEndianShort</a> (*(<a class="code" href="group__util.html#a2">uint16</a> *)buff);
00275 <span class="preprocessor">#endif</span>
00276 <span class="preprocessor"></span>}
00277 
<a name="l00279"></a><a class="code" href="group__util.html#a41">00279</a> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a41">csGetLittleEndianLong</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff)
00280 {
00281 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00282 <span class="preprocessor"></span>  uint32 l; memcpy (&amp;l, buff, <span class="keyword">sizeof</span> (l));
00283   <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">csLittleEndianLong</a> (l);
00284 <span class="preprocessor">#else</span>
00285 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">csLittleEndianLong</a> (*(uint32 *)buff);
00286 <span class="preprocessor">#endif</span>
00287 <span class="preprocessor"></span>}
00288 
<a name="l00290"></a><a class="code" href="group__util.html#a42">00290</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a42">csGetLittleEndianFloat32</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff)
00291 { uint32 l = <a class="code" href="group__util.html#a41">csGetLittleEndianLong</a> (buff); <span class="keywordflow">return</span> <a class="code" href="group__util.html#a28">csLongToFloat</a> (l); }
00292 
<a name="l00294"></a><a class="code" href="group__util.html#a43">00294</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a43">csGetLittleEndianFloat16</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff)
00295 { <a class="code" href="group__util.html#a2">uint16</a> s = <a class="code" href="group__util.html#a40">csGetLittleEndianShort</a> (buff); <span class="keywordflow">return</span> <a class="code" href="group__util.html#a32">csShortToFloat</a> (s); }
00296 
<a name="l00298"></a><a class="code" href="group__util.html#a44">00298</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a44">csSetLittleEndianShort</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff, uint16 s)
00299 {
00300 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00301 <span class="preprocessor"></span>  s = <a class="code" href="group__util.html#a25">csLittleEndianShort</a> (s);
00302   memcpy (buff, &amp;s, <span class="keyword">sizeof</span> (s));
00303 <span class="preprocessor">#else</span>
00304 <span class="preprocessor"></span>  *((<a class="code" href="group__util.html#a2">uint16</a> *)buff) = <a class="code" href="group__util.html#a25">csLittleEndianShort</a> (s);
00305 <span class="preprocessor">#endif</span>
00306 <span class="preprocessor"></span>}
00307 
<a name="l00309"></a><a class="code" href="group__util.html#a45">00309</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a45">csSetLittleEndianLong</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff, uint32 l)
00310 {
00311 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00312 <span class="preprocessor"></span>  l = <a class="code" href="group__util.html#a24">csLittleEndianLong</a> (l);
00313   memcpy (buff, &amp;l, <span class="keyword">sizeof</span> (l));
00314 <span class="preprocessor">#else</span>
00315 <span class="preprocessor"></span>  *((uint32 *)buff) = <a class="code" href="group__util.html#a24">csLittleEndianLong</a> (l);
00316 <span class="preprocessor">#endif</span>
00317 <span class="preprocessor"></span>}
00318 
<a name="l00320"></a><a class="code" href="group__util.html#a46">00320</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a46">csSetLittleEndianFloat32</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff, <span class="keywordtype">float</span> f)
00321 { <a class="code" href="group__util.html#a45">csSetLittleEndianLong</a> (buff, <a class="code" href="group__util.html#a27">csFloatToLong</a> (f)); }
00322 
<a name="l00324"></a><a class="code" href="group__util.html#a47">00324</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a47">csSetLittleEndianFloat16</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff, <span class="keywordtype">float</span> f)
00325 { <a class="code" href="group__util.html#a44">csSetLittleEndianShort</a> (buff, <a class="code" href="group__util.html#a31">csFloatToShort</a> (f)); }
00326 
00327 
<a name="l00329"></a><a class="code" href="group__util.html#a48">00329</a> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a48">csGetBigEndianShort</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff)
00330 {
00331 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00332 <span class="preprocessor"></span>  <a class="code" href="group__util.html#a2">uint16</a> s; memcpy (&amp;s, buff, <span class="keyword">sizeof</span> (s));
00333   <span class="keywordflow">return</span> <a class="code" href="group__util.html#a21">csBigEndianShort</a> (s);
00334 <span class="preprocessor">#else</span>
00335 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="group__util.html#a21">csBigEndianShort</a> (*(<a class="code" href="group__util.html#a2">uint16</a> *)buff);
00336 <span class="preprocessor">#endif</span>
00337 <span class="preprocessor"></span>}
00338 
<a name="l00340"></a><a class="code" href="group__util.html#a49">00340</a> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a49">csGetBigEndianLong</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff)
00341 {
00342 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00343 <span class="preprocessor"></span>  uint32 l; memcpy (&amp;l, buff, <span class="keyword">sizeof</span> (l));
00344   <span class="keywordflow">return</span> <a class="code" href="group__util.html#a20">csBigEndianLong</a> (l);
00345 <span class="preprocessor">#else</span>
00346 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="group__util.html#a20">csBigEndianLong</a> (*(uint32 *)buff);
00347 <span class="preprocessor">#endif</span>
00348 <span class="preprocessor"></span>}
00349 
<a name="l00351"></a><a class="code" href="group__util.html#a50">00351</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a50">csGetBigEndianFloat32</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff)
00352 { uint32 l = <a class="code" href="group__util.html#a49">csGetBigEndianLong</a> (buff); <span class="keywordflow">return</span> <a class="code" href="group__util.html#a28">csLongToFloat</a> (l); }
00353 
<a name="l00355"></a><a class="code" href="group__util.html#a51">00355</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a51">csGetBigEndianFloat16</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *buff)
00356 { <a class="code" href="group__util.html#a2">uint16</a> s = <a class="code" href="group__util.html#a48">csGetBigEndianShort</a> (buff); <span class="keywordflow">return</span> <a class="code" href="group__util.html#a32">csShortToFloat</a> (s); }
00357 
<a name="l00359"></a><a class="code" href="group__util.html#a52">00359</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a52">csSetBigEndianShort</a> (<span class="keywordtype">void</span> *buff, uint16 s)
00360 {
00361 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00362 <span class="preprocessor"></span>  s = <a class="code" href="group__util.html#a21">csBigEndianShort</a> (s);
00363   memcpy (buff, &amp;s, <span class="keyword">sizeof</span> (s));
00364 <span class="preprocessor">#else</span>
00365 <span class="preprocessor"></span>  *((<a class="code" href="group__util.html#a2">uint16</a> *)buff) = <a class="code" href="group__util.html#a21">csBigEndianShort</a> (s);
00366 <span class="preprocessor">#endif</span>
00367 <span class="preprocessor"></span>}
00368 
<a name="l00370"></a><a class="code" href="group__util.html#a53">00370</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a53">csSetBigEndianLong</a> (<span class="keywordtype">void</span> *buff, uint32 l)
00371 {
00372 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00373 <span class="preprocessor"></span>  l = <a class="code" href="group__util.html#a20">csBigEndianLong</a> (l);
00374   memcpy (buff, &amp;l, <span class="keyword">sizeof</span> (l));
00375 <span class="preprocessor">#else</span>
00376 <span class="preprocessor"></span>  *((uint32 *)buff) = <a class="code" href="group__util.html#a20">csBigEndianLong</a> (l);
00377 <span class="preprocessor">#endif</span>
00378 <span class="preprocessor"></span>}
00379 
<a name="l00381"></a><a class="code" href="group__util.html#a54">00381</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a54">csSetBigEndianFloat32</a> (<span class="keywordtype">void</span> *buff, <span class="keywordtype">float</span> f)
00382 { <a class="code" href="group__util.html#a53">csSetBigEndianLong</a> (buff, <a class="code" href="group__util.html#a27">csFloatToLong</a> (f)); }
00383 
<a name="l00385"></a><a class="code" href="group__util.html#a55">00385</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a55">csSetBigEndianFloat16</a> (<span class="keywordtype">void</span> *buff, <span class="keywordtype">float</span> f)
00386 { <a class="code" href="group__util.html#a52">csSetBigEndianShort</a> (buff, <a class="code" href="group__util.html#a31">csFloatToShort</a> (f)); }
00387 
00390 <span class="preprocessor">#endif // __CS_CSENDIAN_H__</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.3 
</small></address> </div></body> </html>
