<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/hash.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>csutil/hash.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2003 by Mat Sutcliffe &lt;oktal@gmx.co.uk&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_UTIL_HASH_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_UTIL_HASH_H__</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include "csextern.h"</span>
00023 <span class="preprocessor">#include "array.h"</span>
00024 
00031 CS_CSUTIL_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> csHashCompute (<span class="keywordtype">char</span> <span class="keyword">const</span>*);
00032 
00039 CS_CSUTIL_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> csHashCompute (<span class="keywordtype">char</span> <span class="keyword">const</span>*, size_t length);
00040 
00044 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00045"></a><a class="code" href="classcsIntegralHashKeyHandler.html">00045</a> <span class="keyword">class </span><a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler</a>
00046 {
00047 <span class="keyword">public</span>:
00048   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ComputeHash (<span class="keyword">const</span> T&amp; key)
00049   {
00050 <span class="preprocessor">#if (CS_PROCESSOR_SIZE == 32)</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#if (_MSC_VER &gt;= 1300)</span>
00052 <span class="preprocessor"></span>    <span class="comment">/*</span>
00053 <span class="comment">      VC7 with 64bit warnings complains about a pointer truncation when T is</span>
00054 <span class="comment">      a pointer. This isn't serious (as csHash&lt;&gt; does not rely on the hash of</span>
00055 <span class="comment">      a key alone to retrieve a value). The __w64 causes VC7 to not emit that</span>
00056 <span class="comment">      warning (on 32bit compilers at least).</span>
00057 <span class="comment">     */</span>
00058     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __w64)key;  
00059 <span class="preprocessor">#else</span>
00060 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)key;  
00061 <span class="preprocessor">#endif</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00063 <span class="preprocessor"></span>    <span class="comment">// Cast to uint64 first to avoid compiler warnings about truncation.</span>
00064     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((<a class="code" href="group__util.html#a6">uint64</a>)key);
00065 <span class="preprocessor">#endif</span>
00066 <span class="preprocessor"></span>  }
00067 
00068   <span class="keyword">static</span> <span class="keywordtype">bool</span> CompareKeys (<span class="keyword">const</span> T&amp; key1, <span class="keyword">const</span> T&amp; key2)
00069   {
00070     <span class="keywordflow">return</span> (key1 == key2);
00071   }
00072 };
00073 
00078 <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>K = <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, 
00079   <span class="keyword">class </span>KeyHandler = <a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler&lt;K&gt;</a> &gt; 
<a name="l00080"></a><a class="code" href="classcsHash.html">00080</a> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>
00081 {
00082 <span class="keyword">protected</span>:
00083   <span class="keyword">struct </span>Element
00084   {
00085     <span class="keyword">const</span> K key;
00086     T value;
00087 
00088     Element (<span class="keyword">const</span> K&amp; key0, <span class="keyword">const</span> T &amp;value0) : key (key0), value (value0) {}
00089     Element (<span class="keyword">const</span> Element &amp;other) : key (other.key), value (other.value) {}
00090   };
00091   <a class="code" href="classcsArray.html">csArray&lt; csArray&lt;Element&gt;</a> &gt; Elements;
00092 
00093   size_t Modulo;
00094 
00095 <span class="keyword">private</span>:
00096   size_t InitModulo;
00097   size_t GrowRate;
00098   size_t MaxSize;
00099   size_t Size;
00100 
00101   <span class="keywordtype">void</span> Grow ()
00102   {
00103     <span class="keyword">static</span> <span class="keyword">const</span> size_t Primes[] =
00104     {
00105       53,         97,         193,       389,       769, 
00106       1543,       3079,       6151,      12289,     24593,
00107       49157,      98317,      196613,    393241,    786433,
00108       1572869,    3145739,    6291469,   12582917,  25165843,
00109       50331653,   100663319,  201326611, 402653189, 805306457,
00110       1610612741, 0
00111     };
00112 
00113     <span class="keyword">const</span> size_t *p;
00114     size_t elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00115     <span class="keywordflow">for</span> (p = Primes; *p &amp;&amp; *p &lt;= elen; p++) ;
00116     Modulo = *p;
00117     CS_ASSERT (Modulo);
00118 
00119     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> (0, MIN (Modulo / GrowRate, 8)));
00120 
00121     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00122     {
00123       <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; src = Elements[i];
00124       size_t slen = src.<a class="code" href="classcsArray.html#a4">Length</a> ();
00125       <span class="keywordflow">for</span> (size_t j = slen; j &gt; 0; j--)
00126       {
00127         <span class="keyword">const</span> Element&amp; srcElem = src[j - 1];
00128         <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; dst = 
00129           Elements.<a class="code" href="classcsArray.html#a9">Get</a> (KeyHandler::ComputeHash (srcElem.key) % Modulo);
00130         <span class="keywordflow">if</span> (&amp;src != &amp;dst)
00131         {
00132           dst.<a class="code" href="classcsArray.html#a16">Push</a> (srcElem);
00133           src.DeleteIndex (j - 1);
00134         }
00135       }
00136     }
00137   }
00138 
00139 <span class="keyword">public</span>:
<a name="l00153"></a><a class="code" href="classcsHash.html#a0">00153</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keywordtype">int</span> size = 23, <span class="keywordtype">int</span> grow_rate = 5, <span class="keywordtype">int</span> max_size = 20000)
00154     : Elements (size), Modulo (size), InitModulo (size),
00155       GrowRate (MIN (grow_rate, size)), MaxSize (max_size), Size (0)
00156   {
00157     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (size, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> (0, MIN (size / GrowRate, 8)));
00158   }
00159 
<a name="l00161"></a><a class="code" href="classcsHash.html#a1">00161</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T&gt;</a> &amp;o) : Elements (o.Elements),
00162     Modulo (o.Modulo), InitModulo (o.InitModulo),
00163     GrowRate (o.GrowRate), MaxSize (o.MaxSize), Size (o.Size) {}
00164 
<a name="l00172"></a><a class="code" href="classcsHash.html#a2">00172</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a2">Put</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00173   {
00174     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00175       Elements[KeyHandler::ComputeHash (key) % Modulo];
00176     values.<a class="code" href="classcsArray.html#a16">Push</a> (Element (key, value));
00177     Size++;
00178     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00179      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00180   }
00181 
<a name="l00183"></a><a class="code" href="classcsHash.html#a3">00183</a>   <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> <a class="code" href="classcsHash.html#a3">GetAll</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00184 <span class="keyword">  </span>{
00185     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00186       Elements[KeyHandler::ComputeHash (key) % Modulo];
00187     <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> ret (values.<a class="code" href="classcsArray.html#a4">Length</a> () / 2);
00188     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00189     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00190     {
00191       <span class="keyword">const</span> Element&amp; v = values[i];
00192       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key)) 
00193         ret.<a class="code" href="classcsArray.html#a16">Push</a> (v.value);
00194     }
00195     <span class="keywordflow">return</span> ret;
00196   }
00197 
<a name="l00199"></a><a class="code" href="classcsHash.html#a4">00199</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a4">PutUnique</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00200   {
00201     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00202       Elements[KeyHandler::ComputeHash (key) % Modulo];
00203     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00204     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00205     {
00206       Element&amp; v = values[i];
00207       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00208       {
00209         v.value = value;
00210         <span class="keywordflow">return</span>;
00211       }
00212     }
00213 
00214     values.<a class="code" href="classcsArray.html#a16">Push</a> (Element (key, value));
00215     Size++;
00216     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00217      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00218   }
00219 
<a name="l00224"></a><a class="code" href="classcsHash.html#a5">00224</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a5">PutFirst</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00225   {
00226     <a class="code" href="classcsHash.html#a4">PutUnique</a>(key, value);
00227   }
00228 
<a name="l00230"></a><a class="code" href="classcsHash.html#a6">00230</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a6">In</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00231 <span class="keyword">  </span>{
00232     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00233       Elements[KeyHandler::ComputeHash (key) % Modulo];
00234     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00235     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00236       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key)) 
00237         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00238 
00239     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00240   }
00241 
<a name="l00246"></a><a class="code" href="classcsHash.html#a7">00246</a>   <span class="keyword">const</span> T* <a class="code" href="classcsHash.html#a7">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00247 <span class="keyword">  </span>{
00248     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00249       Elements[KeyHandler::ComputeHash (key) % Modulo];
00250     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00251     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00252     {
00253       <span class="keyword">const</span> Element&amp; v = values[i];
00254       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00255         <span class="keywordflow">return</span> &amp;v.value;
00256     }
00257 
00258     <span class="keywordflow">return</span> 0;
00259   }
00260 
<a name="l00265"></a><a class="code" href="classcsHash.html#a8">00265</a>   T* <a class="code" href="classcsHash.html#a7">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)
00266   {
00267     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00268       Elements[KeyHandler::ComputeHash (key) % Modulo];
00269     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00270     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00271     {
00272       Element&amp; v = values[i];
00273       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00274         <span class="keywordflow">return</span> &amp;v.value;
00275     }
00276 
00277     <span class="keywordflow">return</span> 0;
00278   }
00279 
<a name="l00284"></a><a class="code" href="classcsHash.html#a9">00284</a>   <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash.html#a9">Get</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T&amp; fallback)<span class="keyword"> const</span>
00285 <span class="keyword">  </span>{
00286     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00287       Elements[KeyHandler::ComputeHash (key) % Modulo];
00288     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00289     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00290     {
00291       <span class="keyword">const</span> Element&amp; v = values[i];
00292       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00293         <span class="keywordflow">return</span> v.value;
00294     }
00295 
00296     <span class="keywordflow">return</span> fallback;
00297   }
00298 
<a name="l00303"></a><a class="code" href="classcsHash.html#a10">00303</a>   T&amp; <a class="code" href="classcsHash.html#a9">Get</a> (<span class="keyword">const</span> K&amp; key, T&amp; fallback)
00304   {
00305     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00306       Elements[KeyHandler::ComputeHash (key) % Modulo];
00307     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00308     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00309     {
00310       Element&amp; v = values[i];
00311       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00312         <span class="keywordflow">return</span> v.value;
00313     }
00314 
00315     <span class="keywordflow">return</span> fallback;
00316   }
00317 
<a name="l00319"></a><a class="code" href="classcsHash.html#a11">00319</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a11">DeleteAll</a> ()
00320   {
00321     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo = InitModulo);
00322     size_t elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00323     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00324       Elements[i].<a class="code" href="classcsArray.html#a30">Empty</a> ();
00325     Size = 0;
00326   }
00327 
<a name="l00329"></a><a class="code" href="classcsHash.html#a12">00329</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a11">DeleteAll</a> (<span class="keyword">const</span> K&amp; key)
00330   {
00331     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00332     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00333       Elements[KeyHandler::ComputeHash (key) % Modulo];
00334     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a4">Length</a> (); i &gt; 0; i--)
00335     {
00336       <span class="keyword">const</span> size_t idx = i - 1;
00337       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[idx].key, key))
00338       {
00339         values.<a class="code" href="classcsArray.html#a33">DeleteIndex</a> (idx);
00340         ret = <span class="keyword">true</span>;
00341         Size--;
00342       }
00343     }
00344     <span class="keywordflow">return</span> ret;
00345   }
00346   
<a name="l00348"></a><a class="code" href="classcsHash.html#a13">00348</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a13">Delete</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00349   {
00350     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00351     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00352       Elements[KeyHandler::ComputeHash (key) % Modulo];
00353     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a4">Length</a> (); i &gt; 0; i--)
00354     {
00355       <span class="keyword">const</span> size_t idx = i - 1;
00356       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[idx].key, key) &amp;&amp; 
00357         (values[idx].value == value))
00358       {
00359         values.<a class="code" href="classcsArray.html#a33">DeleteIndex</a> (idx);
00360         ret = <span class="keyword">true</span>;
00361         Size--;
00362       }
00363     }
00364     <span class="keywordflow">return</span> ret;
00365   }
00366 
<a name="l00368"></a><a class="code" href="classcsHash.html#a14">00368</a>   size_t <a class="code" href="classcsHash.html#a14">GetSize</a> ()<span class="keyword"> const</span>
00369 <span class="keyword">  </span>{
00370     <span class="keywordflow">return</span> Size;
00371   }
00372 
<a name="l00374"></a><a class="code" href="classcsHash_1_1Iterator.html">00374</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>
00375   {
00376   <span class="keyword">private</span>:
00377     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash;
00378     <span class="keyword">const</span> K key;
00379     size_t bucket, size, element;
00380 
00381     <span class="keywordtype">void</span> Seek ()
00382     {
00383       <span class="keywordflow">while</span> ((element &lt; size) &amp;&amp; 
00384         ! KeyHandler::CompareKeys (hash-&gt;Elements[bucket][element].key, key))
00385           element++;
00386     }
00387 
00388   <span class="keyword">protected</span>:
00389     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash0, <span class="keyword">const</span> K&amp; key0) :
00390       hash(hash0),
00391       key(key0), 
00392       bucket(KeyHandler::ComputeHash(key) % hash-&gt;Modulo),
00393       size(hash-&gt;Elements[bucket].Length ())
00394       { <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> (); }
00395 
00396     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>&lt;T, K, KeyHandler&gt;;
00397   <span class="keyword">public</span>:
<a name="l00399"></a><a class="code" href="classcsHash_1_1Iterator.html#a0">00399</a>     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00400       hash (o.hash),
00401       key(o.key),
00402       bucket(o.bucket),
00403       size(o.size),
00404       element(o.element) {}
00405 
<a name="l00407"></a><a class="code" href="classcsHash_1_1Iterator.html#a1">00407</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; <a class="code" href="classcsHash_1_1Iterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; o)
00408     {
00409       hash = o.<a class="code" href="classcsHash_1_1Iterator.html#r0">hash</a>;
00410       key = o.<a class="code" href="classcsHash_1_1Iterator.html#r1">key</a>;
00411       bucket = o.<a class="code" href="classcsHash_1_1Iterator.html#r2">bucket</a>;
00412       size = o.<a class="code" href="classcsHash_1_1Iterator.html#r3">size</a>;
00413       element = o.<a class="code" href="classcsHash_1_1Iterator.html#r4">element</a>;
00414       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00415     }
00416 
<a name="l00418"></a><a class="code" href="classcsHash_1_1Iterator.html#a2">00418</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1Iterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00419 <span class="keyword">    </span>{
00420       <span class="keywordflow">return</span> element &lt; size;
00421     }
00422 
<a name="l00424"></a><a class="code" href="classcsHash_1_1Iterator.html#a3">00424</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1Iterator.html#a3">Next</a> ()
00425     {
00426       <span class="keyword">const</span> T &amp;ret = hash-&gt;Elements[bucket][element].value;
00427       element++;
00428       Seek ();
00429       <span class="keywordflow">return</span> ret;
00430     }
00431 
<a name="l00433"></a><a class="code" href="classcsHash_1_1Iterator.html#a4">00433</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> () { element = 0; Seek (); }
00434   };
00435   <span class="keyword">friend</span> <span class="keyword">class </span>Iterator;
00436 
<a name="l00438"></a><a class="code" href="classcsHash_1_1GlobalIterator.html">00438</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>
00439   {
00440   <span class="keyword">private</span>:
00441     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash;
00442     size_t bucket, size, element;
00443 
00444     <span class="keywordtype">void</span> Zero () { bucket = element = 0; }
00445     <span class="keywordtype">void</span> Init () { size = hash-&gt;Elements[bucket].Length (); }
00446 
00447     <span class="keywordtype">void</span> FindItem ()
00448     {
00449       <span class="keywordflow">if</span> (element &gt;= size)
00450       {
00451         <span class="keywordflow">while</span> (++bucket &lt; hash-&gt;Elements.Length ())
00452         {
00453           Init ();
00454           <span class="keywordflow">if</span> (size != 0)
00455           {
00456             element = 0;
00457             <span class="keywordflow">break</span>;
00458           }
00459         }
00460       }
00461     }
00462 
00463   <span class="keyword">protected</span>:
00464     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash0) : hash (hash0) 
00465     { 
00466       Zero (); 
00467       Init (); 
00468       FindItem ();
00469     }
00470 
00471     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>&lt;T, K, KeyHandler&gt;;
00472   <span class="keyword">public</span>:
<a name="l00474"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a0">00474</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00475       hash (o.hash),
00476       bucket (o.bucket),
00477       size (o.size),
00478       element (o.element) {}
00479 
<a name="l00481"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a1">00481</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; o)
00482     {
00483       hash = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r0">hash</a>;
00484       bucket = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r1">bucket</a>;
00485       size = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r2">size</a>;
00486       element = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r3">element</a>;
00487       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00488     }
00489 
<a name="l00491"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a2">00491</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00492 <span class="keyword">    </span>{
00493       <span class="keywordflow">if</span> (hash-&gt;Elements.Length () == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00494       <span class="keywordflow">return</span> element &lt; size || bucket &lt; hash-&gt;Elements.Length ();
00495     }
00496 
<a name="l00498"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a3">00498</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ()
00499     {
00500       element++;
00501       FindItem ();
00502     }
00503 
<a name="l00505"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a4">00505</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ()
00506     {
00507       <span class="keywordflow">return</span> hash-&gt;Elements[bucket][element].value;
00508     }
00509 
<a name="l00511"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a5">00511</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ()
00512     {
00513       <span class="keyword">const</span> T &amp;ret = <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00514       <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ();
00515       <span class="keywordflow">return</span> ret;
00516     }
00517 
00518     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> (K &amp;key)
00519     {
00520       key = hash-&gt;Elements[bucket][element].key;
00521       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00522     }
00523 
<a name="l00525"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a7">00525</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> (K &amp;key)
00526     {
00527       key = hash-&gt;Elements[bucket][element].key;
00528       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ();
00529     }
00530 
<a name="l00532"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a8">00532</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a8">Reset</a> () { Zero (); Init (); FindItem (); }
00533   };
00534   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00535 
<a name="l00538"></a><a class="code" href="classcsHash.html#a15">00538</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a15">DeleteElement</a> (GlobalIterator&amp; iterator)
00539   {
00540     Elements[iterator.bucket].<a class="code" href="classcsArray.html#a33">DeleteIndex</a>(iterator.element);
00541     Size--;
00542     iterator.size--;
00543     iterator.FindItem ();
00544   }
00545 
<a name="l00552"></a><a class="code" href="classcsHash.html#a16">00552</a>   Iterator <a class="code" href="classcsHash.html#a17">GetIterator</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00553 <span class="keyword">  </span>{
00554     <span class="keywordflow">return</span> Iterator (<span class="keyword">this</span>, key);
00555   }
00556 
<a name="l00562"></a><a class="code" href="classcsHash.html#a17">00562</a>   GlobalIterator <a class="code" href="classcsHash.html#a17">GetIterator</a> ()<span class="keyword"> const</span>
00563 <span class="keyword">  </span>{
00564     <span class="keywordflow">return</span> GlobalIterator (<span class="keyword">this</span>);
00565   }
00566 };
00567 
00573 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> KeyHandler = csIntegralHashKeyHandler&lt;T&gt; &gt; 
<a name="l00574"></a><a class="code" href="classcsSet.html">00574</a> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>
00575 {
00576 <span class="keyword">private</span>:
00577   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a> map;
00578 
00579 <span class="keyword">public</span>:
<a name="l00581"></a><a class="code" href="classcsSet_1_1Iterator.html">00581</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1Iterator.html">Iterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1Iterator.html">Iterator</a>
00582   {
00583   <span class="keyword">protected</span>:
00584     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> () {}
00585   <span class="keyword">public</span>:
00586   };
<a name="l00588"></a><a class="code" href="classcsSet_1_1GlobalIterator.html">00588</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>
00589   {
00590   <span class="keyword">protected</span>:
00591     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> () {}
00592     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsSet.html">csSet&lt;T, KeyHandler&gt;</a> *set0) : 
00593       <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;::GlobalIterator</a>(&amp;set0-&gt;map)
00594     { }
00595 
00596   <span class="keyword">public</span>:
00597     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>&lt;T, KeyHandler&gt;;
00598   };
00599   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00600 
<a name="l00605"></a><a class="code" href="classcsSet.html#a0">00605</a>   <a class="code" href="classcsSet.html#a0">csSet</a> (<span class="keywordtype">int</span> size = 23, <span class="keywordtype">int</span> grow_rate = 5, <span class="keywordtype">int</span> max_size = 20000)
00606         : map (size, grow_rate, max_size)
00607   {
00608   }
00609 
<a name="l00614"></a><a class="code" href="classcsSet.html#a1">00614</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a1">Add</a> (<span class="keyword">const</span> T&amp; object)
00615   {
00616     <span class="keywordflow">if</span> (<a class="code" href="classcsSet.html#a3">In</a> (object)) <span class="keywordflow">return</span>;
00617     <a class="code" href="classcsSet.html#a2">AddNoTest</a> (object);
00618   }
00619 
<a name="l00626"></a><a class="code" href="classcsSet.html#a2">00626</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a2">AddNoTest</a> (<span class="keyword">const</span> T&amp; object)
00627   {
00628     map.<a class="code" href="classcsHash.html#a2">Put</a> (object, object);
00629   }
00630 
<a name="l00634"></a><a class="code" href="classcsSet.html#a3">00634</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a3">In</a> (<span class="keyword">const</span> T&amp; object)<span class="keyword"> const</span>
00635 <span class="keyword">  </span>{
00636     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a6">In</a> (object);
00637   }
00638 
<a name="l00642"></a><a class="code" href="classcsSet.html#a4">00642</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a4">DeleteAll</a> ()
00643   {
00644     map.<a class="code" href="classcsHash.html#a11">DeleteAll</a> ();
00645   }
00646 
<a name="l00652"></a><a class="code" href="classcsSet.html#a5">00652</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a5">Delete</a> (<span class="keyword">const</span> T&amp; object)
00653   {
00654     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a13">Delete</a> (object, object);
00655   }
00656 
<a name="l00658"></a><a class="code" href="classcsSet.html#a6">00658</a>   size_t <a class="code" href="classcsSet.html#a6">GetSize</a> ()<span class="keyword"> const</span>
00659 <span class="keyword">  </span>{
00660     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a14">GetSize</a> ();
00661   }
00662 
<a name="l00664"></a><a class="code" href="classcsSet.html#a7">00664</a>   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a>* <a class="code" href="classcsSet.html#a7">GetHash</a> () { <span class="keywordflow">return</span> &amp;map; }
00665 
<a name="l00671"></a><a class="code" href="classcsSet.html#a8">00671</a>   GlobalIterator <a class="code" href="classcsSet.html#a8">GetIterator</a> ()<span class="keyword"> const</span>
00672 <span class="keyword">  </span>{
00673     <span class="keywordflow">return</span> GlobalIterator(<span class="keyword">this</span>);
00674   }
00675 };
00676 
00677 
00678 <span class="preprocessor">#endif</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.3 
</small></address> </div></body> </html>
