<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/hash.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000022.html">csutil</a></div>
<h1>hash.h</h1><a href="hash_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2003 by Mat Sutcliffe &lt;oktal@gmx.co.uk&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_UTIL_HASH_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_UTIL_HASH_H__</span>
00021 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include "csextern.h"</span>
00027 <span class="preprocessor">#include "<a class="code" href="array_8h.html">array.h</a>"</span>
00028 
00035 CS_CRYSTALSPACE_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="hash_8h.html#a1">csHashCompute</a> (<span class="keywordtype">char</span> <span class="keyword">const</span>*);
00036 
00043 CS_CRYSTALSPACE_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="hash_8h.html#a1">csHashCompute</a> (<span class="keywordtype">char</span> <span class="keyword">const</span>*, size_t length);
00044 
00048 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00049"></a><a class="code" href="classcsIntegralHashKeyHandler.html">00049</a> <span class="keyword">class </span><a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler</a>
00050 {
00051 <span class="keyword">public</span>:
00052   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ComputeHash (<span class="keyword">const</span> T&amp; key)
00053   {
00054 <span class="preprocessor">#if (CS_PROCESSOR_SIZE == 32)</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#if (_MSC_VER &gt;= 1300)</span>
00056 <span class="preprocessor"></span>    <span class="comment">/*</span>
00057 <span class="comment">      VC7 with 64bit warnings complains about a pointer truncation when T is</span>
00058 <span class="comment">      a pointer. This isn't serious (as csHash&lt;&gt; does not rely on the hash of</span>
00059 <span class="comment">      a key alone to retrieve a value). The __w64 causes VC7 to not emit that</span>
00060 <span class="comment">      warning (on 32bit compilers at least).</span>
00061 <span class="comment">     */</span>
00062     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __w64)key;  
00063 <span class="preprocessor">#else</span>
00064 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> int)key;  
00065 <span class="preprocessor">#endif</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00067 <span class="preprocessor"></span>    <span class="comment">// Cast to uint64 first to avoid compiler warnings about truncation.</span>
00068     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> int)((uint64)key);
00069 <span class="preprocessor">#endif</span>
00070 <span class="preprocessor"></span>  }
00071 
00072   <span class="keyword">static</span> <span class="keywordtype">bool</span> CompareKeys (<span class="keyword">const</span> T&amp; key1, <span class="keyword">const</span> T&amp; key2)
00073   {
00074     <span class="keywordflow">return</span> (key1 == key2);
00075   }
00076 };
00077 
00082 <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>K = <span class="keywordtype">unsigned</span> int, 
00083   <span class="keyword">class </span>KeyHandler = <a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler&lt;K&gt;</a> &gt; 
<a name="l00084"></a><a class="code" href="classcsHash.html">00084</a> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>
00085 {
00086 <span class="keyword">protected</span>:
00087   <span class="keyword">struct </span>Element
00088   {
00089     <span class="keyword">const</span> K key;
00090     T value;
00091 
00092     Element (<span class="keyword">const</span> K&amp; key0, <span class="keyword">const</span> T &amp;value0) : key (key0), value (value0) {}
00093     Element (<span class="keyword">const</span> Element &amp;other) : key (other.key), value (other.value) {}
00094   };
00095   <a class="code" href="classcsArray.html">csArray&lt; csArray&lt;Element&gt;</a> &gt; Elements;
00096 
00097   size_t Modulo;
00098 
00099 <span class="keyword">private</span>:
00100   size_t InitModulo;
00101   size_t GrowRate;
00102   size_t MaxSize;
00103   size_t Size;
00104 
00105   <span class="keywordtype">void</span> Grow ()
00106   {
00107     <span class="keyword">static</span> <span class="keyword">const</span> size_t Primes[] =
00108     {
00109       53,         97,         193,       389,       769, 
00110       1543,       3079,       6151,      12289,     24593,
00111       49157,      98317,      196613,    393241,    786433,
00112       1572869,    3145739,    6291469,   12582917,  25165843,
00113       50331653,   100663319,  201326611, 402653189, 805306457,
00114       1610612741, 0
00115     };
00116 
00117     <span class="keyword">const</span> size_t *p;
00118     size_t elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00119     <span class="keywordflow">for</span> (p = Primes; *p &amp;&amp; *p &lt;= elen; p++) ;
00120     Modulo = *p;
00121     CS_ASSERT (Modulo);
00122 
00123     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> (0, MIN (Modulo / GrowRate, 8)));
00124 
00125     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00126     {
00127       <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; src = Elements[i];
00128       size_t slen = src.<a class="code" href="classcsArray.html#a4">Length</a> ();
00129       <span class="keywordflow">for</span> (size_t j = slen; j &gt; 0; j--)
00130       {
00131         <span class="keyword">const</span> Element&amp; srcElem = src[j - 1];
00132         <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; dst = 
00133           Elements.<a class="code" href="classcsArray.html#a9">Get</a> (KeyHandler::ComputeHash (srcElem.key) % Modulo);
00134         <span class="keywordflow">if</span> (&amp;src != &amp;dst)
00135         {
00136           dst.<a class="code" href="classcsArray.html#a16">Push</a> (srcElem);
00137           src.<a class="code" href="classcsArray.html#a33">DeleteIndex</a> (j - 1);
00138         }
00139       }
00140     }
00141   }
00142 
00143 <span class="keyword">public</span>:
<a name="l00157"></a><a class="code" href="classcsHash.html#a0">00157</a>   <a class="code" href="classcsHash.html">csHash</a> (<span class="keywordtype">int</span> size = 23, <span class="keywordtype">int</span> grow_rate = 5, <span class="keywordtype">int</span> max_size = 20000)
00158     : Elements (size), Modulo (size), InitModulo (size),
00159       GrowRate (MIN (grow_rate, size)), MaxSize (max_size), Size (0)
00160   {
00161     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (size, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> (0, MIN (size / GrowRate, 8)));
00162   }
00163 
<a name="l00165"></a><a class="code" href="classcsHash.html#a1">00165</a>   <a class="code" href="classcsHash.html">csHash</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T&gt;</a> &amp;o) : Elements (o.Elements),
00166     Modulo (o.Modulo), InitModulo (o.InitModulo),
00167     GrowRate (o.GrowRate), MaxSize (o.MaxSize), Size (o.Size) {}
00168 
<a name="l00176"></a><a class="code" href="classcsHash.html#a2">00176</a>   <span class="keywordtype">void</span> Put (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00177   {
00178     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00179       Elements[KeyHandler::ComputeHash (key) % Modulo];
00180     values.<a class="code" href="classcsArray.html#a16">Push</a> (Element (key, value));
00181     Size++;
00182     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00183      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00184   }
00185 
<a name="l00187"></a><a class="code" href="classcsHash.html#a3">00187</a>   <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> GetAll (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00188 <span class="keyword">  </span>{
00189     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00190       Elements[KeyHandler::ComputeHash (key) % Modulo];
00191     <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> ret (values.<a class="code" href="classcsArray.html#a4">Length</a> () / 2);
00192     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00193     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00194     {
00195       <span class="keyword">const</span> Element&amp; v = values[i];
00196       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key)) 
00197         ret.<a class="code" href="classcsArray.html#a16">Push</a> (v.value);
00198     }
00199     <span class="keywordflow">return</span> ret;
00200   }
00201 
<a name="l00203"></a><a class="code" href="classcsHash.html#a4">00203</a>   <span class="keywordtype">void</span> PutUnique (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00204   {
00205     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00206       Elements[KeyHandler::ComputeHash (key) % Modulo];
00207     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00208     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00209     {
00210       Element&amp; v = values[i];
00211       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00212       {
00213         v.value = value;
00214         <span class="keywordflow">return</span>;
00215       }
00216     }
00217 
00218     values.<a class="code" href="classcsArray.html#a16">Push</a> (Element (key, value));
00219     Size++;
00220     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00221      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00222   }
00223 
<a name="l00228"></a><a class="code" href="classcsHash.html#a5">00228</a>   <a class="code" href="cssysdef_8h.html#a39">CS_DEPRECATED_METHOD</a> <span class="keywordtype">void</span> PutFirst (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00229   {
00230     PutUnique(key, value);
00231   }
00232 
<a name="l00234"></a><a class="code" href="classcsHash.html#a6">00234</a>   <span class="keywordtype">bool</span> Contains (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00235 <span class="keyword">  </span>{
00236     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00237       Elements[KeyHandler::ComputeHash (key) % Modulo];
00238     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00239     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00240       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key)) 
00241         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00242     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00243   }
00244 
<a name="l00250"></a><a class="code" href="classcsHash.html#a7">00250</a>   <span class="keywordtype">bool</span> In (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00251 <span class="keyword">  </span>{ <span class="keywordflow">return</span> Contains(key); }
00252 
<a name="l00257"></a><a class="code" href="classcsHash.html#a8">00257</a>   <span class="keyword">const</span> T* GetElementPointer (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00258 <span class="keyword">  </span>{
00259     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00260       Elements[KeyHandler::ComputeHash (key) % Modulo];
00261     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00262     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00263     {
00264       <span class="keyword">const</span> Element&amp; v = values[i];
00265       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00266         <span class="keywordflow">return</span> &amp;v.value;
00267     }
00268 
00269     <span class="keywordflow">return</span> 0;
00270   }
00271 
<a name="l00276"></a><a class="code" href="classcsHash.html#a9">00276</a>   T* GetElementPointer (<span class="keyword">const</span> K&amp; key)
00277   {
00278     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00279       Elements[KeyHandler::ComputeHash (key) % Modulo];
00280     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00281     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00282     {
00283       Element&amp; v = values[i];
00284       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00285         <span class="keywordflow">return</span> &amp;v.value;
00286     }
00287 
00288     <span class="keywordflow">return</span> 0;
00289   }
00290 
<a name="l00295"></a><a class="code" href="classcsHash.html#a10">00295</a>   <span class="keyword">const</span> T&amp; Get (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T&amp; fallback)<span class="keyword"> const</span>
00296 <span class="keyword">  </span>{
00297     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00298       Elements[KeyHandler::ComputeHash (key) % Modulo];
00299     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00300     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00301     {
00302       <span class="keyword">const</span> Element&amp; v = values[i];
00303       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00304         <span class="keywordflow">return</span> v.value;
00305     }
00306 
00307     <span class="keywordflow">return</span> fallback;
00308   }
00309 
<a name="l00314"></a><a class="code" href="classcsHash.html#a11">00314</a>   T&amp; Get (<span class="keyword">const</span> K&amp; key, T&amp; fallback)
00315   {
00316     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00317       Elements[KeyHandler::ComputeHash (key) % Modulo];
00318     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00319     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00320     {
00321       Element&amp; v = values[i];
00322       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00323         <span class="keywordflow">return</span> v.value;
00324     }
00325 
00326     <span class="keywordflow">return</span> fallback;
00327   }
00328 
<a name="l00330"></a><a class="code" href="classcsHash.html#a12">00330</a>   <span class="keywordtype">void</span> DeleteAll ()
00331   {
00332     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo = InitModulo);
00333     size_t elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00334     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00335       Elements[i].<a class="code" href="classcsArray.html#a30">Empty</a> ();
00336     Size = 0;
00337   }
00338 
<a name="l00340"></a><a class="code" href="classcsHash.html#a13">00340</a>   <span class="keywordtype">bool</span> DeleteAll (<span class="keyword">const</span> K&amp; key)
00341   {
00342     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00343     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00344       Elements[KeyHandler::ComputeHash (key) % Modulo];
00345     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a4">Length</a> (); i &gt; 0; i--)
00346     {
00347       <span class="keyword">const</span> size_t idx = i - 1;
00348       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[idx].key, key))
00349       {
00350         values.<a class="code" href="classcsArray.html#a34">DeleteIndexFast</a> (idx);
00351         ret = <span class="keyword">true</span>;
00352         Size--;
00353       }
00354     }
00355     <span class="keywordflow">return</span> ret;
00356   }
00357   
<a name="l00359"></a><a class="code" href="classcsHash.html#a14">00359</a>   <span class="keywordtype">bool</span> Delete (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00360   {
00361     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00362     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00363       Elements[KeyHandler::ComputeHash (key) % Modulo];
00364     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a4">Length</a> (); i &gt; 0; i--)
00365     {
00366       <span class="keyword">const</span> size_t idx = i - 1;
00367       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[idx].key, key) &amp;&amp; 
00368         (values[idx].value == value))
00369       {
00370         values.<a class="code" href="classcsArray.html#a34">DeleteIndexFast</a> (idx);
00371         ret = <span class="keyword">true</span>;
00372         Size--;
00373       }
00374     }
00375     <span class="keywordflow">return</span> ret;
00376   }
00377 
<a name="l00379"></a><a class="code" href="classcsHash.html#a15">00379</a>   size_t GetSize ()<span class="keyword"> const</span>
00380 <span class="keyword">  </span>{
00381     <span class="keywordflow">return</span> Size;
00382   }
00383 
<a name="l00385"></a><a class="code" href="classcsHash_1_1Iterator.html">00385</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>
00386   {
00387   <span class="keyword">private</span>:
00388     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash;
00389     <span class="keyword">const</span> K key;
00390     size_t bucket, size, element;
00391 
00392     <span class="keywordtype">void</span> Seek ()
00393     {
00394       <span class="keywordflow">while</span> ((element &lt; size) &amp;&amp; 
00395         ! KeyHandler::CompareKeys (hash-&gt;<a class="code" href="classcsHash.html#p0">Elements</a>[bucket][element].key, key))
00396           element++;
00397     }
00398 
00399   <span class="keyword">protected</span>:
00400     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash0, <span class="keyword">const</span> K&amp; key0) :
00401       hash(hash0),
00402       key(key0), 
00403       bucket(KeyHandler::ComputeHash(key) % hash-&gt;<a class="code" href="classcsHash.html#p1">Modulo</a>),
00404       size(hash-&gt;<a class="code" href="classcsHash.html#p0">Elements</a>[bucket].<a class="code" href="classcsArray.html#a4">Length</a> ())
00405       { Reset (); }
00406 
00407     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>&lt;T, K, KeyHandler&gt;;
00408   <span class="keyword">public</span>:
<a name="l00410"></a><a class="code" href="classcsHash_1_1Iterator.html#a0">00410</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00411       hash (o.hash),
00412       key(o.key),
00413       bucket(o.bucket),
00414       size(o.size),
00415       element(o.element) {}
00416 
<a name="l00418"></a><a class="code" href="classcsHash_1_1Iterator.html#a1">00418</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; o)
00419     {
00420       hash = o.<a class="code" href="classcsHash_1_1Iterator.html#r0">hash</a>;
00421       key = o.<a class="code" href="classcsHash_1_1Iterator.html#r1">key</a>;
00422       bucket = o.<a class="code" href="classcsHash_1_1Iterator.html#r2">bucket</a>;
00423       size = o.<a class="code" href="classcsHash_1_1Iterator.html#r3">size</a>;
00424       element = o.<a class="code" href="classcsHash_1_1Iterator.html#r4">element</a>;
00425       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00426     }
00427 
<a name="l00429"></a><a class="code" href="classcsHash_1_1Iterator.html#a2">00429</a>     <span class="keywordtype">bool</span> HasNext ()<span class="keyword"> const</span>
00430 <span class="keyword">    </span>{
00431       <span class="keywordflow">return</span> element &lt; size;
00432     }
00433 
<a name="l00435"></a><a class="code" href="classcsHash_1_1Iterator.html#a3">00435</a>     <span class="keyword">const</span> T&amp; Next ()
00436     {
00437       <span class="keyword">const</span> T &amp;ret = hash-&gt;<a class="code" href="classcsHash.html#p0">Elements</a>[bucket][element].value;
00438       element++;
00439       Seek ();
00440       <span class="keywordflow">return</span> ret;
00441     }
00442 
<a name="l00444"></a><a class="code" href="classcsHash_1_1Iterator.html#a4">00444</a>     <span class="keywordtype">void</span> Reset () { element = 0; Seek (); }
00445   };
00446   <span class="keyword">friend</span> <span class="keyword">class </span>Iterator;
00447 
<a name="l00449"></a><a class="code" href="classcsHash_1_1GlobalIterator.html">00449</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>
00450   {
00451   <span class="keyword">private</span>:
00452     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash;
00453     size_t bucket, size, element;
00454 
00455     <span class="keywordtype">void</span> Zero () { bucket = element = 0; }
00456     <span class="keywordtype">void</span> Init () { size = hash-&gt;<a class="code" href="classcsHash.html#p0">Elements</a>[bucket].<a class="code" href="classcsArray.html#a4">Length</a> (); }
00457 
00458     <span class="keywordtype">void</span> FindItem ()
00459     {
00460       <span class="keywordflow">if</span> (element &gt;= size)
00461       {
00462         <span class="keywordflow">while</span> (++bucket &lt; hash-&gt;<a class="code" href="classcsHash.html#p0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> ())
00463         {
00464           Init ();
00465           <span class="keywordflow">if</span> (size != 0)
00466           {
00467             element = 0;
00468             <span class="keywordflow">break</span>;
00469           }
00470         }
00471       }
00472     }
00473 
00474   <span class="keyword">protected</span>:
00475     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash0) : hash (hash0) 
00476     { 
00477       Zero (); 
00478       Init (); 
00479       FindItem ();
00480     }
00481 
00482     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>&lt;T, K, KeyHandler&gt;;
00483   <span class="keyword">public</span>:
<a name="l00485"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a0">00485</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00486       hash (o.hash),
00487       bucket (o.bucket),
00488       size (o.size),
00489       element (o.element) {}
00490 
<a name="l00492"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a1">00492</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; o)
00493     {
00494       hash = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r0">hash</a>;
00495       bucket = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r1">bucket</a>;
00496       size = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r2">size</a>;
00497       element = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r3">element</a>;
00498       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00499     }
00500 
<a name="l00502"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a2">00502</a>     <span class="keywordtype">bool</span> HasNext ()<span class="keyword"> const</span>
00503 <span class="keyword">    </span>{
00504       <span class="keywordflow">if</span> (hash-&gt;<a class="code" href="classcsHash.html#p0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> () == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00505       <span class="keywordflow">return</span> element &lt; size || bucket &lt; hash-&gt;<a class="code" href="classcsHash.html#p0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> ();
00506     }
00507 
<a name="l00509"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a3">00509</a>     <span class="keywordtype">void</span> Advance ()
00510     {
00511       element++;
00512       FindItem ();
00513     }
00514 
<a name="l00516"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a4">00516</a>     <span class="keyword">const</span> T&amp; NextNoAdvance ()
00517     {
00518       <span class="keywordflow">return</span> hash-&gt;<a class="code" href="classcsHash.html#p0">Elements</a>[bucket][element].value;
00519     }
00520 
<a name="l00522"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a5">00522</a>     <span class="keyword">const</span> T&amp; Next ()
00523     {
00524       <span class="keyword">const</span> T &amp;ret = NextNoAdvance ();
00525       Advance ();
00526       <span class="keywordflow">return</span> ret;
00527     }
00528 
00529     <span class="keyword">const</span> T&amp; NextNoAdvance (K &amp;key)
00530     {
00531       key = hash-&gt;<a class="code" href="classcsHash.html#p0">Elements</a>[bucket][element].key;
00532       <span class="keywordflow">return</span> NextNoAdvance ();
00533     }
00534 
<a name="l00536"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a7">00536</a>     <span class="keyword">const</span> T&amp; Next (K &amp;key)
00537     {
00538       key = hash-&gt;<a class="code" href="classcsHash.html#p0">Elements</a>[bucket][element].key;
00539       <span class="keywordflow">return</span> Next ();
00540     }
00541 
<a name="l00543"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a8">00543</a>     <span class="keywordtype">void</span> Reset () { Zero (); Init (); FindItem (); }
00544   };
00545   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00546 
<a name="l00549"></a><a class="code" href="classcsHash.html#a16">00549</a>   <span class="keywordtype">void</span> DeleteElement (GlobalIterator&amp; iterator)
00550   {
00551     Elements[iterator.bucket].<a class="code" href="classcsArray.html#a33">DeleteIndex</a>(iterator.element);
00552     Size--;
00553     iterator.size--;
00554     iterator.FindItem ();
00555   }
00556 
<a name="l00563"></a><a class="code" href="classcsHash.html#a17">00563</a>   Iterator GetIterator (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00564 <span class="keyword">  </span>{
00565     <span class="keywordflow">return</span> Iterator (<span class="keyword">this</span>, key);
00566   }
00567 
<a name="l00573"></a><a class="code" href="classcsHash.html#a18">00573</a>   GlobalIterator GetIterator ()<span class="keyword"> const</span>
00574 <span class="keyword">  </span>{
00575     <span class="keywordflow">return</span> GlobalIterator (<span class="keyword">this</span>);
00576   }
00577 };
00578 
00584 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> KeyHandler = csIntegralHashKeyHandler&lt;T&gt; &gt; 
<a name="l00585"></a><a class="code" href="classcsSet.html">00585</a> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>
00586 {
00587 <span class="keyword">private</span>:
00588   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a> map;
00589 
00590 <span class="keyword">public</span>:
<a name="l00592"></a><a class="code" href="classcsSet_1_1GlobalIterator.html">00592</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>
00593   {
00594   <span class="keyword">protected</span>:
00595     <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> () {}
00596     <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsSet.html">csSet&lt;T, KeyHandler&gt;</a> *set0) : 
00597       <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;::GlobalIterator</a>(&amp;set0-&gt;<a class="code" href="classcsSet.html#r0">map</a>)
00598     { }
00599 
00600   <span class="keyword">public</span>:
00601     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>&lt;T, KeyHandler&gt;;
00602   };
00603   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>;
00604 
<a name="l00609"></a><a class="code" href="classcsSet.html#a0">00609</a>   <a class="code" href="classcsSet.html">csSet</a> (<span class="keywordtype">int</span> size = 23, <span class="keywordtype">int</span> grow_rate = 5, <span class="keywordtype">int</span> max_size = 20000)
00610         : map (size, grow_rate, max_size)
00611   {
00612   }
00613 
<a name="l00618"></a><a class="code" href="classcsSet.html#a1">00618</a>   <span class="keywordtype">void</span> Add (<span class="keyword">const</span> T&amp; object)
00619   {
00620     <span class="keywordflow">if</span> (!Contains (object))
00621       AddNoTest (object);
00622   }
00623 
<a name="l00630"></a><a class="code" href="classcsSet.html#a2">00630</a>   <span class="keywordtype">void</span> AddNoTest (<span class="keyword">const</span> T&amp; object)
00631   {
00632     map.<a class="code" href="classcsHash.html#a2">Put</a> (object, object);
00633   }
00634 
<a name="l00638"></a><a class="code" href="classcsSet.html#a3">00638</a>   <span class="keywordtype">bool</span> Contains (<span class="keyword">const</span> T&amp; object)<span class="keyword"> const</span>
00639 <span class="keyword">  </span>{
00640     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a6">Contains</a> (object);
00641   }
00642 
<a name="l00648"></a><a class="code" href="classcsSet.html#a4">00648</a>   <span class="keywordtype">bool</span> In (<span class="keyword">const</span> T&amp; object)<span class="keyword"> const</span>
00649 <span class="keyword">  </span>{ <span class="keywordflow">return</span> Contains(object); }
00650 
<a name="l00654"></a><a class="code" href="classcsSet.html#a5">00654</a>   <span class="keywordtype">void</span> DeleteAll ()
00655   {
00656     map.<a class="code" href="classcsHash.html#a12">DeleteAll</a> ();
00657   }
00658 
<a name="l00664"></a><a class="code" href="classcsSet.html#a6">00664</a>   <span class="keywordtype">bool</span> Delete (<span class="keyword">const</span> T&amp; object)
00665   {
00666     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a14">Delete</a> (object, object);
00667   }
00668 
<a name="l00670"></a><a class="code" href="classcsSet.html#a7">00670</a>   size_t GetSize ()<span class="keyword"> const</span>
00671 <span class="keyword">  </span>{
00672     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a15">GetSize</a> ();
00673   }
00674 
<a name="l00676"></a><a class="code" href="classcsSet.html#a8">00676</a>   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a>* GetHash () { <span class="keywordflow">return</span> &amp;map; }
00677 
<a name="l00683"></a><a class="code" href="classcsSet.html#a9">00683</a>   GlobalIterator GetIterator ()<span class="keyword"> const</span>
00684 <span class="keyword">  </span>{
00685     <span class="keywordflow">return</span> GlobalIterator(<span class="keyword">this</span>);
00686   }
00687 };
00688 
00689 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.9.1 
</small></address> </div></body> </html>
