<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csgfx/vertexlight.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000004.html">csgfx</a></div>
<h1>vertexlight.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">  Copyright (C) 2005 by Marten Svanfeldt</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">  modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">  License as published by the Free Software Foundation; either</span>
00007 <span class="comment">  version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">  This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">  Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">  You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">  License along with this library; if not, write to the Free</span>
00016 <span class="comment">  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_VERTEXLIGHT_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_VERTEXLIGHT_H__</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include "<a class="code" href="math_8h.html">csgeom/math.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="vector3_8h.html">csgeom/vector3.h</a>"</span>
00024 <span class="preprocessor">#include "<a class="code" href="light_8h.html">iengine/light.h</a>"</span>
00025 
00026 <span class="comment">// Attenuation functors</span>
00027 
<a name="l00031"></a><a class="code" href="structcsNoAttenuation.html">00031</a> <span class="keyword">struct </span>CS_CSGFX_EXPORT csNoAttenuation
00032 {
00033   csNoAttenuation (<a class="code" href="structiLight.html">iLight</a> *light)
00034   {}
00035 
00036   CS_FORCEINLINE <span class="keywordtype">void</span> operator() (<span class="keywordtype">float</span> distance, <span class="keywordtype">float</span> &amp;dp)<span class="keyword"> const</span>
00037 <span class="keyword">  </span>{}
00038 };
00039 
<a name="l00044"></a><a class="code" href="structcsLinearAttenuation.html">00044</a> <span class="keyword">struct </span>CS_CSGFX_EXPORT csLinearAttenuation
00045 {
00046   csLinearAttenuation (<a class="code" href="structiLight.html">iLight</a> *light)
00047   {
00048     invrad = 1/light-&gt;<a class="code" href="structiLight.html#a18">GetAttenuationConstants</a> ().<a class="code" href="classcsVector3.html#o0">x</a>;
00049   }
00050 
00051   CS_FORCEINLINE <span class="keywordtype">void</span> operator() (<span class="keywordtype">float</span> distance, <span class="keywordtype">float</span>&amp; dp)<span class="keyword"> const</span>
00052 <span class="keyword">  </span>{
00053     dp = dp * (1 - distance * invrad);
00054   }
00055 
00056   <span class="keywordtype">float</span> invrad;
00057 };
00058 
<a name="l00063"></a><a class="code" href="structcsInverseAttenuation.html">00063</a> <span class="keyword">struct </span>CS_CSGFX_EXPORT csInverseAttenuation
00064 {
00065   csInverseAttenuation (<a class="code" href="structiLight.html">iLight</a> *light)
00066   {}
00067 
00068   CS_FORCEINLINE <span class="keywordtype">void</span> operator() (<span class="keywordtype">float</span> distance, <span class="keywordtype">float</span>&amp; dp)<span class="keyword"> const</span>
00069 <span class="keyword">  </span>{
00070     dp = dp / distance;
00071   }
00072 };
00073 
00074 
<a name="l00079"></a><a class="code" href="structcsRealisticAttenuation.html">00079</a> <span class="keyword">struct </span>CS_CSGFX_EXPORT csRealisticAttenuation
00080 {
00081   csRealisticAttenuation (<a class="code" href="structiLight.html">iLight</a> *light)
00082   {}
00083 
00084   CS_FORCEINLINE <span class="keywordtype">void</span> operator() (<span class="keywordtype">float</span> distance, <span class="keywordtype">float</span>&amp; dp)<span class="keyword"> const</span>
00085 <span class="keyword">  </span>{
00086     dp = dp / (distance*distance);
00087   }
00088 };
00089 
<a name="l00094"></a><a class="code" href="structcsCLQAttenuation.html">00094</a> <span class="keyword">struct </span>CS_CSGFX_EXPORT csCLQAttenuation
00095 {
00096   csCLQAttenuation (<a class="code" href="structiLight.html">iLight</a> *light)
00097     : attnVec (light-&gt;<a class="code" href="structiLight.html#a18">GetAttenuationConstants</a> ())
00098   {}
00099 
00100   CS_FORCEINLINE <span class="keywordtype">void</span> operator() (<span class="keywordtype">float</span> distance, <span class="keywordtype">float</span>&amp; dp)<span class="keyword"> const</span>
00101 <span class="keyword">  </span>{
00102     dp = dp/(<a class="code" href="classcsVector3.html">csVector3</a> (1.0, distance, distance*distance)*attnVec);
00103   }
00104 
00105   <a class="code" href="classcsVector3.html">csVector3</a> attnVec;
00106 };
00107 
00113 <span class="keyword">template</span>&lt;<span class="keyword">class</span> AttenuationProc&gt;
<a name="l00114"></a><a class="code" href="classcsPointLightProc.html">00114</a> <span class="keyword">class </span><a class="code" href="classcsPointLightProc.html">csPointLightProc</a>
00115 {
00116 <span class="keyword">public</span>:
00117   <a class="code" href="classcsPointLightProc.html">csPointLightProc</a> (<a class="code" href="structiLight.html">iLight</a> *light, <a class="code" href="structiMovable.html">iMovable</a> *objectMovable,
00118     <span class="keywordtype">float</span> blackLimit = 0.0001f)
00119     : attn (light), nullColor (0.0f, 0.0f, 0.0f), blackLimit (blackLimit)
00120   {
00121     <a class="code" href="classcsReversibleTransform.html">csReversibleTransform</a> objT = objectMovable-&gt;<a class="code" href="structiMovable.html#a13">GetFullTransform</a> ();
00122     lightPos = objT.<a class="code" href="classcsTransform.html#a11">Other2This</a> (light-&gt;<a class="code" href="structiLight.html#a6">GetMovable</a> ()-&gt;<a class="code" href="structiMovable.html#a9">GetFullPosition</a> ());
00123     lightCol = light-&gt;<a class="code" href="structiLight.html#a7">GetColor</a> ();
00124   }
00125 
00126   CS_FORCEINLINE
00127   <a class="code" href="classcsColor.html">csColor</a> ProcessVertex (<span class="keyword">const</span> <a class="code" href="classcsVector3.html">csVector3</a> &amp;v,<span class="keyword">const</span> <a class="code" href="classcsVector3.html">csVector3</a> &amp;n)<span class="keyword"> const</span>
00128 <span class="keyword">  </span>{
00129     <span class="comment">//compute gouraud shading..</span>
00130     <a class="code" href="classcsVector3.html">csVector3</a> direction = v-lightPos;
00131     <span class="keywordtype">float</span> distance = <a class="code" href="group__floating__point.html#ga5">csQsqrt</a>(direction.<a class="code" href="classcsVector3.html#a21">SquaredNorm</a> ());
00132     <span class="keywordtype">float</span> dp = direction*n/distance;
00133     <span class="keywordflow">if</span> (dp &gt; blackLimit)
00134     {
00135       attn (distance, dp);
00136       <span class="keywordflow">return</span> lightCol*dp;
00137     }
00138     <span class="keywordflow">return</span> nullColor;
00139   }
00140 
00141 <span class="keyword">private</span>:
00142   AttenuationProc attn;
00143   <a class="code" href="classcsVector3.html">csVector3</a> lightPos; <span class="comment">//localspace</span>
00144   <a class="code" href="classcsColor.html">csColor</a> lightCol;
00145   <a class="code" href="classcsColor.html">csColor</a> nullColor;
00146   <span class="keywordtype">float</span> blackLimit;
00147 };
00148 
00154 <span class="keyword">template</span>&lt;<span class="keyword">class</span> AttenuationProc&gt;
<a name="l00155"></a><a class="code" href="classcsDirectionalLightProc.html">00155</a> <span class="keyword">class </span><a class="code" href="classcsDirectionalLightProc.html">csDirectionalLightProc</a>
00156 {
00157 <span class="keyword">public</span>:
00158   <a class="code" href="classcsDirectionalLightProc.html">csDirectionalLightProc</a> (<a class="code" href="structiLight.html">iLight</a> *light, <a class="code" href="structiMovable.html">iMovable</a> *objectMovable,
00159     <span class="keywordtype">float</span> blackLimit = 0.0001f)
00160     : attn (light), nullColor (0.0f, 0.0f, 0.0f), blackLimit (blackLimit)
00161   {
00162     <a class="code" href="classcsReversibleTransform.html">csReversibleTransform</a> objT = objectMovable-&gt;<a class="code" href="structiMovable.html#a13">GetFullTransform</a> ();
00163     <a class="code" href="classcsReversibleTransform.html">csReversibleTransform</a> lightT = light-&gt;<a class="code" href="structiLight.html#a6">GetMovable</a> ()-&gt;<a class="code" href="structiMovable.html#a13">GetFullTransform</a> ();
00164     lightPos = objT.<a class="code" href="classcsTransform.html#a11">Other2This</a> (lightT.<a class="code" href="classcsTransform.html#a6">GetOrigin</a> ());
00165     lightDir = objT.<a class="code" href="classcsTransform.html#a12">Other2ThisRelative</a> (lightT.<a class="code" href="classcsReversibleTransform.html#a10">This2OtherRelative</a> (
00166       light-&gt;<a class="code" href="structiLight.html#a13">GetDirection</a> ()));
00167     lightDir = lightDir.<a class="code" href="classcsVector3.html#a22">Unit</a> ();
00168     lightCol = light-&gt;<a class="code" href="structiLight.html#a7">GetColor</a> ();
00169   }
00170 
00171   CS_FORCEINLINE
00172   <a class="code" href="classcsColor.html">csColor</a> ProcessVertex (<span class="keyword">const</span> <a class="code" href="classcsVector3.html">csVector3</a> &amp;v,<span class="keyword">const</span> <a class="code" href="classcsVector3.html">csVector3</a> &amp;n)<span class="keyword"> const</span>
00173 <span class="keyword">  </span>{
00174     <span class="comment">//compute gouraud shading..</span>
00175     <span class="keywordtype">float</span> dp = lightDir*n;
00176     <span class="keywordflow">if</span> (dp &gt; blackLimit)
00177     {
00178       <a class="code" href="classcsVector3.html">csVector3</a> direction = v-lightPos;
00179       <span class="keywordtype">float</span> distance = <a class="code" href="group__floating__point.html#ga5">csQsqrt</a>(direction.<a class="code" href="classcsVector3.html#a21">SquaredNorm</a> ());
00180       attn (distance, dp);
00181       <span class="keywordflow">return</span> lightCol*dp;
00182     }
00183     <span class="keywordflow">return</span> nullColor;
00184   }
00185 
00186 <span class="keyword">private</span>:
00187   AttenuationProc attn;
00188   <a class="code" href="classcsVector3.html">csVector3</a> lightPos; <span class="comment">//localspace</span>
00189   <a class="code" href="classcsVector3.html">csVector3</a> lightDir; <span class="comment">//localspace</span>
00190   <a class="code" href="classcsColor.html">csColor</a> lightCol;
00191   <a class="code" href="classcsColor.html">csColor</a> nullColor;
00192   <span class="keywordtype">float</span> blackLimit;
00193 };
00194 
00200 <span class="keyword">template</span>&lt;<span class="keyword">class</span> AttenuationProc&gt;
<a name="l00201"></a><a class="code" href="classcsSpotLightProc.html">00201</a> <span class="keyword">class </span><a class="code" href="classcsSpotLightProc.html">csSpotLightProc</a>
00202 {
00203 <span class="keyword">public</span>:
00204   <a class="code" href="classcsSpotLightProc.html">csSpotLightProc</a> (<a class="code" href="structiLight.html">iLight</a> *light, <a class="code" href="structiMovable.html">iMovable</a> *objectMovable,
00205     <span class="keywordtype">float</span> blackLimit = 0.0001f)
00206     : attn (light), nullColor (0.0f, 0.0f, 0.0f), blackLimit (blackLimit)
00207   {
00208     <a class="code" href="classcsReversibleTransform.html">csReversibleTransform</a> objT = objectMovable-&gt;<a class="code" href="structiMovable.html#a13">GetFullTransform</a> ();
00209     <a class="code" href="classcsReversibleTransform.html">csReversibleTransform</a> lightT = light-&gt;<a class="code" href="structiLight.html#a6">GetMovable</a> ()-&gt;<a class="code" href="structiMovable.html#a13">GetFullTransform</a> ();
00210     lightPos = objT.<a class="code" href="classcsTransform.html#a11">Other2This</a> (lightT.<a class="code" href="classcsTransform.html#a6">GetOrigin</a> ());
00211     lightDir = objT.<a class="code" href="classcsTransform.html#a12">Other2ThisRelative</a> (lightT.<a class="code" href="classcsReversibleTransform.html#a10">This2OtherRelative</a> (
00212       light-&gt;<a class="code" href="structiLight.html#a13">GetDirection</a> ()));
00213     lightDir = lightDir.<a class="code" href="classcsVector3.html#a22">Unit</a> ();
00214 
00215     lightCol = light-&gt;<a class="code" href="structiLight.html#a7">GetColor</a> ();
00216     light-&gt;<a class="code" href="structiLight.html#a24">GetSpotLightFalloff</a> (falloffInner, falloffOuter);
00217   }
00218 
00219   CS_FORCEINLINE
00220   <a class="code" href="classcsColor.html">csColor</a> ProcessVertex (<span class="keyword">const</span> <a class="code" href="classcsVector3.html">csVector3</a> &amp;v,<span class="keyword">const</span> <a class="code" href="classcsVector3.html">csVector3</a> &amp;n)<span class="keyword"> const</span>
00221 <span class="keyword">  </span>{
00222     <a class="code" href="classcsVector3.html">csVector3</a> direction = (v-lightPos).Unit ();
00223 
00224     <span class="comment">//compute gouraud shading..</span>
00225     <span class="keywordtype">float</span> dp = direction*n;
00226     <span class="keywordflow">if</span> (dp &gt; blackLimit)
00227     {
00228       <span class="keywordtype">float</span> cosfact =
00229         <a class="code" href="group__geom__utils.html#ga8">csSmoothStep</a> (-(direction*lightDir), falloffOuter, falloffInner);
00230       <span class="keywordflow">if</span> (cosfact &gt; 0)
00231       {
00232         attn (distance, dp);
00233         <span class="keywordflow">return</span> lightCol*dp*cosfact;
00234       }
00235     }
00236     <span class="keywordflow">return</span> nullColor;
00237   }
00238 
00239 <span class="keyword">private</span>:
00240   AttenuationProc attn;
00241   <a class="code" href="classcsVector3.html">csVector3</a> lightPos; <span class="comment">//localspace</span>
00242   <a class="code" href="classcsVector3.html">csVector3</a> lightDir; <span class="comment">//localspace</span>
00243   <a class="code" href="classcsColor.html">csColor</a> lightCol;
00244   <a class="code" href="classcsColor.html">csColor</a> nullColor;
00245   <span class="keywordtype">float</span> blackLimit;
00246   <span class="keywordtype">float</span> falloffInner, falloffOuter;
00247 };
00248 
00249 <span class="keyword">template</span>&lt;<span class="keyword">class </span>LightProc, <span class="keyword">class </span>VertexType = <a class="code" href="classcsVector3.html">csVector3</a>,
00250   <span class="keyword">class </span>ColorType = <a class="code" href="classcsColor.html">csColor</a>&gt;
00251 <span class="keyword">class </span>csVertexLightCalculator
00252 {
00253 <span class="keyword">public</span>:
00254   csVertexLightCalculator ()
00255   {
00256   }
00257 
00258   <span class="keywordtype">void</span> CalculateLighting (<a class="code" href="structiLight.html">iLight</a> *light, <a class="code" href="structiMovable.html">iMovable</a> *objectMovable,
00259     size_t numvert, VertexType *vb, <a class="code" href="classcsVector3.html">csVector3</a> *nb, ColorType *litColor)<span class="keyword"> const</span>
00260 <span class="keyword">  </span>{
00261     <span class="comment">// setup the light calculator</span>
00262     LightProc lighter (light, objectMovable);
00263 
00264     <span class="keywordflow">for</span> (size_t n = 0; n &lt; numvert; n++)
00265     {
00266       litColor[n] = lighter.ProcessVertex (vb[n], nb[n]);
00267     }
00268   }
00269 
00270   <span class="keywordtype">void</span> CalculateLightingAdd (<a class="code" href="structiLight.html">iLight</a> *light, <a class="code" href="structiMovable.html">iMovable</a> *objectMovable,
00271     size_t numvert, VertexType *vb, <a class="code" href="classcsVector3.html">csVector3</a> *nb, ColorType *litColor)<span class="keyword"> const</span>
00272 <span class="keyword">  </span>{
00273     <span class="comment">// setup the light calculator</span>
00274     LightProc lighter (light, objectMovable);
00275 
00276     <span class="keywordflow">for</span> (size_t n = 0; n &lt; numvert; n++)
00277     {
00278       litColor[n] += lighter.ProcessVertex (vb[n], nb[n]);
00279     }
00280   }
00281 
00282   <span class="keywordtype">void</span> CalculateLightingMul (<a class="code" href="structiLight.html">iLight</a> *light, <a class="code" href="structiMovable.html">iMovable</a> *objectMovable,
00283     size_t numvert, VertexType *vb, <a class="code" href="classcsVector3.html">csVector3</a> *nb, ColorType *litColor)<span class="keyword"> const</span>
00284 <span class="keyword">  </span>{
00285     <span class="comment">// setup the light calculator</span>
00286     LightProc lighter (light, objectMovable);
00287 
00288     <span class="keywordflow">for</span> (size_t n = 0; n &lt; numvert; n++)
00289     {
00290       litColor[n] *= lighter.ProcessVertex (vb[n], nb[n]);
00291     }
00292   }
00293 };
00294 
00295 <span class="preprocessor">#endif //__CS_VERTEXLIGHT_H__</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.9.1 
</small></address> </div></body> </html>
