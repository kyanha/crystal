<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: iSCF Struct Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>iSCF Struct Reference<br>
<small>
[<a class="el" href="group__scf.html">Shared Class Facility (SCF)</a>]</small>
</h1>iSCF is the interface that allows using SCF functions from shared classes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="scf_8h-source.html">csutil/scf.h</a>&gt;</code>
<p>
<p>Inheritance diagram for iSCF:
<p><center><img src="structiSCF.png" usemap="#iSCF_map" border="0" alt=""></center>
<map name="iSCF_map">
<area href="structiBase.html" alt="iBase" shape="rect" coords="0,0,43,24">
</map>
<a href="structiSCF-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a0">RegisterClasses</a> (<a class="el" href="structiDocument.html">iDocument</a> *metadata, const char *context=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read additional class descriptions from the given <a class="el" href="structiDocument.html">iDocument</a>.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a1">RegisterClasses</a> (char const *xml, const char *context=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience wrapper for RegisterClasses(iDocument).  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a2">RegisterClasses</a> (const char *pluginPath, <a class="el" href="structiDocument.html">iDocument</a> *metadata, const char *context=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read additional class descriptions from the given <a class="el" href="structiDocument.html">iDocument</a>.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a3">ClassRegistered</a> (const char *iClassID)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whenever the class is present in SCF registry.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a4">CreateInstance</a> (const char *iClassID, const char *iInterface, int iVersion)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an instance of a class that supports given interface.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a5">GetClassDescription</a> (const char *iClassID)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the description of a class.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a6">GetClassDependencies</a> (const char *iClassID)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the dependency list for a class.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsRef.html">csRef</a>&lt; <a class="el" href="structiDocument.html">iDocument</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a7">GetPluginMetadata</a> (char const *iClassID)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a registered class name, returns the meta information associated with the plugin module in which the class is implemented.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a8">UnloadUnusedModules</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unload all unused shared libraries (also called inside scfCreateInstance).  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a9">RegisterClass</a> (const char *iClassID, const char *iLibraryName, const char *iFactoryClass, const char *Description, const char *Dependencies=0, const char *context=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a single dynamic class (implemented in a shared library).  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a10">RegisterClass</a> (<a class="el" href="group__scf.html#ga1">scfFactoryFunc</a>, const char *iClassID, const char *Description, const char *Dependencies=0, const char *context=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a single dynamic class.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a11">RegisterFactoryFunc</a> (<a class="el" href="group__scf.html#ga1">scfFactoryFunc</a>, const char *FactClass)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate a factory function (the function which instantiates a class) with an implementation name (the value in the &lt;implementation&gt; node of the meta information; also the name of the iFactoryClass in RegisterClass).  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a12">UnregisterClass</a> (const char *iClassID)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should be called to deregister a class at run-time.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a13">GetInterfaceName</a> (<a class="el" href="group__scf.html#ga0">scfInterfaceID</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the name of an interface given an interface ID.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__scf.html#ga0">scfInterfaceID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a14">GetInterfaceID</a> (const char *iInterface)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the interface ID number that belongs to the given interface.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a15">Finish</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should be called to finish working with SCF.  <a href="#a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsRef.html">csRef</a>&lt; <a class="el" href="structiStringArray.html">iStringArray</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a16">QueryClassList</a> (char const *pattern)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a list of class names whose prefix matches a pattern string.  <a href="#a16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a17">ScanPluginsPath</a> (const char *path, bool recursive=false, const char *context=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scan a specified native path for plugins and auto-register them.  <a href="#a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#a18">RegisterPlugin</a> (const char *path)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a single plugin.  <a href="#a18"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structiSCF.html">iSCF</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiSCF.html#s0">SCF</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the global instance of iSCF.  <a href="#s0"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
iSCF is the interface that allows using SCF functions from shared classes. 
<p>
Since there should be just one instance of SCF kernel, the shared classes should not use scfXXX functions directly; instead they should obtain a pointer to an iSCF object and work through that pointer. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00896">896</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a3" doxytag="iSCF::ClassRegistered"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iSCF::ClassRegistered           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iClassID</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check whenever the class is present in SCF registry. 
<p>
You can use this function to check whenever a class instance creation failed because the class is not present at all in the class registry, or it just doesn't support the requested interface.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="iSCF::CreateInstance"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void* iSCF::CreateInstance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>iClassID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>iInterface</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iVersion</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an instance of a class that supports given interface. 
<p>
The function returns 0 either if such a class ID is not found in class registry, or a object of given class does not support given interface or supports an incompatible version of given interface. If you want to make a difference between these error conditions, you can check whenever such a class exists using scfClassRegistered() function. <p>
If you specify 0 as iInterfaceID, you'll receive a pointer to the basic interface, no matter what it is. <b>The reference count will be zero thus you should increment it yourself if you use this approach.</b> You can treat the pointer returned just as an iBase*, not more. If you need more, do <a class="el" href="structiBase.html#a3">QueryInterface()</a> on received pointer (this will also increment the reference counter).     </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="iSCF::Finish"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iSCF::Finish           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function should be called to finish working with SCF. 
<p>
This will not free shared objects but they should not be used anymore after calling this function since this will do a forced free of all loaded shared libraries.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="iSCF::GetClassDependencies"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const char* iSCF::GetClassDependencies           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iClassID</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Query the dependency list for a class. 
<p>
The format of dependency string is implementation-specific, SCF itself does not make any assumptions about the format of the string.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="iSCF::GetClassDescription"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const char* iSCF::GetClassDescription           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iClassID</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Query the description of a class. 
<p>
NOTE: At least one instance of this class should exist, or the class should be a static class. Otherwise the function will return 0     </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="iSCF::GetInterfaceID"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__scf.html#ga0">scfInterfaceID</a> iSCF::GetInterfaceID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iInterface</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the interface ID number that belongs to the given interface. 
<p>
If the interface is unknown, a new ID is allocated. This number can be used to quickly determine whether two interfaces are equal.     </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="iSCF::GetInterfaceName"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual char const* iSCF::GetInterfaceName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__scf.html#ga0">scfInterfaceID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the name of an interface given an interface ID. 
<p>
If the ID is unknown, null is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="iSCF::GetPluginMetadata"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsRef.html">csRef</a>&lt;<a class="el" href="structiDocument.html">iDocument</a>&gt; iSCF::GetPluginMetadata           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char const *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iClassID</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given a registered class name, returns the meta information associated with the plugin module in which the class is implemented. 
<p>
Since the meta information associated with a plugin is extensible, plugin authors are free to attach any additional information they desire, beyond that which is used by SCF itself. This function provides a way for clients to access the additional meta information which plugin authors might choose to publish. <p>
If the specified class is not implemented by a plugin module (for instance, it might be implemented directly by the application), or if plugin module is lacking meta information for some reason, then the returned csRef&lt;&gt; will be <em>invalid</em>. You should check for this condition by invoking <a class="el" href="classcsRef.html#a14">csRef&lt;&gt;::IsValid()</a> or simply by using the returned reference in a boolean conditional expression. <p>
Note that it is possible for a single plugin module to export multiple, named SCF classes. The meta information returned by this function belongs to the plugin itself, not to any individual class exported by that plugin. Therefore, if you invoke this method twice for two different classes, and those classes are exported by the same plugin, then the same meta information will be returned by both queries. <p>
If you know the physical path of a plugin, then you can instead invoke <a class="el" href="group__util.html#ga64">csGetPluginMetadata()</a> (csutil/csshlib.h) to retrieve its meta information.     </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="iSCF::QueryClassList"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsRef.html">csRef</a>&lt;<a class="el" href="structiStringArray.html">iStringArray</a>&gt; iSCF::QueryClassList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char const *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pattern</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve a list of class names whose prefix matches a pattern string. 
<p>
For example, QueryClassList("crystalspace.sound.loader.") will return a list of class names which begin with the string "crystalspace.sound.loader.". If pattern is zero length or the null pointer, then all registered class names are returned. If any class names match the pattern, then the return value is a list of strings. If no class names match the pattern string, then the returned list is empty.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="iSCF::RegisterClass"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iSCF::RegisterClass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__scf.html#ga1">scfFactoryFunc</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>iClassID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>Description</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>Dependencies</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>context</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a single dynamic class. 
<p>
This function tells SCF kernel that a specific class is implemented within a specific module (typically a static library, as opposed to a plugin module). You also can provide an application-specific dependency list.     </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="iSCF::RegisterClass"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iSCF::RegisterClass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>iClassID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>iLibraryName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>iFactoryClass</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>Description</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>Dependencies</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>context</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a single dynamic class (implemented in a shared library). 
<p>
This function tells SCF kernel that a specific class is implemented within a specific shared library. There can be multiple classes within a single shared library. You also can provide an application-specific dependency list. 'context' is an information about the source of the plugin. It primarily affects whether a class conflict is reported. If the same class already exists in the same context, a warning is emitted; if it's in a different context, only there is a notification only in debug mode.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="iSCF::RegisterClasses"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iSCF::RegisterClasses           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pluginPath</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiDocument.html">iDocument</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>context</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read additional class descriptions from the given <a class="el" href="structiDocument.html">iDocument</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="iSCF::RegisterClasses"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iSCF::RegisterClasses           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char const *&nbsp;</td>
          <td class="mdname" nowrap> <em>xml</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>context</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A convenience wrapper for RegisterClasses(iDocument). 
<p>
Assumes that the string input argument is XML, which it wraps in an <a class="el" href="structiDocument.html">iDocument</a> and then passes to RegisterClasses(iDocument).     </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="iSCF::RegisterClasses"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iSCF::RegisterClasses           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiDocument.html">iDocument</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>context</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read additional class descriptions from the given <a class="el" href="structiDocument.html">iDocument</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="iSCF::RegisterFactoryFunc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iSCF::RegisterFactoryFunc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__scf.html#ga1">scfFactoryFunc</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>FactClass</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Associate a factory function (the function which instantiates a class) with an implementation name (the value in the &lt;implementation&gt; node of the meta information; also the name of the iFactoryClass in RegisterClass). 
<p>
Returns true upon sucess, or false if the class does not exist or already has an associated creation function.     </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="iSCF::RegisterPlugin"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iSCF::RegisterPlugin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>path</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a single plugin. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>(Almost) fully qualified native path to the plugin binary. 'Almost' because it doesn't have to be the actual binary - it is sufficient if the file name suffix is ".csplugin", no matter what the real extension for binaries on a platform is or whether there actually is an external .csplugin file. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether loading of the plugin was successful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="iSCF::ScanPluginsPath"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iSCF::ScanPluginsPath           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>recursive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>context</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scan a specified native path for plugins and auto-register them. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="iSCF::UnloadUnusedModules"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iSCF::UnloadUnusedModules           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unload all unused shared libraries (also called inside scfCreateInstance). 
<p>
If you want to be sure that all unused shared libraries are unloaded, call this function. It is automatically invoked inside scfCreateInstance(), thus it is called from time to time if you constantly create new objects.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="iSCF::UnregisterClass"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iSCF::UnregisterClass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iClassID</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function should be called to deregister a class at run-time. 
<p>
By calling this function you will remove the description of a class, no matter whenever it is statically or dynamically linked, from the SCF registry.     </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="s0" doxytag="iSCF::SCF"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structiSCF.html">iSCF</a>* <a class="el" href="structiSCF.html#s0">iSCF::SCF</a><code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is the global instance of iSCF. 
<p>
On most platforms, this variable is module-global; for instance, the application has an <a class="el" href="structiSCF.html#s0">iSCF::SCF</a> variable, and each plugin module has an <a class="el" href="structiSCF.html#s0">iSCF::SCF</a> variable, all of which point at the same shared instance of iSCF. On other platforms, though, the variable might truly be global, in which case the variable itself is shared by application and all plugin modules. In actual practice, however, whether the variable's scope is global or only module-global, makes no difference since clients access the shared instance uniformly as <a class="el" href="structiSCF.html#s0">iSCF::SCF</a>. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00909">909</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>csutil/<a class="el" href="scf_8h-source.html">scf.h</a></ul>
<hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.9.1 
</small></address> </div></body> </html>
