<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: iCollideSystem Struct Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>iCollideSystem Struct Reference</h1>This is the Collide plug-in.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="ivaria_2collider_8h-source.html">ivaria/collider.h</a>&gt;</code>
<p>
<p>Inheritance diagram for iCollideSystem:
<p><center><img src="structiCollideSystem.png" usemap="#iCollideSystem_map" border="0" alt=""></center>
<map name="iCollideSystem_map">
<area href="structiBase.html" alt="iBase" shape="rect" coords="0,0,94,24">
</map>
<a href="structiCollideSystem-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiCollider.html">iCollider</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiCollideSystem.html#a0">CreateCollider</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *mesh)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="structiCollider.html">iCollider</a> for the given mesh geometry.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiCollideSystem.html#a1">Collide</a> (<a class="el" href="structiCollider.html">iCollider</a> *collider1, const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *trans1, <a class="el" href="structiCollider.html">iCollider</a> *collider2, const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *trans2)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test collision between two colliders.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structcsCollisionPair.html">csCollisionPair</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiCollideSystem.html#a2">GetCollisionPairs</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get pointer to current array of collision pairs.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiCollideSystem.html#a3">GetCollisionPairCount</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of collision pairs in array.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiCollideSystem.html#a4">ResetCollisionPairs</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the array with collision pairs.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiCollideSystem.html#a5">CollideRay</a> (<a class="el" href="structiCollider.html">iCollider</a> *collider, const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *trans, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collide a collider with a world space ray.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classcsArray.html">csArray</a>&lt; <a class="el" href="structcsIntersectingTriangle.html">csIntersectingTriangle</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiCollideSystem.html#a6">GetIntersectingTriangles</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the array of intersection points as returned by <a class="el" href="structiCollideSystem.html#a5">CollideRay()</a>.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiCollideSystem.html#a7">SetOneHitOnly</a> (bool o)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate if we are interested only in the first hit that is found.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiCollideSystem.html#a8">GetOneHitOnly</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if this CD system will only return the first hit that is found.  <a href="#a8"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This is the Collide plug-in. 
<p>
This plugin is a factory for creating <a class="el" href="structiCollider.html">iCollider</a> entities. A collider represents an entity in the collision detection world. It uses the geometry data as given by <a class="el" href="structiPolygonMesh.html">iPolygonMesh</a>. <p>
Main creators of instances implementing this interface: <ul>
<li>
OPCODE plugin (crystalspace.collisiondetection.opcode) </li>
</ul>
Main ways to get pointers to this interface: <ul>
<li>
CS_QUERY_REGISTRY() </li>
</ul>
Main users of this interface: <ul>
<li>
<a class="el" href="classcsColliderWrapper.html">csColliderWrapper</a> </li>
<li>
<a class="el" href="classcsColliderHelper.html">csColliderHelper</a> </li>
</ul>

<p>

<p>
Definition at line <a class="el" href="ivaria_2collider_8h-source.html#l00093">93</a> of file <a class="el" href="ivaria_2collider_8h-source.html">collider.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a1" doxytag="iCollideSystem::Collide"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iCollideSystem::Collide           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiCollider.html">iCollider</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>collider1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>trans1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiCollider.html">iCollider</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>collider2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>trans2</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test collision between two colliders. 
<p>
This is only supported for <a class="el" href="structiCollider.html">iCollider</a> objects created by this plugin. Returns false if no collision or else true. The collisions will be added to the collision pair array that you can query with GetCollisionPairs and reset/clear with ResetCollisionPairs (very important! Do not forget this). Every call to Collide will add to that array.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collider1</em>&nbsp;</td><td>is the first collider as created by this same collide system (never pass in a collider created by another collide system). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trans1</em>&nbsp;</td><td>is the transform for the object represented by the first collider. If the collider belongs to a mesh object then you can get the transform by calling mesh-&gt;GetMovable ()-&gt;GetFullTransform(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>collider2</em>&nbsp;</td><td>is the second collider. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trans2</em>&nbsp;</td><td>is the second transform. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if there are triangles that intersect. The array with collision pairs will be updated. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="iCollideSystem::CollideRay"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iCollideSystem::CollideRay           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiCollider.html">iCollider</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>collider</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Collide a collider with a world space ray. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collider</em>&nbsp;</td><td>is the collider to test with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trans</em>&nbsp;</td><td>is the transform for the object represented by the collider. If the collider belongs to a mesh object then you can get the transform by calling mesh-&gt;GetMovable()-&gt;GetFullTransform(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>is the start of the ray. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>is the end of the ray. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if there was a collision. The array with intersecting triangles will be updated (see <a class="el" href="structiCollideSystem.html#a6">GetIntersectingTriangles()</a>). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="iCollideSystem::CreateCollider"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiCollider.html">iCollider</a>&gt; iCollideSystem::CreateCollider           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mesh</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a <a class="el" href="structiCollider.html">iCollider</a> for the given mesh geometry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mesh</em>&nbsp;</td><td>is a structure describing the geometry from which the collider will be made. You can get such a mesh either by making your own subclass of <a class="el" href="structiPolygonMesh.html">iPolygonMesh</a>, by getting a mesh from iMeshObject-&gt;GetObjectModel()-&gt;GetPolygonMeshColldet(), or else by using <a class="el" href="classcsPolygonMesh.html">csPolygonMesh</a>, or <a class="el" href="classcsPolygonMeshBox.html">csPolygonMeshBox</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a reference to a collider that you have to store. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="iCollideSystem::GetCollisionPairCount"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual size_t iCollideSystem::GetCollisionPairCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get number of collision pairs in array. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the number of collision pairs. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="iCollideSystem::GetCollisionPairs"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structcsCollisionPair.html">csCollisionPair</a>* iCollideSystem::GetCollisionPairs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get pointer to current array of collision pairs. 
<p>
This array will grow with every call to Collide until you clear it using 'ResetCollisionPairs'. Note that the triangles are in object space and not world space! <dl compact><dt><b>Returns:</b></dt><dd>an array of collision pairs for all <a class="el" href="structiCollideSystem.html#a1">Collide()</a> calls that occured between now and the call to <a class="el" href="structiCollideSystem.html#a4">ResetCollisionPairs()</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="iCollideSystem::GetIntersectingTriangles"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const <a class="el" href="classcsArray.html">csArray</a>&lt;<a class="el" href="structcsIntersectingTriangle.html">csIntersectingTriangle</a>&gt;&amp; iCollideSystem::GetIntersectingTriangles           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the array of intersection points as returned by <a class="el" href="structiCollideSystem.html#a5">CollideRay()</a>. 
<p>
Note that the coordinates in the array of triangles is in object space of the collider object and not world space!     </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="iCollideSystem::GetOneHitOnly"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iCollideSystem::GetOneHitOnly           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true if this CD system will only return the first hit that is found. 
<p>
For CD systems that support multiple hits this will return the value set by the <a class="el" href="structiCollideSystem.html#a7">SetOneHitOnly()</a> function. For CD systems that support one hit only this will always return true. <dl compact><dt><b>Returns:</b></dt><dd>true if there is only one hit recorder for every call to <a class="el" href="structiCollideSystem.html#a1">Collide()</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="iCollideSystem::ResetCollisionPairs"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iCollideSystem::ResetCollisionPairs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset the array with collision pairs. 
<p>
It is very important to call this before collision detection. Otherwise the internal table of collision pairs will grow forever.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="iCollideSystem::SetOneHitOnly"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iCollideSystem::SetOneHitOnly           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>o</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Indicate if we are interested only in the first hit that is found. 
<p>
This is only valid for CD algorithms that actually allow the detection of multiple CD hit points. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>is true if you are only interested in one colliding triangle per call to Collide. By default this is 'false' unless the CD system only supports single hits. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>ivaria/<a class="el" href="ivaria_2collider_8h-source.html">collider.h</a></ul>
<hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.9.1 
</small></address> </div></body> </html>
