<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/ref.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>csutil/ref.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">  Crystal Space Smart Pointers</span>
00003 <span class="comment">  Copyright (C) 2002 by Jorrit Tyberghein and Matthias Braun</span>
00004 <span class="comment"></span>
00005 <span class="comment">  This library is free software; you can redistribute it and/or</span>
00006 <span class="comment">  modify it under the terms of the GNU Library General Public</span>
00007 <span class="comment">  License as published by the Free Software Foundation; either</span>
00008 <span class="comment">  version 2 of the License, or (at your option) any later version.</span>
00009 <span class="comment"></span>
00010 <span class="comment">  This library is distributed in the hope that it will be useful,</span>
00011 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00012 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00013 <span class="comment">  Library General Public License for more details.</span>
00014 <span class="comment"></span>
00015 <span class="comment">  You should have received a copy of the GNU Library General Public</span>
00016 <span class="comment">  License along with this library; if not, write to the Free</span>
00017 <span class="comment">  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00018 <span class="comment">*/</span>
00019 
00020 <span class="preprocessor">#ifndef __CS_REF_H__</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define __CS_REF_H__</span>
00022 <span class="preprocessor"></span>
00023 <span class="preprocessor">#include "csextern.h"</span>
00024 
00025 <span class="preprocessor">#define CS_VOIDED_PTR 0xffffffff</span>
00026 <span class="preprocessor"></span>
00027 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span><a class="code" href="classcsRef.html">csRef</a>;
00028 
00029 <span class="preprocessor">#if defined(CS_DEBUG)</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#  define CS_TEST_VOIDPTRUSAGE</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#  undef CS_TEST_VOIDPTRUSAGE</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#ifdef CS_REF_TRACKER</span>
00036 <span class="preprocessor"></span><span class="preprocessor"> #include &lt;typeinfo&gt;</span>
00037 <span class="preprocessor"> #include "csutil/reftrackeraccess.h"</span>
00038 
00039 <span class="preprocessor"> #define CSREF_TRACK(x, cmd, refCount, obj, tag)    \</span>
00040 <span class="preprocessor">  {                                                 \</span>
00041 <span class="preprocessor">    const int rc = obj ? refCount : -1;             \</span>
00042 <span class="preprocessor">    if (obj) cmd;                                   \</span>
00043 <span class="preprocessor">    if (obj)                                        \</span>
00044 <span class="preprocessor">    {                                               \</span>
00045 <span class="preprocessor">      csRefTrackerAccess::SetDescription (obj,      \</span>
00046 <span class="preprocessor">        typeid(T).name());                          \</span>
00047 <span class="preprocessor">      csRefTrackerAccess::Match ## x (obj, rc, tag);\</span>
00048 <span class="preprocessor">    }                                               \</span>
00049 <span class="preprocessor">  }</span>
00050 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_INCREF(obj,tag)    \</span>
00051 <span class="preprocessor">  CSREF_TRACK(IncRef, obj-&gt;IncRef(), obj-&gt;GetRefCount(), obj, tag);</span>
00052 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_DECREF(obj,tag)    \</span>
00053 <span class="preprocessor">  CSREF_TRACK(DecRef, obj-&gt;DecRef(), obj-&gt;GetRefCount(), obj, tag);</span>
00054 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_ASSIGN(obj,tag)    \</span>
00055 <span class="preprocessor">  CSREF_TRACK(IncRef, (0), obj-&gt;GetRefCount() - 1, obj, tag);</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00057 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_INCREF(obj,tag) \</span>
00058 <span class="preprocessor">  if (obj) obj-&gt;IncRef();</span>
00059 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_DECREF(obj,tag) \</span>
00060 <span class="preprocessor">  if (obj) obj-&gt;DecRef();</span>
00061 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_ASSIGN(obj,tag)</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00063 <span class="preprocessor"></span>
00074 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00075"></a><a class="code" href="classcsPtr.html">00075</a> <span class="keyword">class  </span><a class="code" href="classcsPtr.html">csPtr</a>
00076 {
00077 <span class="keyword">private</span>:
00078   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsRef.html">csRef</a>&lt;T&gt;;
00079   T* obj;
00080 
00081 <span class="keyword">public</span>:
00082   <a class="code" href="classcsPtr.html">csPtr</a> (T* p) : obj (p) { CSREF_TRACK_ASSIGN(obj, <span class="keyword">this</span>); }
00083 
00084   <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
00085   <span class="keyword">explicit</span> <a class="code" href="classcsPtr.html">csPtr</a> (<a class="code" href="classcsRef.html">csRef&lt;T2&gt;</a> <span class="keyword">const</span>&amp; r) : obj((T2*)r) 
00086   { 
00087     CSREF_TRACK_INCREF (obj, <span class="keyword">this</span>);
00088   }
00089 
00090 <span class="preprocessor">#ifdef CS_TEST_VOIDPTRUSAGE</span>
00091 <span class="preprocessor"></span>  ~<a class="code" href="classcsPtr.html">csPtr</a> ()
00092   {
00093     <span class="comment">// If not assigned to a csRef we have a problem (leak).</span>
00094     <span class="comment">// So if this assert fires for you, then you are calling</span>
00095     <span class="comment">// a function that returns a csPtr and not using the result</span>
00096     <span class="comment">// (or at least not assigning it to a csRef). This is a memory</span>
00097     <span class="comment">// leak and you should fix that.</span>
00098     CS_ASSERT (obj == (T*)CS_VOIDED_PTR);
00099   }
00100 <span class="preprocessor">#endif</span>
00101 <span class="preprocessor"></span>
00102   <a class="code" href="classcsPtr.html">csPtr</a> (<span class="keyword">const</span> <a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp; copy)
00103   {
00104     obj = copy.<a class="code" href="classcsPtr.html#o0">obj</a>;
00105 <span class="preprocessor">#ifdef CS_TEST_VOIDPTRUSAGE</span>
00106 <span class="preprocessor"></span>    ((<a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp;)copy).obj = (T*)CS_VOIDED_PTR;
00107 <span class="preprocessor">#endif</span>
00108 <span class="preprocessor"></span>  }
00109 };
00110 
00117 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00118"></a><a class="code" href="classcsRef.html">00118</a> <span class="keyword">class  </span><a class="code" href="classcsRef.html">csRef</a>
00119 {
00120 <span class="keyword">private</span>:
00121   T* obj;
00122 
00123 <span class="keyword">public</span>:
<a name="l00129"></a><a class="code" href="classcsRef.html#a0">00129</a>   <a class="code" href="classcsRef.html#a0">csRef</a> () : obj (0) {}
00130 
<a name="l00136"></a><a class="code" href="classcsRef.html#a1">00136</a>   <a class="code" href="classcsRef.html#a0">csRef</a> (<span class="keyword">const</span> <a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp; newobj)
00137   {
00138     obj = newobj.<a class="code" href="classcsPtr.html#o0">obj</a>;
00139 <span class="preprocessor">#   ifdef CS_TEST_VOIDPTRUSAGE</span>
00140 <span class="preprocessor"></span>    CS_ASSERT (newobj.<a class="code" href="classcsPtr.html#o0">obj</a> != (T*)CS_VOIDED_PTR);
00141 <span class="preprocessor">#   endif</span>
00142 <span class="preprocessor"></span>    <span class="comment">// The following line is outside the ifdef to make sure</span>
00143     <span class="comment">// we have binary compatibility.</span>
00144     ((<a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp;)newobj).obj = (T*)CS_VOIDED_PTR;
00145   }
00146 
<a name="l00151"></a><a class="code" href="classcsRef.html#a2">00151</a>   <a class="code" href="classcsRef.html#a0">csRef</a> (T* newobj) : obj (newobj)
00152   {
00153     CSREF_TRACK_INCREF (obj, <span class="keyword">this</span>);
00154   }
00155   
00159   <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
<a name="l00160"></a><a class="code" href="classcsRef.html#a3">00160</a>   <a class="code" href="classcsRef.html#a0">csRef</a> (<a class="code" href="classcsRef.html">csRef&lt;T2&gt;</a> <span class="keyword">const</span>&amp; other) : obj ((T2*)other)
00161   {
00162     CSREF_TRACK_INCREF (obj, <span class="keyword">this</span>);
00163   }
00164 
<a name="l00168"></a><a class="code" href="classcsRef.html#a4">00168</a>   <a class="code" href="classcsRef.html#a0">csRef</a> (<a class="code" href="classcsRef.html">csRef</a> <span class="keyword">const</span>&amp; other) : obj (other.obj)
00169   {
00170     CSREF_TRACK_INCREF (obj, <span class="keyword">this</span>);
00171   }
00172 
<a name="l00176"></a><a class="code" href="classcsRef.html#a5">00176</a>   <a class="code" href="classcsRef.html#a5">~csRef</a> ()
00177   {
00178     CSREF_TRACK_DECREF (obj, <span class="keyword">this</span>);
00179   }
00180 
<a name="l00190"></a><a class="code" href="classcsRef.html#a6">00190</a>   <a class="code" href="classcsRef.html">csRef</a>&amp; <a class="code" href="classcsRef.html#a6">operator = </a>(<span class="keyword">const</span> <a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp; newobj)
00191   {
00192     T* oldobj = obj;
00193     <span class="comment">// First assign and then DecRef() of old object!</span>
00194     obj = newobj.<a class="code" href="classcsPtr.html#o0">obj</a>;
00195 <span class="preprocessor">#   ifdef CS_TEST_VOIDPTRUSAGE</span>
00196 <span class="preprocessor"></span>    CS_ASSERT (newobj.<a class="code" href="classcsPtr.html#o0">obj</a> != (T*)CS_VOIDED_PTR);
00197 <span class="preprocessor">#   endif</span>
00198 <span class="preprocessor"></span>    <span class="comment">// The following line is outside the ifdef to make sure</span>
00199     <span class="comment">// we have binary compatibility.</span>
00200     ((<a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp;)newobj).obj = (T*)CS_VOIDED_PTR;
00201     CSREF_TRACK_DECREF (oldobj, <span class="keyword">this</span>);
00202     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00203   }
00204 
<a name="l00217"></a><a class="code" href="classcsRef.html#a7">00217</a>   <a class="code" href="classcsRef.html">csRef</a>&amp; <a class="code" href="classcsRef.html#a6">operator = </a>(T* newobj)
00218   {
00219     <span class="keywordflow">if</span> (obj != newobj)
00220     {
00221       T* oldobj = obj;
00222       <span class="comment">// It is very important to first assign the new value to</span>
00223       <span class="comment">// 'obj' BEFORE calling DecRef() on the old object. Otherwise</span>
00224       <span class="comment">// it is easy to get in infinite loops with objects being</span>
00225       <span class="comment">// destructed forever (when ref=0 is used for example).</span>
00226       obj = newobj;
00227       CSREF_TRACK_INCREF (newobj, <span class="keyword">this</span>);
00228       CSREF_TRACK_DECREF (oldobj, <span class="keyword">this</span>);
00229     }
00230     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00231   }
00232 
<a name="l00255"></a><a class="code" href="classcsRef.html#a8">00255</a>   <span class="keywordtype">void</span> <a class="code" href="classcsRef.html#a8">AttachNew</a> (<a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a> newObj)
00256   {
00257     <span class="comment">// Note: The parameter usage of csPtr&lt;T&gt; instead of csPtr&lt;T&gt;&amp; is</span>
00258     <span class="comment">// deliberate and not to be considered a bug.</span>
00259 
00260     <span class="comment">// Just Re-use csPtr assignment logic</span>
00261     *<span class="keyword">this</span> = newObj;
00262   }
00263 
00265   <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
<a name="l00266"></a><a class="code" href="classcsRef.html#a9">00266</a>   <a class="code" href="classcsRef.html">csRef</a>&amp; <a class="code" href="classcsRef.html#a6">operator = </a>(<a class="code" href="classcsRef.html">csRef&lt;T2&gt;</a> <span class="keyword">const</span>&amp; other)
00267   {
00268     T* p = (T2*)other;
00269     this-&gt;<a class="code" href="classcsRef.html#a6">operator=</a>(p);
00270     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00271   }
00272 
<a name="l00274"></a><a class="code" href="classcsRef.html#a10">00274</a>   <a class="code" href="classcsRef.html">csRef</a>&amp; <a class="code" href="classcsRef.html#a6">operator = </a>(<a class="code" href="classcsRef.html">csRef</a> <span class="keyword">const</span>&amp; other)
00275   {
00276     this-&gt;<a class="code" href="classcsRef.html#a6">operator=</a>(other.<a class="code" href="classcsRef.html#o0">obj</a>);
00277     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00278   }
00279 
<a name="l00281"></a><a class="code" href="classcsRef.html#l0">00281</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#l0">operator == </a>(<span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r2)
00282   {
00283     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#o0">obj</a> == r2.<a class="code" href="classcsRef.html#o0">obj</a>;
00284   }
<a name="l00286"></a><a class="code" href="classcsRef.html#l1">00286</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#l1">operator != </a>(<span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r2)
00287   {
00288     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#o0">obj</a> != r2.<a class="code" href="classcsRef.html#o0">obj</a>;
00289   }
<a name="l00291"></a><a class="code" href="classcsRef.html#l2">00291</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#l0">operator == </a>(<span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1, T* obj)
00292   {
00293     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#o0">obj</a> == obj;
00294   }
<a name="l00296"></a><a class="code" href="classcsRef.html#l3">00296</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#l1">operator != </a>(<span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1, T* obj)
00297   {
00298     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#o0">obj</a> != obj;
00299   }
<a name="l00301"></a><a class="code" href="classcsRef.html#l4">00301</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#l0">operator == </a>(T* obj, <span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1)
00302   {
00303     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#o0">obj</a> == obj;
00304   }
<a name="l00306"></a><a class="code" href="classcsRef.html#l5">00306</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#l1">operator != </a>(T* obj, <span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1)
00307   {
00308     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#o0">obj</a> != obj;
00309   }
00310 
<a name="l00312"></a><a class="code" href="classcsRef.html#a11">00312</a>   T* <a class="code" href="classcsRef.html#a11">operator -&gt; </a>()<span class="keyword"> const</span>
00313 <span class="keyword">  </span>{ <span class="keywordflow">return</span> obj; }
00314   
<a name="l00316"></a><a class="code" href="classcsRef.html#a12">00316</a>   <a class="code" href="classcsRef.html#a12">operator T* </a>()<span class="keyword"> const</span>
00317 <span class="keyword">  </span>{ <span class="keywordflow">return</span> obj; }
00318   
<a name="l00320"></a><a class="code" href="classcsRef.html#a13">00320</a>   T&amp; <a class="code" href="classcsRef.html#a13">operator* </a>()<span class="keyword"> const</span>
00321 <span class="keyword">  </span>{ <span class="keywordflow">return</span> *obj; }
00322 
<a name="l00327"></a><a class="code" href="classcsRef.html#a14">00327</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#a14">IsValid</a> ()<span class="keyword"> const</span>
00328 <span class="keyword">  </span>{ <span class="keywordflow">return</span> (obj != 0); }
00329 };
00330 
00331 <span class="preprocessor">#undef CSREF_TRACK_INCREF</span>
00332 <span class="preprocessor"></span><span class="preprocessor">#undef CSREF_TRACK_DECREF</span>
00333 <span class="preprocessor"></span><span class="preprocessor">#undef CSREF_TRACK_ASSIGN</span>
00334 <span class="preprocessor"></span>
00335 <span class="preprocessor">#endif // __CS_REF_H__</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
