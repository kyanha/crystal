<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/bitarray.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000022.html">csutil</a></div>
<h1>bitarray.h</h1><a href="bitarray_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2000 by Andrew Kirmse</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="comment">// A one-dimensional array of bits, similar to STL bitset.</span>
00020 <span class="comment">//</span>
00021 <span class="comment">// Copyright 2000 Andrew Kirmse.  All rights reserved.</span>
00022 <span class="comment">//</span>
00023 <span class="comment">// Permission is granted to use this code for any purpose, as long as this</span>
00024 <span class="comment">// copyright message remains intact.</span>
00025 
00026 <span class="preprocessor">#ifndef __CS_BITARRAY_H__</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define __CS_BITARRAY_H__</span>
00028 <span class="preprocessor"></span>
00033 <span class="preprocessor">#include "csextern.h"</span>
00034 
00035 <span class="keyword">class </span><a class="code" href="classcsBitArrayHashKeyHandler.html">csBitArrayHashKeyHandler</a>;
00036 
<a name="l00040"></a><a class="code" href="classcsBitArray.html">00040</a> <span class="keyword">class </span>CS_CRYSTALSPACE_EXPORT <a class="code" href="classcsBitArray.html">csBitArray</a>
00041 {
00042 <span class="keyword">public</span>:
00043   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> store_type;
00044 
00045 <span class="keyword">private</span>:
00046   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsBitArrayHashKeyHandler.html">csBitArrayHashKeyHandler</a>;
00047   <span class="keyword">enum</span>
00048   {
00049     bits_per_byte = 8,
00050     cell_size     = <span class="keyword">sizeof</span>(store_type) * bits_per_byte
00051   };
00052 
00053   store_type* mpStore;
00054   store_type  mSingleWord; <span class="comment">// Use this buffer when mLength is 1</span>
00055   size_t mLength;          <span class="comment">// Length of mpStore in units of store_type</span>
00056   size_t mNumBits;
00057 
00059   <span class="keyword">static</span> size_t GetIndex (size_t bit_num)
00060   {
00061     <span class="keywordflow">return</span> bit_num / cell_size;
00062   }
00063 
00065   <span class="keyword">static</span> size_t GetOffset (size_t bit_num)
00066   {
00067     <span class="keywordflow">return</span> bit_num % cell_size;
00068   }
00069 
00074   store_type <span class="keyword">const</span>* GetStore()<span class="keyword"> const</span>
00075 <span class="keyword">  </span>{
00076     <span class="keywordflow">return</span> mLength &lt;= 1 ? &amp;mSingleWord : mpStore;
00077   }
00078 
00083   store_type* GetStore()
00084   {
00085     <span class="keywordflow">return</span> mLength &lt;= 1 ? &amp;mSingleWord : mpStore;
00086   }
00087 
00089   <span class="keywordtype">void</span> Trim()
00090   {
00091     size_t extra_bits = mNumBits % cell_size;
00092     <span class="keywordflow">if</span> (mLength &gt; 0 &amp;&amp; extra_bits != 0)
00093       GetStore()[mLength - 1] &amp;= ~((~(store_type)0) &lt;&lt; extra_bits);
00094   }
00095 
00100   <span class="keywordtype">void</span> SetSize (size_t newSize)
00101   {
00102     size_t newLength;
00103     <span class="keywordflow">if</span> (newSize == 0)
00104       newLength = 0;
00105     <span class="keywordflow">else</span>
00106       newLength = 1 + GetIndex (newSize - 1);
00107 
00108     <span class="keywordflow">if</span> (newLength != mLength)
00109     {
00110       <span class="comment">// Avoid allocation if length is 1 (common case)</span>
00111       store_type* newStore;
00112       <span class="keywordflow">if</span> (newLength &lt;= 1)
00113         newStore = &amp;mSingleWord;
00114       <span class="keywordflow">else</span>
00115         newStore = <span class="keyword">new</span> store_type[newLength];
00116 
00117       <span class="keywordflow">if</span> (newLength &gt; 0)
00118       {
00119         <span class="keywordflow">if</span> (mLength &gt; 0)
00120         {
00121           store_type <span class="keyword">const</span>* oldStore = GetStore();
00122           <span class="keywordflow">if</span> (newStore != oldStore)
00123           {
00124             memcpy (newStore, oldStore, 
00125               (MIN (mLength, newLength)) * <span class="keyword">sizeof</span> (store_type));
00126             <span class="keywordflow">if</span> (newLength &gt; mLength)
00127               memset(newStore + mLength, 0,
00128                      (newLength - mLength) * <span class="keyword">sizeof</span> (store_type));
00129           }
00130         }
00131         <span class="keywordflow">else</span>
00132           memset (newStore, 0, newLength * <span class="keyword">sizeof</span> (store_type));
00133       }
00134 
00135       <span class="keywordflow">if</span> (mpStore != 0)
00136         <span class="keyword">delete</span>[] mpStore;
00137 
00138       mpStore = newLength &gt; 1 ? newStore : 0;
00139       mLength = newLength;
00140     }
00141 
00142     mNumBits = newSize;
00143     Trim();
00144   }
00145 
00146 <span class="keyword">public</span>:
00150   <span class="keyword">class </span>CS_CRYSTALSPACE_EXPORT BitProxy
00151   {
00152   <span class="keyword">private</span>:
00153     <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;mArray;
00154     size_t mPos;
00155   <span class="keyword">public</span>:
00157     BitProxy(<a class="code" href="classcsBitArray.html">csBitArray</a> &amp;array, size_t pos): mArray(array), mPos(pos)
00158     {}
00159 
00161     BitProxy &amp;operator= (<span class="keywordtype">bool</span> value)
00162     {
00163       mArray.Set (mPos, value);
00164       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00165     }
00166 
00168     BitProxy &amp;operator= (<span class="keyword">const</span> BitProxy &amp;that)
00169     {
00170       mArray.Set (mPos, that.mArray.IsBitSet (that.mPos));
00171       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00172     }
00173 
00175     operator bool()<span class="keyword"> const</span>
00176 <span class="keyword">    </span>{
00177       <span class="keywordflow">return</span> mArray.IsBitSet (mPos);
00178     }
00179 
00184     <span class="keywordtype">bool</span> Flip()
00185     {
00186       mArray.FlipBit (mPos);
00187       <span class="keywordflow">return</span> mArray.IsBitSet (mPos);
00188     }
00189   };
00190   <span class="keyword">friend</span> <span class="keyword">class </span>BitProxy;
00191 
<a name="l00195"></a><a class="code" href="classcsBitArray.html#a0">00195</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> () : mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00196   {
00197     SetSize (0);
00198   }
00199 
<a name="l00203"></a><a class="code" href="classcsBitArray.html#a1">00203</a>   <span class="keyword">explicit</span> <a class="code" href="classcsBitArray.html">csBitArray</a>(size_t size) :
00204     mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00205   {
00206     SetSize (size);
00207   }
00208 
<a name="l00212"></a><a class="code" href="classcsBitArray.html#a2">00212</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that) :
00213     mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00214   {
00215     *<span class="keyword">this</span> = that; <span class="comment">// Invokes this-&gt;operator=().</span>
00216   }
00217 
<a name="l00219"></a><a class="code" href="classcsBitArray.html#a3">00219</a>   ~<a class="code" href="classcsBitArray.html">csBitArray</a>()
00220   {
00221     <span class="keywordflow">if</span> (mpStore != 0)
00222       <span class="keyword">delete</span>[] mpStore;
00223   }
00224 
<a name="l00226"></a><a class="code" href="classcsBitArray.html#a4">00226</a>   size_t Length()<span class="keyword"> const</span>
00227 <span class="keyword">  </span>{
00228     <span class="keywordflow">return</span> mNumBits;
00229   }
00230 
<a name="l00236"></a><a class="code" href="classcsBitArray.html#a5">00236</a>   <span class="keywordtype">void</span> SetLength (size_t newSize)
00237   {
00238     SetSize (newSize);
00239   }
00240 
00241   <span class="comment">//</span>
00242   <span class="comment">// Operators</span>
00243   <span class="comment">//</span>
00244 
<a name="l00246"></a><a class="code" href="classcsBitArray.html#a6">00246</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)
00247   {
00248     <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;that)
00249     {
00250       SetSize (that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00251       memcpy (GetStore(), that.<a class="code" href="classcsBitArray.html#d0">GetStore</a>(), mLength * <span class="keyword">sizeof</span>(store_type));
00252     }
00253     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00254   }
00255 
<a name="l00257"></a><a class="code" href="classcsBitArray.html#a7">00257</a>   BitProxy operator[] (size_t pos)
00258   {
00259     CS_ASSERT (pos &lt; mNumBits);
00260     <span class="keywordflow">return</span> BitProxy(*<span class="keyword">this</span>, pos);
00261   }
00262 
<a name="l00264"></a><a class="code" href="classcsBitArray.html#a8">00264</a>   <span class="keywordtype">bool</span> operator[] (size_t pos)<span class="keyword"> const</span>
00265 <span class="keyword">  </span>{
00266     <span class="keywordflow">return</span> IsBitSet(pos);
00267   }
00268 
<a name="l00270"></a><a class="code" href="classcsBitArray.html#a9">00270</a>   <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)<span class="keyword"> const</span>
00271 <span class="keyword">  </span>{
00272     <span class="keywordflow">if</span> (mNumBits != that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>)
00273       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00274 
00275     store_type <span class="keyword">const</span>* p0 = GetStore();
00276     store_type <span class="keyword">const</span>* p1 = that.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00277     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; mLength; i++)
00278       <span class="keywordflow">if</span> (p0[i] != p1[i])
00279         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00280     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00281   }
00282 
<a name="l00284"></a><a class="code" href="classcsBitArray.html#a10">00284</a>   <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)<span class="keyword"> const</span>
00285 <span class="keyword">  </span>{
00286     <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == that);
00287   }
00288 
<a name="l00290"></a><a class="code" href="classcsBitArray.html#a11">00290</a>   <a class="code" href="classcsBitArray.html">csBitArray</a>&amp; operator &amp;= (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)
00291   {
00292     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00293     store_type* p0 = GetStore();
00294     store_type <span class="keyword">const</span>* p1 = that.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00295     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00296       p0[i] &amp;= p1[i];
00297     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00298   }
00299 
<a name="l00301"></a><a class="code" href="classcsBitArray.html#a12">00301</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> operator |= (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)
00302   {
00303     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00304     store_type* p0 = GetStore();
00305     store_type <span class="keyword">const</span>* p1 = that.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00306     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00307       p0[i] |= p1[i];
00308     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00309   }
00310 
<a name="l00312"></a><a class="code" href="classcsBitArray.html#a13">00312</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> operator ^= (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)
00313   {
00314     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00315     store_type* p0 = GetStore();
00316     store_type <span class="keyword">const</span>* p1 = that.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00317     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00318       p0[i] ^= p1[i];
00319     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00320   }
00321 
<a name="l00323"></a><a class="code" href="classcsBitArray.html#a14">00323</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> operator~()<span class="keyword"> const</span>
00324 <span class="keyword">  </span>{
00325     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html">csBitArray</a>(*this).FlipAllBits();
00326   }
00327 
<a name="l00329"></a><a class="code" href="classcsBitArray.html#n2">00329</a>   <span class="keyword">friend</span> <a class="code" href="classcsBitArray.html">csBitArray</a> operator&amp; (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a1, <span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a2)
00330   {
00331     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html">csBitArray</a>(a1) &amp;= a2;
00332   }
00333 
<a name="l00335"></a><a class="code" href="classcsBitArray.html#n3">00335</a>   <span class="keyword">friend</span> <a class="code" href="classcsBitArray.html">csBitArray</a> operator | (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a1, <span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a2)
00336   {
00337     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html">csBitArray</a>(a1) |= a2;
00338   }
00339 
<a name="l00341"></a><a class="code" href="classcsBitArray.html#n4">00341</a>   <span class="keyword">friend</span> <a class="code" href="classcsBitArray.html">csBitArray</a> operator ^ (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a1, <span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a2)
00342   {
00343     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html">csBitArray</a>(a1) ^= a2;
00344   }
00345 
00346   <span class="comment">//</span>
00347   <span class="comment">// Plain English interface</span>
00348   <span class="comment">//</span>
00349 
<a name="l00351"></a><a class="code" href="classcsBitArray.html#a15">00351</a>   <span class="keywordtype">void</span> Clear()
00352   {
00353     memset (GetStore(), 0, mLength * <span class="keyword">sizeof</span>(store_type));
00354   }
00355 
<a name="l00357"></a><a class="code" href="classcsBitArray.html#a16">00357</a>   <span class="keywordtype">void</span> SetBit (size_t pos)
00358   {
00359     CS_ASSERT (pos &lt; mNumBits);
00360     GetStore()[GetIndex(pos)] |= ((store_type)1) &lt;&lt; GetOffset(pos);
00361   }
00362 
<a name="l00364"></a><a class="code" href="classcsBitArray.html#a17">00364</a>   <span class="keywordtype">void</span> ClearBit (size_t pos)
00365   {
00366     CS_ASSERT (pos &lt; mNumBits);
00367     GetStore()[GetIndex(pos)] &amp;= ~(((store_type)1) &lt;&lt; GetOffset(pos));
00368   }
00369 
<a name="l00371"></a><a class="code" href="classcsBitArray.html#a18">00371</a>   <span class="keywordtype">void</span> FlipBit (size_t pos)
00372   {
00373     CS_ASSERT (pos &lt; mNumBits);
00374     GetStore()[GetIndex(pos)] ^= ((store_type)1) &lt;&lt; GetOffset(pos);
00375   }
00376 
<a name="l00378"></a><a class="code" href="classcsBitArray.html#a19">00378</a>   <span class="keywordtype">void</span> Set (size_t pos, <span class="keywordtype">bool</span> val = <span class="keyword">true</span>)
00379   {
00380     <span class="keywordflow">if</span> (val)
00381       SetBit(pos);
00382     <span class="keywordflow">else</span>
00383       ClearBit(pos);
00384   }
00385 
<a name="l00387"></a><a class="code" href="classcsBitArray.html#a20">00387</a>   <span class="keywordtype">bool</span> IsBitSet (size_t pos)<span class="keyword"> const</span>
00388 <span class="keyword">  </span>{
00389     CS_ASSERT (pos &lt; mNumBits);
00390     <span class="keywordflow">return</span> (GetStore()[GetIndex(pos)] &amp; (((store_type)1) &lt;&lt; GetOffset(pos)))
00391       != 0;
00392   }
00393 
<a name="l00395"></a><a class="code" href="classcsBitArray.html#a21">00395</a>   <span class="keywordtype">bool</span> AreSomeBitsSet (size_t pos, size_t count)<span class="keyword"> const</span>
00396 <span class="keyword">  </span>{
00397     CS_ASSERT (pos + count &lt;= mNumBits);
00398     store_type <span class="keyword">const</span>* p = GetStore();
00399     <span class="keywordflow">while</span> (count &gt; 0)
00400     {
00401       size_t index = GetIndex (pos);
00402       size_t offset = GetOffset (pos);
00403       size_t checkCount = MIN(count, cell_size - offset);
00404       store_type mask = ((checkCount == cell_size) ? ~(store_type)0 :
00405                          ((((store_type)1) &lt;&lt; checkCount) - 1)) &lt;&lt; offset;
00406       <span class="keywordflow">if</span> (p[index] &amp; mask)
00407         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00408       pos += checkCount;
00409       count -= checkCount;
00410     }
00411     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00412   }
00413   
<a name="l00415"></a><a class="code" href="classcsBitArray.html#a22">00415</a>   <span class="keywordtype">bool</span> AllBitsFalse()<span class="keyword"> const</span>
00416 <span class="keyword">  </span>{
00417     store_type <span class="keyword">const</span>* p = GetStore();
00418     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00419       <span class="keywordflow">if</span> (p[i] != 0)
00420         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00421     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00422   }
00423 
<a name="l00425"></a><a class="code" href="classcsBitArray.html#a23">00425</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;FlipAllBits()
00426   {
00427     store_type* p = GetStore();
00428     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00429       p[i] = ~p[i];
00430     Trim();
00431     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00432   }
00433 
<a name="l00438"></a><a class="code" href="classcsBitArray.html#a24">00438</a>   <span class="keywordtype">void</span> Delete(size_t pos, size_t count)
00439   {
00440     <span class="keywordflow">if</span> (count &gt; 0)
00441     {
00442       size_t dst = pos;
00443       size_t src = pos + count;
00444       CS_ASSERT(src &lt;= mNumBits);
00445       size_t ntail = mNumBits - src;
00446       <span class="keywordflow">while</span> (ntail-- &gt; 0)
00447         Set(dst++, IsBitSet(src++));
00448       SetSize(mNumBits - count);
00449     }
00450   }
00451 
<a name="l00456"></a><a class="code" href="classcsBitArray.html#a25">00456</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> Slice(size_t pos, size_t count)<span class="keyword"> const</span>
00457 <span class="keyword">  </span>{
00458     CS_ASSERT(pos + count &lt;= mNumBits);
00459     <a class="code" href="classcsBitArray.html">csBitArray</a> a(count);
00460     <span class="keywordflow">for</span> (size_t i = pos, o = 0; i &lt; pos + count; i++)
00461       <span class="keywordflow">if</span> (IsBitSet(i))
00462         a.<a class="code" href="classcsBitArray.html#a16">SetBit</a>(o++);
00463     <span class="keywordflow">return</span> a;
00464   }
00465 
<a name="l00467"></a><a class="code" href="classcsBitArray.html#a26">00467</a>   store_type* GetArrayBits()
00468   {
00469     <span class="keywordflow">return</span> GetStore();
00470   }
00471 
<a name="l00476"></a><a class="code" href="classcsBitArray.html#a27">00476</a>   store_type GetSingleWord()
00477   {
00478     CS_ASSERT(mpStore == 0);
00479     <span class="keywordflow">return</span> mSingleWord;
00480   }
00481 
<a name="l00486"></a><a class="code" href="classcsBitArray.html#a28">00486</a>   <span class="keywordtype">void</span> SetSingleWord (store_type sw)
00487   {
00488     CS_ASSERT(mpStore == 0);
00489     mSingleWord = sw;
00490   }
00491 };
00492 
<a name="l00496"></a><a class="code" href="classcsBitArrayHashKeyHandler.html">00496</a> <span class="keyword">class </span><a class="code" href="classcsBitArrayHashKeyHandler.html">csBitArrayHashKeyHandler</a>
00497 {
00498 <span class="keyword">public</span>:
00499   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ComputeHash (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a>&amp; key)
00500   {
00501     <span class="keyword">const</span> size_t uintCount = <span class="keyword">sizeof</span> (csBitArray::store_type) / <span class="keyword">sizeof</span> (<a class="code" href="group__util.html#ga18">uint</a>);
00502     <span class="keyword">union</span>
00503 <span class="keyword">    </span>{
00504       csBitArray::store_type store;
00505       <a class="code" href="group__util.html#ga18">uint</a> ui[uintCount];
00506     } bitStoreToUint;
00507     <a class="code" href="group__util.html#ga18">uint</a> hash = 0;
00508     csBitArray::store_type <span class="keyword">const</span>* p = key.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00509     <span class="comment">// @@@ Not very good. Find a better hash function; however, it should</span>
00510     <span class="comment">// return the same hash for two bit arrays that are the same except for</span>
00511     <span class="comment">// the amount of trailing zeros. (e.g. f(10010110) == f(100101100000...))</span>
00512     <span class="keywordflow">for</span> (size_t i = 0; i &lt; key.<a class="code" href="classcsBitArray.html#r2">mLength</a>; i++)
00513     {
00514       bitStoreToUint.store = p[i];
00515       <span class="keywordflow">for</span> (size_t j = 0; j &lt; uintCount; j++)
00516         hash += bitStoreToUint.ui[j];
00517     }
00518     <span class="keywordflow">return</span> hash;
00519   }
00520   <span class="keyword">static</span> <span class="keywordtype">bool</span> CompareKeys (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a>&amp; key1, <span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a>&amp; key2)
00521   {
00522     csBitArray::store_type <span class="keyword">const</span>* p0 = key1.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00523     csBitArray::store_type <span class="keyword">const</span>* p1 = key2.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00524     size_t compareNum = MIN (key1.<a class="code" href="classcsBitArray.html#r2">mLength</a>, key2.<a class="code" href="classcsBitArray.html#r2">mLength</a>);
00525     size_t i = 0;
00526     <span class="keywordflow">for</span> (; i &lt; compareNum; i++)
00527       <span class="keywordflow">if</span> (p0[i] != p1[i])
00528         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00529     <span class="keywordflow">if</span> (key1.<a class="code" href="classcsBitArray.html#r2">mLength</a> &gt; key2.<a class="code" href="classcsBitArray.html#r2">mLength</a>)
00530     {
00531       <span class="keywordflow">for</span> (; i &lt; key1.<a class="code" href="classcsBitArray.html#r2">mLength</a>; i++)
00532         <span class="keywordflow">if</span> (p0[i] != 0)
00533           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00534     }
00535     <span class="keywordflow">else</span>
00536     {
00537       <span class="keywordflow">for</span> (; i &lt; key2.<a class="code" href="classcsBitArray.html#r2">mLength</a>; i++)
00538         <span class="keywordflow">if</span> (p1[i] != 0)
00539           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00540     }
00541     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00542   }
00543 };
00544 
00545 <span class="preprocessor">#endif // __CS_BITARRAY_H__</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.2 
</small></address> </div></body> </html>
