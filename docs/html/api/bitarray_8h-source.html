<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/bitarray.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.9 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000022.html">csutil</a></div>
<h1>bitarray.h</h1><a href="bitarray_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2000 by Andrew Kirmse</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="comment">// A one-dimensional array of bits, similar to STL bitset.</span>
00020 <span class="comment">//</span>
00021 <span class="comment">// Copyright 2000 Andrew Kirmse.  All rights reserved.</span>
00022 <span class="comment">//</span>
00023 <span class="comment">// Permission is granted to use this code for any purpose, as long as this</span>
00024 <span class="comment">// copyright message remains intact.</span>
00025 
00026 <span class="preprocessor">#ifndef __CS_BITARRAY_H__</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define __CS_BITARRAY_H__</span>
00028 <span class="preprocessor"></span>
00033 <span class="preprocessor">#include "csextern.h"</span>
00034 
00035 <span class="keyword">class </span><a class="code" href="classcsBitArrayHashKeyHandler.html">csBitArrayHashKeyHandler</a>;
00036 
<a name="l00040"></a><a class="code" href="classcsBitArray.html">00040</a> <span class="keyword">class </span>CS_CRYSTALSPACE_EXPORT csBitArray
00041 {
00042 <span class="keyword">public</span>:
00043   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> store_type;
00044 <span class="keyword">private</span>:
00045   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsBitArrayHashKeyHandler.html">csBitArrayHashKeyHandler</a>;
00046   <span class="keyword">enum</span>
00047   {
00048     bits_per_byte = 8,
00049     cell_size     = <span class="keyword">sizeof</span>(store_type) * bits_per_byte
00050   };
00051 
00052   store_type *mpStore;
00053   store_type mSingleWord; <span class="comment">// Use this buffer when mLength is 1</span>
00054   size_t mLength;       <span class="comment">// Length of mpStore in units of store_type</span>
00055   size_t mNumBits;
00056 
00058   <span class="keyword">static</span> <span class="keyword">inline</span> size_t GetIndex (size_t bit_num)
00059   {
00060     <span class="keywordflow">return</span> bit_num / cell_size;
00061   }
00062 
00063   <span class="keyword">static</span> <span class="keyword">inline</span> size_t GetOffset (size_t bit_num)
00064   {
00065     <span class="keywordflow">return</span> bit_num % cell_size;
00066   }
00067 
00068   <span class="keywordtype">void</span> SetSize (size_t newSize)
00069   {
00070     size_t newLength;
00071     <span class="keywordflow">if</span> (newSize == 0)
00072       newLength = 0;
00073     <span class="keywordflow">else</span>
00074       newLength = 1 + GetIndex (newSize - 1);
00075 
00076     <span class="comment">// Avoid allocation if length is 1 (common case)</span>
00077     store_type* newStore;
00078     <span class="keywordflow">if</span> (newLength &lt;= 1)
00079       newStore = &amp;mSingleWord;
00080     <span class="keywordflow">else</span>
00081       newStore = <span class="keyword">new</span> store_type[newLength];
00082     
00083     <span class="keywordflow">if</span> (newLength &gt; 0)
00084     {
00085       <span class="keywordflow">if</span> (mLength &gt; 0)
00086       {
00087         <span class="keywordflow">if</span> (newStore != mpStore)
00088           memcpy (newStore, mpStore, 
00089             (MIN (mLength, newLength)) * <span class="keyword">sizeof</span> (store_type));
00090       }
00091       <span class="keywordflow">else</span>
00092         memset (newStore, 0, newLength * <span class="keyword">sizeof</span> (store_type));
00093     }
00094 
00095     <span class="keywordflow">if</span> (mLength &gt; 1)
00096       <span class="keyword">delete</span> mpStore;
00097 
00098     mpStore = newStore;
00099     mNumBits = newSize;
00100     mLength = newLength;
00101   }
00102 
00104   <span class="keyword">inline</span> <span class="keywordtype">void</span> Trim()
00105   {
00106     size_t extra_bits = mNumBits % cell_size;
00107     <span class="keywordflow">if</span> (mLength &gt; 0 &amp;&amp; extra_bits != 0)
00108       mpStore[mLength - 1] &amp;= ~((~(store_type) 0) &lt;&lt; extra_bits);
00109   }
00110 
00111 <span class="keyword">public</span>:
00115   <span class="keyword">class </span>CS_CRYSTALSPACE_EXPORT BitProxy
00116   {
00117   <span class="keyword">private</span>:
00118     csBitArray &amp;mArray;
00119     size_t mPos;
00120   <span class="keyword">public</span>:
00122     BitProxy(csBitArray &amp;array, size_t pos): mArray(array), mPos(pos)
00123     {}
00124 
00126     BitProxy &amp;<a class="code" href="classcsBitArray.html#a6">operator= </a>(<span class="keywordtype">bool</span> value)
00127     {
00128       mArray.<a class="code" href="classcsBitArray.html#a19">Set</a> (mPos, value);
00129       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00130     }
00131 
00133     BitProxy &amp;<a class="code" href="classcsBitArray.html#a6">operator= </a>(<span class="keyword">const</span> BitProxy &amp;that)
00134     {
00135       mArray.<a class="code" href="classcsBitArray.html#a19">Set</a> (mPos, that.mArray.IsBitSet (that.mPos));
00136       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00137     }
00138 
00140     operator bool()<span class="keyword"> const</span>
00141 <span class="keyword">    </span>{
00142       <span class="keywordflow">return</span> mArray.<a class="code" href="classcsBitArray.html#a20">IsBitSet</a> (mPos);
00143     }
00144 
00146     <span class="keywordtype">bool</span> Flip()
00147     {
00148       mArray.<a class="code" href="classcsBitArray.html#a18">FlipBit</a> (mPos);
00149       <span class="keywordflow">return</span> mArray.<a class="code" href="classcsBitArray.html#a20">IsBitSet</a> (mPos);
00150     }
00151   };
00152   <span class="keyword">friend</span> <span class="keyword">class </span>BitProxy;
00153 
<a name="l00157"></a><a class="code" href="classcsBitArray.html#a0">00157</a>   <a class="code" href="classcsBitArray.html#a0">csBitArray</a> () : mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00158   {
00159     SetSize (0);
00160     <span class="comment">// Clear last bits</span>
00161     Trim();
00162   }
00163 
<a name="l00167"></a><a class="code" href="classcsBitArray.html#a1">00167</a>   <span class="keyword">explicit</span> <a class="code" href="classcsBitArray.html#a0">csBitArray</a>(size_t size) :
00168     mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00169   {
00170     SetSize (size);
00171     <span class="comment">// Clear last bits</span>
00172     Trim();
00173   }
00174 
<a name="l00178"></a><a class="code" href="classcsBitArray.html#a2">00178</a>   <a class="code" href="classcsBitArray.html#a0">csBitArray</a> (<span class="keyword">const</span> csBitArray &amp;that) :
00179     mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00180   {
00181     *<span class="keyword">this</span> = that; <span class="comment">// Invokes this-&gt;operator=().</span>
00182   }
00183 
<a name="l00185"></a><a class="code" href="classcsBitArray.html#a3">00185</a>   <a class="code" href="classcsBitArray.html#a3">~csBitArray</a>()
00186   {
00187     <span class="keywordflow">if</span> (mLength &gt; 1)
00188       <span class="keyword">delete</span> mpStore;
00189   }
00190 
<a name="l00192"></a><a class="code" href="classcsBitArray.html#a4">00192</a>   size_t <a class="code" href="classcsBitArray.html#a4">Length</a>()<span class="keyword"> const</span>
00193 <span class="keyword">  </span>{
00194     <span class="keywordflow">return</span> mNumBits;
00195   }
00196 
<a name="l00202"></a><a class="code" href="classcsBitArray.html#a5">00202</a>   <span class="keywordtype">void</span> <a class="code" href="classcsBitArray.html#a5">SetLength</a> (size_t newSize)
00203   {
00204     SetSize (newSize);
00205     <span class="comment">// Clear last bits</span>
00206     Trim ();
00207   }
00208 
00209   <span class="comment">//</span>
00210   <span class="comment">// Operators</span>
00211   <span class="comment">//</span>
00212 
<a name="l00214"></a><a class="code" href="classcsBitArray.html#a6">00214</a>   csBitArray &amp;<a class="code" href="classcsBitArray.html#a6">operator=</a>(<span class="keyword">const</span> csBitArray &amp;that)
00215   {
00216     <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;that)
00217     {
00218       SetSize (that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00219       memcpy (mpStore, that.<a class="code" href="classcsBitArray.html#r0">mpStore</a>, mLength * <span class="keyword">sizeof</span>(store_type));
00220     }
00221     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00222   }
00223 
<a name="l00225"></a><a class="code" href="classcsBitArray.html#a7">00225</a>   BitProxy <a class="code" href="classcsBitArray.html#a7">operator[] </a>(size_t pos)
00226   {
00227     CS_ASSERT (pos &lt; mNumBits);
00228     <span class="keywordflow">return</span> BitProxy(*<span class="keyword">this</span>, pos);
00229   }
00230 
<a name="l00232"></a><a class="code" href="classcsBitArray.html#a8">00232</a>   <span class="keyword">const</span> BitProxy <a class="code" href="classcsBitArray.html#a7">operator[] </a>(size_t pos)<span class="keyword"> const</span>
00233 <span class="keyword">  </span>{
00234     CS_ASSERT (pos &lt; mNumBits);
00235     <span class="keywordflow">return</span> BitProxy(CS_CONST_CAST(csBitArray&amp;,*<span class="keyword">this</span>), pos);
00236   }
00237 
<a name="l00239"></a><a class="code" href="classcsBitArray.html#a9">00239</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsBitArray.html#a9">operator==</a>(<span class="keyword">const</span> csBitArray &amp;that)<span class="keyword"> const</span>
00240 <span class="keyword">  </span>{
00241     <span class="keywordflow">if</span> (mNumBits != that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>)
00242       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00243 
00244     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; mLength; i++)
00245       <span class="keywordflow">if</span> (mpStore[i] != that.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i])
00246         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00247     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00248   }
00249 
<a name="l00251"></a><a class="code" href="classcsBitArray.html#a10">00251</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsBitArray.html#a10">operator != </a>(<span class="keyword">const</span> csBitArray &amp;that)<span class="keyword"> const</span>
00252 <span class="keyword">  </span>{
00253     <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == that);
00254   }
00255 
<a name="l00257"></a><a class="code" href="classcsBitArray.html#a11">00257</a>   csBitArray&amp; <a class="code" href="classcsBitArray.html#a11">operator &amp;= </a>(<span class="keyword">const</span> csBitArray &amp;that)
00258   {
00259     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00260     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00261       mpStore[i] &amp;= that.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i];
00262     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00263   }
00264 
<a name="l00266"></a><a class="code" href="classcsBitArray.html#a12">00266</a>   csBitArray <a class="code" href="classcsBitArray.html#a12">operator |= </a>(<span class="keyword">const</span> csBitArray &amp;that)
00267   {
00268     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00269     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00270       mpStore[i] |= that.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i];
00271     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00272   }
00273 
<a name="l00275"></a><a class="code" href="classcsBitArray.html#a13">00275</a>   csBitArray <a class="code" href="classcsBitArray.html#a13">operator ^= </a>(<span class="keyword">const</span> csBitArray &amp;that)
00276   {
00277     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00278     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00279       mpStore[i] ^= that.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i];
00280     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00281   }
00282 
<a name="l00284"></a><a class="code" href="classcsBitArray.html#a14">00284</a>   csBitArray <a class="code" href="classcsBitArray.html#a14">operator~</a>()<span class="keyword"> const</span>
00285 <span class="keyword">  </span>{
00286     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html#a0">csBitArray</a>(*this).<a class="code" href="classcsBitArray.html#a23">FlipAllBits</a>();
00287   }
00288 
<a name="l00290"></a><a class="code" href="classcsBitArray.html#n2">00290</a>   <span class="keyword">friend</span> csBitArray <a class="code" href="classcsBitArray.html#n2">operator&amp; </a>(<span class="keyword">const</span> csBitArray &amp;a1, <span class="keyword">const</span> csBitArray &amp;a2)
00291   {
00292     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html#a0">csBitArray</a>(a1) &amp;= a2;
00293   }
00294 
<a name="l00296"></a><a class="code" href="classcsBitArray.html#n3">00296</a>   <span class="keyword">friend</span> csBitArray <a class="code" href="classcsBitArray.html#n3">operator | </a>(<span class="keyword">const</span> csBitArray &amp;a1, <span class="keyword">const</span> csBitArray &amp;a2)
00297   {
00298     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html#a0">csBitArray</a>(a1) |= a2;
00299   }
00300 
<a name="l00302"></a><a class="code" href="classcsBitArray.html#n4">00302</a>   <span class="keyword">friend</span> csBitArray <a class="code" href="classcsBitArray.html#n4">operator ^ </a>(<span class="keyword">const</span> csBitArray &amp;a1, <span class="keyword">const</span> csBitArray &amp;a2)
00303   {
00304     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html#a0">csBitArray</a>(a1) ^= a2;
00305   }
00306 
00307   <span class="comment">//</span>
00308   <span class="comment">// Plain English interface</span>
00309   <span class="comment">//</span>
00310 
<a name="l00312"></a><a class="code" href="classcsBitArray.html#a15">00312</a>   <span class="keywordtype">void</span> <a class="code" href="classcsBitArray.html#a15">Clear</a>()
00313   {
00314     memset (mpStore, 0, mLength * <span class="keyword">sizeof</span>(store_type));
00315   }
00316 
<a name="l00318"></a><a class="code" href="classcsBitArray.html#a16">00318</a>   <span class="keywordtype">void</span> <a class="code" href="classcsBitArray.html#a16">SetBit</a> (size_t pos)
00319   {
00320     CS_ASSERT (pos &lt; mNumBits);
00321     mpStore[GetIndex(pos)] |= 1 &lt;&lt; GetOffset(pos);
00322   }
00323 
<a name="l00325"></a><a class="code" href="classcsBitArray.html#a17">00325</a>   <span class="keywordtype">void</span> <a class="code" href="classcsBitArray.html#a17">ClearBit</a> (size_t pos)
00326   {
00327     CS_ASSERT (pos &lt; mNumBits);
00328     mpStore[GetIndex(pos)] &amp;= ~(1 &lt;&lt; GetOffset(pos));
00329   }
00330 
<a name="l00332"></a><a class="code" href="classcsBitArray.html#a18">00332</a>   <span class="keywordtype">void</span> <a class="code" href="classcsBitArray.html#a18">FlipBit</a> (size_t pos)
00333   {
00334     CS_ASSERT (pos &lt; mNumBits);
00335     mpStore[GetIndex(pos)] ^= 1 &lt;&lt; GetOffset(pos);
00336   }
00337 
<a name="l00339"></a><a class="code" href="classcsBitArray.html#a19">00339</a>   <span class="keywordtype">void</span> <a class="code" href="classcsBitArray.html#a19">Set</a> (size_t pos, <span class="keywordtype">bool</span> val)
00340   {
00341     val ? <a class="code" href="classcsBitArray.html#a16">SetBit</a>(pos) : <a class="code" href="classcsBitArray.html#a17">ClearBit</a>(pos);
00342   }
00343 
<a name="l00345"></a><a class="code" href="classcsBitArray.html#a20">00345</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsBitArray.html#a20">IsBitSet</a> (size_t pos)<span class="keyword"> const</span>
00346 <span class="keyword">  </span>{
00347     CS_ASSERT (pos &lt; mNumBits);
00348     <span class="keywordflow">return</span> (mpStore[GetIndex(pos)] &amp; (1 &lt;&lt; GetOffset(pos))) != 0;
00349   }
00350 
<a name="l00355"></a><a class="code" href="classcsBitArray.html#a21">00355</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsBitArray.html#a21">AreSomeBitsSet</a> (size_t pos, size_t count)<span class="keyword"> const</span>
00356 <span class="keyword">  </span>{
00357     CS_ASSERT (pos + count &lt;= mNumBits);
00358     <span class="keywordflow">while</span> (count &gt; 0)
00359     {
00360       size_t index = GetIndex (pos);
00361       size_t offset = GetOffset (pos);
00362       size_t checkCount = MIN(count, cell_size - offset);
00363             
00364       store_type mask = 
00365         ((checkCount == cell_size) ? ~0 : ((1 &lt;&lt; checkCount) - 1)) &lt;&lt; offset;
00366       <span class="keywordflow">if</span> (mpStore[index] &amp; mask) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00367       pos += checkCount;
00368       count -= checkCount;
00369     }
00370     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00371   }
00372   
<a name="l00374"></a><a class="code" href="classcsBitArray.html#a22">00374</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsBitArray.html#a22">AllBitsFalse</a>()<span class="keyword"> const</span>
00375 <span class="keyword">  </span>{
00376     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i &lt; mLength; i++)
00377       <span class="keywordflow">if</span> (mpStore[i] != 0)
00378         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00379     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00380   }
00381 
<a name="l00383"></a><a class="code" href="classcsBitArray.html#a23">00383</a>   csBitArray &amp;<a class="code" href="classcsBitArray.html#a23">FlipAllBits</a>()
00384   {
00385     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i &lt; mLength; i++)
00386       mpStore[i] = ~mpStore[i];
00387 
00388     Trim();
00389     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00390   }
00391 
<a name="l00396"></a><a class="code" href="classcsBitArray.html#a24">00396</a>   <span class="keywordtype">void</span> <a class="code" href="classcsBitArray.html#a24">Delete</a>(size_t pos, size_t count)
00397   {
00398     <span class="keywordflow">if</span> (count &gt; 0)
00399     {
00400       size_t dst = pos;
00401       size_t src = pos + count;
00402       CS_ASSERT(src &lt;= mNumBits);
00403       size_t ntail = mNumBits - src;
00404       <span class="keywordflow">while</span> (ntail-- &gt; 0)
00405         <a class="code" href="classcsBitArray.html#a19">Set</a>(dst++, <a class="code" href="classcsBitArray.html#a20">IsBitSet</a>(src++));
00406       mNumBits -= count;
00407       Trim();
00408     }
00409   }
00410 
<a name="l00415"></a><a class="code" href="classcsBitArray.html#a25">00415</a>   csBitArray <a class="code" href="classcsBitArray.html#a25">Slice</a>(size_t pos, size_t count)<span class="keyword"> const</span>
00416 <span class="keyword">  </span>{
00417     CS_ASSERT(pos + count &lt;= mNumBits);
00418     csBitArray a(count);
00419     <span class="comment">// Slow, but simple and effective.</span>
00420     <span class="keywordflow">for</span> (size_t i = pos, o = 0; i &lt; pos + count; i++)
00421       <span class="keywordflow">if</span> (<a class="code" href="classcsBitArray.html#a20">IsBitSet</a>(i))
00422         a.<a class="code" href="classcsBitArray.html#a16">SetBit</a>(o++);
00423     <span class="keywordflow">return</span> a;
00424   }
00425 
<a name="l00427"></a><a class="code" href="classcsBitArray.html#a26">00427</a>   store_type* <a class="code" href="classcsBitArray.html#a26">GetArrayBits</a>()
00428   {
00429     <span class="keywordflow">return</span> mpStore;
00430   }
00431 
<a name="l00436"></a><a class="code" href="classcsBitArray.html#a27">00436</a>   store_type <a class="code" href="classcsBitArray.html#a27">GetSingleWord</a>()
00437   {
00438     <span class="keywordflow">return</span> mSingleWord;
00439   }
00440 
<a name="l00445"></a><a class="code" href="classcsBitArray.html#a28">00445</a>   <span class="keywordtype">void</span> <a class="code" href="classcsBitArray.html#a28">SetSingleWord</a> (store_type sw)
00446   {
00447     mSingleWord = sw;
00448   }
00449 };
00450 
<a name="l00454"></a><a class="code" href="classcsBitArrayHashKeyHandler.html">00454</a> <span class="keyword">class </span><a class="code" href="classcsBitArrayHashKeyHandler.html">csBitArrayHashKeyHandler</a>
00455 {
00456 <span class="keyword">public</span>:
00457   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ComputeHash (<span class="keyword">const</span> csBitArray&amp; key)
00458   {
00459     <span class="keyword">const</span> size_t uintCount = <span class="keyword">sizeof</span> (csBitArray::store_type) / <span class="keyword">sizeof</span> (<a class="code" href="group__util.html#ga18">uint</a>);
00460     <span class="keyword">union</span>
00461 <span class="keyword">    </span>{
00462       csBitArray::store_type store;
00463       <a class="code" href="group__util.html#ga18">uint</a> ui[uintCount];
00464     } bitStoreToUint;
00465     <a class="code" href="group__util.html#ga18">uint</a> hash = 0;
00466     <span class="comment">// @@@ Not very good. Find a better hash function; however, it should</span>
00467     <span class="comment">// return the same hash for two bit arrays that are the same except for</span>
00468     <span class="comment">// the amount of trailing zeros. (e.g. f(10010110) == f(100101100000...))</span>
00469     <span class="keywordflow">for</span> (size_t i = 0; i &lt; key.<a class="code" href="classcsBitArray.html#r2">mLength</a>; i++)
00470     {
00471       bitStoreToUint.store = key.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i];
00472       <span class="keywordflow">for</span> (size_t j = 0; j &lt; uintCount; j++)
00473         hash += bitStoreToUint.ui[j];
00474     }
00475     <span class="keywordflow">return</span> hash;
00476   }
00477   <span class="keyword">static</span> <span class="keywordtype">bool</span> CompareKeys (<span class="keyword">const</span> csBitArray&amp; key1, <span class="keyword">const</span> csBitArray&amp; key2)
00478   {
00479     size_t compareNum = MIN (key1.<a class="code" href="classcsBitArray.html#r2">mLength</a>, key2.<a class="code" href="classcsBitArray.html#r2">mLength</a>);
00480     size_t i = 0;
00481     <span class="keywordflow">for</span> (; i &lt; compareNum; i++)
00482       <span class="keywordflow">if</span> (key1.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i] != key2.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00483     <span class="keywordflow">if</span> (key1.<a class="code" href="classcsBitArray.html#r2">mLength</a> &gt; key2.<a class="code" href="classcsBitArray.html#r2">mLength</a>)
00484     {
00485       <span class="keywordflow">for</span> (; i &lt; key1.<a class="code" href="classcsBitArray.html#r2">mLength</a>; i++)
00486         <span class="keywordflow">if</span> (key1.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i] != 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00487     }
00488     <span class="keywordflow">else</span>
00489     {
00490       <span class="keywordflow">for</span> (; i &lt; key2.<a class="code" href="classcsBitArray.html#r2">mLength</a>; i++)
00491         <span class="keywordflow">if</span> (key2.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i] != 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00492     }
00493     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00494   }
00495 };
00496 
00497 <span class="preprocessor">#endif // __CS_BITARRAY_H__</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.9 
</small></address> </div></body> </html>
