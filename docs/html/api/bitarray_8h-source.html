<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/bitarray.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>csutil/bitarray.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2000 by Andrew Kirmse</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="comment">// A one-dimensional array of bits, similar to STL bitset.</span>
00020 <span class="comment">//</span>
00021 <span class="comment">// Copyright 2000 Andrew Kirmse.  All rights reserved.</span>
00022 <span class="comment">//</span>
00023 <span class="comment">// Permission is granted to use this code for any purpose, as long as this</span>
00024 <span class="comment">// copyright message remains intact.</span>
00025 
00026 <span class="preprocessor">#ifndef __CS_BITARRAY_H__</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define __CS_BITARRAY_H__</span>
00028 <span class="preprocessor"></span>
00029 <span class="preprocessor">#include "csextern.h"</span>
00030 
<a name="l00034"></a><a class="code" href="classcsBitArray.html">00034</a> <span class="keyword">class </span>CS_CSUTIL_EXPORT <a class="code" href="classcsBitArray.html">csBitArray</a>
00035 {
00036 <span class="keyword">public</span>:
00037   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> store_type;
00038 <span class="keyword">private</span>:
00039   <span class="keyword">enum</span>
00040   {
00041     bits_per_byte = 8,
00042     cell_size     = <span class="keyword">sizeof</span>(store_type) * bits_per_byte
00043   };
00044 
00045   store_type *mpStore;
00046   store_type mSingleWord; <span class="comment">// Use this buffer when mLength is 1</span>
00047   size_t mLength;       <span class="comment">// Length of mpStore in units of store_type</span>
00048   size_t mNumBits;
00049 
00051   <span class="keyword">static</span> <span class="keyword">inline</span> size_t GetIndex (size_t bit_num)
00052   {
00053     <span class="keywordflow">return</span> bit_num / cell_size;
00054   }
00055 
00056   <span class="keyword">static</span> <span class="keyword">inline</span> size_t GetOffset (size_t bit_num)
00057   {
00058     <span class="keywordflow">return</span> bit_num % cell_size;
00059   }
00060 
00061   <span class="keywordtype">void</span> SetSize (size_t newSize)
00062   {
00063     size_t newLength;
00064     <span class="keywordflow">if</span> (newSize == 0)
00065       newLength = 0;
00066     <span class="keywordflow">else</span>
00067       newLength = 1 + GetIndex (newSize - 1);
00068 
00069     <span class="comment">// Avoid allocation if length is 1 (common case)</span>
00070     store_type* newStore;
00071     <span class="keywordflow">if</span> (newLength &lt;= 1)
00072       newStore = &amp;mSingleWord;
00073     <span class="keywordflow">else</span>
00074       newStore = <span class="keyword">new</span> store_type[newLength];
00075     
00076     <span class="keywordflow">if</span> (newLength &gt; 0)
00077     {
00078       <span class="keywordflow">if</span> (mLength &gt; 0)
00079         memcpy (newStore, mpStore, 
00080           (MIN (mLength, newLength)) * <span class="keyword">sizeof</span> (store_type));
00081       <span class="keywordflow">else</span>
00082         memset (newStore, 0, newLength * <span class="keyword">sizeof</span> (store_type));
00083     }
00084 
00085     <span class="keywordflow">if</span> (mLength &gt; 1)
00086       <span class="keyword">delete</span> mpStore;
00087 
00088     mpStore = newStore;
00089     mNumBits = newSize;
00090     mLength = newLength;
00091   }
00092 
00094   <span class="keyword">inline</span> <span class="keywordtype">void</span> Trim()
00095   {
00096     size_t extra_bits = mNumBits % cell_size;
00097     <span class="keywordflow">if</span> (mLength &gt; 0 &amp;&amp; extra_bits != 0)
00098       mpStore[mLength - 1] &amp;= ~((~(store_type) 0) &lt;&lt; extra_bits);
00099   }
00100 
00101 <span class="keyword">public</span>:
00105   <span class="keyword">class </span>CS_CSUTIL_EXPORT BitProxy
00106   {
00107   <span class="keyword">private</span>:
00108     <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;mArray;
00109     size_t mPos;
00110   <span class="keyword">public</span>:
00112     BitProxy(<a class="code" href="classcsBitArray.html">csBitArray</a> &amp;array, <span class="keywordtype">unsigned</span> pos): mArray(array), mPos(pos)
00113     {}
00114 
00116     BitProxy &amp;operator= (<span class="keywordtype">bool</span> value)
00117     {
00118       mArray.<a class="code" href="classcsBitArray.html#a19">Set</a> (mPos, value);
00119       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00120     }
00121 
00123     BitProxy &amp;operator= (<span class="keyword">const</span> BitProxy &amp;that)
00124     {
00125       mArray.<a class="code" href="classcsBitArray.html#a19">Set</a> (mPos, that.mArray.IsBitSet (that.mPos));
00126       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00127     }
00128 
00130     operator bool()<span class="keyword"> const</span>
00131 <span class="keyword">    </span>{
00132       <span class="keywordflow">return</span> mArray.<a class="code" href="classcsBitArray.html#a20">IsBitSet</a> (mPos);
00133     }
00134 
00136     <span class="keywordtype">bool</span> Flip()
00137     {
00138       mArray.<a class="code" href="classcsBitArray.html#a18">FlipBit</a> (mPos);
00139       <span class="keywordflow">return</span> mArray.<a class="code" href="classcsBitArray.html#a20">IsBitSet</a> (mPos);
00140     }
00141   };
00142   <span class="keyword">friend</span> <span class="keyword">class </span>BitProxy;
00143 
<a name="l00147"></a><a class="code" href="classcsBitArray.html#a0">00147</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> () : mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00148   {
00149     SetSize (0);
00150     <span class="comment">// Clear last bits</span>
00151     Trim();
00152   }
00153 
<a name="l00157"></a><a class="code" href="classcsBitArray.html#a1">00157</a>   <span class="keyword">explicit</span> <a class="code" href="classcsBitArray.html">csBitArray</a>(size_t size) :
00158     mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00159   {
00160     SetSize (size);
00161     <span class="comment">// Clear last bits</span>
00162     Trim();
00163   }
00164 
<a name="l00168"></a><a class="code" href="classcsBitArray.html#a2">00168</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that) :
00169     mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00170   {
00171     *<span class="keyword">this</span> = that;
00172   }
00173 
<a name="l00175"></a><a class="code" href="classcsBitArray.html#a3">00175</a>   <span class="keyword">virtual</span> ~<a class="code" href="classcsBitArray.html">csBitArray</a>()
00176   {
00177     <span class="keywordflow">if</span> (mLength &gt; 1)
00178       <span class="keyword">delete</span> mpStore;
00179   }
00180 
<a name="l00182"></a><a class="code" href="classcsBitArray.html#a4">00182</a>   size_t Length()<span class="keyword"> const</span>
00183 <span class="keyword">  </span>{
00184     <span class="keywordflow">return</span> mNumBits;
00185   }
00186 
<a name="l00192"></a><a class="code" href="classcsBitArray.html#a5">00192</a>   <span class="keywordtype">void</span> SetLength (size_t newSize)
00193   {
00194     SetSize (newSize);
00195     <span class="comment">// Clear last bits</span>
00196     Trim ();
00197   }
00198 
00199   <span class="comment">//</span>
00200   <span class="comment">// Operators</span>
00201   <span class="comment">//</span>
00202 
<a name="l00204"></a><a class="code" href="classcsBitArray.html#a6">00204</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)
00205   {
00206     <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;that)
00207     {
00208       SetSize (that.<a class="code" href="classcsBitArray.html#o3">mNumBits</a>);
00209       memcpy (mpStore, that.<a class="code" href="classcsBitArray.html#o0">mpStore</a>, mLength * <span class="keyword">sizeof</span>(store_type));
00210     }
00211     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00212   }
00213 
<a name="l00215"></a><a class="code" href="classcsBitArray.html#a7">00215</a>   BitProxy operator[] (size_t pos)
00216   {
00217     CS_ASSERT (pos &lt; mNumBits);
00218     <span class="keywordflow">return</span> BitProxy(*<span class="keyword">this</span>, pos);
00219   }
00220 
<a name="l00222"></a><a class="code" href="classcsBitArray.html#a8">00222</a>   <span class="keyword">const</span> BitProxy operator[] (size_t pos)<span class="keyword"> const</span>
00223 <span class="keyword">  </span>{
00224     CS_ASSERT (pos &lt; mNumBits);
00225     <span class="keywordflow">return</span> BitProxy(CS_CONST_CAST(<a class="code" href="classcsBitArray.html">csBitArray</a>&amp;,*<span class="keyword">this</span>), pos);
00226   }
00227 
<a name="l00229"></a><a class="code" href="classcsBitArray.html#a9">00229</a>   <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)<span class="keyword"> const</span>
00230 <span class="keyword">  </span>{
00231     <span class="keywordflow">if</span> (mNumBits != that.<a class="code" href="classcsBitArray.html#o3">mNumBits</a>)
00232       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00233 
00234     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; mLength; i++)
00235       <span class="keywordflow">if</span> (mpStore[i] != that.<a class="code" href="classcsBitArray.html#o0">mpStore</a>[i])
00236         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00237     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00238   }
00239 
<a name="l00241"></a><a class="code" href="classcsBitArray.html#a10">00241</a>   <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)<span class="keyword"> const</span>
00242 <span class="keyword">  </span>{
00243     <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == that);
00244   }
00245 
<a name="l00247"></a><a class="code" href="classcsBitArray.html#a11">00247</a>   <a class="code" href="classcsBitArray.html">csBitArray</a>&amp; operator &amp;= (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)
00248   {
00249     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#o3">mNumBits</a>);
00250     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00251       mpStore[i] &amp;= that.<a class="code" href="classcsBitArray.html#o0">mpStore</a>[i];
00252     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00253   }
00254 
<a name="l00256"></a><a class="code" href="classcsBitArray.html#a12">00256</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> operator |= (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)
00257   {
00258     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#o3">mNumBits</a>);
00259     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00260       mpStore[i] |= that.<a class="code" href="classcsBitArray.html#o0">mpStore</a>[i];
00261     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00262   }
00263 
<a name="l00265"></a><a class="code" href="classcsBitArray.html#a13">00265</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> operator ^= (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;that)
00266   {
00267     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#o3">mNumBits</a>);
00268     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00269       mpStore[i] ^= that.<a class="code" href="classcsBitArray.html#o0">mpStore</a>[i];
00270     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00271   }
00272 
<a name="l00274"></a><a class="code" href="classcsBitArray.html#a14">00274</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> operator~()<span class="keyword"> const</span>
00275 <span class="keyword">  </span>{
00276     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html">csBitArray</a>(*this).FlipAllBits();
00277   }
00278 
<a name="l00280"></a><a class="code" href="classcsBitArray.html#l1">00280</a>   <span class="keyword">friend</span> <a class="code" href="classcsBitArray.html">csBitArray</a> operator&amp; (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a1, <span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a2)
00281   {
00282     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html">csBitArray</a>(a1) &amp;= a2;
00283   }
00284 
<a name="l00286"></a><a class="code" href="classcsBitArray.html#l2">00286</a>   <span class="keyword">friend</span> <a class="code" href="classcsBitArray.html">csBitArray</a> operator | (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a1, <span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a2)
00287   {
00288     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html">csBitArray</a>(a1) |= a2;
00289   }
00290 
<a name="l00292"></a><a class="code" href="classcsBitArray.html#l3">00292</a>   <span class="keyword">friend</span> <a class="code" href="classcsBitArray.html">csBitArray</a> operator ^ (<span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a1, <span class="keyword">const</span> <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;a2)
00293   {
00294     <span class="keywordflow">return</span> <a class="code" href="classcsBitArray.html">csBitArray</a>(a1) ^= a2;
00295   }
00296 
00297   <span class="comment">//</span>
00298   <span class="comment">// Plain English interface</span>
00299   <span class="comment">//</span>
00300 
<a name="l00302"></a><a class="code" href="classcsBitArray.html#a15">00302</a>   <span class="keywordtype">void</span> Clear()
00303   {
00304     memset (mpStore, 0, mLength * <span class="keyword">sizeof</span>(store_type));
00305   }
00306 
<a name="l00308"></a><a class="code" href="classcsBitArray.html#a16">00308</a>   <span class="keywordtype">void</span> SetBit (size_t pos)
00309   {
00310     CS_ASSERT (pos &lt; mNumBits);
00311     mpStore[GetIndex(pos)] |= 1 &lt;&lt; GetOffset(pos);
00312   }
00313 
<a name="l00315"></a><a class="code" href="classcsBitArray.html#a17">00315</a>   <span class="keywordtype">void</span> ClearBit (size_t pos)
00316   {
00317     CS_ASSERT (pos &lt; mNumBits);
00318     mpStore[GetIndex(pos)] &amp;= ~(1 &lt;&lt; GetOffset(pos));
00319   }
00320 
<a name="l00322"></a><a class="code" href="classcsBitArray.html#a18">00322</a>   <span class="keywordtype">void</span> FlipBit (size_t pos)
00323   {
00324     CS_ASSERT (pos &lt; mNumBits);
00325     mpStore[GetIndex(pos)] ^= 1 &lt;&lt; GetOffset(pos);
00326   }
00327 
<a name="l00329"></a><a class="code" href="classcsBitArray.html#a19">00329</a>   <span class="keywordtype">void</span> Set (size_t pos, <span class="keywordtype">bool</span> val)
00330   {
00331     val ? SetBit(pos) : ClearBit(pos);
00332   }
00333 
<a name="l00335"></a><a class="code" href="classcsBitArray.html#a20">00335</a>   <span class="keywordtype">bool</span> IsBitSet (size_t pos)<span class="keyword"> const</span>
00336 <span class="keyword">  </span>{
00337     CS_ASSERT (pos &lt; mNumBits);
00338     <span class="keywordflow">return</span> (mpStore[GetIndex(pos)] &amp; (1 &lt;&lt; GetOffset(pos))) != 0;
00339   }
00340 
<a name="l00345"></a><a class="code" href="classcsBitArray.html#a21">00345</a>   <span class="keywordtype">bool</span> AreSomeBitsSet (size_t pos, size_t count)<span class="keyword"> const</span>
00346 <span class="keyword">  </span>{
00347     CS_ASSERT (pos &lt; mNumBits);
00348     CS_ASSERT ((pos + count) &lt; mNumBits);
00349     
00350     <span class="keywordflow">while</span> (count &gt; 0)
00351     {
00352       size_t index = GetIndex (pos);
00353       size_t offset = GetOffset (pos);
00354       size_t checkCount = MIN(count, cell_size - offset);
00355             
00356       store_type mask = ((1 &lt;&lt; checkCount) - 1) &lt;&lt; offset;
00357       <span class="keywordflow">if</span> (mpStore[index] &amp; mask) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00358       pos += checkCount;
00359       count -= checkCount;
00360     }
00361     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00362   }
00363   
<a name="l00365"></a><a class="code" href="classcsBitArray.html#a22">00365</a>   <span class="keywordtype">bool</span> AllBitsFalse()<span class="keyword"> const</span>
00366 <span class="keyword">  </span>{
00367     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i &lt; mLength; i++)
00368       <span class="keywordflow">if</span> (mpStore[i] != 0)
00369         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00370     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00371   }
00372 
<a name="l00374"></a><a class="code" href="classcsBitArray.html#a23">00374</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> &amp;FlipAllBits()
00375   {
00376     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i &lt; mLength; i++)
00377       mpStore[i] = ~mpStore[i];
00378 
00379     Trim();
00380     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00381   }
00382 
<a name="l00384"></a><a class="code" href="classcsBitArray.html#a24">00384</a>   store_type* GetArrayBits()
00385   {
00386     <span class="keywordflow">return</span> mpStore;
00387   }
00388 
<a name="l00393"></a><a class="code" href="classcsBitArray.html#a25">00393</a>   store_type GetSingleWord()
00394   {
00395     <span class="keywordflow">return</span> mSingleWord;
00396   }
00397 
<a name="l00402"></a><a class="code" href="classcsBitArray.html#a26">00402</a>   <span class="keywordtype">void</span> SetSingleWord (store_type sw)
00403   {
00404     mSingleWord = sw;
00405   }
00406 };
00407 
00408 <span class="preprocessor">#endif // __CS_BITARRAY_H__</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
