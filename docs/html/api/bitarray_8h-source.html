<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/bitarray.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>csutil/bitarray.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2000 by Andrew Kirmse</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="comment">// A one-dimensional array of bits, similar to STL bitset.</span>
00020 <span class="comment">//</span>
00021 <span class="comment">// Copyright 2000 Andrew Kirmse.  All rights reserved.</span>
00022 <span class="comment">//</span>
00023 <span class="comment">// Permission is granted to use this code for any purpose, as long as this</span>
00024 <span class="comment">// copyright message remains intact.</span>
00025 
00026 <span class="preprocessor">#ifndef __CS_BITARRAY_H__</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define __CS_BITARRAY_H__</span>
00028 <span class="preprocessor"></span>
00029 <span class="preprocessor">#include "csextern.h"</span>
00030 
<a name="l00034"></a><a class="code" href="classcsBitArray.html">00034</a> <span class="keyword">class </span>CS_CSUTIL_EXPORT csBitArray
00035 {
00036 <span class="keyword">public</span>:
00037   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> store_type;
00038 <span class="keyword">private</span>:
00039   <span class="keyword">enum</span>
00040   {
00041     bits_per_byte = 8,
00042     cell_size     = <span class="keyword">sizeof</span>(store_type) * bits_per_byte
00043   };
00044 
00045   store_type *mpStore;
00046   store_type mSingleWord; <span class="comment">// Use this buffer when mLength is 1</span>
00047   size_t mLength;       <span class="comment">// Length of mpStore in units of store_type</span>
00048   size_t mNumBits;
00049 
00051   <span class="keyword">static</span> <span class="keyword">inline</span> size_t GetIndex (size_t bit_num)
00052   {
00053     <span class="keywordflow">return</span> bit_num / cell_size;
00054   }
00055 
00056   <span class="keyword">static</span> <span class="keyword">inline</span> size_t GetOffset (size_t bit_num)
00057   {
00058     <span class="keywordflow">return</span> bit_num % cell_size;
00059   }
00060 
00061   <span class="keywordtype">void</span> SetSize (size_t newSize)
00062   {
00063     size_t newLength;
00064     <span class="keywordflow">if</span> (newSize == 0)
00065       newLength = 0;
00066     <span class="keywordflow">else</span>
00067       newLength = 1 + GetIndex (newSize - 1);
00068 
00069     <span class="comment">// Avoid allocation if length is 1 (common case)</span>
00070     store_type* newStore;
00071     <span class="keywordflow">if</span> (newLength &lt;= 1)
00072       newStore = &amp;mSingleWord;
00073     <span class="keywordflow">else</span>
00074       newStore = <span class="keyword">new</span> store_type[newLength];
00075     
00076     <span class="keywordflow">if</span> (newLength &gt; 0)
00077     {
00078       <span class="keywordflow">if</span> (mLength &gt; 0)
00079       {
00080         <span class="keywordflow">if</span> (newStore != mpStore)
00081           memcpy (newStore, mpStore, 
00082             (MIN (mLength, newLength)) * <span class="keyword">sizeof</span> (store_type));
00083       }
00084       <span class="keywordflow">else</span>
00085         memset (newStore, 0, newLength * <span class="keyword">sizeof</span> (store_type));
00086     }
00087 
00088     <span class="keywordflow">if</span> (mLength &gt; 1)
00089       <span class="keyword">delete</span> mpStore;
00090 
00091     mpStore = newStore;
00092     mNumBits = newSize;
00093     mLength = newLength;
00094   }
00095 
00097   <span class="keyword">inline</span> <span class="keywordtype">void</span> Trim()
00098   {
00099     size_t extra_bits = mNumBits % cell_size;
00100     <span class="keywordflow">if</span> (mLength &gt; 0 &amp;&amp; extra_bits != 0)
00101       mpStore[mLength - 1] &amp;= ~((~(store_type) 0) &lt;&lt; extra_bits);
00102   }
00103 
00104 <span class="keyword">public</span>:
00108   <span class="keyword">class </span>CS_CSUTIL_EXPORT BitProxy
00109   {
00110   <span class="keyword">private</span>:
00111     csBitArray &amp;mArray;
00112     size_t mPos;
00113   <span class="keyword">public</span>:
00115     BitProxy(csBitArray &amp;array, size_t pos): mArray(array), mPos(pos)
00116     {}
00117 
00119     BitProxy &amp;operator= (<span class="keywordtype">bool</span> value)
00120     {
00121       mArray.Set (mPos, value);
00122       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00123     }
00124 
00126     BitProxy &amp;operator= (<span class="keyword">const</span> BitProxy &amp;that)
00127     {
00128       mArray.Set (mPos, that.mArray.IsBitSet (that.mPos));
00129       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00130     }
00131 
00133     operator bool()<span class="keyword"> const</span>
00134 <span class="keyword">    </span>{
00135       <span class="keywordflow">return</span> mArray.IsBitSet (mPos);
00136     }
00137 
00139     <span class="keywordtype">bool</span> Flip()
00140     {
00141       mArray.FlipBit (mPos);
00142       <span class="keywordflow">return</span> mArray.IsBitSet (mPos);
00143     }
00144   };
00145   <span class="keyword">friend</span> <span class="keyword">class </span>BitProxy;
00146 
<a name="l00150"></a><a class="code" href="classcsBitArray.html#a0">00150</a>   csBitArray () : mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00151   {
00152     SetSize (0);
00153     <span class="comment">// Clear last bits</span>
00154     Trim();
00155   }
00156 
<a name="l00160"></a><a class="code" href="classcsBitArray.html#a1">00160</a>   <span class="keyword">explicit</span> csBitArray(size_t size) :
00161     mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00162   {
00163     SetSize (size);
00164     <span class="comment">// Clear last bits</span>
00165     Trim();
00166   }
00167 
<a name="l00171"></a><a class="code" href="classcsBitArray.html#a2">00171</a>   csBitArray (<span class="keyword">const</span> csBitArray &amp;that) :
00172     mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00173   {
00174     *<span class="keyword">this</span> = that;
00175   }
00176 
<a name="l00178"></a><a class="code" href="classcsBitArray.html#a3">00178</a>   <span class="keyword">virtual</span> ~csBitArray()
00179   {
00180     <span class="keywordflow">if</span> (mLength &gt; 1)
00181       <span class="keyword">delete</span> mpStore;
00182   }
00183 
<a name="l00185"></a><a class="code" href="classcsBitArray.html#a4">00185</a>   size_t Length()<span class="keyword"> const</span>
00186 <span class="keyword">  </span>{
00187     <span class="keywordflow">return</span> mNumBits;
00188   }
00189 
<a name="l00195"></a><a class="code" href="classcsBitArray.html#a5">00195</a>   <span class="keywordtype">void</span> SetLength (size_t newSize)
00196   {
00197     SetSize (newSize);
00198     <span class="comment">// Clear last bits</span>
00199     Trim ();
00200   }
00201 
00202   <span class="comment">//</span>
00203   <span class="comment">// Operators</span>
00204   <span class="comment">//</span>
00205 
<a name="l00207"></a><a class="code" href="classcsBitArray.html#a6">00207</a>   csBitArray &amp;operator=(<span class="keyword">const</span> csBitArray &amp;that)
00208   {
00209     <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;that)
00210     {
00211       SetSize (that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00212       memcpy (mpStore, that.<a class="code" href="classcsBitArray.html#r0">mpStore</a>, mLength * <span class="keyword">sizeof</span>(store_type));
00213     }
00214     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00215   }
00216 
<a name="l00218"></a><a class="code" href="classcsBitArray.html#a7">00218</a>   BitProxy operator[] (size_t pos)
00219   {
00220     CS_ASSERT (pos &lt; mNumBits);
00221     <span class="keywordflow">return</span> BitProxy(*<span class="keyword">this</span>, pos);
00222   }
00223 
<a name="l00225"></a><a class="code" href="classcsBitArray.html#a8">00225</a>   <span class="keyword">const</span> BitProxy operator[] (size_t pos)<span class="keyword"> const</span>
00226 <span class="keyword">  </span>{
00227     CS_ASSERT (pos &lt; mNumBits);
00228     <span class="keywordflow">return</span> BitProxy(CS_CONST_CAST(csBitArray&amp;,*<span class="keyword">this</span>), pos);
00229   }
00230 
<a name="l00232"></a><a class="code" href="classcsBitArray.html#a9">00232</a>   <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> csBitArray &amp;that)<span class="keyword"> const</span>
00233 <span class="keyword">  </span>{
00234     <span class="keywordflow">if</span> (mNumBits != that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>)
00235       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00236 
00237     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; mLength; i++)
00238       <span class="keywordflow">if</span> (mpStore[i] != that.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i])
00239         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00240     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00241   }
00242 
<a name="l00244"></a><a class="code" href="classcsBitArray.html#a10">00244</a>   <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> csBitArray &amp;that)<span class="keyword"> const</span>
00245 <span class="keyword">  </span>{
00246     <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == that);
00247   }
00248 
<a name="l00250"></a><a class="code" href="classcsBitArray.html#a11">00250</a>   csBitArray&amp; operator &amp;= (<span class="keyword">const</span> csBitArray &amp;that)
00251   {
00252     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00253     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00254       mpStore[i] &amp;= that.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i];
00255     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00256   }
00257 
<a name="l00259"></a><a class="code" href="classcsBitArray.html#a12">00259</a>   csBitArray operator |= (<span class="keyword">const</span> csBitArray &amp;that)
00260   {
00261     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00262     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00263       mpStore[i] |= that.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i];
00264     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00265   }
00266 
<a name="l00268"></a><a class="code" href="classcsBitArray.html#a13">00268</a>   csBitArray operator ^= (<span class="keyword">const</span> csBitArray &amp;that)
00269   {
00270     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00271     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00272       mpStore[i] ^= that.<a class="code" href="classcsBitArray.html#r0">mpStore</a>[i];
00273     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00274   }
00275 
<a name="l00277"></a><a class="code" href="classcsBitArray.html#a14">00277</a>   csBitArray operator~()<span class="keyword"> const</span>
00278 <span class="keyword">  </span>{
00279     <span class="keywordflow">return</span> csBitArray(*this).FlipAllBits();
00280   }
00281 
<a name="l00283"></a><a class="code" href="classcsBitArray.html#n1">00283</a>   <span class="keyword">friend</span> csBitArray operator&amp; (<span class="keyword">const</span> csBitArray &amp;a1, <span class="keyword">const</span> csBitArray &amp;a2)
00284   {
00285     <span class="keywordflow">return</span> csBitArray(a1) &amp;= a2;
00286   }
00287 
<a name="l00289"></a><a class="code" href="classcsBitArray.html#n2">00289</a>   <span class="keyword">friend</span> csBitArray operator | (<span class="keyword">const</span> csBitArray &amp;a1, <span class="keyword">const</span> csBitArray &amp;a2)
00290   {
00291     <span class="keywordflow">return</span> csBitArray(a1) |= a2;
00292   }
00293 
<a name="l00295"></a><a class="code" href="classcsBitArray.html#n3">00295</a>   <span class="keyword">friend</span> csBitArray operator ^ (<span class="keyword">const</span> csBitArray &amp;a1, <span class="keyword">const</span> csBitArray &amp;a2)
00296   {
00297     <span class="keywordflow">return</span> csBitArray(a1) ^= a2;
00298   }
00299 
00300   <span class="comment">//</span>
00301   <span class="comment">// Plain English interface</span>
00302   <span class="comment">//</span>
00303 
<a name="l00305"></a><a class="code" href="classcsBitArray.html#a15">00305</a>   <span class="keywordtype">void</span> Clear()
00306   {
00307     memset (mpStore, 0, mLength * <span class="keyword">sizeof</span>(store_type));
00308   }
00309 
<a name="l00311"></a><a class="code" href="classcsBitArray.html#a16">00311</a>   <span class="keywordtype">void</span> SetBit (size_t pos)
00312   {
00313     CS_ASSERT (pos &lt; mNumBits);
00314     mpStore[GetIndex(pos)] |= 1 &lt;&lt; GetOffset(pos);
00315   }
00316 
<a name="l00318"></a><a class="code" href="classcsBitArray.html#a17">00318</a>   <span class="keywordtype">void</span> ClearBit (size_t pos)
00319   {
00320     CS_ASSERT (pos &lt; mNumBits);
00321     mpStore[GetIndex(pos)] &amp;= ~(1 &lt;&lt; GetOffset(pos));
00322   }
00323 
<a name="l00325"></a><a class="code" href="classcsBitArray.html#a18">00325</a>   <span class="keywordtype">void</span> FlipBit (size_t pos)
00326   {
00327     CS_ASSERT (pos &lt; mNumBits);
00328     mpStore[GetIndex(pos)] ^= 1 &lt;&lt; GetOffset(pos);
00329   }
00330 
<a name="l00332"></a><a class="code" href="classcsBitArray.html#a19">00332</a>   <span class="keywordtype">void</span> Set (size_t pos, <span class="keywordtype">bool</span> val)
00333   {
00334     val ? SetBit(pos) : ClearBit(pos);
00335   }
00336 
<a name="l00338"></a><a class="code" href="classcsBitArray.html#a20">00338</a>   <span class="keywordtype">bool</span> IsBitSet (size_t pos)<span class="keyword"> const</span>
00339 <span class="keyword">  </span>{
00340     CS_ASSERT (pos &lt; mNumBits);
00341     <span class="keywordflow">return</span> (mpStore[GetIndex(pos)] &amp; (1 &lt;&lt; GetOffset(pos))) != 0;
00342   }
00343 
<a name="l00348"></a><a class="code" href="classcsBitArray.html#a21">00348</a>   <span class="keywordtype">bool</span> AreSomeBitsSet (size_t pos, size_t count)<span class="keyword"> const</span>
00349 <span class="keyword">  </span>{
00350     CS_ASSERT (pos &lt; mNumBits);
00351     CS_ASSERT ((pos + count) &lt; mNumBits);
00352     
00353     <span class="keywordflow">while</span> (count &gt; 0)
00354     {
00355       size_t index = GetIndex (pos);
00356       size_t offset = GetOffset (pos);
00357       size_t checkCount = MIN(count, cell_size - offset);
00358             
00359       store_type mask = ((1 &lt;&lt; checkCount) - 1) &lt;&lt; offset;
00360       <span class="keywordflow">if</span> (mpStore[index] &amp; mask) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00361       pos += checkCount;
00362       count -= checkCount;
00363     }
00364     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00365   }
00366   
<a name="l00368"></a><a class="code" href="classcsBitArray.html#a22">00368</a>   <span class="keywordtype">bool</span> AllBitsFalse()<span class="keyword"> const</span>
00369 <span class="keyword">  </span>{
00370     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i &lt; mLength; i++)
00371       <span class="keywordflow">if</span> (mpStore[i] != 0)
00372         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00373     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00374   }
00375 
<a name="l00377"></a><a class="code" href="classcsBitArray.html#a23">00377</a>   csBitArray &amp;FlipAllBits()
00378   {
00379     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i &lt; mLength; i++)
00380       mpStore[i] = ~mpStore[i];
00381 
00382     Trim();
00383     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00384   }
00385 
<a name="l00387"></a><a class="code" href="classcsBitArray.html#a24">00387</a>   store_type* GetArrayBits()
00388   {
00389     <span class="keywordflow">return</span> mpStore;
00390   }
00391 
<a name="l00396"></a><a class="code" href="classcsBitArray.html#a25">00396</a>   store_type GetSingleWord()
00397   {
00398     <span class="keywordflow">return</span> mSingleWord;
00399   }
00400 
<a name="l00405"></a><a class="code" href="classcsBitArray.html#a26">00405</a>   <span class="keywordtype">void</span> SetSingleWord (store_type sw)
00406   {
00407     mSingleWord = sw;
00408   }
00409 };
00410 
00411 <span class="preprocessor">#endif // __CS_BITARRAY_H__</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.3 
</small></address> </div></body> </html>
