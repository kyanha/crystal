<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>iMeshWrapper struct Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>iMeshWrapper Struct Reference<br>
<small>
[<a class="el" href="group__engine3d__meshes.html">Mesh support</a>]</small>
</h1>A mesh wrapper is an engine-level object that wraps around an actual mesh object (<a class="el" href="structiMeshObject.html">iMeshObject</a>). 
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="mesh_8h-source.html">mesh.h</a>&gt;</code>
<p>
<p>Inheritance diagram for iMeshWrapper:
<p><center><img src="structiMeshWrapper.png" usemap="#iMeshWrapper_map" border="0" alt=""></center>
<map name="iMeshWrapper_map">
<area href="structiBase.html" alt="iBase" shape="rect" coords="0,0,95,24">
</map>
<a href="structiMeshWrapper-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiObject.html">iObject</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a0">QueryObject</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the <a class="el" href="structiObject.html">iObject</a> for this mesh object.</em> <a href="#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiMeshObject.html">iMeshObject</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a1">GetMeshObject</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the <a class="el" href="structiMeshObject.html">iMeshObject</a>.</em> <a href="#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a2">SetMeshObject</a> (<a class="el" href="structiMeshObject.html">iMeshObject</a> *)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set the <a class="el" href="structiMeshObject.html">iMeshObject</a>.</em> <a href="#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiPortalContainer.html">iPortalContainer</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a3">GetPortalContainer</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>If this mesh is a portal container you can use <a class="el" href="structiMeshWrapper.html#a3">GetPortalContainer()</a> to get the portal container interface.</em> <a href="#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiLightingInfo.html">iLightingInfo</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a4">GetLightingInfo</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the optional lighting information that is implemented by this mesh object.</em> <a href="#a4"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiShadowReceiver.html">iShadowReceiver</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a5">GetShadowReceiver</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the optional shadow receiver that is implemented by this mesh object.</em> <a href="#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiShadowCaster.html">iShadowCaster</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a6">GetShadowCaster</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the optional shadow caster that is implemented by this mesh object.</em> <a href="#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="group__util.html#a8">uint</a>&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a7">GetVisibilityNumber</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Optimization to avoid having to do SCF_QUERY_INTERFACE for <a class="el" href="structiVisibilityObject.html">iVisibilityObject</a>.</em> <a href="#a7"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a8">GetFactory</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the parent factory.</em> <a href="#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a9">SetFactory</a> (<a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> *factory)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set the parent factory (this only sets a pointer).</em> <a href="#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a10">SetLightingUpdate</a> (int flags, int num_lights)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Control how lighting updates should take place.</em> <a href="#a10"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiMovable.html">iMovable</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a11">GetMovable</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the movable instance for this object.</em> <a href="#a11"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a12">PlaceMesh</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This routine will find out in which sectors a mesh object is positioned.</em> <a href="#a12"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a13">HitBeamBBox</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check if this mesh is hit by this object space vector.</em> <a href="#a13"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a14">HitBeamOutline</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check if this object is hit by this object space vector.</em> <a href="#a14"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a15">HitBeamObject</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr, int *polygon_idx=0)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check if this object is hit by this object space vector.</em> <a href="#a15"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a16">HitBeam</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check if this object is hit by this world space vector.</em> <a href="#a16"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a17">SetDrawCallback</a> (<a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a> *cb)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set a callback which is called just before the object is drawn.</em> <a href="#a17"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a18">RemoveDrawCallback</a> (<a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a> *cb)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Remove a draw callback.</em> <a href="#a18"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a19">GetDrawCallbackCount</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the number of draw callbacks.</em> <a href="#a19"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a20">GetDrawCallback</a> (int idx) const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the specified draw callback.</em> <a href="#a20"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a21">SetRenderPriority</a> (long rp)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The renderer will render all objects in a sector based on this number.</em> <a href="#a21"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual long&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a22">GetRenderPriority</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the render priority.</em> <a href="#a22"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a23">SetRenderPriorityRecursive</a> (long rp)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Same as <a class="el" href="structiMeshWrapper.html#a21">SetRenderPriority()</a> but this version will recursively set render priority for the children too.</em> <a href="#a23"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classcsFlags.html">csFlags</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a24">GetFlags</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get flags for this meshwrapper.</em> <a href="#a24"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a25">SetFlagsRecursive</a> (<a class="el" href="group__util.html#a4">uint32</a> mask, <a class="el" href="group__util.html#a4">uint32</a> flags)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set some flags with the given mask for this mesh and all children.</em> <a href="#a25"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a26">SetZBufMode</a> (<a class="el" href="group__gfx3d.html#a75">csZBufMode</a> mode)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set the Z-buf drawing mode to use for this object.</em> <a href="#a26"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="group__gfx3d.html#a75">csZBufMode</a>&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a27">GetZBufMode</a> () const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the Z-buf drawing mode.</em> <a href="#a27"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a28">SetZBufModeRecursive</a> (<a class="el" href="group__gfx3d.html#a75">csZBufMode</a> mode)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Same as <a class="el" href="structiMeshWrapper.html#a26">SetZBufMode()</a> but this will also set the z-buf mode for the children too.</em> <a href="#a28"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a29">HardTransform</a> (const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;t)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Do a hard transform of this object.</em> <a href="#a29"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a30">GetWorldBoundingBox</a> (<a class="el" href="classcsBox3.html">csBox3</a> &amp;cbox)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the bounding box of this object in world space.</em> <a href="#a30"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a31">GetTransformedBoundingBox</a> (const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;trans, <a class="el" href="classcsBox3.html">csBox3</a> &amp;cbox)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the bounding box of this object after applying a transformation to it.</em> <a href="#a31"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual float&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a32">GetScreenBoundingBox</a> (<a class="el" href="structiCamera.html">iCamera</a> *camera, <a class="el" href="classcsBox2.html">csBox2</a> &amp;sbox, <a class="el" href="classcsBox3.html">csBox3</a> &amp;cbox)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get a very inaccurate bounding box of the object in screen space.</em> <a href="#a32"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiMeshList.html">iMeshList</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a33">GetChildren</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get all the children of this mesh object.</em> <a href="#a33"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual iMeshWrapper *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a34">GetParentContainer</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the parent of this mesh.</em> <a href="#a34"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a35">SetParentContainer</a> (iMeshWrapper *)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set the parent of this mesh.</em> <a href="#a35"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a36">GetRadius</a> (<a class="el" href="classcsVector3.html">csVector3</a> &amp;rad, <a class="el" href="classcsVector3.html">csVector3</a> &amp;cent) const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the radius of this mesh and all its children.</em> <a href="#a36"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiLODControl.html">iLODControl</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a37">CreateStaticLOD</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a LOD control for this mesh wrapper.</em> <a href="#a37"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a38">DestroyStaticLOD</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destroy the LOD control for this mesh.</em> <a href="#a38"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structiLODControl.html">iLODControl</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a39">GetStaticLOD</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the LOD control for this mesh.</em> <a href="#a39"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a40">AddMeshToStaticLOD</a> (int lod, iMeshWrapper *mesh)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set a given child mesh at a specific lod level.</em> <a href="#a40"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a41">RemoveMeshFromStaticLOD</a> (iMeshWrapper *mesh)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Remove a child mesh from all lod levels.</em> <a href="#a41"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a42">DrawShadow</a> (<a class="el" href="structiRenderView.html">iRenderView</a> *rview, <a class="el" href="structiLight.html">iLight</a> *light)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Draws the shadow buffer pass.</em> <a href="#a42"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a43">DrawLight</a> (<a class="el" href="structiRenderView.html">iRenderView</a> *rview, <a class="el" href="structiLight.html">iLight</a> *light)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Draws the diffuse light mesh object.</em> <a href="#a43"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a44">CastHardwareShadow</a> (bool castShadow)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Enable/disable hardware based shadows alltogheter.</em> <a href="#a44"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a45">SetDrawAfterShadow</a> (bool drawAfter)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sets so that the meshobject is rendered after all fancy HW-shadow-stuff.</em> <a href="#a45"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="structiMeshWrapper.html#a46">GetDrawAfterShadow</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get if the meshobject is rendered after all fancy HW-shadow-stuff.</em> <a href="#a46"></a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A mesh wrapper is an engine-level object that wraps around an actual mesh object (<a class="el" href="structiMeshObject.html">iMeshObject</a>).
<p>
Every mesh object in the engine is represented by a mesh wrapper, which keeps the pointer to the mesh object, its position, its name, etc. 
<p>
 Think of the mesh wrapper as the hook that holds the mesh object in the engine. An effect of this is that the i???State interfaces (e.g. <a class="el" href="structiSprite3DState.html">iSprite3DState</a>) must be queried from the mesh *objects*, not the wrappers! 
<p>
 Note that a mesh object should never be contained in more than one wrapper. 
<p>
 Main creators of instances implementing this interface: <ul>
<li><a class="el" href="structiEngine.html#a28">iEngine::CreateSectorWallsMesh()</a> <li><a class="el" href="structiEngine.html#a29">iEngine::CreateThingMesh()</a> <li><a class="el" href="structiEngine.html#a72">iEngine::CreateMeshWrapper()</a> <li><a class="el" href="structiEngine.html#a76">iEngine::LoadMeshWrapper()</a> <li><a class="el" href="structiEngine.html#a77">iEngine::CreatePortalContainer()</a> <li><a class="el" href="structiEngine.html#a78">iEngine::CreatePortal()</a> <li><a class="el" href="structiLoader.html#a10">iLoader::LoadMeshObject()</a> </ul>
Main ways to get pointers to this interface: <ul>
<li><a class="el" href="structiEngine.html#a43">iEngine::FindMeshObject()</a> <li><a class="el" href="structiMeshList.html#a1">iMeshList::Get()</a> <li><a class="el" href="structiMeshList.html#a7">iMeshList::FindByName()</a> <li><a class="el" href="structiMeshWrapperIterator.html#a0">iMeshWrapperIterator::Next()</a> <li><a class="el" href="structiLoaderContext.html#a4">iLoaderContext::FindMeshObject()</a> </ul>
Main users of this interface: <ul>
<li><a class="el" href="structiEngine.html">iEngine</a> </ul>

<p>

<p>
Definition at line <a class="el" href="mesh_8h-source.html#l00191">191</a> of file <a class="el" href="mesh_8h-source.html">mesh.h</a>.<hr><h2>Member Function Documentation</h2>
<a name="a40" doxytag="iMeshWrapper::AddMeshToStaticLOD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::AddMeshToStaticLOD </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>lod</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iMeshWrapper *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mesh</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a given child mesh at a specific lod level.
<p>
Note that a mesh can be at several lod levels at once.     </td>
  </tr>
</table>
<a name="a44" doxytag="iMeshWrapper::CastHardwareShadow"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::CastHardwareShadow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>castShadow</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable/disable hardware based shadows alltogheter.
<p>
    </td>
  </tr>
</table>
<a name="a37" doxytag="iMeshWrapper::CreateStaticLOD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiLODControl.html">iLODControl</a>* iMeshWrapper::CreateStaticLOD </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a LOD control for this mesh wrapper.
<p>
This is relevant only if the mesh is a hierarchical mesh. The LOD control will be used to select which children are visible and which are not. Use this to create static lod.     </td>
  </tr>
</table>
<a name="a38" doxytag="iMeshWrapper::DestroyStaticLOD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::DestroyStaticLOD </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy the LOD control for this mesh.
<p>
After this call the hierarchical mesh will act as usual.     </td>
  </tr>
</table>
<a name="a43" doxytag="iMeshWrapper::DrawLight"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::DrawLight </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRenderView.html">iRenderView</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rview</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structiLight.html">iLight</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>light</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws the diffuse light mesh object.
<p>
    </td>
  </tr>
</table>
<a name="a42" doxytag="iMeshWrapper::DrawShadow"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::DrawShadow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRenderView.html">iRenderView</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rview</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structiLight.html">iLight</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>light</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws the shadow buffer pass.
<p>
This sets of the stencil for the lights     </td>
  </tr>
</table>
<a name="a33" doxytag="iMeshWrapper::GetChildren"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiMeshList.html">iMeshList</a>* iMeshWrapper::GetChildren </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get all the children of this mesh object.
<p>
This is used for hierarchical meshes. If you want to make a hierarchical mesh you can call GetChildren ()-&gt;Add (mesh).     </td>
  </tr>
</table>
<a name="a46" doxytag="iMeshWrapper::GetDrawAfterShadow"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool iMeshWrapper::GetDrawAfterShadow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get if the meshobject is rendered after all fancy HW-shadow-stuff.
<p>
    </td>
  </tr>
</table>
<a name="a20" doxytag="iMeshWrapper::GetDrawCallback"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a>* iMeshWrapper::GetDrawCallback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>idx</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the specified draw callback.
<p>
    </td>
  </tr>
</table>
<a name="a19" doxytag="iMeshWrapper::GetDrawCallbackCount"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int iMeshWrapper::GetDrawCallbackCount </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the number of draw callbacks.
<p>
    </td>
  </tr>
</table>
<a name="a8" doxytag="iMeshWrapper::GetFactory"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a>* iMeshWrapper::GetFactory </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the parent factory.
<p>
    </td>
  </tr>
</table>
<a name="a24" doxytag="iMeshWrapper::GetFlags"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classcsFlags.html">csFlags</a>&amp; iMeshWrapper::GetFlags </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get flags for this meshwrapper.
<p>
The following flags are supported: <ul>
<li>CS_ENTITY_CONVEX: entity is convex. This can help the engine with optimizing rendering. Currently not used. <li><a class="el" href="group__engine3d__meshes.html#a0">CS_ENTITY_DETAIL</a>: this is a detail object. Again this is a hint for the engine to render this object differently. Currently not used. <li><a class="el" href="group__engine3d__meshes.html#a1">CS_ENTITY_CAMERA</a>: entity will always be centered around the camera. <li><a class="el" href="group__engine3d__meshes.html#a2">CS_ENTITY_INVISIBLEMESH</a>: entity is not rendered.  <li><a class="el" href="group__engine3d__meshes.html#a6">CS_ENTITY_NOHITBEAM</a>: this entity will not be considered by <a class="el" href="structiMeshWrapper.html#a16">HitBeam()</a>  calls. <li><a class="el" href="group__engine3d__meshes.html#a3">CS_ENTITY_INVISIBLE</a>: means that either CS_ENTITY_INVISIBLEMESH and  CS_ENTITY_NOHITBEAM are set. <li><a class="el" href="group__engine3d__meshes.html#a4">CS_ENTITY_NOSHADOWS</a>: cast no shadows. <li><a class="el" href="group__engine3d__meshes.html#a5">CS_ENTITY_NOLIGHTING</a>: do not light this object. </ul>
    </td>
  </tr>
</table>
<a name="a4" doxytag="iMeshWrapper::GetLightingInfo"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiLightingInfo.html">iLightingInfo</a>* iMeshWrapper::GetLightingInfo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the optional lighting information that is implemented by this mesh object.
<p>
If the mesh object doesn't implement it then this will return 0. This is similar (but more efficient) to calling SCF_QUERY_INTERFACE on the mesh object for <a class="el" href="structiLightingInfo.html">iLightingInfo</a>.     </td>
  </tr>
</table>
<a name="a1" doxytag="iMeshWrapper::GetMeshObject"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiMeshObject.html">iMeshObject</a>* iMeshWrapper::GetMeshObject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the <a class="el" href="structiMeshObject.html">iMeshObject</a>.
<p>
    </td>
  </tr>
</table>
<a name="a11" doxytag="iMeshWrapper::GetMovable"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiMovable.html">iMovable</a>* iMeshWrapper::GetMovable </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the movable instance for this object.
<p>
It is very important to call <a class="el" href="structiMeshWrapper.html#a11">GetMovable()</a>-&gt;UpdateMove() after doing any kind of modification to this movable to make sure that internal data structures are correctly updated.     </td>
  </tr>
</table>
<a name="a34" doxytag="iMeshWrapper::GetParentContainer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual iMeshWrapper* iMeshWrapper::GetParentContainer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the parent of this mesh.
<p>
Returns 0 if the mesh has no parent (i.e. it is contained in the engine directly). If not 0 then this mesh is part of a hierarchical mesh.     </td>
  </tr>
</table>
<a name="a3" doxytag="iMeshWrapper::GetPortalContainer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiPortalContainer.html">iPortalContainer</a>* iMeshWrapper::GetPortalContainer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If this mesh is a portal container you can use <a class="el" href="structiMeshWrapper.html#a3">GetPortalContainer()</a> to get the portal container interface.
<p>
    </td>
  </tr>
</table>
<a name="a36" doxytag="iMeshWrapper::GetRadius"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::GetRadius </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cent</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the radius of this mesh and all its children.
<p>
    </td>
  </tr>
</table>
<a name="a22" doxytag="iMeshWrapper::GetRenderPriority"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual long iMeshWrapper::GetRenderPriority </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the render priority.
<p>
    </td>
  </tr>
</table>
<a name="a32" doxytag="iMeshWrapper::GetScreenBoundingBox"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual float iMeshWrapper::GetScreenBoundingBox </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiCamera.html">iCamera</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>camera</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsBox2.html">csBox2</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sbox</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsBox3.html">csBox3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cbox</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a very inaccurate bounding box of the object in screen space.
<p>
Returns -1 if object behind the camera or else the distance between the camera and the furthest point of the 3D box.     </td>
  </tr>
</table>
<a name="a6" doxytag="iMeshWrapper::GetShadowCaster"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiShadowCaster.html">iShadowCaster</a>* iMeshWrapper::GetShadowCaster </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the optional shadow caster that is implemented by this mesh object.
<p>
If the mesh object doesn't implement it then this will return 0. This is similar (but more efficient) to calling SCF_QUERY_INTERFACE on the mesh object for <a class="el" href="structiShadowCaster.html">iShadowCaster</a>. 
<p>
 Note! If the mesh is a static lod mesh (i.e. a parent of a mesh hierarchy that is used for static lod) then this will return a shadow caster that gets shadows from the highest detail objects.     </td>
  </tr>
</table>
<a name="a5" doxytag="iMeshWrapper::GetShadowReceiver"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiShadowReceiver.html">iShadowReceiver</a>* iMeshWrapper::GetShadowReceiver </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the optional shadow receiver that is implemented by this mesh object.
<p>
If the mesh object doesn't implement it then this will return 0. This is similar (but more efficient) to calling SCF_QUERY_INTERFACE on the mesh object for <a class="el" href="structiShadowReceiver.html">iShadowReceiver</a>. 
<p>
 Note! If the mesh is a static lod mesh (i.e. a parent of a mesh hierarchy that is used for static lod) then this will return a shadow receiver that automatically multiplexes the receiving shadows to all child meshes.     </td>
  </tr>
</table>
<a name="a39" doxytag="iMeshWrapper::GetStaticLOD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiLODControl.html">iLODControl</a>* iMeshWrapper::GetStaticLOD </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the LOD control for this mesh.
<p>
This will return 0 if this is a normal (hierarchical) mesh. Otherwise it will return an object with which you can control the static LOD of this object.     </td>
  </tr>
</table>
<a name="a31" doxytag="iMeshWrapper::GetTransformedBoundingBox"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::GetTransformedBoundingBox </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>trans</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsBox3.html">csBox3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cbox</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the bounding box of this object after applying a transformation to it.
<p>
This is really a very inaccurate function as it will take the bounding box of the object in object space and then transform this bounding box.     </td>
  </tr>
</table>
<a name="a7" doxytag="iMeshWrapper::GetVisibilityNumber"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="group__util.html#a8">uint</a> iMeshWrapper::GetVisibilityNumber </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimization to avoid having to do SCF_QUERY_INTERFACE for <a class="el" href="structiVisibilityObject.html">iVisibilityObject</a>.
<p>
    </td>
  </tr>
</table>
<a name="a30" doxytag="iMeshWrapper::GetWorldBoundingBox"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::GetWorldBoundingBox </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsBox3.html">csBox3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>cbox</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the bounding box of this object in world space.
<p>
This routine will cache the bounding box and only recalculate it if the movable changes.     </td>
  </tr>
</table>
<a name="a27" doxytag="iMeshWrapper::GetZBufMode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="group__gfx3d.html#a75">csZBufMode</a> iMeshWrapper::GetZBufMode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the Z-buf drawing mode.
<p>
    </td>
  </tr>
</table>
<a name="a29" doxytag="iMeshWrapper::HardTransform"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::HardTransform </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>t</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do a hard transform of this object.
<p>
This transformation and the original coordinates are not remembered but the object space coordinates are directly computed (world space coordinates are set to the object space coordinates by this routine). Note that some implementations of mesh objects will not change the orientation of the object but only the position. 
<p>
 Note also that some mesh objects don't support HardTransform. You can find out by calling <a class="el" href="structiMeshObject.html">iMeshObject</a>-&gt;SupportsHardTransform(). In that case you can sometimes still call <a class="el" href="structiMeshWrapper.html#a29">HardTransform()</a> on the factory.     </td>
  </tr>
</table>
<a name="a16" doxytag="iMeshWrapper::HitBeam"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool iMeshWrapper::HitBeam </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>start</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>end</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>isect</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if this object is hit by this world space vector.
<p>
Return the collision point in world space coordinates.     </td>
  </tr>
</table>
<a name="a13" doxytag="iMeshWrapper::HitBeamBBox"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int iMeshWrapper::HitBeamBBox </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>start</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>end</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>isect</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if this mesh is hit by this object space vector.
<p>
This will do a rough but fast test based on bounding box only. So this means that it might return a hit even though the object isn't really hit at all. Depends on how much the bounding box overestimates the object. This also returns the face number as defined in <a class="el" href="classcsBox3.html">csBox3</a> on which face the hit occured. Useful for grid structures.     </td>
  </tr>
</table>
<a name="a15" doxytag="iMeshWrapper::HitBeamObject"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool iMeshWrapper::HitBeamObject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>start</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>end</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>isect</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>polygon_idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if this object is hit by this object space vector.
<p>
Return the collision point in object space coordinates. This version is more accurate than HitBeamOutline.     </td>
  </tr>
</table>
<a name="a14" doxytag="iMeshWrapper::HitBeamOutline"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool iMeshWrapper::HitBeamOutline </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>start</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>end</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>isect</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if this object is hit by this object space vector.
<p>
Outline check.     </td>
  </tr>
</table>
<a name="a12" doxytag="iMeshWrapper::PlaceMesh"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::PlaceMesh </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine will find out in which sectors a mesh object is positioned.
<p>
To use it the mesh has to be placed in one starting sector. This routine will then start from that sector, find all portals that touch the sprite and add all additional sectors from those portals. Note that this routine using a bounding sphere for this test so it is possible that the mesh will be added to sectors where it really isn't located (but the sphere is). 
<p>
 If the mesh is already in several sectors those additional sectors will be ignored and only the first one will be used for this routine. 
<p>
 Placing a mesh in different sectors is important when the mesh crosses a portal boundary. If you don't do this then it is possible that the mesh will be clipped wrong. For small mesh objects you can get away by not doing this in most cases.     </td>
  </tr>
</table>
<a name="a0" doxytag="iMeshWrapper::QueryObject"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structiObject.html">iObject</a>* iMeshWrapper::QueryObject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the <a class="el" href="structiObject.html">iObject</a> for this mesh object.
<p>
This can be used to get the name of the mesh wrapper and also to attach other user objects to this mesh (like for collision detection or game data).     </td>
  </tr>
</table>
<a name="a18" doxytag="iMeshWrapper::RemoveDrawCallback"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::RemoveDrawCallback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>cb</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a draw callback.
<p>
    </td>
  </tr>
</table>
<a name="a41" doxytag="iMeshWrapper::RemoveMeshFromStaticLOD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::RemoveMeshFromStaticLOD </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">iMeshWrapper *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>mesh</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a child mesh from all lod levels.
<p>
The mesh is not removed from the list of child meshes however.     </td>
  </tr>
</table>
<a name="a45" doxytag="iMeshWrapper::SetDrawAfterShadow"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetDrawAfterShadow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>drawAfter</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets so that the meshobject is rendered after all fancy HW-shadow-stuff.
<p>
    </td>
  </tr>
</table>
<a name="a17" doxytag="iMeshWrapper::SetDrawCallback"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetDrawCallback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>cb</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a callback which is called just before the object is drawn.
<p>
This is useful to do some expensive computations which only need to be done on a visible object. Note that this function will be called even if the object is not visible. In general it is called if there is a likely probability that the object is visible (i.e. it is in the same sector as the camera for example).     </td>
  </tr>
</table>
<a name="a9" doxytag="iMeshWrapper::SetFactory"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetFactory </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>factory</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the parent factory (this only sets a pointer).
<p>
    </td>
  </tr>
</table>
<a name="a25" doxytag="iMeshWrapper::SetFlagsRecursive"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetFlagsRecursive </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__util.html#a4">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__util.html#a4">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set some flags with the given mask for this mesh and all children.
<p>
    </td>
  </tr>
</table>
<a name="a10" doxytag="iMeshWrapper::SetLightingUpdate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetLightingUpdate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>num_lights</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Control how lighting updates should take place.
<p>
'num_lights' is the number of lights that will be given to the mesh object at maximum (default is 8). 'flags' can be a combination of one of the following: <ul>
<li><a class="el" href="group__engine3d__meshes.html#a7">CS_LIGHTINGUPDATE_SORTRELEVANCE</a> (default on). <li><a class="el" href="group__engine3d__meshes.html#a8">CS_LIGHTINGUPDATE_ALWAYSUPDATE</a> (default off). </ul>
Note that this function has no effect on thing mesh objects as they use another lighting system (lightmaps). Also some genmesh objects can optionally also use the other lighting system in which nothing will happen either.     </td>
  </tr>
</table>
<a name="a2" doxytag="iMeshWrapper::SetMeshObject"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetMeshObject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshObject.html">iMeshObject</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the <a class="el" href="structiMeshObject.html">iMeshObject</a>.
<p>
    </td>
  </tr>
</table>
<a name="a35" doxytag="iMeshWrapper::SetParentContainer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetParentContainer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">iMeshWrapper *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the parent of this mesh.
<p>
This only changes the 'parent' pointer but does not add the mesh as a child mesh. Internal use only.     </td>
  </tr>
</table>
<a name="a21" doxytag="iMeshWrapper::SetRenderPriority"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetRenderPriority </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rp</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The renderer will render all objects in a sector based on this number.
<p>
Low numbers get rendered first. High numbers get rendered later. There are a few often used slots: <ul>
<li>1. Sky objects are rendered before everything else. Usually they are rendered using ZFILL (or ZNONE). <li>2. Walls are rendered after that. They usually use ZFILL. <li>3. After that normal objects are rendered using the Z-buffer (ZUSE). <li>4. Alpha transparent objects or objects using some other transparency system are rendered after that. They are usually rendered using ZTEST. </ul>
    </td>
  </tr>
</table>
<a name="a23" doxytag="iMeshWrapper::SetRenderPriorityRecursive"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetRenderPriorityRecursive </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rp</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="structiMeshWrapper.html#a21">SetRenderPriority()</a> but this version will recursively set render priority for the children too.
<p>
    </td>
  </tr>
</table>
<a name="a26" doxytag="iMeshWrapper::SetZBufMode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetZBufMode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gfx3d.html#a75">csZBufMode</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>mode</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the Z-buf drawing mode to use for this object.
<p>
Possible values are: <ul>
<li><a class="el" href="group__gfx3d.html#a75a53">CS_ZBUF_NONE</a>: do not read nor write the Z-buffer. <li><a class="el" href="group__gfx3d.html#a75a54">CS_ZBUF_FILL</a>: only write the Z-buffer but do not read. <li><a class="el" href="group__gfx3d.html#a75a56">CS_ZBUF_USE</a>: write and read the Z-buffer. <li><a class="el" href="group__gfx3d.html#a75a55">CS_ZBUF_TEST</a>: only read the Z-buffer but do not write. </ul>
    </td>
  </tr>
</table>
<a name="a28" doxytag="iMeshWrapper::SetZBufModeRecursive"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iMeshWrapper::SetZBufModeRecursive </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gfx3d.html#a75">csZBufMode</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>mode</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="structiMeshWrapper.html#a26">SetZBufMode()</a> but this will also set the z-buf mode for the children too.
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>iengine/<a class="el" href="mesh_8h-source.html">mesh.h</a></ul>
<hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
