<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: iEngine Struct Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>iEngine Struct Reference</h1><!-- doxytag: class="iEngine" --><!-- doxytag: inherits="iBase" -->This interface is the main interface to the 3D engine.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="engine_8h-source.html">iengine/engine.h</a>&gt;</code>
<p>
<p>Inheritance diagram for iEngine:
<p><center><img src="structiEngine.png" usemap="#iEngine_map" border="0" alt=""></center>
<map name="iEngine_map">
<area href="structiBase.html" alt="iBase" shape="rect" coords="0,0,54,24">
</map>
<a href="structiEngine-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiObject.html">iObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#a0">QueryObject</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="structiObject.html">iObject</a> for the engine.  <a href="#a0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Sector handling</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z549_0">AddEngineSectorCallback</a> (<a class="el" href="structiEngineSectorCallback.html">iEngineSectorCallback</a> *cb)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sector callback.  <a href="#z549_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiSector.html">iSector</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z549_1">CreateSector</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a empty sector with given name.  <a href="#z549_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiSector.html">iSector</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z549_2">FindSector</a> (const char *name, <a class="el" href="structiRegion.html">iRegion</a> *region=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the given sector.  <a href="#z549_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiSectorIterator.html">iSectorIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z549_3">GetNearbySectors</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos, float radius)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine returns an iterator to iterate over all nearby sectors.  <a href="#z549_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiSectorList.html">iSectorList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z549_4">GetSectors</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of sectors.  <a href="#z549_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z549_5">RemoveEngineSectorCallback</a> (<a class="el" href="structiEngineSectorCallback.html">iEngineSectorCallback</a> *cb)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a sector callback.  <a href="#z549_5"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh handling</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_0">AddMeshAndChildren</a> (<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *mesh)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to add a mesh and all children of that mesh to the engine.  <a href="#z550_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_1">CreateMeshWrapper</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an uninitialized mesh wrapper Assign to a <a class="el" href="classcsRef.html">csRef</a>.  <a href="#z550_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_2">CreateMeshWrapper</a> (const char *classid, const char *name, <a class="el" href="structiSector.html">iSector</a> *sector=0, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos=<a class="el" href="classcsVector3.html">csVector3</a>(0, 0, 0))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a mesh wrapper from a class id.  <a href="#z550_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_3">CreateMeshWrapper</a> (<a class="el" href="structiMeshObject.html">iMeshObject</a> *meshobj, const char *name, <a class="el" href="structiSector.html">iSector</a> *sector=0, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos=<a class="el" href="classcsVector3.html">csVector3</a>(0, 0, 0))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a mesh wrapper for an existing mesh object.  <a href="#z550_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_4">CreateMeshWrapper</a> (<a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> *factory, const char *name, <a class="el" href="structiSector.html">iSector</a> *sector=0, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos=<a class="el" href="classcsVector3.html">csVector3</a>(0, 0, 0))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to create a mesh object for a given factory.  <a href="#z550_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_5">CreateSectorWallsMesh</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to create the thing containing the convex outline of a sector.  <a href="#z550_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_6">CreateThingMesh</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to create a thing mesh in a sector.  <a href="#z550_6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_7">FindMeshObject</a> (const char *name, <a class="el" href="structiRegion.html">iRegion</a> *region=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the given mesh object.  <a href="#z550_7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshList.html">iMeshList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_8">GetMeshes</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of meshes.  <a href="#z550_8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapperIterator.html">iMeshWrapperIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_9">GetNearbyMeshes</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsBox3.html">csBox3</a> &amp;box, bool crossPortals=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine returns an iterator to iterate over all meshes that are in a box.  <a href="#z550_9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapperIterator.html">iMeshWrapperIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_10">GetNearbyMeshes</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos, float radius, bool crossPortals=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine returns an iterator to iterate over all meshes that are within a radius of a given position.  <a href="#z550_10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_11">LoadMeshWrapper</a> (const char *name, const char *loaderClassId, <a class="el" href="structiDataBuffer.html">iDataBuffer</a> *input, <a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to load a mesh object from a given loader plugin.  <a href="#z550_11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z550_12">WantToDie</a> (<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *mesh)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sometimes a mesh wants to destruct itself (for example a particle system that has only limited lifetime).  <a href="#z550_12"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Render priority functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_0">ClearRenderPriorities</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all render priorities.  <a href="#z545_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_1">GetAlphaRenderPriority</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the render priority for alpha objects (attached to 'alpha' name).  <a href="#z545_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_2">GetObjectRenderPriority</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the render priority for general objects (attached to 'object' name).  <a href="#z545_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_3">GetPortalRenderPriority</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the render priority for portal objects (attached to 'portal' name).  <a href="#z545_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_4">GetRenderPriority</a> (const char *name) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a render priority by name.  <a href="#z545_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_5">GetRenderPriorityCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of render priorities.  <a href="#z545_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_6">GetRenderPriorityName</a> (long priority) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of the render priority or 0 if none existant.  <a href="#z545_6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="engine_8h.html#a6">csRenderPrioritySorting</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_7">GetRenderPrioritySorting</a> (long priority) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the render priority sorting flag.  <a href="#z545_7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="engine_8h.html#a6">csRenderPrioritySorting</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_8">GetRenderPrioritySorting</a> (const char *name) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the render priority sorting flag.  <a href="#z545_8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_9">GetSkyRenderPriority</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the render priority for sky objects (attached to 'sky' name).  <a href="#z545_9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_10">GetWallRenderPriority</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the render priority for wall objects (attached to 'wall' name).  <a href="#z545_10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z545_11">RegisterRenderPriority</a> (const char *name, long priority, <a class="el" href="engine_8h.html#a6">csRenderPrioritySorting</a> rendsort=CS_RENDPRI_SORT_NONE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a new render priority.  <a href="#z545_11"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Material handling</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMaterial.html">iMaterial</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z546_0">CreateBaseMaterial</a> (<a class="el" href="structiTextureWrapper.html">iTextureWrapper</a> *txt)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a base material that can be used to give to the texture manager.  <a href="#z546_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMaterialWrapper.html">iMaterialWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z546_1">CreateMaterial</a> (const char *name, <a class="el" href="structiTextureWrapper.html">iTextureWrapper</a> *texture)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a material to be loaded during <a class="el" href="structiEngine.html#z544_7">Prepare()</a>.  <a href="#z546_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMaterialWrapper.html">iMaterialWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z546_2">FindMaterial</a> (const char *name, <a class="el" href="structiRegion.html">iRegion</a> *region=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the given material.  <a href="#z546_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMaterialList.html">iMaterialList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z546_3">GetMaterialList</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of all materials.  <a href="#z546_3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Texture handling</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiTextureWrapper.html">iTextureWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z547_0">CreateBlackTexture</a> (const char *name, int w, int h, <a class="el" href="classcsColor.html">csColor</a> *transp, int flags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a black texture.  <a href="#z547_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiTextureWrapper.html">iTextureWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z547_1">CreateTexture</a> (const char *name, const char *fileName, <a class="el" href="classcsColor.html">csColor</a> *transp, int flags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a texture from a file.  <a href="#z547_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiTextureWrapper.html">iTextureWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z547_2">FindTexture</a> (const char *name, <a class="el" href="structiRegion.html">iRegion</a> *region=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the given texture.  <a href="#z547_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z547_3">GetTextureFormat</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the format to load textures (usually this depends on texture manager).  <a href="#z547_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiTextureList.html">iTextureList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z547_4">GetTextureList</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of all textures.  <a href="#z547_4"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Camera handling</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiCamera.html">iCamera</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z553_0">CreateCamera</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new camera.  <a href="#z553_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiCameraPosition.html">iCameraPosition</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z553_1">FindCameraPosition</a> (const char *name, <a class="el" href="structiRegion.html">iRegion</a> *region=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the given camera position.  <a href="#z553_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiCameraPositionList.html">iCameraPositionList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z553_2">GetCameraPositions</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of camera positions.  <a href="#z553_2"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Other</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiFrustumView.html">iFrustumView</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_0">CreateFrustumView</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="structiFrustumView.html">iFrustumView</a> instance that you can give to iVisibilityCuller-&gt;CastShadows().  <a href="#z557_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiObjectWatcher.html">iObjectWatcher</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_1">CreateObjectWatcher</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an object watcher instance that you can use to watch other objects.  <a href="#z557_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_2">DeleteAll</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete everything in the engine.  <a href="#z557_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiCollection.html">iCollection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_3">FindCollection</a> (const char *name, <a class="el" href="structiRegion.html">iRegion</a> *region=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the given collection.  <a href="#z557_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiCollectionList.html">iCollectionList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_4">GetCollections</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of collections.  <a href="#z557_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiObjectIterator.html">iObjectIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_5">GetNearbyObjects</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos, float radius, bool crossPortals=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine returns an iterator to iterate over all objects that are within a radius of a given position.  <a href="#z557_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiSharedVariableList.html">iSharedVariableList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_6">GetVariableList</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of all shared variables.  <a href="#z557_6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapperIterator.html">iMeshWrapperIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_7">GetVisibleMeshes</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsFrustum.html">csFrustum</a> &amp;frustum)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine returns an iterator to iterate over all meshes that are potentially visible as seen from a given position.  <a href="#z557_7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapperIterator.html">iMeshWrapperIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_8">GetVisibleMeshes</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine returns an iterator to iterate over all meshes that are potentially visible as seen from a given position.  <a href="#z557_8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiObjectIterator.html">iObjectIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_9">GetVisibleObjects</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsFrustum.html">csFrustum</a> &amp;frustum)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine returns an iterator to iterate over all objects that are potentially visible as seen from a given position.  <a href="#z557_9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiObjectIterator.html">iObjectIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_10">GetVisibleObjects</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine returns an iterator to iterate over all objects that are potentially visible as seen from a given position.  <a href="#z557_10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_11">RemoveObject</a> (<a class="el" href="structiBase.html">iBase</a> *object)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to 'remove' a CS object from the engine.  <a href="#z557_11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z557_12">ResetWorldSpecificSettings</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset a subset of flags/settings (which may differ from one world/map to another) to its defaults.  <a href="#z557_12"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Light handling</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiLight.html">iLight</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z548_0">CreateLight</a> (const char *name, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos, float radius, const <a class="el" href="classcsColor.html">csColor</a> &amp;color, <a class="el" href="light_8h.html#a15">csLightDynamicType</a> dyntype=CS_LIGHT_DYNAMICTYPE_STATIC)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a static/pseudo-dynamic light.  <a href="#z548_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiLight.html">iLight</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z548_1">FindLight</a> (const char *Name, bool RegionOnly=false) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a static/pseudo-dynamic light by name.  <a href="#z548_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiLight.html">iLight</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z548_2">FindLightID</a> (const char *light_id) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a static/pseudo-dynamic light by id.  <a href="#z548_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z548_3">GetAmbientLight</a> (<a class="el" href="classcsColor.html">csColor</a> &amp;) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the amount of ambient light.  <a href="#z548_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z548_4">GetDefaultAmbientLight</a> (<a class="el" href="classcsColor.html">csColor</a> &amp;c) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the default amount of ambient light.  <a href="#z548_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiLightIterator.html">iLightIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z548_5">GetLightIterator</a> (<a class="el" href="structiRegion.html">iRegion</a> *region=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an iterator to iterate over all static lights of the engine.  <a href="#z548_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z548_6">GetNearbyLights</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsBox3.html">csBox3</a> &amp;box, <a class="el" href="structiLight.html">iLight</a> **lights, int max_num_lights)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine returns all lights which might affect an object with some bounding box.  <a href="#z548_6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z548_7">GetNearbyLights</a> (<a class="el" href="structiSector.html">iSector</a> *sector, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos, <a class="el" href="structiLight.html">iLight</a> **lights, int max_num_lights)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine returns all lights which might affect an object at some position.  <a href="#z548_7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z548_8">RemoveLight</a> (<a class="el" href="structiLight.html">iLight</a> *light)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a light and update all lightmaps.  <a href="#z548_8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z548_9">SetAmbientLight</a> (const <a class="el" href="classcsColor.html">csColor</a> &amp;)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the amount of ambient light.  <a href="#z548_9"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Saving/loading</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiLoaderContext.html">iLoaderContext</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z556_0">CreateLoaderContext</a> (<a class="el" href="structiRegion.html">iRegion</a> *region=0, bool curRegOnly=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a loader context that you can give to loader plugins.  <a href="#z556_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z556_1">GetSaveableFlag</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get whether saving should be possible (default OFF).  <a href="#z556_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z556_2">SetSaveableFlag</a> (bool enable)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether saving should be possible (default OFF).  <a href="#z556_2"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh factory handling</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z551_0">CreateMeshFactory</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an uninitialized mesh factory wrapper Assign to a <a class="el" href="classcsRef.html">csRef</a>.  <a href="#z551_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z551_1">CreateMeshFactory</a> (<a class="el" href="structiMeshObjectFactory.html">iMeshObjectFactory</a> *factory, const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a mesh factory wrapper for an existing mesh factory Assign to a <a class="el" href="classcsRef.html">csRef</a>.  <a href="#z551_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z551_2">CreateMeshFactory</a> (const char *classId, const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to create a mesh factory from a given type.  <a href="#z551_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z551_3">FindMeshFactory</a> (const char *name, <a class="el" href="structiRegion.html">iRegion</a> *region=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the given mesh factory.  <a href="#z551_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshFactoryList.html">iMeshFactoryList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z551_4">GetMeshFactories</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of mesh factories.  <a href="#z551_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z551_5">LoadMeshFactory</a> (const char *name, const char *loaderClassId, <a class="el" href="structiDataBuffer.html">iDataBuffer</a> *input)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to load a mesh factory from a given loader plugin.  <a href="#z551_5"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Portal handling</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z554_0">CreatePortal</a> (const char *name, <a class="el" href="structiSector.html">iSector</a> *sourceSector, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos, <a class="el" href="structiSector.html">iSector</a> *destSector, <a class="el" href="classcsVector3.html">csVector3</a> *vertices, int num_vertices, <a class="el" href="structiPortal.html">iPortal</a> *&amp;portal)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to create a portal from one sector to another.  <a href="#z554_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z554_1">CreatePortal</a> (const char *name, <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *parentMesh, <a class="el" href="structiSector.html">iSector</a> *destSector, <a class="el" href="classcsVector3.html">csVector3</a> *vertices, int num_vertices, <a class="el" href="structiPortal.html">iPortal</a> *&amp;portal)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to create a portal from one sector to another and make this portal a child mesh of another mesh.  <a href="#z554_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z554_2">CreatePortalContainer</a> (const char *name, <a class="el" href="structiSector.html">iSector</a> *sector=0, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos=<a class="el" href="classcsVector3.html">csVector3</a>(0, 0, 0))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty portal container in some sector.  <a href="#z554_2"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Region handling</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z552_0">CreateRegion</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new region and add it to the region list.  <a href="#z552_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiRegionList.html">iRegionList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z552_1">GetRegions</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of all regions.  <a href="#z552_1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Drawing related</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_0">Draw</a> (<a class="el" href="structiCamera.html">iCamera</a> *c, <a class="el" href="structiClipper2D.html">iClipper2D</a> *clipper)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw the 3D world given a camera and a clipper.  <a href="#z555_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_1">GetBeginDrawFlags</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the required flags for 3D-&gt;BeginDraw() which should be called from the application.  <a href="#z555_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_2">GetClearScreen</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of the clear screen flag set with <a class="el" href="structiEngine.html#z555_12">SetClearScreen()</a>.  <a href="#z555_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_3">GetClearZBuf</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of the clear Z-buffer flag set with <a class="el" href="structiEngine.html#z555_13">SetClearZBuf()</a>.  <a href="#z555_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiTextureHandle.html">iTextureHandle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_4">GetContext</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current drawing context.  <a href="#z555_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiRenderLoop.html">iRenderLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_5">GetCurrentDefaultRenderloop</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current render loop.  <a href="#z555_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="cstypes_8h.html#a27">uint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_6">GetCurrentFrameNumber</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current framenumber.  <a href="#z555_6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_7">GetDefaultClearScreen</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get default clear screen flag.  <a href="#z555_7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_8">GetDefaultClearZBuf</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get default clear z-buffer flag.  <a href="#z555_8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiRenderLoopManager.html">iRenderLoopManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_9">GetRenderLoopManager</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the render loop manager.  <a href="#z555_9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiRenderView.html">iRenderView</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_10">GetTopLevelClipper</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the top-level clipper.  <a href="#z555_10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_11">PrecacheDraw</a> (<a class="el" href="structiRegion.html">iRegion</a> *region=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function precaches all meshes by calling GetRenderMeshes() on them.  <a href="#z555_11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_12">SetClearScreen</a> (bool yesno)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Require that the screen is cleared every frame.  <a href="#z555_12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_13">SetClearZBuf</a> (bool yesno)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Require that the Z-buffer is cleared every frame.  <a href="#z555_13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_14">SetContext</a> (<a class="el" href="structiTextureHandle.html">iTextureHandle</a> *ctxt)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the drawing context.  <a href="#z555_14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z555_15">SetCurrentDefaultRenderloop</a> (<a class="el" href="structiRenderLoop.html">iRenderLoop</a> *loop)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the current render loop.  <a href="#z555_15"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Preparation and relighting methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_0">ForceRelight</a> (<a class="el" href="structiLight.html">iLight</a> *light, <a class="el" href="structiRegion.html">iRegion</a> *region=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force a relight for the given light.  <a href="#z544_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_1">ForceRelight</a> (<a class="el" href="structiRegion.html">iRegion</a> *region=0, <a class="el" href="structiProgressMeter.html">iProgressMeter</a> *meter=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force a relight of all lighting.  <a href="#z544_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiCacheManager.html">iCacheManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_2">GetCacheManager</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the cache manager that the engine is currently using.  <a href="#z544_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_3">GetDefaultMaxLightmapSize</a> (int &amp;w, int &amp;h)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve default maximum lightmap size.  <a href="#z544_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_4">GetLightingCacheMode</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mode for the lighting cache.  <a href="#z544_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_5">GetMaxLightmapAspectRatio</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum aspect ratio for lightmaps.  <a href="#z544_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_6">GetMaxLightmapSize</a> (int &amp;w, int &amp;h)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve maximum lightmap size.  <a href="#z544_6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_7">Prepare</a> (<a class="el" href="structiProgressMeter.html">iProgressMeter</a> *meter=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare the engine.  <a href="#z544_7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_8">PrepareMeshes</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls UpdateMove for all meshes to initialise bounding boxes.  <a href="#z544_8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_9">PrepareTextures</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare the textures.  <a href="#z544_9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_10">SetCacheManager</a> (<a class="el" href="structiCacheManager.html">iCacheManager</a> *cache_mgr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the cache manager that the engine will use.  <a href="#z544_10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_11">SetLightingCacheMode</a> (int mode)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mode for the lighting cache (combination of CS_ENGINE_CACHE_???).  <a href="#z544_11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_12">SetMaxLightmapSize</a> (int w, int h)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum lightmap dimensions.  <a href="#z544_12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEngine.html#z544_13">ShineLights</a> (<a class="el" href="structiRegion.html">iRegion</a> *region=0, <a class="el" href="structiProgressMeter.html">iProgressMeter</a> *meter=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate all lighting information.  <a href="#z544_13"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This interface is the main interface to the 3D engine. 
<p>
The engine is responsible for creating new engine-specific objects such as sectors, mesh objects, mesh object factories, lights, and so on. <p>
Main creators of instances implementing this interface:<ul>
<li>3D Engine plugin (crystalspace.engine.3d)</li></ul>
<p>
Main ways to get pointers to this interface:<ul>
<li><a class="el" href="iutil_2objreg_8h.html#a1">CS_QUERY_REGISTRY()</a></li></ul>
<p>
Main users of this interface:<ul>
<li>Application.</li></ul>

<p>

<p>
Definition at line <a class="el" href="engine_8h-source.html#l00157">157</a> of file <a class="el" href="engine_8h-source.html">engine.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z549_0"></a><!-- doxytag: member="iEngine::AddEngineSectorCallback" ref="z549_0" args="(iEngineSectorCallback *cb)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::AddEngineSectorCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiEngineSectorCallback.html">iEngineSectorCallback</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a sector callback. 
<p>
This will call <a class="el" href="structiBase.html#a3">IncRef()</a> on the callback So make sure you call <a class="el" href="structiBase.html#a1">DecRef()</a> to release your own reference.    </td>
  </tr>
</table>
<a class="anchor" name="z550_0"></a><!-- doxytag: member="iEngine::AddMeshAndChildren" ref="z550_0" args="(iMeshWrapper *mesh)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::AddMeshAndChildren           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mesh</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenience function to add a mesh and all children of that mesh to the engine. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z545_0"></a><!-- doxytag: member="iEngine::ClearRenderPriorities" ref="z545_0" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::ClearRenderPriorities           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear all render priorities. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z546_0"></a><!-- doxytag: member="iEngine::CreateBaseMaterial" ref="z546_0" args="(iTextureWrapper *txt)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMaterial.html">iMaterial</a>&gt; iEngine::CreateBaseMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiTextureWrapper.html">iTextureWrapper</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>txt</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a base material that can be used to give to the texture manager. 
<p>
Assign to a <a class="el" href="classcsRef.html">csRef</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>txt</em>&nbsp;</td><td>The texture map this material will use. Note that this can be 0 in which case a base material without texture will be created. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>You will need to call iMaterialWrapper::Register() and iMaterialWrapper::GetMaterialHandler()-&gt;<a class="el" href="structiEngine.html#z544_7">Prepare()</a> on you new material if you load the material after <a class="el" href="structiEngine.html#z544_7">iEngine::Prepare()</a> has been called.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z547_0"></a><!-- doxytag: member="iEngine::CreateBlackTexture" ref="z547_0" args="(const char *name, int w, int h, csColor *transp, int flags)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiTextureWrapper.html">iTextureWrapper</a>* iEngine::CreateBlackTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsColor.html">csColor</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>transp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a black texture. 
<p>
This is mostly useful for procedural textures. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to use for this texture in the engine </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>the texture width (must be a power of 2, eg 64, 128, 256, 512...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the texture height (must be a power of 2, eg 64, 128, 256, 512...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transp</em>&nbsp;</td><td>pixels in the image with this key color will be considered transparent instead of being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>see <a class="el" href="structiEngine.html#z547_1">CreateTexture()</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structiEngine.html#z547_1">CreateTexture()</a> note about registering textures.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z553_0"></a><!-- doxytag: member="iEngine::CreateCamera" ref="z553_0" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiCamera.html">iCamera</a>&gt; iEngine::CreateCamera           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new camera. 
<p>
Assign to a <a class="el" href="classcsRef.html">csRef</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z557_0"></a><!-- doxytag: member="iEngine::CreateFrustumView" ref="z557_0" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiFrustumView.html">iFrustumView</a>&gt; iEngine::CreateFrustumView           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a <a class="el" href="structiFrustumView.html">iFrustumView</a> instance that you can give to iVisibilityCuller-&gt;CastShadows(). 
<p>
You can initialize that instance so that your own function is called for every object that is being visited.    </td>
  </tr>
</table>
<a class="anchor" name="z548_0"></a><!-- doxytag: member="iEngine::CreateLight" ref="z548_0" args="(const char *name, const csVector3 &amp;pos, float radius, const csColor &amp;color, csLightDynamicType dyntype=CS_LIGHT_DYNAMICTYPE_STATIC)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiLight.html">iLight</a>&gt; iEngine::CreateLight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsColor.html">csColor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="light_8h.html#a15">csLightDynamicType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>dyntype</em> = <code>CS_LIGHT_DYNAMICTYPE_STATIC</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a static/pseudo-dynamic light. 
<p>
Assign to a <a class="el" href="classcsRef.html">csRef</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name for this light (may be 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>the position of this light in world coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>the maximum distance at which this light will affect objects </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>the color of this light (also affects light intensity) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dyntype</em>&nbsp;</td><td>is the type of the light. This can be <a class="el" href="light_8h.html#a15a6">CS_LIGHT_DYNAMICTYPE_DYNAMIC</a>, <a class="el" href="light_8h.html#a15a5">CS_LIGHT_DYNAMICTYPE_PSEUDO</a>, or <a class="el" href="light_8h.html#a15a4">CS_LIGHT_DYNAMICTYPE_STATIC</a>. Note that after creating a light you must add it to a sector by calling sector-&gt;GetLights ()-&gt;Add (light); If the light is dynamic you also must call Setup() to calculate lighting. Otherwise you must use engine-&gt;<a class="el" href="structiEngine.html#z544_1">ForceRelight()</a> if you create a light after calling engine-&gt;<a class="el" href="structiEngine.html#z544_7">Prepare()</a>. Otherwise you can let engine-&gt;<a class="el" href="structiEngine.html#z544_7">Prepare()</a> do it. </td></tr>
  </table>
</dl>
Note! If you are using a system with hardware accelerated lighting (i.e. no lightmaps) then the discussion above is not relevant.    </td>
  </tr>
</table>
<a class="anchor" name="z556_0"></a><!-- doxytag: member="iEngine::CreateLoaderContext" ref="z556_0" args="(iRegion *region=0, bool curRegOnly=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiLoaderContext.html">iLoaderContext</a>&gt; iEngine::CreateLoaderContext           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>curRegOnly</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a loader context that you can give to loader plugins. 
<p>
It will basically allow loader plugins to find materials. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>optional loader region </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curRegOnly</em>&nbsp;</td><td>if region is valid and and curRegOnly is true then only that region will be searched. Assign to a <a class="el" href="classcsRef.html">csRef</a>.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z546_1"></a><!-- doxytag: member="iEngine::CreateMaterial" ref="z546_1" args="(const char *name, iTextureWrapper *texture)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMaterialWrapper.html">iMaterialWrapper</a>* iEngine::CreateMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiTextureWrapper.html">iTextureWrapper</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a material to be loaded during <a class="el" href="structiEngine.html#z544_7">Prepare()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>engine name for this material </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>texture to use for this material</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z551_0"></a><!-- doxytag: member="iEngine::CreateMeshFactory" ref="z551_0" args="(const char *name)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a>&gt; iEngine::CreateMeshFactory           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an uninitialized mesh factory wrapper Assign to a <a class="el" href="classcsRef.html">csRef</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name for the factory wrapper</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z551_1"></a><!-- doxytag: member="iEngine::CreateMeshFactory" ref="z551_1" args="(iMeshObjectFactory *factory, const char *name)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a>&gt; iEngine::CreateMeshFactory           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshObjectFactory.html">iMeshObjectFactory</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a mesh factory wrapper for an existing mesh factory Assign to a <a class="el" href="classcsRef.html">csRef</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>factory</em>&nbsp;</td><td>the mesh factory to be wrapped, the engine doesn't "know" about a mesh factory until associated with a FactoryWrapper </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name for the factory wrapper</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z551_2"></a><!-- doxytag: member="iEngine::CreateMeshFactory" ref="z551_2" args="(const char *classId, const char *name)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a>&gt; iEngine::CreateMeshFactory           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>classId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenience function to create a mesh factory from a given type. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>classId</em>&nbsp;</td><td>the SCF name of the plugin (like 'crystalspace.mesh.object.ball'). The type plugin will only be loaded if needed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The factory will be registered with the engine under the given name. If there is already a factory with that name no new factory will be created but the found one is returned instead. If the name is 0 then no name will be set and no check will happen if the factory already exists. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on failure; you must assign the result to a <a class="el" href="classcsRef.html">csRef</a> or use <a class="el" href="structiBase.html#a1">DecRef()</a>.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z550_1"></a><!-- doxytag: member="iEngine::CreateMeshWrapper" ref="z550_1" args="(const char *name)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>&gt; iEngine::CreateMeshWrapper           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an uninitialized mesh wrapper Assign to a <a class="el" href="classcsRef.html">csRef</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z550_2"></a><!-- doxytag: member="iEngine::CreateMeshWrapper" ref="z550_2" args="(const char *classid, const char *name, iSector *sector=0, const csVector3 &amp;pos=csVector3(0, 0, 0))=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>&gt; iEngine::CreateMeshWrapper           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>classid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em> = <code><a class="el" href="classcsVector3.html">csVector3</a>(0,&nbsp;0,&nbsp;0)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a mesh wrapper from a class id. 
<p>
This function will first make a factory from the plugin and then see if that factory itself implements <a class="el" href="structiMeshObject.html">iMeshObject</a> too. This means this function is useful to create thing mesh objects (which are both factory and object at the same time). If that fails this function will call NewInstance() on the factory and return that object then. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>classid</em>&nbsp;</td><td>The SCF name of the plugin (like 'crystalspace.mesh.object.ball'). The type plugin will only be loaded if needed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The engine name for the mesh wrapper; may be null. Different mesh objects can have the same name (in contrast with factory objects). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sector</em>&nbsp;</td><td>the sector to initially place this mesh in If 'sector' is 0 then the mesh object will not be set to a position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>the position in the sector </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The meshwrapper on success (assign to a <a class="el" href="classcsRef.html">csRef</a>), or 0 on failure.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z550_3"></a><!-- doxytag: member="iEngine::CreateMeshWrapper" ref="z550_3" args="(iMeshObject *meshobj, const char *name, iSector *sector=0, const csVector3 &amp;pos=csVector3(0, 0, 0))=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>&gt; iEngine::CreateMeshWrapper           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshObject.html">iMeshObject</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>meshobj</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em> = <code><a class="el" href="classcsVector3.html">csVector3</a>(0,&nbsp;0,&nbsp;0)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a mesh wrapper for an existing mesh object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>meshobj</em>&nbsp;</td><td>the mesh object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The engine name for the mesh wrapper; may be null. Different mesh objects can have the same name (in contrast with factory objects). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sector</em>&nbsp;</td><td>the sector to initially place this mesh in If 'sector' is 0 then the mesh object will not be set to a position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>the position in the sector </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The meshwrapper on success (assign to a <a class="el" href="classcsRef.html">csRef</a>), or 0 on failure.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z550_4"></a><!-- doxytag: member="iEngine::CreateMeshWrapper" ref="z550_4" args="(iMeshFactoryWrapper *factory, const char *name, iSector *sector=0, const csVector3 &amp;pos=csVector3(0, 0, 0))=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>&gt; iEngine::CreateMeshWrapper           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em> = <code><a class="el" href="classcsVector3.html">csVector3</a>(0,&nbsp;0,&nbsp;0)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenience function to create a mesh object for a given factory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>factory</em>&nbsp;</td><td>the factory that will produce this mesh </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The engine name for the mesh wrapper; may be null. Different mesh objects can have the same name (in contrast with factory objects). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sector</em>&nbsp;</td><td>the sector to initially place this mesh in If 'sector' is 0 then the mesh object will not be set to a position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>the position in the sector </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The meshwrapper on success (assign to a <a class="el" href="classcsRef.html">csRef</a>), or 0 on failure.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z557_1"></a><!-- doxytag: member="iEngine::CreateObjectWatcher" ref="z557_1" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiObjectWatcher.html">iObjectWatcher</a>&gt; iEngine::CreateObjectWatcher           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an object watcher instance that you can use to watch other objects. 
<p>
The engine will not keep a reference to this object.    </td>
  </tr>
</table>
<a class="anchor" name="z554_0"></a><!-- doxytag: member="iEngine::CreatePortal" ref="z554_0" args="(const char *name, iSector *sourceSector, const csVector3 &amp;pos, iSector *destSector, csVector3 *vertices, int num_vertices, iPortal *&amp;portal)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>&gt; iEngine::CreatePortal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sourceSector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>destSector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiPortal.html">iPortal</a> *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>portal</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenience function to create a portal from one sector to another. 
<p>
Use SCF_QUERY_INTERFACE with <a class="el" href="structiPortalContainer.html">iPortalContainer</a> on the returned mesh for more control over the portal(s) in the portal object. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is the name of the portal container mesh to create the portal in. If the sourceSector already has a mesh with that name then that will be used. If there is already a mesh with that name but it is not a portal container then a new mesh will be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceSector</em>&nbsp;</td><td>is the sector where the portal container will be placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>the position inside that sector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destSector</em>&nbsp;</td><td>the sector where the single portal that is created inside the portal object will point too. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>list of vertices comprising the portal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_vertices</em>&nbsp;</td><td>number of elements in 'vertices'. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>return value for the created portal. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The meshwrapper on success (assign to a <a class="el" href="classcsRef.html">csRef</a>), or 0 on failure.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z554_1"></a><!-- doxytag: member="iEngine::CreatePortal" ref="z554_1" args="(const char *name, iMeshWrapper *parentMesh, iSector *destSector, csVector3 *vertices, int num_vertices, iPortal *&amp;portal)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>&gt; iEngine::CreatePortal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>parentMesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>destSector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiPortal.html">iPortal</a> *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>portal</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenience function to create a portal from one sector to another and make this portal a child mesh of another mesh. 
<p>
Use SCF_QUERY_INTERFACE with <a class="el" href="structiPortalContainer.html">iPortalContainer</a> on the returned mesh for more control over the portal(s) in the portal object. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is the name of the portal container mesh to create the portal in. If the parentMesh already has a mesh with that name then that will be used. If there is already a mesh with that name but it is not a portal container then a new mesh will be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parentMesh</em>&nbsp;</td><td>is the mesh where the portal container will be placed as a child. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destSector</em>&nbsp;</td><td>is the sector where the single portal that is created inside the portal object will point too. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>list of vertices comprising the portal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_vertices</em>&nbsp;</td><td>number of elements in 'vertices'. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>is a return value for the created portal. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The meshwrapper on success (assign to a <a class="el" href="classcsRef.html">csRef</a>), or 0 on failure.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z554_2"></a><!-- doxytag: member="iEngine::CreatePortalContainer" ref="z554_2" args="(const char *name, iSector *sector=0, const csVector3 &amp;pos=csVector3(0, 0, 0))=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>&gt; iEngine::CreatePortalContainer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em> = <code><a class="el" href="classcsVector3.html">csVector3</a>(0,&nbsp;0,&nbsp;0)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an empty portal container in some sector. 
<p>
Use this portal container to create portals to other sectors. Use SCF_QUERY_INTERFACE with <a class="el" href="structiPortalContainer.html">iPortalContainer</a> on the mesh object inside the returned mesh to control the portals. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>of the portal mesh. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sector</em>&nbsp;</td><td>is the location of the portal object and not the sector the portals will point too. If not given then the portal container is not put in any mesh. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>is an optional position inside the sector (if given). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The meshwrapper on success (assign to a <a class="el" href="classcsRef.html">csRef</a>), or 0 on failure.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z552_0"></a><!-- doxytag: member="iEngine::CreateRegion" ref="z552_0" args="(const char *name)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiRegion.html">iRegion</a>* iEngine::CreateRegion           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new region and add it to the region list. 
<p>
If the region already exists then this function will just return the pointer to that region. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name for the region</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z549_1"></a><!-- doxytag: member="iEngine::CreateSector" ref="z549_1" args="(const char *name)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiSector.html">iSector</a>* iEngine::CreateSector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a empty sector with given name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the sector name</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z550_5"></a><!-- doxytag: member="iEngine::CreateSectorWallsMesh" ref="z550_5" args="(iSector *sector, const char *name)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>&gt; iEngine::CreateSectorWallsMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenience function to create the thing containing the convex outline of a sector. 
<p>
The thing will be empty but it will have <a class="el" href="graph3d_8h.html#a114a49">CS_ZBUF_FILL</a> set (so that the Z-buffer will be filled by the polygons of this object) and have 'wall' as render priority. This version creates a mesh wrapper. Assign to a <a class="el" href="classcsRef.html">csRef</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sector</em>&nbsp;</td><td>the sector to add walls to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name of the walls mesh that will be created</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z547_1"></a><!-- doxytag: member="iEngine::CreateTexture" ref="z547_1" args="(const char *name, const char *fileName, csColor *transp, int flags)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiTextureWrapper.html">iTextureWrapper</a>* iEngine::CreateTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsColor.html">csColor</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>transp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a texture from a file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to use for this texture in the engine </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fileName</em>&nbsp;</td><td>the filename (on the VFS!) of the texture to load </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transp</em>&nbsp;</td><td>pixels in the image with this key color will be considered transparent instead of being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>One or more texturing flags OR'd together, flag include <ul>
<li>
CS_TEXTURE_2D image will be used only for 2D drawing </li>
<li>
CS_TEXTURE_3D image will be textured onto 3D polygon (this is almost always the flag you want) </li>
<li>
CS_TEXTURE_DITHER texture will be dithered before use </li>
<li>
CS_TEXTURE_NOMIPMAPS texture will not be mipmapped before use </li>
</ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>You will need to call <a class="el" href="structiTextureWrapper.html#a10">iTextureWrapper::Register()</a> on you new texture if you load the texture after <a class="el" href="structiEngine.html#z544_7">iEngine::Prepare()</a> has been called.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z550_6"></a><!-- doxytag: member="iEngine::CreateThingMesh" ref="z550_6" args="(iSector *sector, const char *name)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>&gt; iEngine::CreateThingMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenience function to create a thing mesh in a sector. 
<p>
This mesh will have <a class="el" href="graph3d_8h.html#a114a51">CS_ZBUF_USE</a> set (use Z-buffer fully) and have 'object' as render priority. This means this function is useful for general objects. Assign to a <a class="el" href="classcsRef.html">csRef</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sector</em>&nbsp;</td><td>the sector to add the object to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name of the mesh that will be created</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z557_2"></a><!-- doxytag: member="iEngine::DeleteAll" ref="z557_2" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::DeleteAll           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete everything in the engine. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_0"></a><!-- doxytag: member="iEngine::Draw" ref="z555_0" args="(iCamera *c, iClipper2D *clipper)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::Draw           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiCamera.html">iCamera</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiClipper2D.html">iClipper2D</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>clipper</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draw the 3D world given a camera and a clipper. 
<p>
Note that in order to be able to draw using the given 3D driver all textures must have been registered to that driver (using <a class="el" href="structiEngine.html#z544_7">Prepare()</a>). Note that you need to call <a class="el" href="structiEngine.html#z544_7">Prepare()</a> again if you switch to another 3D driver.    </td>
  </tr>
</table>
<a class="anchor" name="z553_1"></a><!-- doxytag: member="iEngine::FindCameraPosition" ref="z553_1" args="(const char *name, iRegion *region=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiCameraPosition.html">iCameraPosition</a>* iEngine::FindCameraPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the given camera position. 
<p>
The name can be a normal name. In that case this function will look in all regions except if region is not 0 in which case it will only look in that region. If the name is specified as 'regionname/objectname' then this function will only look in the specified region and return 0 if that region doesn't contain the object or the region doesn't exist. In this case the region parameter is ignored. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name of the desired camera position </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>if specified, search only this region (also see note above)</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z557_3"></a><!-- doxytag: member="iEngine::FindCollection" ref="z557_3" args="(const char *name, iRegion *region=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiCollection.html">iCollection</a>* iEngine::FindCollection           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the given collection. 
<p>
The name can be a normal name. In that case this function will look in all regions except if region is not 0 in which case it will only look in that region. If the name is specified as 'regionname/objectname' then this function will only look in the specified region and return 0 if that region doesn't contain the object or the region doesn't exist. In this case the region parameter is ignored. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name of the desired collection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>if specified, search only this region (also see note above)</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z548_1"></a><!-- doxytag: member="iEngine::FindLight" ref="z548_1" args="(const char *Name, bool RegionOnly=false) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiLight.html">iLight</a>* iEngine::FindLight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>Name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>RegionOnly</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find a static/pseudo-dynamic light by name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Name</em>&nbsp;</td><td>the engine name of the desired light </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionOnly</em>&nbsp;</td><td>(parameter presently unused)</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z548_2"></a><!-- doxytag: member="iEngine::FindLightID" ref="z548_2" args="(const char *light_id) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiLight.html">iLight</a>* iEngine::FindLightID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>light_id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find a static/pseudo-dynamic light by id. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>light_id</em>&nbsp;</td><td>a 16-byte MD5 checksum for the light.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z546_2"></a><!-- doxytag: member="iEngine::FindMaterial" ref="z546_2" args="(const char *name, iRegion *region=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMaterialWrapper.html">iMaterialWrapper</a>* iEngine::FindMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the given material. 
<p>
The name can be a normal name. In that case this function will look in all regions except if region is not 0 in which case it will only look in that region. If the name is specified as 'regionname/objectname' then this function will only look in the specified region and return 0 if that region doesn't contain the object or the region doesn't exist. In this case the region parameter is ignored. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name of the desired material </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>if specified, search only this region (also see note above)</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z551_3"></a><!-- doxytag: member="iEngine::FindMeshFactory" ref="z551_3" args="(const char *name, iRegion *region=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a>* iEngine::FindMeshFactory           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the given mesh factory. 
<p>
The name can be a normal name. In that case this function will look in all regions except if region is not 0 in which case it will only look in that region. If the name is specified as 'regionname/objectname' then this function will only look in the specified region and return 0 if that region doesn't contain the object or the region doesn't exist. In this case the region parameter is ignored. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name of the desired mesh factory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>if specified, search only this region (also see note above)</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z550_7"></a><!-- doxytag: member="iEngine::FindMeshObject" ref="z550_7" args="(const char *name, iRegion *region=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>* iEngine::FindMeshObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the given mesh object. 
<p>
The name can be a normal name. In that case this function will look in all regions except if region is not 0 in which case it will only look in that region. If the name is specified as 'regionname/objectname' then this function will only look in the specified region and return 0 if that region doesn't contain the object or the region doesn't exist. In this case the region parameter is ignored. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name of the desired mesh </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>if specified, search only this region (also see note above)</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z549_2"></a><!-- doxytag: member="iEngine::FindSector" ref="z549_2" args="(const char *name, iRegion *region=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiSector.html">iSector</a>* iEngine::FindSector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the given sector. 
<p>
The name can be a normal name. In that case this function will look in all regions except if region is not 0 in which case it will only look in that region. If the name is specified as 'regionname/objectname' then this function will only look in the specified region and return 0 if that region doesn't contain the object or the region doesn't exist. In this case the region parameter is ignored. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name of the desired sector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>if specified, search only this region (also see note above)</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z547_2"></a><!-- doxytag: member="iEngine::FindTexture" ref="z547_2" args="(const char *name, iRegion *region=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiTextureWrapper.html">iTextureWrapper</a>* iEngine::FindTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the given texture. 
<p>
The name can be a normal name. In that case this function will look in all regions except if region is not 0 in which case it will only look in that region. If the name is specified as 'regionname/objectname' then this function will only look in the specified region and return 0 if that region doesn't contain the object or the region doesn't exist. In this case the region parameter is ignored. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the engine name of the desired texture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>if specified, search only this region (also see note above)</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z544_0"></a><!-- doxytag: member="iEngine::ForceRelight" ref="z544_0" args="(iLight *light, iRegion *region=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::ForceRelight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiLight.html">iLight</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>light</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Force a relight for the given light. 
<p>
This is useful to update the lightmaps after a static or pseudo-dynamic light has been added (don't use this for dynamic lights). If there are a lot of objects this function can be slow. The optional region can be given to limit calculation to objects in the region. <p>
The current flags set with <a class="el" href="structiEngine.html#z544_11">SetLightingCacheMode()</a> controls if the lightmaps will be cached or not. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>light</em>&nbsp;</td><td>The newly added light to shine </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>If supplied, only affect objects in this region</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z544_1"></a><!-- doxytag: member="iEngine::ForceRelight" ref="z544_1" args="(iRegion *region=0, iProgressMeter *meter=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::ForceRelight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiProgressMeter.html">iProgressMeter</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>meter</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Force a relight of all lighting. 
<p>
It is better to call this instead of calling engine-&gt;<a class="el" href="structiEngine.html#z544_7">Prepare()</a> again as engine-&gt;<a class="el" href="structiEngine.html#z544_7">Prepare()</a> will also do other stuff (like registering textures). Warning! This function can be very slow (depending on the number of lights and objects in the world). The optional region can be given to limit calculation to objects in the region. <p>
The current flags set with <a class="el" href="structiEngine.html#z544_11">SetLightingCacheMode()</a> controls if the lightmaps will be cached or not. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>only relight objects in this region (will relight every object in the engine by default) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>meter</em>&nbsp;</td><td>If supplied, the meter object will be called back periodically to report the progress of engine lighting calculation.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z545_1"></a><!-- doxytag: member="iEngine::GetAlphaRenderPriority" ref="z545_1" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual long iEngine::GetAlphaRenderPriority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the render priority for alpha objects (attached to 'alpha' name). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z548_3"></a><!-- doxytag: member="iEngine::GetAmbientLight" ref="z548_3" args="(csColor &amp;) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::GetAmbientLight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsColor.html">csColor</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the amount of ambient light. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_1"></a><!-- doxytag: member="iEngine::GetBeginDrawFlags" ref="z555_1" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int iEngine::GetBeginDrawFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the required flags for 3D-&gt;BeginDraw() which should be called from the application. 
<p>
These flags must be or-ed with optional other flags that the application might be interested in. Use <a class="el" href="structiEngine.html#z555_13">SetClearZBuf()</a> to let this function return that the Z-buffer must be cleared.    </td>
  </tr>
</table>
<a class="anchor" name="z544_2"></a><!-- doxytag: member="iEngine::GetCacheManager" ref="z544_2" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiCacheManager.html">iCacheManager</a>* iEngine::GetCacheManager           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the cache manager that the engine is currently using. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z553_2"></a><!-- doxytag: member="iEngine::GetCameraPositions" ref="z553_2" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiCameraPositionList.html">iCameraPositionList</a>* iEngine::GetCameraPositions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the list of camera positions. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_2"></a><!-- doxytag: member="iEngine::GetClearScreen" ref="z555_2" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iEngine::GetClearScreen           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the value of the clear screen flag set with <a class="el" href="structiEngine.html#z555_12">SetClearScreen()</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_3"></a><!-- doxytag: member="iEngine::GetClearZBuf" ref="z555_3" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iEngine::GetClearZBuf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the value of the clear Z-buffer flag set with <a class="el" href="structiEngine.html#z555_13">SetClearZBuf()</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z557_4"></a><!-- doxytag: member="iEngine::GetCollections" ref="z557_4" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiCollectionList.html">iCollectionList</a>* iEngine::GetCollections           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the list of collections. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_4"></a><!-- doxytag: member="iEngine::GetContext" ref="z555_4" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiTextureHandle.html">iTextureHandle</a>* iEngine::GetContext           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the current drawing context. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_5"></a><!-- doxytag: member="iEngine::GetCurrentDefaultRenderloop" ref="z555_5" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiRenderLoop.html">iRenderLoop</a>* iEngine::GetCurrentDefaultRenderloop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current render loop. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>This will the loop that is set to be the current default with <a class="el" href="structiEngine.html#z555_15">SetCurrentDefaultRenderloop()</a>. This doesn't have to be the engine's default render loop (note the difference between the "current" and "default" render loop - former one is the loop used currently for drawing, latter one is a default loop created at engine initialization time.) To retrieve the default loop, use <div class="fragment"><pre class="fragment">  <a class="code" href="structiEngine.html#z555_9">GetRenderLoopManager</a>()-&gt;<a class="code" href="structiRenderLoopManager.html#a4">Retrieve</a> (#<a class="code" href="group__engine3d__rloop.html#ga0">CS_DEFAULT_RENDERLOOP_NAME</a>);
</pre></div></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_6"></a><!-- doxytag: member="iEngine::GetCurrentFrameNumber" ref="z555_6" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="cstypes_8h.html#a27">uint</a> iEngine::GetCurrentFrameNumber           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current framenumber. 
<p>
This should be incremented once every Draw    </td>
  </tr>
</table>
<a class="anchor" name="z548_4"></a><!-- doxytag: member="iEngine::GetDefaultAmbientLight" ref="z548_4" args="(csColor &amp;c) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::GetDefaultAmbientLight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsColor.html">csColor</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>c</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the default amount of ambient light. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_7"></a><!-- doxytag: member="iEngine::GetDefaultClearScreen" ref="z555_7" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iEngine::GetDefaultClearScreen           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get default clear screen flag. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_8"></a><!-- doxytag: member="iEngine::GetDefaultClearZBuf" ref="z555_8" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iEngine::GetDefaultClearZBuf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get default clear z-buffer flag. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z544_3"></a><!-- doxytag: member="iEngine::GetDefaultMaxLightmapSize" ref="z544_3" args="(int &amp;w, int &amp;h)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::GetDefaultMaxLightmapSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve default maximum lightmap size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>lightmap width </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>lightmap height</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z544_4"></a><!-- doxytag: member="iEngine::GetLightingCacheMode" ref="z544_4" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int iEngine::GetLightingCacheMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the mode for the lighting cache. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z548_5"></a><!-- doxytag: member="iEngine::GetLightIterator" ref="z548_5" args="(iRegion *region=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiLightIterator.html">iLightIterator</a>&gt; iEngine::GetLightIterator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>region</em> = <code>0</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an iterator to iterate over all static lights of the engine. 
<p>
Assign to a <a class="el" href="classcsRef.html">csRef</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>only iterate over the lights in this region (otherwise iterate over all lights)</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z546_3"></a><!-- doxytag: member="iEngine::GetMaterialList" ref="z546_3" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMaterialList.html">iMaterialList</a>* iEngine::GetMaterialList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the list of all materials. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z544_5"></a><!-- doxytag: member="iEngine::GetMaxLightmapAspectRatio" ref="z544_5" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int iEngine::GetMaxLightmapAspectRatio           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the maximum aspect ratio for lightmaps. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z544_6"></a><!-- doxytag: member="iEngine::GetMaxLightmapSize" ref="z544_6" args="(int &amp;w, int &amp;h)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::GetMaxLightmapSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve maximum lightmap size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>lightmap width </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>lightmap height</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z550_8"></a><!-- doxytag: member="iEngine::GetMeshes" ref="z550_8" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshList.html">iMeshList</a>* iEngine::GetMeshes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the list of meshes. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z551_4"></a><!-- doxytag: member="iEngine::GetMeshFactories" ref="z551_4" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshFactoryList.html">iMeshFactoryList</a>* iEngine::GetMeshFactories           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the list of mesh factories. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z548_6"></a><!-- doxytag: member="iEngine::GetNearbyLights" ref="z548_6" args="(iSector *sector, const csBox3 &amp;box, iLight **lights, int max_num_lights)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int iEngine::GetNearbyLights           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsBox3.html">csBox3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiLight.html">iLight</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>lights</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>max_num_lights</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine returns all lights which might affect an object with some bounding box. 
<p>
<br>
 It will only return as many lights as the size that you specified for the light array. The returned lights are not guaranteed to be sorted but they are guaranteed to be the specified number of lights closest to the given position.<br>
 This function returns the actual number of lights added to the 'lights' array.    </td>
  </tr>
</table>
<a class="anchor" name="z548_7"></a><!-- doxytag: member="iEngine::GetNearbyLights" ref="z548_7" args="(iSector *sector, const csVector3 &amp;pos, iLight **lights, int max_num_lights)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int iEngine::GetNearbyLights           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiLight.html">iLight</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>lights</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>max_num_lights</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine returns all lights which might affect an object at some position. 
<p>
<br>
 It will only return as many lights as the size that you specified for the light array. The returned lights are not guaranteed to be sorted but they are guaranteed to be the specified number of lights closest to the given position.<br>
 This function returns the actual number of lights added to the 'lights' array.    </td>
  </tr>
</table>
<a class="anchor" name="z550_9"></a><!-- doxytag: member="iEngine::GetNearbyMeshes" ref="z550_9" args="(iSector *sector, const csBox3 &amp;box, bool crossPortals=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapperIterator.html">iMeshWrapperIterator</a>&gt; iEngine::GetNearbyMeshes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsBox3.html">csBox3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>crossPortals</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine returns an iterator to iterate over all meshes that are in a box. 
<p>
If crossPortals is true it will search through portals. Otherwise it will limit the search to the sector passed in. Portal visibility is tested with the center of the box.    </td>
  </tr>
</table>
<a class="anchor" name="z550_10"></a><!-- doxytag: member="iEngine::GetNearbyMeshes" ref="z550_10" args="(iSector *sector, const csVector3 &amp;pos, float radius, bool crossPortals=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapperIterator.html">iMeshWrapperIterator</a>&gt; iEngine::GetNearbyMeshes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>crossPortals</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine returns an iterator to iterate over all meshes that are within a radius of a given position. 
<p>
If crossPortals is true it will search through portals. Otherwise it will limit the search to the sector passed in.    </td>
  </tr>
</table>
<a class="anchor" name="z557_5"></a><!-- doxytag: member="iEngine::GetNearbyObjects" ref="z557_5" args="(iSector *sector, const csVector3 &amp;pos, float radius, bool crossPortals=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiObjectIterator.html">iObjectIterator</a>&gt; iEngine::GetNearbyObjects           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>crossPortals</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine returns an iterator to iterate over all objects that are within a radius of a given position. 
<p>
The current implementation only does meshes but in future lights will also be supported. You can use <a class="el" href="group__scf.html#ga77">SCF_QUERY_INTERFACE</a> to get any interface from the returned objects. If crossPortals is true it will search through portals. Otherwise it will limit the search to the sector passed in. If you only want to have meshes then it is more efficient to call <a class="el" href="structiEngine.html#z550_10">GetNearbyMeshes()</a> as you can then avoid the call to <a class="el" href="group__scf.html#ga77">SCF_QUERY_INTERFACE</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z549_3"></a><!-- doxytag: member="iEngine::GetNearbySectors" ref="z549_3" args="(iSector *sector, const csVector3 &amp;pos, float radius)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiSectorIterator.html">iSectorIterator</a>&gt; iEngine::GetNearbySectors           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>radius</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine returns an iterator to iterate over all nearby sectors. 
<p>
Assign to a <a class="el" href="classcsRef.html">csRef</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z545_2"></a><!-- doxytag: member="iEngine::GetObjectRenderPriority" ref="z545_2" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual long iEngine::GetObjectRenderPriority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the render priority for general objects (attached to 'object' name). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z545_3"></a><!-- doxytag: member="iEngine::GetPortalRenderPriority" ref="z545_3" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual long iEngine::GetPortalRenderPriority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the render priority for portal objects (attached to 'portal' name). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z552_1"></a><!-- doxytag: member="iEngine::GetRegions" ref="z552_1" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiRegionList.html">iRegionList</a>* iEngine::GetRegions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the list of all regions. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_9"></a><!-- doxytag: member="iEngine::GetRenderLoopManager" ref="z555_9" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiRenderLoopManager.html">iRenderLoopManager</a>* iEngine::GetRenderLoopManager           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the render loop manager. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z545_4"></a><!-- doxytag: member="iEngine::GetRenderPriority" ref="z545_4" args="(const char *name) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual long iEngine::GetRenderPriority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a render priority by name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is the name you want (usually one of 'sky', 'portal', 'wall', 'object', or 'alpha' but you can define your own render priorities). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if render priority doesn't exist.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z545_5"></a><!-- doxytag: member="iEngine::GetRenderPriorityCount" ref="z545_5" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int iEngine::GetRenderPriorityCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the number of render priorities. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z545_6"></a><!-- doxytag: member="iEngine::GetRenderPriorityName" ref="z545_6" args="(long priority) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const char* iEngine::GetRenderPriorityName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>priority</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the name of the render priority or 0 if none existant. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z545_7"></a><!-- doxytag: member="iEngine::GetRenderPrioritySorting" ref="z545_7" args="(long priority) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="engine_8h.html#a6">csRenderPrioritySorting</a> iEngine::GetRenderPrioritySorting           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>priority</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the render priority sorting flag. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z545_8"></a><!-- doxytag: member="iEngine::GetRenderPrioritySorting" ref="z545_8" args="(const char *name) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="engine_8h.html#a6">csRenderPrioritySorting</a> iEngine::GetRenderPrioritySorting           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the render priority sorting flag. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z556_1"></a><!-- doxytag: member="iEngine::GetSaveableFlag" ref="z556_1" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iEngine::GetSaveableFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get whether saving should be possible (default OFF). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z549_4"></a><!-- doxytag: member="iEngine::GetSectors" ref="z549_4" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiSectorList.html">iSectorList</a>* iEngine::GetSectors           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the list of sectors. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z545_9"></a><!-- doxytag: member="iEngine::GetSkyRenderPriority" ref="z545_9" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual long iEngine::GetSkyRenderPriority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the render priority for sky objects (attached to 'sky' name). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z547_3"></a><!-- doxytag: member="iEngine::GetTextureFormat" ref="z547_3" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int iEngine::GetTextureFormat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Query the format to load textures (usually this depends on texture manager). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z547_4"></a><!-- doxytag: member="iEngine::GetTextureList" ref="z547_4" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiTextureList.html">iTextureList</a>* iEngine::GetTextureList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the list of all textures. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_10"></a><!-- doxytag: member="iEngine::GetTopLevelClipper" ref="z555_10" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiRenderView.html">iRenderView</a>* iEngine::GetTopLevelClipper           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the top-level clipper. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z557_6"></a><!-- doxytag: member="iEngine::GetVariableList" ref="z557_6" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiSharedVariableList.html">iSharedVariableList</a>* iEngine::GetVariableList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the list of all shared variables. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z557_7"></a><!-- doxytag: member="iEngine::GetVisibleMeshes" ref="z557_7" args="(iSector *sector, const csFrustum &amp;frustum)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapperIterator.html">iMeshWrapperIterator</a>&gt; iEngine::GetVisibleMeshes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsFrustum.html">csFrustum</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>frustum</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine returns an iterator to iterate over all meshes that are potentially visible as seen from a given position. 
<p>
This routine has a frustum restricting the view. CURRENTLY NOT IMPLEMENTED!    </td>
  </tr>
</table>
<a class="anchor" name="z557_8"></a><!-- doxytag: member="iEngine::GetVisibleMeshes" ref="z557_8" args="(iSector *sector, const csVector3 &amp;pos)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapperIterator.html">iMeshWrapperIterator</a>&gt; iEngine::GetVisibleMeshes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine returns an iterator to iterate over all meshes that are potentially visible as seen from a given position. 
<p>
This routine assumes full 360 degree visibility. CURRENTLY NOT IMPLEMENTED!    </td>
  </tr>
</table>
<a class="anchor" name="z557_9"></a><!-- doxytag: member="iEngine::GetVisibleObjects" ref="z557_9" args="(iSector *sector, const csFrustum &amp;frustum)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiObjectIterator.html">iObjectIterator</a>&gt; iEngine::GetVisibleObjects           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsFrustum.html">csFrustum</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>frustum</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine returns an iterator to iterate over all objects that are potentially visible as seen from a given position. 
<p>
This routine has a frustum restricting the view. You can use <a class="el" href="group__scf.html#ga77">SCF_QUERY_INTERFACE</a> to get any interface from the returned objects.<p>
If you only want meshes then use <a class="el" href="structiEngine.html#z557_8">GetVisibleMeshes()</a>. CURRENTLY NOT IMPLEMENTED!    </td>
  </tr>
</table>
<a class="anchor" name="z557_10"></a><!-- doxytag: member="iEngine::GetVisibleObjects" ref="z557_10" args="(iSector *sector, const csVector3 &amp;pos)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiObjectIterator.html">iObjectIterator</a>&gt; iEngine::GetVisibleObjects           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine returns an iterator to iterate over all objects that are potentially visible as seen from a given position. 
<p>
This routine assumes full 360 degree visibility. You can use <a class="el" href="group__scf.html#ga77">SCF_QUERY_INTERFACE</a> to get any interface from the returned objects.<p>
If you only want meshes then use <a class="el" href="structiEngine.html#z557_8">GetVisibleMeshes()</a>. CURRENTLY NOT IMPLEMENTED!    </td>
  </tr>
</table>
<a class="anchor" name="z545_10"></a><!-- doxytag: member="iEngine::GetWallRenderPriority" ref="z545_10" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual long iEngine::GetWallRenderPriority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the render priority for wall objects (attached to 'wall' name). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z551_5"></a><!-- doxytag: member="iEngine::LoadMeshFactory" ref="z551_5" args="(const char *name, const char *loaderClassId, iDataBuffer *input)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a>&gt; iEngine::LoadMeshFactory           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>loaderClassId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiDataBuffer.html">iDataBuffer</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>input</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenience function to load a mesh factory from a given loader plugin. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>engine name for the mesh factory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loaderClassId</em>&nbsp;</td><td>the SCF class name of the desired mesh factory plugin </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>data to initialize the mesh factory (plugin-specific) Assign to a <a class="el" href="classcsRef.html">csRef</a>.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z550_11"></a><!-- doxytag: member="iEngine::LoadMeshWrapper" ref="z550_11" args="(const char *name, const char *loaderClassId, iDataBuffer *input, iSector *sector, const csVector3 &amp;pos)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>&gt; iEngine::LoadMeshWrapper           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>loaderClassId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiDataBuffer.html">iDataBuffer</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiSector.html">iSector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sector</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenience function to load a mesh object from a given loader plugin. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The engine name for the mesh wrapper; may be null. Different mesh objects can have the same name (in contrast with factory objects). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loaderClassId</em>&nbsp;</td><td>the SCF class of the loader to use to create the meshwrapper </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>data passed to the loader to generate the mesh </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sector</em>&nbsp;</td><td>the sector to initially place this mesh in If 'sector' is 0 then the mesh object will not be set to a position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>the position in the sector </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The meshwrapper on success (assign to a <a class="el" href="classcsRef.html">csRef</a>), or 0 on failure.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_11"></a><!-- doxytag: member="iEngine::PrecacheDraw" ref="z555_11" args="(iRegion *region=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::PrecacheDraw           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>region</em> = <code>0</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function precaches all meshes by calling GetRenderMeshes() on them. 
<p>
By doing this the level will run smoother if you walk through it because all meshes will have had a chance to update caches and stuff. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>is an optional region. If given then only objects in that region will be precached.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z544_7"></a><!-- doxytag: member="iEngine::Prepare" ref="z544_7" args="(iProgressMeter *meter=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iEngine::Prepare           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiProgressMeter.html">iProgressMeter</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>meter</em> = <code>0</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prepare the engine. 
<p>
This function must be called after you loaded/created the world. It will prepare all lightmaps for use and also free all images that were loaded for the texture manager (the texture manager should have them locally now). The optional progress meter will be used to report progress. <p>
The behaviour regarding cached lighting depends on the flag you can set with the <a class="el" href="structiEngine.html#z544_11">SetLightingCacheMode()</a> function. The default behaviour is to read the lightmap cache when present but don't calculate lighting if cache is not present. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>meter</em>&nbsp;</td><td>If supplied, the meter object will be called back periodically to report the progress of engine preparation.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z544_8"></a><!-- doxytag: member="iEngine::PrepareMeshes" ref="z544_8" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::PrepareMeshes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls UpdateMove for all meshes to initialise bounding boxes. 
<p>
<a class="el" href="structiEngine.html#z544_7">Prepare()</a> will call this function automatically so you normally don't have to call it.    </td>
  </tr>
</table>
<a class="anchor" name="z544_9"></a><!-- doxytag: member="iEngine::PrepareTextures" ref="z544_9" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::PrepareTextures           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prepare the textures. 
<p>
It will initialise all loaded textures for the texture manager. (Normally you shouldn't call this function directly, because it will be called by <a class="el" href="structiEngine.html#z544_7">Prepare()</a> for you. This function will also prepare all loaded materials after preparing the textures.    </td>
  </tr>
</table>
<a class="anchor" name="a0"></a><!-- doxytag: member="iEngine::QueryObject" ref="a0" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiObject.html">iObject</a>* iEngine::QueryObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the <a class="el" href="structiObject.html">iObject</a> for the engine. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z545_11"></a><!-- doxytag: member="iEngine::RegisterRenderPriority" ref="z545_11" args="(const char *name, long priority, csRenderPrioritySorting rendsort=CS_RENDPRI_SORT_NONE)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::RegisterRenderPriority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="engine_8h.html#a6">csRenderPrioritySorting</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rendsort</em> = <code>CS_RENDPRI_SORT_NONE</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a new render priority. 
<p>
Render priorities are assigned to objects and controls the order in which objects are rendered by the engine. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>a name to refer to this render priority </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>a numerical priority; this is used to order the render priorities where lower numbers are rendered before higher numbers. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rendsort</em>&nbsp;</td><td>One of the CS_RENDPRI_... flags. By default this is <a class="el" href="engine_8h.html#a6a3">CS_RENDPRI_SORT_NONE</a>. The following values are possible: <ul>
<li>
<a class="el" href="engine_8h.html#a6a3">CS_RENDPRI_SORT_NONE</a>: objects in this render priority are not sorted. </li>
<li>
<a class="el" href="engine_8h.html#a6a5">CS_RENDPRI_SORT_FRONT2BACK</a>: sort objects front to back (as seen from camera viewpoint). </li>
<li>
<a class="el" href="engine_8h.html#a6a4">CS_RENDPRI_SORT_BACK2FRONT</a>: sort objects back to front. </li>
</ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The default render priorities are 'sky', 'portal', 'wall', 'object' and 'alpha' (in that priority order, where sky is rendered first and alpha is rendered last). Should you wish to add your own render priority, you must call <a class="el" href="structiEngine.html#z545_0">ClearRenderPriorities()</a> and re-add the default render priorities along with your own new priorities.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z549_5"></a><!-- doxytag: member="iEngine::RemoveEngineSectorCallback" ref="z549_5" args="(iEngineSectorCallback *cb)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::RemoveEngineSectorCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiEngineSectorCallback.html">iEngineSectorCallback</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a sector callback. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z548_8"></a><!-- doxytag: member="iEngine::RemoveLight" ref="z548_8" args="(iLight *light)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::RemoveLight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiLight.html">iLight</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>light</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a light and update all lightmaps. 
<p>
This function only works correctly for dynamic or pseudo-dynamic static lights. If you give a normal static light then the light will be removed but lightmaps will not be affected. You can call <a class="el" href="structiEngine.html#z544_1">ForceRelight()</a> to force relighting then. <p>
The current flags set with <a class="el" href="structiEngine.html#z544_11">SetLightingCacheMode()</a> controls if the lightmaps will be cached or not. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>light</em>&nbsp;</td><td>the light to remove</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z557_11"></a><!-- doxytag: member="iEngine::RemoveObject" ref="z557_11" args="(iBase *object)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iEngine::RemoveObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiBase.html">iBase</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>object</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenience function to 'remove' a CS object from the engine. 
<p>
This will not clear the object but it will remove all references to that object that the engine itself keeps. This function works for: <a class="el" href="structiSector.html">iSector</a>, <a class="el" href="structiCollection.html">iCollection</a>, <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>, <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a>, <a class="el" href="structiCameraPosition.html">iCameraPosition</a>, <a class="el" href="structiLight.html">iLight</a>, <a class="el" href="structiMaterialWrapper.html">iMaterialWrapper</a>, and <a class="el" href="structiTextureWrapper.html">iTextureWrapper</a>. Note that the object is only removed if the resulting ref count will become zero. So basically this function only releases the references that the engine holds. <p>
This function returns true if the engine recognized the object as one on which it can operate. <p>
This function will also remove the object from the region it may be in.    </td>
  </tr>
</table>
<a class="anchor" name="z557_12"></a><!-- doxytag: member="iEngine::ResetWorldSpecificSettings" ref="z557_12" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::ResetWorldSpecificSettings           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset a subset of flags/settings (which may differ from one world/map to another) to its defaults. 
<p>
This currently includes:<ul>
<li>clear z buffer flag</li><li>lightmap cell size</li><li>maximum lightmap size</li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z548_9"></a><!-- doxytag: member="iEngine::SetAmbientLight" ref="z548_9" args="(const csColor &amp;)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::SetAmbientLight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsColor.html">csColor</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the amount of ambient light. 
<p>
This has no effect until you recalculate the lightmaps.    </td>
  </tr>
</table>
<a class="anchor" name="z544_10"></a><!-- doxytag: member="iEngine::SetCacheManager" ref="z544_10" args="(iCacheManager *cache_mgr)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::SetCacheManager           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiCacheManager.html">iCacheManager</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cache_mgr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the cache manager that the engine will use. 
<p>
If this is not done then the engine will use its own cache manager based on VFS. This will do an incref on the given cache manager and a decref on the old one. The engine will release the cache manager at destruction time. To set the cache manager to the default VFS based cache manager for the current VFS directory you can use the following code: <div class="fragment"><pre class="fragment"> vfs-&gt;ChDir (...);
 engine-&gt;SetCacheManager (0);   <span class="comment">// Clear it.</span>
 engine-&gt;GetCacheManager ();    <span class="comment">// Force a regeneration.</span>
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="z555_12"></a><!-- doxytag: member="iEngine::SetClearScreen" ref="z555_12" args="(bool yesno)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::SetClearScreen           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>yesno</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Require that the screen is cleared every frame. 
<p>
The engine itself will not use this setting but will only return the correct flag in <a class="el" href="structiEngine.html#z555_1">GetBeginDrawFlags()</a> so that the screen is actually cleared. Note that this requires that the application actually uses <a class="el" href="structiEngine.html#z555_1">GetBeginDrawFlags()</a> in the call to g3d-&gt;BeginDraw() (which it should). By default this flag is false. It is useful to set this flag to true if you have a level that doesn't itself have another way to initialize the screen. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>yesno</em>&nbsp;</td><td>true to clear the screen before each frame, false to leave the screen as-is (which may leave garbage on the screen)</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_13"></a><!-- doxytag: member="iEngine::SetClearZBuf" ref="z555_13" args="(bool yesno)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::SetClearZBuf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>yesno</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Require that the Z-buffer is cleared every frame. 
<p>
The engine itself will not use this setting but will only return the correct flag in <a class="el" href="structiEngine.html#z555_1">GetBeginDrawFlags()</a> so that the Z-buffer is actually cleared. Note that this requires that the application actually uses <a class="el" href="structiEngine.html#z555_1">GetBeginDrawFlags()</a> in the call to g3d-&gt;BeginDraw() (which it should). By default this flag is false. It is useful to set this flag to true if you have a level that doesn't itself have another way to initialize the Z-buffer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>yesno</em>&nbsp;</td><td>true to clear the Z buffer after each frame, false to leave the zbuffer as-is</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z555_14"></a><!-- doxytag: member="iEngine::SetContext" ref="z555_14" args="(iTextureHandle *ctxt)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::SetContext           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiTextureHandle.html">iTextureHandle</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ctxt</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the drawing context. 
<p>
This is a texture handle that is used as the procedural texture to render on. If this is 0 then the screen is assumed.    </td>
  </tr>
</table>
<a class="anchor" name="z555_15"></a><!-- doxytag: member="iEngine::SetCurrentDefaultRenderloop" ref="z555_15" args="(iRenderLoop *loop)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iEngine::SetCurrentDefaultRenderloop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRenderLoop.html">iRenderLoop</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>loop</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the current render loop. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>loop</em>&nbsp;</td><td>The loop to be made the current render loop. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether the change was successful (a value of 0 for <code>will</code> let the method fail.)</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z544_11"></a><!-- doxytag: member="iEngine::SetLightingCacheMode" ref="z544_11" args="(int mode)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::SetLightingCacheMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mode</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the mode for the lighting cache (combination of CS_ENGINE_CACHE_???). 
<p>
Default is <a class="el" href="engine_8h.html#a0">CS_ENGINE_CACHE_READ</a> | <a class="el" href="engine_8h.html#a2">CS_ENGINE_CACHE_NOUPDATE</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td><ul>
<li><a class="el" href="engine_8h.html#a0">CS_ENGINE_CACHE_READ</a>: Read the cache.</li><li><a class="el" href="engine_8h.html#a1">CS_ENGINE_CACHE_WRITE</a>: Write the cache.</li><li><a class="el" href="engine_8h.html#a2">CS_ENGINE_CACHE_NOUPDATE</a>: Don't update lighting automatically if it is not up-to-date. This is on by default. If you disable this then lighting will be calculated even if CS_ENGINE_CACHE_WRITE is not set which means that the resulting calculation is not written to the cache.</li></ul>
</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z544_12"></a><!-- doxytag: member="iEngine::SetMaxLightmapSize" ref="z544_12" args="(int w, int h)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::SetMaxLightmapSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the maximum lightmap dimensions. 
<p>
Polys with lightmaps larger than this are not lit. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>lightmap width </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>lightmap height</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z556_2"></a><!-- doxytag: member="iEngine::SetSaveableFlag" ref="z556_2" args="(bool enable)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::SetSaveableFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>enable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set whether saving should be possible (default OFF). 
<p>
To allow saving of a world after it has been loaded, some objects may need to keep track of extra data that would otherwise not be needed if the world will never be written out again. The 'saveable' flag informs those objects about whether to keep that information or not. Saving a world with this flag disables is still possible, but the result might incomplete.    </td>
  </tr>
</table>
<a class="anchor" name="z544_13"></a><!-- doxytag: member="iEngine::ShineLights" ref="z544_13" args="(iRegion *region=0, iProgressMeter *meter=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::ShineLights           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRegion.html">iRegion</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiProgressMeter.html">iProgressMeter</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>meter</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate all lighting information. 
<p>
Normally you shouldn't call this function directly, because it will be called by <a class="el" href="structiEngine.html#z544_7">Prepare()</a>. If the optional 'region' parameter is given then only lights will be recalculated for the given region. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>If supplied, only calculate lighting for lights and objects in the given region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>meter</em>&nbsp;</td><td>If supplied, the meter object will be called back periodically to report the progress of engine lighting calculation.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z550_12"></a><!-- doxytag: member="iEngine::WantToDie" ref="z550_12" args="(iMeshWrapper *mesh)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEngine::WantToDie           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mesh</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sometimes a mesh wants to destruct itself (for example a particle system that has only limited lifetime). 
<p>
It can do that by calling this function on itself. The engine will then remove the object before the next frame.    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>iengine/<a class="el" href="engine_8h-source.html">engine.h</a></ul>
<hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.4 
</small></address> </div></body> </html>
