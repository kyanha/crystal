<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Shared Class Facility (SCF) (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Shared Class Facility (SCF)</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiBase.html">iBase</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the basic interface: all other interfaces should be derived from this one, this will allow us to always use at least some minimal functionality given any interface pointer. </em> <a href="structiBase.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiComponent.html">iComponent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This interface describes a generic component in Crystal Space. </em> <a href="structiComponent.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiFactory.html">iFactory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iFactory is an interface that is used to create instances of shared classes. </em> <a href="structiFactory.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classscfInterface.html">scfInterface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface query class. </em> <a href="classscfInterface.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiObjectRegistry.html">iObjectRegistry</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This interface serves as a registry of other objects. </em> <a href="structiObjectRegistry.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiObjectRegistryIterator.html">iObjectRegistryIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use an instance of this class to iterate over objects in the object registry. </em> <a href="structiObjectRegistryIterator.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiPluginIterator.html">iPluginIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An iterator to iterate over all plugins in the plugin manager. </em> <a href="structiPluginIterator.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiPluginManager.html">iPluginManager</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the plugin manager. </em> <a href="structiPluginManager.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiSCF.html">iSCF</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iSCF is the interface that allows using SCF functions from shared classes. </em> <a href="structiSCF.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a5">SCF_DECLARE_IBASE_POOLED</a>(parentClass)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Embed this macro instead of <a class="el" href="group__scf.html#a21">SCF_DECLARE_IBASE</a> into an SCF class that is to be pooled. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a6">SCF_CONSTRUCT_IBASE_POOLED</a>(Pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has to be invoked inside the class constructor instead of <a class="el" href="group__scf.html#a23">SCF_CONSTRUCT_IBASE</a>. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a7">SCF_IMPLEMENT_IBASE_POOL_CTOR</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement the constructor for the pool manager of <em>Class</em>. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a8">SCF_IMPLEMENT_IBASE_POOL_DTOR</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement the destructor for the pool manager of <em>Class</em>. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a9">SCF_IMPLEMENT_IBASE_POOL_ALLOC</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement <em>Alloc()</em> for the pool manager of <em>Class</em>. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a10">SCF_IMPLEMENT_IBASE_POOL_RECYCLE</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement <em>Recycle()</em> for the pool manager of <em>Class</em>. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a11">SCF_IMPLEMENT_IBASE_POOL</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement pool manager for <em>Class</em>. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a12">SCF_IMPLEMENT_IBASE_INCREF_POOLED</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement IncRef() for a pooled class. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a13">SCF_IMPLEMENT_IBASE_DECREF_POOLED</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement DecRef() for a pooled class. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a14">SCF_IMPLEMENT_IBASE_POOLED</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this in the source module instead of <a class="el" href="group__scf.html#a34">SCF_IMPLEMENT_IBASE</a>. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a15">SCF_IMPLEMENT_DEFAULT_POOLRECYCLE</a>(Class)&nbsp;&nbsp;&nbsp;void Class::PoolRecycle () { }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement a default <em>Class::PoolRecycle()</em>. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a16">SCF_TRACE</a>(x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro for typing debug strings: Add #define SCF_DEBUG at the top of modules you want to track miscelaneous SCF activity and recompile. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a17">SCF_PRINT_CALL_ADDRESS</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro for getting the address we were called from (stack backtracing). </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a18">SCF_CONSTRUCT_VERSION</a>(Major, Minor, Micro)&nbsp;&nbsp;&nbsp;((Major &lt;&lt; 24) | (Minor &lt;&lt; 16) | Micro)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this macro to construct interface version numbers. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a21">SCF_DECLARE_IBASE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro should be embedded into any SCF-capable class definition to declare the minimal functionality required by <a class="el" href="structiBase.html">iBase</a> interface. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a22">SCF_DECLARE_EMBEDDED_IBASE</a>(OuterClass)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SCF_DECLARE_EMBEDDED_IBASE is used to declare the methods of <a class="el" href="structiBase.html">iBase</a> inside an embedded class that is exposed via QueryInterface... </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a23">SCF_CONSTRUCT_IBASE</a>(Parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_CONSTRUCT_IBASE macro should be invoked inside the constructor of a class (not inside an embedded interface). </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a24">SCF_CONSTRUCT_EMBEDDED_IBASE</a>(Interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_CONSTRUCT_EMBEDDED_IBASE macro should be invoked inside the constructor of a class that has an embedded interface (not inside the constructor of the embedded interface). </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a25">SCF_DESTRUCT_IBASE</a>()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_DESTRUCT_IBASE macro should be invoked inside the destructor of a class (not inside an embedded interface). </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a26">SCF_DESTRUCT_EMBEDDED_IBASE</a>(Interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_DESTRUCT_EMBEDDED_IBASE macro should be invoked inside the destructor of a class that has an embedded interface (not inside the destructor of the embedded interface). </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a27">SCF_IMPLEMENT_IBASE_INCREF</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a27">SCF_IMPLEMENT_IBASE_INCREF()</a> macro implements the IncRef() method for a class in a C++ source module. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a28">SCF_IMPLEMENT_IBASE_DECREF</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a28">SCF_IMPLEMENT_IBASE_DECREF()</a> macro implements the DecRef() method for a class in a C++ source module. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a29">SCF_IMPLEMENT_IBASE_REMOVE_REF_OWNERS</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a29">SCF_IMPLEMENT_IBASE_REMOVE_REF_OWNERS()</a> macro implements the scfRemoveRefOwners() method for a class in a C++ source module. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a30">SCF_IMPLEMENT_IBASE_REFOWNER</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a30">SCF_IMPLEMENT_IBASE_REFOWNER()</a> macro implements the AddRefOwner() and RemoveRefOwner() for a weak reference. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a31">SCF_IMPLEMENT_IBASE_GETREFCOUNT</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a31">SCF_IMPLEMENT_IBASE_GETREFCOUNT()</a> macro implements GetRefCount() for a class in a C++ source module. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a32">SCF_IMPLEMENT_IBASE_QUERY</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a32">SCF_IMPLEMENT_IBASE_QUERY()</a> macro implements the opening boilerplate for the QueryInterface() method for a class in a C++ source module. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a33">SCF_IMPLEMENT_IBASE_QUERY_END</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_IMPLEMENT_IBASE_QUERY_END macro implements the closing boilerplate for the QueryInterface() method for a class in a C++ source module. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a34">SCF_IMPLEMENT_IBASE</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a34">SCF_IMPLEMENT_IBASE()</a> macro should be used within the C++ source module that implements a interface derived from <a class="el" href="structiBase.html">iBase</a>. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a35">SCF_IMPLEMENT_IBASE_END</a>&nbsp;&nbsp;&nbsp;SCF_IMPLEMENT_IBASE_QUERY_END</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_IMPLEMENT_IBASE_END macro is used to finish an SCF_IMPLEMENT_IBASE definition. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a36">SCF_IMPLEMENT_EMBEDDED_IBASE_INCREF</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a36">SCF_IMPLEMENT_EMBEDDED_IBASE_INCREF()</a> macro implements the IncRef() method for an embedded class in a C++ source module. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a37">SCF_IMPLEMENT_EMBEDDED_IBASE_DECREF</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a37">SCF_IMPLEMENT_EMBEDDED_IBASE_DECREF()</a> macro implements the DecRef() method for an embedded class in a C++ source module. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a38">SCF_IMPLEMENT_EMBEDDED_IBASE_GETREFCOUNT</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a38">SCF_IMPLEMENT_EMBEDDED_IBASE_GETREFCOUNT()</a> macro implements the GetRefCount() method for an embedded class in a C++ source module. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a39">SCF_IMPLEMENT_EMBEDDED_IBASE_REFOWNER</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a39">SCF_IMPLEMENT_EMBEDDED_IBASE_REFOWNER()</a> macro implements the AddRefOwner() and RemoveRefOwner() for a weak reference. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a40">SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a40">SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY()</a> macro implements the opening boilerplate for the QueryInterface() method for an embedded class in a C++ source module. </em> <a href="#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a41">SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY_END</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY_END macro implements the closing boilerplate for the QueryInterface() method for a class in an embedded C++ source module. </em> <a href="#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a42">SCF_IMPLEMENT_EMBEDDED_IBASE</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SCF_IMPLEMENT_EMBEDDED_IBASE should be used to implement embedded interfaces derived from <a class="el" href="structiBase.html">iBase</a>. </em> <a href="#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a43">SCF_IMPLEMENT_EMBEDDED_IBASE_END</a>&nbsp;&nbsp;&nbsp;SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY_END</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_IMPLEMENT_EMBEDDED_IBASE_END macro is used to finish an SCF_IMPLEMENT_EMBEDDED_IBASE definition. </em> <a href="#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a44">SCF_IMPLEMENTS_INTERFACE</a>(Interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The IMPLEMENT_INTERFACE macro is used inside QueryInterface function to check if user requested a specific interface, whenever requested version of the interface correspond to the version we have and to return a pointer to that interface if everything is correct. </em> <a href="#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a45">SCF_IMPLEMENTS_EMBEDDED_INTERFACE</a>(Interface)&nbsp;&nbsp;&nbsp;SCF_IMPLEMENTS_INTERFACE_COMMON (Interface, (&amp;scf##Interface))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IMPLEMENT_EMBEDDED_INTERFACE is same as IMPLEMENT_INTERFACE but is used when class implements the interface as an embedded member. </em> <a href="#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a46">SCF_IMPLEMENTS_INTERFACE_COMMON</a>(Interface, Object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a common macro used in all IMPLEMENTS_XXX_INTERFACE macros. </em> <a href="#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a47">SCF_DECLARE_IBASE_EXT</a>(ParentClass)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The following macro is used in "expansion SCF classes". </em> <a href="#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a48">SCF_IMPLEMENT_IBASE_EXT_INCREF</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a48">SCF_IMPLEMENT_IBASE_EXT_INCREF()</a> macro implements the IncRef() method for a class extending another SCF class in a C++ source module. </em> <a href="#a48"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a49">SCF_IMPLEMENT_IBASE_EXT_DECREF</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a49">SCF_IMPLEMENT_IBASE_EXT_DECREF()</a> macro implements the DecRef() method for a class extending another SCF class in a C++ source module. </em> <a href="#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a50">SCF_IMPLEMENT_IBASE_EXT_GETREFCOUNT</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a50">SCF_IMPLEMENT_IBASE_EXT_GETREFCOUNT()</a> macro implements the GetRefCount() method for a class extending another SCF class in a C++ source module. </em> <a href="#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a51">SCF_IMPLEMENT_IBASE_EXT_REFOWNER</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a51">SCF_IMPLEMENT_IBASE_EXT_REFOWNER()</a> macro implements the AddRefOwner() and RemoveRefOwner() for a weak reference. </em> <a href="#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a52">SCF_IMPLEMENT_IBASE_EXT_QUERY</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="group__scf.html#a52">SCF_IMPLEMENT_IBASE_EXT_QUERY()</a> macro implements the opening boilerplate for the QueryInterface() method for a class extending another SCF class in a C++ source module. </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a53">SCF_IMPLEMENT_IBASE_EXT_QUERY_END</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_IMPLEMENT_IBASE_EXT_QUERY_END macro implements the closing boilerplate for the QueryInterface() method for a class extending another SCF class in a C++ source module. </em> <a href="#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a54">SCF_IMPLEMENT_IBASE_EXT</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro implements same functionality as SCF_IMPLEMENT_IBASE except that it should be used for expansion SCF classes. </em> <a href="#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a55">SCF_IMPLEMENT_IBASE_EXT_END</a>&nbsp;&nbsp;&nbsp;SCF_IMPLEMENT_IBASE_EXT_QUERY_END</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro implements same functionality as SCF_IMPLEMENT_IBASE_END except that it is used for expansion SCF classes. </em> <a href="#a55"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a56">SCF_IMPLEMENT_FACTORY_INIT</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_IMPLEMENT_FACTORY_INIT macro defines initialization code for a plugin module. </em> <a href="#a56"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a57">SCF_IMPLEMENT_FACTORY_FINIS</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_IMPLEMENT_FACTORY_FINIS macro defines finalization code for a plugin module. </em> <a href="#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a58">SCF_IMPLEMENT_FACTORY_CREATE</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_IMPLEMENT_FACTORY_CREATE macro is used to define a factory for one of exported classes. </em> <a href="#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a59">SCF_IMPLEMENT_FACTORY</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The SCF_IMPLEMENT_FACTORY macro is used to define a factory for one of exported classes. </em> <a href="#a59"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a61">SCF_REGISTER_STATIC_CLASS</a>(Class, Ident, Desc, Dep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically register a built-in class with SCF during startup. </em> <a href="#a61"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a62">SCF_REGISTER_STATIC_LIBRARY</a>(Module, MetaInfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically register a static library with SCF during startup. </em> <a href="#a62"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a63">SCF_REGISTER_FACTORY_FUNC</a>(Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used in conjunction with SCF_REGISTER_STATIC_LIBRARY to ensure that a reference to the class(s) registered via SCF_REGISTER_STATIC_LIBRARY are actually linked into the application. </em> <a href="#a63"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a64">SCF_CREATE_INSTANCE</a>(ClassID, Interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handy macro to create an instance of a shared class. </em> <a href="#a64"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a65">SCF_VERSION</a>(Name, Major, Minor, Micro)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SCF_VERSION can be used to define an interface's version number; you should specify interface name and major, minor and micro version components. </em> <a href="#a65"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a66">SCF_QUERY_INTERFACE</a>(Object, Interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shortcut macro to query given interface from given object. </em> <a href="#a66"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a67">SCF_QUERY_INTERFACE_SAFE</a>(Object, Interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shortcut macro to query given interface from given object. </em> <a href="#a67"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a71">CS_QUERY_PLUGIN_CLASS</a>(Object, ClassID, Interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a plugin by its class ID. </em> <a href="#a71"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a72">CS_LOAD_PLUGIN</a>(Object, ClassID, Interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell plugin manager to load a plugin. </em> <a href="#a72"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a73">CS_LOAD_PLUGIN_ALWAYS</a>(Object, ClassID)&nbsp;&nbsp;&nbsp;<a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiBase.html">iBase</a>&gt; ((Object)-&gt;LoadPlugin (ClassID, 0, 0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="group__scf.html#a72">CS_LOAD_PLUGIN()</a> but does nott bother asking for a interface. </em> <a href="#a73"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a74">CS_QUERY_REGISTRY_PLUGIN</a>(obj, object_reg, scf_id, interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this macro to query the object registry, loading a plugin if needed. </em> <a href="#a74"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a0">scfInterfaceID</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of registered interface handle used by <a class="el" href="structiBase.html#a3">iBase::QueryInterface()</a>. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef void *(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a1">scfFactoryFunc</a> )(<a class="el" href="structiBase.html">iBase</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of factory function which creates an instance of an SCF class. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a2">scfInitialize</a> (<a class="el" href="classcsPluginPaths.html">csPluginPaths</a> *pluginPaths, bool verbose=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should be called to initialize client SCF library. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a3">scfInitialize</a> (int argc, const char *const argv[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should be called to initialize client SCF library. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__scf.html#a4">scfCompatibleVersion</a> (int iVersion, int iItfVersion)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function checks whenever an interface is compatible with given version. </em> <a href="#a4"></a><em><br><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a name="a72" doxytag="plugin.h::CS_LOAD_PLUGIN"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CS_LOAD_PLUGIN</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Object,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ClassID,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Interface&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="classcsPtr.html">csPtr&lt;Interface&gt;</a> ((Interface *)((Object)-&gt;LoadPlugin                    \
  (ClassID, #Interface, <a class="code" href="classscfInterface.html#e0">scfInterface&lt;Interface&gt;::GetVersion</a>())))
</pre></div>Tell plugin manager to load a plugin. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Object</em>&nbsp;</td><td>An object that implements <a class="el" href="structiPluginManager.html">iPluginManager</a>. </td></tr>
    <tr><td valign=top><em>ClassID</em>&nbsp;</td><td>The SCF class name (ex. crystalspace.graphics3d.software). </td></tr>
    <tr><td valign=top><em>Interface</em>&nbsp;</td><td>Desired nterface name (ex. <a class="el" href="structiGraphics2D.html">iGraphics2D</a>, <a class="el" href="structiVFS.html">iVFS</a>, etc.). </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="plugin_8h-source.html#l00056">56</a> of file <a class="el" href="plugin_8h-source.html">plugin.h</a>.    </td>
  </tr>
</table>
<a name="a73" doxytag="plugin.h::CS_LOAD_PLUGIN_ALWAYS"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CS_LOAD_PLUGIN_ALWAYS</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Object,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ClassID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;<a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiBase.html">iBase</a>&gt; ((Object)-&gt;LoadPlugin (ClassID, 0, 0))
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="group__scf.html#a72">CS_LOAD_PLUGIN()</a> but does nott bother asking for a interface. 
<p>
This is useful for unconditionally loading plugins. 
<p>
Definition at line <a class="el" href="plugin_8h-source.html#l00064">64</a> of file <a class="el" href="plugin_8h-source.html">plugin.h</a>.    </td>
  </tr>
</table>
<a name="a71" doxytag="plugin.h::CS_QUERY_PLUGIN_CLASS"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CS_QUERY_PLUGIN_CLASS</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Object,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ClassID,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Interface&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="classcsPtr.html">csPtr&lt;Interface&gt;</a> ((Interface *)((Object)-&gt;QueryPlugin                   \
  (ClassID, #Interface, <a class="code" href="classscfInterface.html#e0">scfInterface&lt;Interface&gt;::GetVersion</a>())))
</pre></div>Find a plugin by its class ID. 
<p>
First the plugin with requested class identifier is found, and after this it is queried for the respective interface; if it does not implement the requested interface, 0 is returned. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Object</em>&nbsp;</td><td>An object that implements <a class="el" href="structiPluginManager.html">iPluginManager</a>. </td></tr>
    <tr><td valign=top><em>ClassID</em>&nbsp;</td><td>The SCF class name (ex. crystalspace.graphics3d.software). </td></tr>
    <tr><td valign=top><em>Interface</em>&nbsp;</td><td>Desired nterface name (ex. <a class="el" href="structiGraphics2D.html">iGraphics2D</a>, <a class="el" href="structiVFS.html">iVFS</a>, etc.). </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="plugin_8h-source.html#l00046">46</a> of file <a class="el" href="plugin_8h-source.html">plugin.h</a>.    </td>
  </tr>
</table>
<a name="a74" doxytag="plugin.h::CS_QUERY_REGISTRY_PLUGIN"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CS_QUERY_REGISTRY_PLUGIN</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">obj,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>object_reg,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>scf_id,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>interface&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordflow">do</span> { \
  obj = CS_QUERY_REGISTRY(object_reg, interface); \
  <span class="keywordflow">if</span> (!obj.IsValid()) \
  { \
    <a class="code" href="classcsRef.html">csRef&lt;iPluginManager&gt;</a> mgr = CS_QUERY_REGISTRY(object_reg,<a class="code" href="structiPluginManager.html">iPluginManager</a>); \
    <span class="keywordflow">if</span> (!mgr.<a class="code" href="classcsRef.html#a14">IsValid</a>()) \
    { \
      <a class="code" href="group__util.html#a127">csReport</a>(object_reg, CS_REPORTER_SEVERITY_ERROR, \
        <span class="stringliteral">"crystalspace.plugin.query"</span>, <span class="stringliteral">"Plugin manager missing from "</span> \
        <span class="stringliteral">"object-registry when attempting to query/load class: %s"</span>, scf_id); \
    } \
    obj = <a class="code" href="group__scf.html#a72">CS_LOAD_PLUGIN</a>(mgr, scf_id, interface); \
    <span class="keywordflow">if</span> (!obj.IsValid()) \
    { \
      <a class="code" href="group__util.html#a127">csReport</a>(object_reg, CS_REPORTER_SEVERITY_WARNING, \
        <span class="stringliteral">"crystalspace.plugin.query"</span>, <span class="stringliteral">"Failed to load class \"%s\" with "</span> \
        <span class="stringliteral">"interface \""</span> #interface <span class="stringliteral">"\""</span>, scf_id); \
    } \
    <span class="keywordflow">if</span> (!object_reg-&gt;Register(obj, #interface)) \
    { \
      <a class="code" href="group__util.html#a127">csReport</a>(object_reg, CS_REPORTER_SEVERITY_WARNING, \
        <span class="stringliteral">"crystalspace.plugin.query"</span>, <span class="stringliteral">"Failed to register class \"%s\" with "</span> \
        <span class="stringliteral">"tag \""</span> #interface <span class="stringliteral">"\" in the object-registry."</span>, scf_id); \
    } \
  } \
} <span class="keywordflow">while</span> (0)
</pre></div>Use this macro to query the object registry, loading a plugin if needed. 
<p>
If an object with a given interface exists in an object registry, get that object from the registry. If the registry query fails, try to load a plugin and get the interface from there. If that succeeds, the interface is added to the registry for future use and given a tag the same name as the requested interface. Example use:<p>
<div class="fragment"><pre> <a class="code" href="classcsRef.html">csRef</a>\&lt;<a class="code" href="structiDynamics.html">iDynamics</a>\&gt; dynamic_system;
 <a class="code" href="group__scf.html#a74">CS_QUERY_REGISTRY_PLUGIN</a>(dynamic_system, object_reg, 
   <span class="stringliteral">"crystalspace.dynamics.ode"</span>, <a class="code" href="structiDynamics.html">iDynamics</a>);
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>obj</em>&nbsp;</td><td><a class="el" href="classcsRef.html">csRef</a> to hold the discovered or created/loaded object. </td></tr>
    <tr><td valign=top><em>object_reg</em>&nbsp;</td><td>The object registry (of type <a class="el" href="structiObjectRegistry.html">iObjectRegistry</a>). </td></tr>
    <tr><td valign=top><em>scf_id</em>&nbsp;</td><td>The requested SCF class name (ex. "crystalspace.dynamice.ode") </td></tr>
    <tr><td valign=top><em>interface</em>&nbsp;</td><td>The interface to requested from class scf_id (ex. <a class="el" href="structiDynamics.html">iDynamics</a>). This argument is also stringified and used as the objects tag in the registry. </td></tr>
  </table>
</dl>
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>This probably ought to be made more thread-safe by locking the object registry if possible. </dd></dl>

<p>
Definition at line <a class="el" href="plugin_8h-source.html#l00090">90</a> of file <a class="el" href="plugin_8h-source.html">plugin.h</a>.    </td>
  </tr>
</table>
<a name="a24" doxytag="scf.h::SCF_CONSTRUCT_EMBEDDED_IBASE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_CONSTRUCT_EMBEDDED_IBASE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Interface&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>Interface.scfParent = <span class="keyword">this</span>;                                             \
  csRefTrackerAccess::AddAlias (&amp;Interface, <span class="keyword">this</span>);
</pre></div>The SCF_CONSTRUCT_EMBEDDED_IBASE macro should be invoked inside the constructor of a class that has an embedded interface (not inside the constructor of the embedded interface). 
<p>
The macro will initialize the pointer to the parent object (to the object this one is embedded into). The argument to this macro is the name of the parent's instance variable by which the embedded object is known (typically something like `scfiFooBar'). 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00163">163</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a23" doxytag="scf.h::SCF_CONSTRUCT_IBASE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_CONSTRUCT_IBASE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Parent&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>csRefTrackerAccess::TrackConstruction (<span class="keyword">this</span>);                           \
  csRefTrackerAccess::SetDescription (<span class="keyword">this</span>, CS_TYPENAME(*<span class="keyword">this</span>));        \
  scfRefCount = 1;                                                      \
  scfWeakRefOwners = 0;                                                 \
  scfParent = Parent; <span class="keywordflow">if</span> (scfParent) scfParent-&gt;IncRef();               \
  SCF_INIT_TRACKER_ALIASES
</pre></div>The SCF_CONSTRUCT_IBASE macro should be invoked inside the constructor of a class (not inside an embedded interface). 
<p>
Normally each constructor should accept an iBase* parameter (that is passed by scfCreateInstance function) which should be passed to this macro. The macro will zero the reference count and initialize the pointer to the parent object. If the object is unparented (a common case), it is okay to use null as the argument to this macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00146">146</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.
<p>
Referenced by <a class="el" href="databuf_8h-source.html#l00045">csDataBuffer::csDataBuffer()</a>, <a class="el" href="csgeom_2path_8h-source.html#l00070">csPath::csPath()</a>, <a class="el" href="csgeom_2polymesh_8h-source.html#l00067">csPolygonMesh::csPolygonMesh()</a>, <a class="el" href="csgeom_2polymesh_8h-source.html#l00221">csPolygonMeshBox::csPolygonMeshBox()</a>, <a class="el" href="scfstrset_8h-source.html#l00040">csScfStringSet::csScfStringSet()</a>, <a class="el" href="scfstr_8h-source.html#l00036">scfString::scfString()</a>, and <a class="el" href="scfstringarray_8h-source.html#l00036">scfStringArray::scfStringArray()</a>.    </td>
  </tr>
</table>
<a name="a6" doxytag="pooledscfclass.h::SCF_CONSTRUCT_IBASE_POOLED"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_CONSTRUCT_IBASE_POOLED</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="group__scf.html#a23">SCF_CONSTRUCT_IBASE</a>(0);                         \
  poolNext = 0;                                         \
  scfPool = (Pool);
</pre></div>Has to be invoked inside the class constructor instead of <a class="el" href="group__scf.html#a23">SCF_CONSTRUCT_IBASE</a>. 
<p>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00078">78</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a18" doxytag="scf.h::SCF_CONSTRUCT_VERSION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_CONSTRUCT_VERSION</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Major,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Minor,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Micro&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;((Major &lt;&lt; 24) | (Minor &lt;&lt; 16) | Micro)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Use this macro to construct interface version numbers. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00069">69</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a64" doxytag="scf.h::SCF_CREATE_INSTANCE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_CREATE_INSTANCE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ClassID,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Interface&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="classcsPtr.html">csPtr&lt;Interface&gt;</a> (                                                    \
    (Interface *)<a class="code" href="structiSCF.html#s0">iSCF::SCF</a>-&gt;<a class="code" href="structiSCF.html#a4">CreateInstance</a> (                            \
    ClassID, #Interface, <a class="code" href="classscfInterface.html">scfInterface&lt;Interface&gt;</a>::GetVersion()))
</pre></div>Handy macro to create an instance of a shared class. 
<p>
This is a simple wrapper around scfCreateInstance. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00723">723</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a22" doxytag="scf.h::SCF_DECLARE_EMBEDDED_IBASE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_DECLARE_EMBEDDED_IBASE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OuterClass&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">public</span>:                                                                 \
  OuterClass *scfParent;                                \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> IncRef ();                                               \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> DecRef ();                                               \
  <span class="keyword">virtual</span> <span class="keywordtype">int</span> GetRefCount ();                                           \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> AddRefOwner (<a class="code" href="structiBase.html">iBase</a>** ref_owner);                         \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> RemoveRefOwner (<a class="code" href="structiBase.html">iBase</a>** ref_owner);                      \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> *QueryInterface (scfInterfaceID iInterfaceID, <span class="keywordtype">int</span> iVersion)
</pre></div>SCF_DECLARE_EMBEDDED_IBASE is used to declare the methods of <a class="el" href="structiBase.html">iBase</a> inside an embedded class that is exposed via QueryInterface... 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00127">127</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a21" doxytag="scf.h::SCF_DECLARE_IBASE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_DECLARE_IBASE
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">int</span> scfRefCount;                                        \
  <a class="code" href="classcsArray.html">csArray&lt;iBase**&gt;</a>* scfWeakRefOwners;                                   \
  <span class="keywordtype">void</span> scfRemoveRefOwners ();                                           \
  <a class="code" href="group__scf.html#a22">SCF_DECLARE_EMBEDDED_IBASE</a> (<a class="code" href="structiBase.html">iBase</a>)
</pre></div>This macro should be embedded into any SCF-capable class definition to declare the minimal functionality required by <a class="el" href="structiBase.html">iBase</a> interface. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00117">117</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a47" doxytag="scf.h::SCF_DECLARE_IBASE_EXT"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_DECLARE_IBASE_EXT</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ParentClass&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">typedef</span> ParentClass __scf_superclass;                                   \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> IncRef ();                                               \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> DecRef ();                                               \
  <span class="keyword">virtual</span> <span class="keywordtype">int</span> GetRefCount ();                                           \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> AddRefOwner (<a class="code" href="structiBase.html">iBase</a>** ref_owner);                         \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> RemoveRefOwner (<a class="code" href="structiBase.html">iBase</a>** ref_owner);                      \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> *QueryInterface (scfInterfaceID iInterfaceID, <span class="keywordtype">int</span> iVersion)
</pre></div>The following macro is used in "expansion SCF classes". 
<p>
An expansion class is a class that extends the functionality of another SCF class. For example, suppose a class TheWolf that implements the iWolf interface. Separately it is a useful class per se, but if you want to implement an additional class TheDog that is a subclass of TheWolf and which implements an additional interface iDog in theory you should just override the QueryInterface method and return the corresponding pointer when asked. The following macro makes such overrides simpler to write. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00451">451</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a5" doxytag="pooledscfclass.h::SCF_DECLARE_IBASE_POOLED"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_DECLARE_IBASE_POOLED</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">parentClass&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="group__scf.html#a21">SCF_DECLARE_IBASE</a>;                                      \
  <span class="keyword">class </span>Pool                                            \
  {                                                     \
    parentClass* pool;                                  \
  <span class="keyword">public</span>:                                               \
    Pool ();                                            \
    ~Pool ();                                           \
    parentClass* Alloc ();                              \
    <span class="keywordtype">void</span> Recycle (parentClass* instance);               \
  };                                                    \
  <span class="keyword">friend</span> <span class="keyword">class </span>Pool;                                    \
  Pool* scfPool;                                        \
  parentClass* poolNext;                                \
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> PoolRecycle ();                          \
</pre></div>Embed this macro instead of <a class="el" href="group__scf.html#a21">SCF_DECLARE_IBASE</a> into an SCF class that is to be pooled. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>To obtain an instance of <em>Class</em>, create an instance of <em>Class::Pool</em> and use it's Alloc() method, e.g.: <div class="fragment"><pre>  csFoo::Pool fooPool;
  ...
  csFoo* foo = fooPool.Alloc ();
</pre></div><p>
A pooled class <em>Class</em> must implement a constructor with the following prototype: <div class="fragment"><pre>   Class (Pool* pool);
</pre></div><p>
Inside the constructor, <a class="el" href="group__scf.html#a6">SCF_CONSTRUCT_IBASE_POOLED</a> needs to be called. <p>
If you need to set instance-specific data, you need to provide a custom method for that. <p>
You have to provide a method <div class="fragment"><pre> <span class="keywordtype">void</span> PoolRecycle (); 
</pre></div>to clean up instance-specific data (as due the pooling the destructor will not be called if all references are cleared). The <a class="el" href="group__scf.html#a15">SCF_IMPLEMENT_DEFAULT_POOLRECYCLE</a> macro contains a default (empty) implementation. </dd></dl>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00058">58</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a26" doxytag="scf.h::SCF_DESTRUCT_EMBEDDED_IBASE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_DESTRUCT_EMBEDDED_IBASE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Interface&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>csRefTrackerAccess::RemoveAlias (&amp;Interface, <span class="keyword">this</span>);                     \
  Interface.scfParent = 0;
</pre></div>The SCF_DESTRUCT_EMBEDDED_IBASE macro should be invoked inside the destructor of a class that has an embedded interface (not inside the destructor of the embedded interface). 
<p>
It reverses the initialization performed by the <a class="el" href="group__scf.html#a24">SCF_CONSTRUCT_EMBEDDED_IBASE()</a> macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00182">182</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a25" doxytag="scf.h::SCF_DESTRUCT_IBASE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_DESTRUCT_IBASE</td>
          <td class="md" valign="top">(&nbsp;</td>
&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>csRefTrackerAccess::TrackDestruction (<span class="keyword">this</span>, scfRefCount);               \
  scfRemoveRefOwners ();
</pre></div>The SCF_DESTRUCT_IBASE macro should be invoked inside the destructor of a class (not inside an embedded interface). 
<p>
It reverses the initialization performed by the <a class="el" href="group__scf.html#a23">SCF_CONSTRUCT_IBASE()</a> macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00172">172</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.
<p>
Referenced by <a class="el" href="databuf_8h-source.html#l00074">csDataBuffer::~csDataBuffer()</a>, <a class="el" href="csgeom_2path_8h-source.html#l00076">csPath::~csPath()</a>, <a class="el" href="scfstrset_8h-source.html#l00048">csScfStringSet::~csScfStringSet()</a>, <a class="el" href="scfstr_8h-source.html#l00052">scfString::~scfString()</a>, and <a class="el" href="scfstringarray_8h-source.html#l00040">scfStringArray::~scfStringArray()</a>.    </td>
  </tr>
</table>
<a name="a15" doxytag="pooledscfclass.h::SCF_IMPLEMENT_DEFAULT_POOLRECYCLE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_DEFAULT_POOLRECYCLE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;void Class::PoolRecycle () { }
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Implement a default <em>Class::PoolRecycle()</em>. 
<p>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00182">182</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a42" doxytag="scf.h::SCF_IMPLEMENT_EMBEDDED_IBASE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_EMBEDDED_IBASE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="group__scf.html#a36">SCF_IMPLEMENT_EMBEDDED_IBASE_INCREF</a>(Class)                              \
  <a class="code" href="group__scf.html#a37">SCF_IMPLEMENT_EMBEDDED_IBASE_DECREF</a>(Class)                            \
  <a class="code" href="group__scf.html#a38">SCF_IMPLEMENT_EMBEDDED_IBASE_GETREFCOUNT</a>(Class)                       \
  <a class="code" href="group__scf.html#a39">SCF_IMPLEMENT_EMBEDDED_IBASE_REFOWNER</a>(Class)                          \
  <a class="code" href="group__scf.html#a40">SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY</a>(Class)
</pre></div>SCF_IMPLEMENT_EMBEDDED_IBASE should be used to implement embedded interfaces derived from <a class="el" href="structiBase.html">iBase</a>. 
<p>
It differs from SCF_IMPLEMENT_IBASE because embedded interface don't have reference counts themselves, but instead use the reference count of their parent object. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00396">396</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a37" doxytag="scf.h::SCF_IMPLEMENT_EMBEDDED_IBASE_DECREF"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_EMBEDDED_IBASE_DECREF</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::DecRef ()                                                   \
{                                                                       \
  <a class="code" href="group__scf.html#a16">SCF_TRACE</a> ((<span class="stringliteral">"  (%s *)%p-&gt;DecRef (%d)\n"</span>, #Class, <span class="keyword">this</span>,                \
              scfParent-&gt;GetRefCount ()-1));                            \
  scfParent-&gt;DecRef ();                                                 \
}
</pre></div>The <a class="el" href="group__scf.html#a37">SCF_IMPLEMENT_EMBEDDED_IBASE_DECREF()</a> macro implements the DecRef() method for an embedded class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a42">SCF_IMPLEMENT_EMBEDDED_IBASE()</a> convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00336">336</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a43" doxytag="scf.h::SCF_IMPLEMENT_EMBEDDED_IBASE_END"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_EMBEDDED_IBASE_END&nbsp;&nbsp;&nbsp;SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY_END
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The SCF_IMPLEMENT_EMBEDDED_IBASE_END macro is used to finish an SCF_IMPLEMENT_EMBEDDED_IBASE definition. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00407">407</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a38" doxytag="scf.h::SCF_IMPLEMENT_EMBEDDED_IBASE_GETREFCOUNT"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_EMBEDDED_IBASE_GETREFCOUNT</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">int</span> Class::GetRefCount ()                                               \
{                                                                       \
  <span class="keywordflow">return</span> scfParent-&gt;GetRefCount ();                                     \
}
</pre></div>The <a class="el" href="group__scf.html#a38">SCF_IMPLEMENT_EMBEDDED_IBASE_GETREFCOUNT()</a> macro implements the GetRefCount() method for an embedded class in a C++ source module. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00348">348</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a36" doxytag="scf.h::SCF_IMPLEMENT_EMBEDDED_IBASE_INCREF"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_EMBEDDED_IBASE_INCREF</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::IncRef ()                                                   \
{                                                                       \
  <a class="code" href="group__scf.html#a16">SCF_TRACE</a> ((<span class="stringliteral">"  (%s *)%p-&gt;IncRef (%d)\n"</span>, #Class, <span class="keyword">this</span>,                \
    scfParent-&gt;GetRefCount () + 1));                                    \
  scfParent-&gt;IncRef ();                                                 \
}
</pre></div>The <a class="el" href="group__scf.html#a36">SCF_IMPLEMENT_EMBEDDED_IBASE_INCREF()</a> macro implements the IncRef() method for an embedded class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a42">SCF_IMPLEMENT_EMBEDDED_IBASE()</a> convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00322">322</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a40" doxytag="scf.h::SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> *Class::QueryInterface (scfInterfaceID iInterfaceID, <span class="keywordtype">int</span> iVersion) \
{                                                                       \
  <a class="code" href="group__scf.html#a16">SCF_TRACE</a> ((<span class="stringliteral">"  (%s *)%p-&gt;QueryInterface (%u, %08X)\n"</span>,                \
    #Class, <span class="keyword">this</span>, iInterfaceID, iVersion));
</pre></div>The <a class="el" href="group__scf.html#a40">SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY()</a> macro implements the opening boilerplate for the QueryInterface() method for an embedded class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a42">SCF_IMPLEMENT_EMBEDDED_IBASE()</a> convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00374">374</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a41" doxytag="scf.h::SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY_END"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY_END
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordflow">return</span> scfParent-&gt;QueryInterface (iInterfaceID, iVersion);              \
}
</pre></div>The SCF_IMPLEMENT_EMBEDDED_IBASE_QUERY_END macro implements the closing boilerplate for the QueryInterface() method for a class in an embedded C++ source module. 
<p>
Typically, this macro is automatically employed by the SCF_IMPLEMENT_EMBEDDED_IBASE_END convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00386">386</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a39" doxytag="scf.h::SCF_IMPLEMENT_EMBEDDED_IBASE_REFOWNER"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_EMBEDDED_IBASE_REFOWNER</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::AddRefOwner (<a class="code" href="structiBase.html">iBase</a>** ref_owner)                             \
{                                                                       \
  scfParent-&gt;AddRefOwner (ref_owner);                                   \
}                                                                       \
<span class="keywordtype">void</span> Class::RemoveRefOwner (<a class="code" href="structiBase.html">iBase</a>** ref_owner)                          \
{                                                                       \
  scfParent-&gt;RemoveRefOwner (ref_owner);                                \
}
</pre></div>The <a class="el" href="group__scf.html#a39">SCF_IMPLEMENT_EMBEDDED_IBASE_REFOWNER()</a> macro implements the AddRefOwner() and RemoveRefOwner() for a weak reference. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00358">358</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a59" doxytag="scf.h::SCF_IMPLEMENT_FACTORY"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_FACTORY</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="group__scf.html#a56">SCF_IMPLEMENT_FACTORY_INIT</a>(Class)                                       \
  <a class="code" href="group__scf.html#a57">SCF_IMPLEMENT_FACTORY_FINIS</a>(Class)                                    \
  <a class="code" href="group__scf.html#a58">SCF_IMPLEMENT_FACTORY_CREATE</a>(Class)
</pre></div>The SCF_IMPLEMENT_FACTORY macro is used to define a factory for one of exported classes. 
<p>
You can define the function manually, of course, if the constructor for your class has some specific constructor arguments (that is, more than one iBase* argument). 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00618">618</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a58" doxytag="scf.h::SCF_IMPLEMENT_FACTORY_CREATE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_FACTORY_CREATE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>CS_EXPORTED_FUNCTION                                                    \
<span class="keywordtype">void</span>* CS_EXPORTED_NAME(Class,_Create)(<a class="code" href="structiBase.html">iBase</a> *iParent)                   \
{                                                                       \
  <span class="keywordtype">void</span> *ret = <span class="keyword">new</span> Class (iParent);                                      \
  <a class="code" href="group__scf.html#a16">SCF_TRACE</a> ((<span class="stringliteral">"  %p = new %s ()\n"</span>, ret, #Class));                      \
  <span class="keywordflow">return</span> ret;                                                           \
}
</pre></div>The SCF_IMPLEMENT_FACTORY_CREATE macro is used to define a factory for one of exported classes. 
<p>
You can define the function manually, of course, if the constructor for your class has some specific constructor arguments (that is, more than one iBase* argument). 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00603">603</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a57" doxytag="scf.h::SCF_IMPLEMENT_FACTORY_FINIS"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_FACTORY_FINIS</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>CS_EXPORTED_FUNCTION                                                    \
<span class="keywordtype">void</span> CS_EXPORTED_NAME(Class,_scfFinalize)()                             \
{                                                                       \
<a class="code" href="cssysdef_8h.html#a21">CS_STATIC_VARIABLE_CLEANUP</a>                                              \
}
</pre></div>The SCF_IMPLEMENT_FACTORY_FINIS macro defines finalization code for a plugin module. 
<p>
As with SCF_IMPLEMENT_FACTORY_INIT, only one instance of this function will be invoked to finalize the module. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00590">590</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a56" doxytag="scf.h::SCF_IMPLEMENT_FACTORY_INIT"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_FACTORY_INIT</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> Class ## _scfUnitInitialize(<a class="code" href="structiSCF.html">iSCF</a>* SCF)               \
{ <a class="code" href="structiSCF.html#s0">iSCF::SCF</a> = SCF; }                                                    \
CS_EXPORTED_FUNCTION                                                    \
<span class="keywordtype">void</span> CS_EXPORTED_NAME(Class,_scfInitialize)(<a class="code" href="structiSCF.html">iSCF</a>* SCF)                  \
{ Class ## _scfUnitInitialize(SCF); }
</pre></div>The SCF_IMPLEMENT_FACTORY_INIT macro defines initialization code for a plugin module. 
<p>
This function should set the plugin-global <a class="el" href="structiSCF.html#s0">iSCF::SCF</a> variable, and otherwise initialize the plugin module. Although a version of this function will be created for each SCF factory exported by the plugin, SCF will call one, and only one, to perform the plugin initialization. The choice of which function will be invoked to initialize the plugin is an SCF implementation detail. You should not attempt to predict which class_scfInitialize() function will be used, nor should use try to sway SCF's choice. Implementation note: There are some rare instances where a particularly picky (and probably buggy) compiler does not allow C++ expressions within a function declared `extern "C"'. For this reason, the <a class="el" href="structiSCF.html#s0">iSCF::SCF</a> variable is instead initialized in the Class_scfUnitInitialize() function which is not qualified as `extern "C"'. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00577">577</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a34" doxytag="scf.h::SCF_IMPLEMENT_IBASE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="group__scf.html#a27">SCF_IMPLEMENT_IBASE_INCREF</a>(Class)                                       \
  <a class="code" href="group__scf.html#a28">SCF_IMPLEMENT_IBASE_DECREF</a>(Class)                                     \
  <a class="code" href="group__scf.html#a31">SCF_IMPLEMENT_IBASE_GETREFCOUNT</a>(Class)                                \
  <a class="code" href="group__scf.html#a30">SCF_IMPLEMENT_IBASE_REFOWNER</a>(Class)                                   \
  <a class="code" href="group__scf.html#a29">SCF_IMPLEMENT_IBASE_REMOVE_REF_OWNERS</a>(Class)                          \
  <a class="code" href="group__scf.html#a32">SCF_IMPLEMENT_IBASE_QUERY</a>(Class)
</pre></div>The <a class="el" href="group__scf.html#a34">SCF_IMPLEMENT_IBASE()</a> macro should be used within the C++ source module that implements a interface derived from <a class="el" href="structiBase.html">iBase</a>. 
<p>
Of course, you can still implement those methods manually, if you desire ... 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00301">301</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a28" doxytag="scf.h::SCF_IMPLEMENT_IBASE_DECREF"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_DECREF</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::DecRef ()                                                   \
{                                                                       \
  csRefTrackerAccess::TrackDecRef (<span class="keyword">this</span>, scfRefCount);                  \
  <span class="keywordflow">if</span> (scfRefCount == 1)                                                 \
  {                                                                     \
    <a class="code" href="group__scf.html#a16">SCF_TRACE</a> ((<span class="stringliteral">" delete (%s *)%p\n"</span>, #Class, <span class="keyword">this</span>));                   \
    scfRemoveRefOwners ();                                              \
    <span class="keywordflow">if</span> (scfParent)                                                      \
      scfParent-&gt;DecRef ();                                             \
    <span class="keyword">delete</span> <span class="keyword">this</span>;                                                        \
    <span class="keywordflow">return</span>;                                                             \
  }                                                                     \
  scfRefCount--;                                                        \
}
</pre></div>The <a class="el" href="group__scf.html#a28">SCF_IMPLEMENT_IBASE_DECREF()</a> macro implements the DecRef() method for a class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a34">SCF_IMPLEMENT_IBASE()</a> convenience macro. <p>
A note about the implementation: We do the "if" before the "scRefCount--" to make sure that calling Inc/DecRef doesn't result in a 2nd delete 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00207">207</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a13" doxytag="pooledscfclass.h::SCF_IMPLEMENT_IBASE_DECREF_POOLED"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_DECREF_POOLED</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::DecRef ()                                   \
{                                                       \
  <span class="keywordflow">if</span> (scfRefCount == 1)                                 \
  {                                                     \
    scfPool-&gt;Recycle (<span class="keyword">this</span>);                            \
    <span class="keywordflow">return</span>;                                             \
  }                                                     \
  scfRefCount--;                                        \
}
</pre></div>Implement DecRef() for a pooled class. 
<p>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00156">156</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a35" doxytag="scf.h::SCF_IMPLEMENT_IBASE_END"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_END&nbsp;&nbsp;&nbsp;SCF_IMPLEMENT_IBASE_QUERY_END
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The SCF_IMPLEMENT_IBASE_END macro is used to finish an SCF_IMPLEMENT_IBASE definition. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00313">313</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a54" doxytag="scf.h::SCF_IMPLEMENT_IBASE_EXT"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_EXT</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="group__scf.html#a48">SCF_IMPLEMENT_IBASE_EXT_INCREF</a>(Class)                                   \
  <a class="code" href="group__scf.html#a49">SCF_IMPLEMENT_IBASE_EXT_DECREF</a>(Class)                                 \
  <a class="code" href="group__scf.html#a50">SCF_IMPLEMENT_IBASE_EXT_GETREFCOUNT</a>(Class)                            \
  <a class="code" href="group__scf.html#a51">SCF_IMPLEMENT_IBASE_EXT_REFOWNER</a>(Class)                               \
  <a class="code" href="group__scf.html#a52">SCF_IMPLEMENT_IBASE_EXT_QUERY</a>(Class)
</pre></div>This macro implements same functionality as SCF_IMPLEMENT_IBASE except that it should be used for expansion SCF classes. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00534">534</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a49" doxytag="scf.h::SCF_IMPLEMENT_IBASE_EXT_DECREF"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_EXT_DECREF</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::DecRef ()                                                   \
{                                                                       \
  __scf_superclass::DecRef ();                                          \
}
</pre></div>The <a class="el" href="group__scf.html#a49">SCF_IMPLEMENT_IBASE_EXT_DECREF()</a> macro implements the DecRef() method for a class extending another SCF class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a54">SCF_IMPLEMENT_IBASE_EXT()</a> convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00478">478</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a55" doxytag="scf.h::SCF_IMPLEMENT_IBASE_EXT_END"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_EXT_END&nbsp;&nbsp;&nbsp;SCF_IMPLEMENT_IBASE_EXT_QUERY_END
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro implements same functionality as SCF_IMPLEMENT_IBASE_END except that it is used for expansion SCF classes. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00545">545</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a50" doxytag="scf.h::SCF_IMPLEMENT_IBASE_EXT_GETREFCOUNT"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_EXT_GETREFCOUNT</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">int</span> Class::GetRefCount ()                                               \
{                                                                       \
  <span class="keywordflow">return</span> __scf_superclass::GetRefCount ();                              \
}
</pre></div>The <a class="el" href="group__scf.html#a50">SCF_IMPLEMENT_IBASE_EXT_GETREFCOUNT()</a> macro implements the GetRefCount() method for a class extending another SCF class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a54">SCF_IMPLEMENT_IBASE_EXT()</a> convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00490">490</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a48" doxytag="scf.h::SCF_IMPLEMENT_IBASE_EXT_INCREF"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_EXT_INCREF</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::IncRef ()                                                   \
{                                                                       \
  __scf_superclass::IncRef ();                                          \
}
</pre></div>The <a class="el" href="group__scf.html#a48">SCF_IMPLEMENT_IBASE_EXT_INCREF()</a> macro implements the IncRef() method for a class extending another SCF class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a54">SCF_IMPLEMENT_IBASE_EXT()</a> convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00466">466</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a52" doxytag="scf.h::SCF_IMPLEMENT_IBASE_EXT_QUERY"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_EXT_QUERY</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> *Class::QueryInterface (scfInterfaceID iInterfaceID, <span class="keywordtype">int</span> iVersion) \
{
</pre></div>The <a class="el" href="group__scf.html#a52">SCF_IMPLEMENT_IBASE_EXT_QUERY()</a> macro implements the opening boilerplate for the QueryInterface() method for a class extending another SCF class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a54">SCF_IMPLEMENT_IBASE_EXT()</a> convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00516">516</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a53" doxytag="scf.h::SCF_IMPLEMENT_IBASE_EXT_QUERY_END"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_EXT_QUERY_END
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordflow">return</span> __scf_superclass::QueryInterface (iInterfaceID, iVersion);       \
}
</pre></div>The SCF_IMPLEMENT_IBASE_EXT_QUERY_END macro implements the closing boilerplate for the QueryInterface() method for a class extending another SCF class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the SCF_IMPLEMENT_IBASE_EXT_END convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00526">526</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a51" doxytag="scf.h::SCF_IMPLEMENT_IBASE_EXT_REFOWNER"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_EXT_REFOWNER</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::AddRefOwner (<a class="code" href="structiBase.html">iBase</a>** ref_owner)                             \
{                                                                       \
  __scf_superclass::AddRefOwner (ref_owner);                            \
}                                                                       \
<span class="keywordtype">void</span> Class::RemoveRefOwner (<a class="code" href="structiBase.html">iBase</a>** ref_owner)                          \
{                                                                       \
  __scf_superclass::RemoveRefOwner (ref_owner);                         \
}
</pre></div>The <a class="el" href="group__scf.html#a51">SCF_IMPLEMENT_IBASE_EXT_REFOWNER()</a> macro implements the AddRefOwner() and RemoveRefOwner() for a weak reference. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00500">500</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a31" doxytag="scf.h::SCF_IMPLEMENT_IBASE_GETREFCOUNT"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_GETREFCOUNT</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">int</span> Class::GetRefCount ()                                               \
{                                                                       \
  <span class="keywordflow">return</span> scfRefCount;                                                   \
}
</pre></div>The <a class="el" href="group__scf.html#a31">SCF_IMPLEMENT_IBASE_GETREFCOUNT()</a> macro implements GetRefCount() for a class in a C++ source module. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00267">267</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a27" doxytag="scf.h::SCF_IMPLEMENT_IBASE_INCREF"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_INCREF</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::IncRef ()                                                   \
{                                                                       \
  <a class="code" href="group__scf.html#a16">SCF_TRACE</a> ((<span class="stringliteral">"  (%s *)%p-&gt;IncRef (%d)\n"</span>, #Class, <span class="keyword">this</span>, scfRefCount + 1));\
  csRefTrackerAccess::TrackIncRef (<span class="keyword">this</span>, scfRefCount);                  \
  scfRefCount++;                                                        \
}
</pre></div>The <a class="el" href="group__scf.html#a27">SCF_IMPLEMENT_IBASE_INCREF()</a> macro implements the IncRef() method for a class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a34">SCF_IMPLEMENT_IBASE()</a> convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00191">191</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a12" doxytag="pooledscfclass.h::SCF_IMPLEMENT_IBASE_INCREF_POOLED"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_INCREF_POOLED</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::IncRef ()                                   \
{                                                       \
  scfRefCount++;                                        \
}
</pre></div>Implement IncRef() for a pooled class. 
<p>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00147">147</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a11" doxytag="pooledscfclass.h::SCF_IMPLEMENT_IBASE_POOL"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_POOL</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="group__scf.html#a7">SCF_IMPLEMENT_IBASE_POOL_CTOR</a>(Class)                    \
  <a class="code" href="group__scf.html#a8">SCF_IMPLEMENT_IBASE_POOL_DTOR</a>(Class)                  \
  <a class="code" href="group__scf.html#a9">SCF_IMPLEMENT_IBASE_POOL_ALLOC</a>(Class)                 \
  <a class="code" href="group__scf.html#a10">SCF_IMPLEMENT_IBASE_POOL_RECYCLE</a>(Class)
</pre></div>Implement pool manager for <em>Class</em>. 
<p>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00138">138</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="pooledscfclass.h::SCF_IMPLEMENT_IBASE_POOL_ALLOC"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_POOL_ALLOC</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>Class* Class::Pool::Alloc ()                            \
{                                                       \
  Class* newInst;                                       \
  <span class="keywordflow">if</span> (pool != 0)                                        \
  {                                                     \
    newInst = pool;                                     \
    pool = pool-&gt;poolNext;                              \
  }                                                     \
  <span class="keywordflow">else</span>                                                  \
    newInst = <span class="keyword">new</span> Class (<span class="keyword">this</span>);                         \
  <span class="keywordflow">return</span> newInst;                                       \
}
</pre></div>Implement <em>Alloc()</em> for the pool manager of <em>Class</em>. 
<p>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00110">110</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="pooledscfclass.h::SCF_IMPLEMENT_IBASE_POOL_CTOR"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_POOL_CTOR</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>Class::Pool::Pool ()                                    \
{                                                       \
  pool = 0;                                             \
}
</pre></div>Implement the constructor for the pool manager of <em>Class</em>. 
<p>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00086">86</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="pooledscfclass.h::SCF_IMPLEMENT_IBASE_POOL_DTOR"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_POOL_DTOR</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>Class::Pool::~Pool ()                                   \
{                                                       \
  <span class="keywordflow">while</span> (pool != 0)                                     \
  {                                                     \
    Class* n = pool-&gt;poolNext;                          \
    pool-&gt;PoolRecycle ();                               \
    <span class="keyword">delete</span> pool;                                        \
    pool = n;                                           \
  }                                                     \
}
</pre></div>Implement the destructor for the pool manager of <em>Class</em>. 
<p>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00095">95</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a10" doxytag="pooledscfclass.h::SCF_IMPLEMENT_IBASE_POOL_RECYCLE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_POOL_RECYCLE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::Pool::Recycle (Class* instance)             \
{                                                       \
  instance-&gt;PoolRecycle ();                             \
  instance-&gt;poolNext = pool;                            \
  pool = instance;                                      \
}
</pre></div>Implement <em>Recycle()</em> for the pool manager of <em>Class</em>. 
<p>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00127">127</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a14" doxytag="pooledscfclass.h::SCF_IMPLEMENT_IBASE_POOLED"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_POOLED</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="group__scf.html#a11">SCF_IMPLEMENT_IBASE_POOL</a>(Class)                 \
  <a class="code" href="group__scf.html#a12">SCF_IMPLEMENT_IBASE_INCREF_POOLED</a>(Class)              \
  <a class="code" href="group__scf.html#a13">SCF_IMPLEMENT_IBASE_DECREF_POOLED</a>(Class)              \
  <a class="code" href="group__scf.html#a31">SCF_IMPLEMENT_IBASE_GETREFCOUNT</a>(Class)                \
  <a class="code" href="group__scf.html#a30">SCF_IMPLEMENT_IBASE_REFOWNER</a>(Class)                   \
  <a class="code" href="group__scf.html#a29">SCF_IMPLEMENT_IBASE_REMOVE_REF_OWNERS</a>(Class)          \
  <a class="code" href="group__scf.html#a32">SCF_IMPLEMENT_IBASE_QUERY</a>(Class)
</pre></div>Use this in the source module instead of <a class="el" href="group__scf.html#a34">SCF_IMPLEMENT_IBASE</a>. 
<p>

<p>
Definition at line <a class="el" href="pooledscfclass_8h-source.html#l00170">170</a> of file <a class="el" href="pooledscfclass_8h-source.html">pooledscfclass.h</a>.    </td>
  </tr>
</table>
<a name="a32" doxytag="scf.h::SCF_IMPLEMENT_IBASE_QUERY"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_QUERY</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> *Class::QueryInterface (scfInterfaceID iInterfaceID, <span class="keywordtype">int</span> iVersion) \
{                                                                       \
  <a class="code" href="group__scf.html#a16">SCF_TRACE</a> ((<span class="stringliteral">"  (%s *)%p-&gt;QueryInterface (%u, %08X)\n"</span>,                \
    #Class, <span class="keyword">this</span>, iInterfaceID, iVersion));
</pre></div>The <a class="el" href="group__scf.html#a32">SCF_IMPLEMENT_IBASE_QUERY()</a> macro implements the opening boilerplate for the QueryInterface() method for a class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a34">SCF_IMPLEMENT_IBASE()</a> convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00279">279</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a33" doxytag="scf.h::SCF_IMPLEMENT_IBASE_QUERY_END"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_QUERY_END
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordflow">return</span> scfParent ?                                                      \
    scfParent-&gt;QueryInterface (iInterfaceID, iVersion) : 0;             \
}
</pre></div>The SCF_IMPLEMENT_IBASE_QUERY_END macro implements the closing boilerplate for the QueryInterface() method for a class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the SCF_IMPLEMENT_IBASE_END convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00291">291</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a30" doxytag="scf.h::SCF_IMPLEMENT_IBASE_REFOWNER"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_REFOWNER</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::AddRefOwner (<a class="code" href="structiBase.html">iBase</a>** ref_owner)                             \
{                                                                       \
  <span class="keywordflow">if</span> (!scfWeakRefOwners)                                                \
    scfWeakRefOwners = <span class="keyword">new</span> <a class="code" href="classcsArray.html">csArray&lt;iBase**&gt;</a> (0, 4);                     \
  scfWeakRefOwners-&gt;InsertSorted (ref_owner);                           \
}                                                                       \
<span class="keywordtype">void</span> Class::RemoveRefOwner (<a class="code" href="structiBase.html">iBase</a>** ref_owner)                          \
{                                                                       \
  <span class="keywordflow">if</span> (!scfWeakRefOwners)                                                \
    scfWeakRefOwners = <span class="keyword">new</span> <a class="code" href="classcsArray.html">csArray&lt;iBase**&gt;</a> (0, 4);                     \
  size_t index = scfWeakRefOwners-&gt;FindSortedKey (                      \
    <a class="code" href="classcsArrayCmp.html">csArrayCmp&lt;iBase**, iBase**&gt;</a> (ref_owner));                          \
  <span class="keywordflow">if</span> (index != csArrayItemNotFound) scfWeakRefOwners-&gt;DeleteIndex (     \
    index);                                                             \
}
</pre></div>The <a class="el" href="group__scf.html#a30">SCF_IMPLEMENT_IBASE_REFOWNER()</a> macro implements the AddRefOwner() and RemoveRefOwner() for a weak reference. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00246">246</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a29" doxytag="scf.h::SCF_IMPLEMENT_IBASE_REMOVE_REF_OWNERS"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENT_IBASE_REMOVE_REF_OWNERS</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordtype">void</span> Class::scfRemoveRefOwners ()                                       \
{                                                                       \
  <span class="keywordflow">if</span> (!scfWeakRefOwners) <span class="keywordflow">return</span>;                                        \
  <span class="keywordflow">for</span> (size_t i = 0 ; i &lt; scfWeakRefOwners-&gt;Length () ; i++)            \
  {                                                                     \
    <a class="code" href="structiBase.html">iBase</a>** p = (*scfWeakRefOwners)[i];                                 \
    *p = 0;                                                             \
  }                                                                     \
  <span class="keyword">delete</span> scfWeakRefOwners;                                              \
  scfWeakRefOwners = 0;                                                 \
}
</pre></div>The <a class="el" href="group__scf.html#a29">SCF_IMPLEMENT_IBASE_REMOVE_REF_OWNERS()</a> macro implements the scfRemoveRefOwners() method for a class in a C++ source module. 
<p>
Typically, this macro is automatically employed by the <a class="el" href="group__scf.html#a34">SCF_IMPLEMENT_IBASE()</a> convenience macro. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00229">229</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a45" doxytag="scf.h::SCF_IMPLEMENTS_EMBEDDED_INTERFACE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENTS_EMBEDDED_INTERFACE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Interface&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;SCF_IMPLEMENTS_INTERFACE_COMMON (Interface, (&amp;scf##Interface))
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
IMPLEMENT_EMBEDDED_INTERFACE is same as IMPLEMENT_INTERFACE but is used when class implements the interface as an embedded member. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00424">424</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a44" doxytag="scf.h::SCF_IMPLEMENTS_INTERFACE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENTS_INTERFACE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Interface&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>csRefTrackerAccess::AddAlias (CS_STATIC_CAST(Interface*, <span class="keyword">this</span>), <span class="keyword">this</span>);\
  <a class="code" href="group__scf.html#a46">SCF_IMPLEMENTS_INTERFACE_COMMON</a> (Interface, <span class="keyword">this</span>)
</pre></div>The IMPLEMENT_INTERFACE macro is used inside QueryInterface function to check if user requested a specific interface, whenever requested version of the interface correspond to the version we have and to return a pointer to that interface if everything is correct. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00416">416</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a46" doxytag="scf.h::SCF_IMPLEMENTS_INTERFACE_COMMON"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_IMPLEMENTS_INTERFACE_COMMON</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Interface,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Object&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">static</span> <a class="code" href="group__scf.html#a0">scfInterfaceID</a> Interface##_scfID = (<a class="code" href="group__scf.html#a0">scfInterfaceID</a>)-1;           \
  <span class="keywordflow">if</span> (Interface##_scfID == (<a class="code" href="group__scf.html#a0">scfInterfaceID</a>)-1)                          \
    Interface##_scfID = <a class="code" href="structiSCF.html#s0">iSCF::SCF</a>-&gt;<a class="code" href="structiSCF.html#a14">GetInterfaceID</a> (#Interface);         \
  <span class="keywordflow">if</span> (iInterfaceID == Interface##_scfID &amp;&amp;                              \
    <a class="code" href="group__scf.html#a4">scfCompatibleVersion</a> (iVersion, <a class="code" href="classscfInterface.html">scfInterface&lt;Interface&gt;</a>::GetVersion())) \
  {                                                                     \
    (Object)-&gt;IncRef ();                                                \
    <span class="keywordflow">return</span> CS_STATIC_CAST(Interface*, Object);                          \
  }
</pre></div>This is a common macro used in all IMPLEMENTS_XXX_INTERFACE macros. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00430">430</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a17" doxytag="scf.h::SCF_PRINT_CALL_ADDRESS"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_PRINT_CALL_ADDRESS
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Macro for getting the address we were called from (stack backtracing). 
<p>
This works ONLY For GCC &gt;= 2.8.0 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00065">65</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a66" doxytag="scf.h::SCF_QUERY_INTERFACE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_QUERY_INTERFACE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Object,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Interface&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="classcsPtr.html">csPtr&lt;Interface&gt;</a> ((Interface *)(Object)-&gt;QueryInterface (               \
  <a class="code" href="classscfInterface.html">scfInterface&lt;Interface&gt;</a>::GetID (), <a class="code" href="classscfInterface.html">scfInterface&lt;Interface&gt;</a>::GetVersion()))
</pre></div>Shortcut macro to query given interface from given object. 
<p>
This is a wrapper around <a class="el" href="structiBase.html#a3">iBase::QueryInterface</a> method. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00812">812</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a67" doxytag="scf.h::SCF_QUERY_INTERFACE_SAFE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_QUERY_INTERFACE_SAFE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Object,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Interface&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><a class="code" href="classcsPtr.html">csPtr&lt;Interface&gt;</a> ((Interface *)(<a class="code" href="structiBase.html#e0">iBase::QueryInterfaceSafe</a> ((Object),    \
  <a class="code" href="classscfInterface.html">scfInterface&lt;Interface&gt;</a>::GetID (), <a class="code" href="classscfInterface.html">scfInterface&lt;Interface&gt;</a>::GetVersion())))
</pre></div>Shortcut macro to query given interface from given object. 
<p>
This is a wrapper around <a class="el" href="structiBase.html#a3">iBase::QueryInterface</a> method. This version tests if Object is 0 and will return 0 in that case. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00821">821</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a63" doxytag="scf.h::SCF_REGISTER_FACTORY_FUNC"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_REGISTER_FACTORY_FUNC</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>CS_EXPORTED_FUNCTION <span class="keywordtype">void</span>* CS_EXPORTED_NAME(Class,_Create)(<a class="code" href="structiBase.html">iBase</a>*);     \
  <span class="keyword">class </span>Class##_StaticInit                                              \
  {                                                                     \
  <span class="keyword">public</span>:                                                               \
    Class##_StaticInit()                                                \
    {                                                                   \
      <a class="code" href="group__scf.html#a2">scfInitialize</a>(0);                                                 \
      <a class="code" href="structiSCF.html#s0">iSCF::SCF</a>-&gt;<a class="code" href="structiSCF.html#a11">RegisterFactoryFunc</a>(CS_EXPORTED_NAME(Class,_Create),#Class); \
    }                                                                   \
  } Class##_static_init__;
</pre></div>Used in conjunction with SCF_REGISTER_STATIC_LIBRARY to ensure that a reference to the class(s) registered via SCF_REGISTER_STATIC_LIBRARY are actually linked into the application. 
<p>
Invoke this macro once for each &lt;implementation&gt; node mentioned in the MetaInfo registered with SCF_REGISTER_STATIC_LIBRARY. Invocations of this macro must appear after the the invocation of SCF_REGISTER_STATIC_LIBRARY. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00670">670</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a61" doxytag="scf.h::SCF_REGISTER_STATIC_CLASS"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_REGISTER_STATIC_CLASS</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Class,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Ident,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Desc,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Dep&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>CS_EXPORTED_FUNCTION <span class="keywordtype">void</span>* CS_EXPORTED_NAME(Class,_Create)(<a class="code" href="structiBase.html">iBase</a>*);     \
  <span class="keyword">class </span>Class##_StaticInit__                                            \
  {                                                                     \
  <span class="keyword">public</span>:                                                               \
    Class##_StaticInit__()                                              \
    {                                                                   \
      <a class="code" href="group__scf.html#a2">scfInitialize</a>(0);                                                 \
      <a class="code" href="structiSCF.html#s0">iSCF::SCF</a>-&gt;<a class="code" href="structiSCF.html#a9">RegisterClass</a>(                                         \
        CS_EXPORTED_NAME(Class,_Create), Ident, Desc, Dep,              \
        SCF_STATIC_CLASS_CONTEXT);                                      \
    }                                                                   \
  } Class##_static_init__;
</pre></div>Automatically register a built-in class with SCF during startup. 
<p>
When SCF classes are statically linked (vs dynamic linking) they should be referenced from somewhere inside your program, otherwise the static libraries won't be linked into the static executable. This macro defines a dummy variable that registers the class during initialization and ensures that it gets linked into the program 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00633">633</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a62" doxytag="scf.h::SCF_REGISTER_STATIC_LIBRARY"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_REGISTER_STATIC_LIBRARY</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Module,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>MetaInfo&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">class </span>Module##_StaticInit                                               \
  {                                                                     \
  <span class="keyword">public</span>:                                                               \
    Module##_StaticInit()                                               \
    {                                                                   \
      <a class="code" href="group__scf.html#a2">scfInitialize</a>(0);                                                 \
      <a class="code" href="structiSCF.html#s0">iSCF::SCF</a>-&gt;<a class="code" href="structiSCF.html#a0">RegisterClasses</a>(MetaInfo, SCF_STATIC_CLASS_CONTEXT);   \
    }                                                                   \
  } Module##_static_init__;
</pre></div>Automatically register a static library with SCF during startup. 
<p>
Employ this macro along with one or more invocations of SCF_REGISTER_FACTORY_FUNC. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00651">651</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a16" doxytag="scf.h::SCF_TRACE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_TRACE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Macro for typing debug strings: Add #define SCF_DEBUG at the top of modules you want to track miscelaneous SCF activity and recompile. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00054">54</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a65" doxytag="scf.h::SCF_VERSION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCF_VERSION</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Name,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Major,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Minor,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Micro&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">struct </span>Name;                                                            \
CS_SPECIALIZE_TEMPLATE                                                  \
<span class="keyword">class </span><a class="code" href="classscfInterface.html">scfInterface</a>&lt;Name&gt;                                                \
{                                                                       \
<span class="keyword">public</span>:                                                                 \
  <span class="keyword">static</span> <span class="keywordtype">int</span> GetVersion()                                               \
  {                                                                     \
    <span class="keywordflow">return</span> <a class="code" href="group__scf.html#a18">SCF_CONSTRUCT_VERSION</a>(Major, Minor, Micro);                  \
  }                                                                     \
  <span class="keyword">static</span> <a class="code" href="group__scf.html#a0">scfInterfaceID</a> GetID()                                         \
  {                                                                     \
    <span class="keyword">static</span> <a class="code" href="group__scf.html#a0">scfInterfaceID</a> ID = (<a class="code" href="group__scf.html#a0">scfInterfaceID</a>)-1;                      \
    <span class="keywordflow">if</span> (ID == (<a class="code" href="group__scf.html#a0">scfInterfaceID</a>)(-1))                                     \
      ID = <a class="code" href="structiSCF.html#s0">iSCF::SCF</a>-&gt;<a class="code" href="structiSCF.html#a14">GetInterfaceID</a>(#Name);                            \
    <span class="keywordflow">return</span> ID;                                                          \
  }                                                                     \
  <span class="keyword">static</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* GetName()                                          \
  {                                                                     \
    <span class="keywordflow">return</span> #Name;                                                       \
  }                                                                     \
}
</pre></div>SCF_VERSION can be used to define an interface's version number; you should specify interface name and major, minor and micro version components. 
<p>
This way: <pre><div>
 SCF_VERSION (iSomething, 0, 0, 1);
 struct iSomething : public <a class="el" href="structiBase.html">iBase</a>
 {
   ...
 };
 </pre></div> 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00740">740</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a name="a1" doxytag="scf.h::scfFactoryFunc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef void*(* <a class="el" href="group__scf.html#a1">scfFactoryFunc</a>)(<a class="el" href="structiBase.html">iBase</a>*)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Type of factory function which creates an instance of an SCF class. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00717">717</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a0" doxytag="scf.h::scfInterfaceID"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef unsigned long <a class="el" href="group__scf.html#a0">scfInterfaceID</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Type of registered interface handle used by <a class="el" href="structiBase.html#a3">iBase::QueryInterface()</a>. 
<p>

<p>
Definition at line <a class="el" href="scf_8h-source.html#l00041">41</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.
<p>
Referenced by <a class="el" href="scf_8h-source.html#l00790">scfInterface&lt; T &gt;::GetID()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a4" doxytag="scf.h::scfCompatibleVersion"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool scfCompatibleVersion </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>iVersion</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iItfVersion</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function checks whenever an interface is compatible with given version. 
<p>
SCF uses the following comparison criteria: if the major version numbers are equal and required minor and micro version is less or equal than target version minor and micro numbers, the versions are considered compatible. 
<p>
Definition at line <a class="el" href="scf_8h-source.html#l00855">855</a> of file <a class="el" href="scf_8h-source.html">scf.h</a>.    </td>
  </tr>
</table>
<a name="a3" doxytag="scf.h::scfInitialize"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void scfInitialize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>argc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *const&nbsp;</td>
          <td class="mdname" nowrap> <em>argv</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function should be called to initialize client SCF library. 
<p>
It uses the default plugin paths provided by <a class="el" href="group__util.html#a72">csGetPluginPaths()</a>.     </td>
  </tr>
</table>
<a name="a2" doxytag="scf.h::scfInitialize"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void scfInitialize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsPluginPaths.html">csPluginPaths</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pluginPaths</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>verbose</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function should be called to initialize client SCF library. 
<p>
If a number of plugin paths are provided, the directories will be scanned for plugins and their SCF-related registry data will be retrieved. The root node within the registry data document should be named "plugin", and the SCF-related information should be in a child node of the root named "scf". It is legal to call scfInitialize more than once (possibly providing a different set of directories each time). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pluginPaths</em>&nbsp;</td><td>Directories that will be scanned for plugins. If this parameter is 0, the paths returned by <a class="el" href="group__util.html#a72">csGetPluginPaths()</a> will be scanned. </td></tr>
    <tr><td valign=top><em>verbose</em>&nbsp;</td><td>If true, diagnostic information will be emitted for each path scanned and each plugin queried. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Remarks:</b></dt><dd>The path list is ignored for static builds. </dd></dl>
    </td>
  </tr>
</table>
<hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.3 
</small></address> </div></body> </html>
