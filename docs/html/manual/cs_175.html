<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: Texture Mapping Together</TITLE>

<META NAME="description" CONTENT="Crystal Space: Texture Mapping Together">
<META NAME="keywords" CONTENT="Crystal Space: Texture Mapping Together">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC433"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_174.html#SEC432"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_176.html#SEC434"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_170.html#SEC425"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_171.html#SEC426"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_178.html#SEC439"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC956">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H4> 7.5.6.4 Bringing it All Together </H4>
<!--docid::SEC433::-->
<P>

Using all this information we have enough to correctly map a texture on
screen.  Let's disregard clipping for the moment and just explain all the
steps from the original object space polygon until the final texture mapped
polygon on screen.
</P><P>

We will assume that the polygon (and the texture) has already been transformed
from object to world space.  So we start with a world space polygon, <EM>Pw</EM>.
</P><P>

First all vertices of the polygon are transformed to camera space (note that
in Crystal Space this is done earlier since vertices are shared for one
sector.  This text ignores that and just concentrates on one polygon) with the
equation:
</P><P>

<BLOCKQUOTE>
<EM>Vc = Mwc * (Vw - Vwc)</EM>
</BLOCKQUOTE>
<P>

(Also note that at this point you could discard vertices because they are
behind the view plane (or <EM>Z = 0</EM>).  We assume here that the polygon is
completely visible so this does not matter.)
</P><P>

At this point we do perspective correction on the polygon.  This means that we
create a new 2-dimensional polygon with vertices <EM>Vs</EM> (in screen space)
using the following equations:
</P><P>

<BLOCKQUOTE>
<EM>Vs.x = (F * Vc.x) / Vc.z</EM><BR>
<EM>Vs.y = (F * Vc.y) / Vc.z</EM>
</BLOCKQUOTE>
<P>

Now we create the matrix to transform camera space to texture space starting
from the matrix to transform world space to texture space.  Given:
</P><P>

<BLOCKQUOTE>
<EM>Vc = Mwc * (Vw - Vwc)</EM>
</BLOCKQUOTE>
<P>

We calculate (using the inverse matrix of <EM>Mwc</EM>):
</P><P>

<BLOCKQUOTE>
<TABLE>
<TR><TD><EM>Mcw * Vc + Vwc = Vw</EM> </TD><TD> (Equation 1)</TD>
</TR></TABLE>
</BLOCKQUOTE>
<P>

Given also:
</P><P>

<BLOCKQUOTE>
<TABLE>
<TR><TD><EM>Vt = Mwt * (Vw - Vwt)</EM> </TD><TD> (Equation 2)</TD>
</TR></TABLE>
</BLOCKQUOTE>
<P>

We substitute (1) into (2) to get:
</P><P>

<BLOCKQUOTE>
<EM>Vt = Mwt * (Mcw * Vc + Vwc - Vwt)</EM>
</BLOCKQUOTE>
<P>

This can also be re-written as:
</P><P>

<BLOCKQUOTE>
<EM>Vt = Mwt * (Mcw * Vc + Mcw * Mwc * (Vwc - Vwt))</EM>
</BLOCKQUOTE>
<P>

Which simplifies to:
</P><P>

<BLOCKQUOTE>
<EM>Vt = Mwt * Mcw * (Vc + Mwc * (Vwc - Vwt))</EM>
</BLOCKQUOTE>
<P>

If we say that:
</P><P>

<BLOCKQUOTE>
<EM>Mct = Mwt * Mcw</EM><BR>
<EM>Vct = Mwc * (Vwt - Vwc)</EM>
</BLOCKQUOTE>
<P>

We then get:
</P><P>

<BLOCKQUOTE>
<EM>Vt = Mct * (Vc - Vct)</EM>
</BLOCKQUOTE>
<P>

And this is the equation transforming camera space to texture space.
</P><P>

Then we need to transform the world space plane equation to a camera space
plane equation.  This we do as follows.
</P><P>

The plane vector
<EM>Nw = (Aw,Bw,Cw)</EM>
is transformed to
<EM>Nc = (Ac,Bc,Cc)</EM>
using the following equation:
</P><P>

<BLOCKQUOTE>
<EM>Nc = Mwc * Nw</EM>
</BLOCKQUOTE>
<P>

Using the first vertex of the polygon in camera space coordinates (<EM>Vc</EM>)
we then calculate <EM>Dc</EM> as follows.
</P><P>

Since the plane equation in camera space is equal to:
</P><P>

<BLOCKQUOTE>
<EM>Ac * Vc.x + Bc * Vc.y + Cc * Vc.z + Dc = 0</EM>
</BLOCKQUOTE>
<P>

For every vertex <EM>Vc</EM> on the polygon we can calculate the missing <EM>Dc</EM>
as follows:
</P><P>

<BLOCKQUOTE>
<EM>Dc = -Ac * Vc.x - Bc * Vc.y - Cc * Vc.z</EM>
</BLOCKQUOTE>
<P>

Using this information (the polygon in perspective corrected 2D coordinates,
the transformation from camera space to texture space and the plane equation
in camera space) we can draw the polygon on the screen and perform correct
texture mapping.  This happens as follows.
</P><P>

From the perspective correction equations:
</P><P>

<BLOCKQUOTE>
<EM>Vs.x = (F * Vc.x) / Vc.z</EM><BR>
<EM>Vs.y = (F * Vc.y) / Vc.z</EM>
</BLOCKQUOTE>
<P>

We can invert them to:
</P><P>

<BLOCKQUOTE>
<TABLE>
<TR><TD><EM>Vc.x = (Vs.x * Vc.z) / F</EM> </TD><TD> (Equation 3)</TD>
</TR>
<TR><TD><EM>Vc.y = (Vs.y * Vc.z) / F</EM> </TD><TD> (Equation 4)</TD>
</TR></TABLE>
</BLOCKQUOTE>
<P>

We can now substitute (3) and (4) into the following equation:
</P><P>

<BLOCKQUOTE>
<EM>Ac * Vc.x + Bc * Vc.y + Cc * Vc.z + Dc = 0</EM>
</BLOCKQUOTE>
<P>

And get:
</P><P>

<BLOCKQUOTE>
<EM>(Ac * Vs.x * Vc.z) / F + (Bc * Vs.y * Vc.z) / F + (F * Cc * Vc.z) / F = -Dc</EM>
</BLOCKQUOTE>
<P>

Or:
</P><P>

<BLOCKQUOTE>
<EM>-(Ac * Vs.x) / (F*Dc) - (Bc * Vs.y) / (F*Dc) - Cc / (F*Dc) = 1 / Vc.z</EM>
</BLOCKQUOTE>
<P>

This equation is very important.  From this it follows that <EM>1/z</EM> linear
is in screen space and this can be used for perspective correct texture
mapping.  Lets define the following three new variables:
</P><P>

<BLOCKQUOTE>
<EM>M = -Ac / (F * Dc)</EM><BR>
<EM>N = -Bc / (F * Dc)</EM><BR>
<EM>O = -Cc / Dc</EM>
</BLOCKQUOTE>
<P>

So the <EM>1/z</EM> equation in linear screen space is then written as:
</P><P>

<BLOCKQUOTE>
<TABLE>
<TR><TD><EM>1 / Vc.z = M * Vs.x + N * Vs.y + O</EM> </TD><TD> (Equation 5)</TD>
</TR></TABLE>
</BLOCKQUOTE>
<P>

So now we can easily calculate <EM>1/z</EM> at every point in screen space.  But
we also need to calculate the texture coordinates (<EM>u,v</EM>) or <EM>Vt</EM>.
Let's call the individual fields of the transformation matrix <EM>Mct</EM> as
follows:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>      / m11 m12 m13 \
Mct = | m21 m22 m23 |   Vct = (v1 v2 v3)
      \ m31 m32 m33 /
</pre></td></tr></table></P><P>

For simplicity let's use <EM>u</EM> for <EM>Vt.u</EM> and <EM>v</EM> for <EM>Vt.v</EM>
(the <EM>u,v</EM> texture coordinates).  Let us also use <EM>x</EM>, <EM>y</EM>,
and <EM>z</EM> for <EM>Vc.x</EM>, <EM>Vc.y</EM>, <EM>Vc.z</EM> respectively.
</P><P>

Then from:
</P><P>

<BLOCKQUOTE>
<EM>Vt = Mct * (Vc - Vct)</EM>
</BLOCKQUOTE>
<P>

We get:
</P><P>

<BLOCKQUOTE>
<EM>u = m11 * (x - v1) + m12 * (y - v2) + m13 * (z - v3)</EM><BR>
<EM>v = m21 * (x - v1) + m22 * (y - v2) + m23 * (z - v3)</EM>
</BLOCKQUOTE>
<P>

This can be rewritten as:
</P><P>

<BLOCKQUOTE>
<EM>u = m11 * x + m12 * y + m13 * z - (m11 * v1 + m12 * v2 + m13 * v3)</EM><BR>
<EM>v = m21 * x + m22 * y + m23 * z - (m21 * v1 + m22 * v2 + m23 * v3)</EM>
</BLOCKQUOTE>
<P>

To simplify let's introduce a couple new variables to take the place of
complicated expressions from the above equations.
</P><P>

<BLOCKQUOTE>
<EM>P = - (m11 * v1 + m12 * v2 + m13 * v3)</EM><BR>
<EM>Q = - (m21 * v1 + m22 * v2 + m23 * v3)</EM>
</BLOCKQUOTE>
<P>

And we have:
</P><P>

<BLOCKQUOTE>
<EM>u = m11 * x + m12 * y + m13 * z + P</EM><BR>
<EM>v = m21 * x + m22 * y + m23 * z + Q</EM>
</BLOCKQUOTE>
<P>

As earlier, we substitute the inverse perspective correction equations (3)
and (4) into the previous equations and we get:
</P><P>

<BLOCKQUOTE>
<EM>u = (m11 * Vs.x * z) / F + (m12 * Vs.y * z) / F + m13 * z + P</EM><BR>
<EM>v = (m21 * Vs.x * z) / F + (m22 * Vs.y * z) / F + m23 * z + Q</EM>
</BLOCKQUOTE>
<P>

And then rewrite as:
</P><P>

<BLOCKQUOTE>
<EM>u / z = (m11 * Vs.x) / F + (m12 * Vs.y) / F + m13 + P / z</EM><BR>
<EM>v / z = (m21 * Vs.x) / F + (m22 * Vs.y) / F + m23 + Q / z</EM>
</BLOCKQUOTE>
<P>

Substitute the linear <EM>1/z</EM> equation (5) into this to get:
</P><P>

<BLOCKQUOTE>
<EM>u / z = (m11 * Vs.x) / F + (m12 * Vs.y) / F + m13 + P * (M * Vs.x + N * Vs.y + O)</EM><BR>
<EM>v / z = (m21 * Vs.x) / F + (m22 * Vs.y) / F + m23 + Q * (M * Vs.x + N * Vs.y + O)</EM>
</BLOCKQUOTE>
<P>

Rewrite as:
</P><P>

<BLOCKQUOTE>
<EM>u / z = (m11 * Vs.x + m12 * Vs.y + F * (m13 + P * (M*Vs.x + N*Vs.y + O)) / F</EM><BR>
<EM>v / z = (m21 * Vs.x + m22 * Vs.y + F * (m23 + Q * (M*Vs.x + N*Vs.y + O)) / F</EM>
</BLOCKQUOTE>
<P>

And finally rewrite as:
</P><P>

<BLOCKQUOTE>
<EM>u / z = (m11 / F + P * M) * Vs.x + (m12 / F + P * N) * Vs.y + (m13 + P * O)</EM><BR>
<EM>v / z = (m21 / F + Q * M) * Vs.x + (m22 / F + Q * N) * Vs.y + (m23 + Q * O)</EM>
</BLOCKQUOTE>
<P>

These are again two important equations because they state that <EM>u/z</EM> and
<EM>v/z</EM> are also linear in screen space.  Using this we can easily
calculate (<EM>u,v</EM>) at every screen space point.
</P><P>

Now let's define:
</P><P>

<BLOCKQUOTE>
<EM>J1 = m11 / F + P * M</EM><BR>
<EM>J2 = m12 / F + P * N</EM><BR>
<EM>J3 = m13 + P * O</EM><BR>
<EM>K1 = m21 / F + Q * M</EM><BR>
<EM>K2 = m22 / F + Q * N</EM><BR>
<EM>K3 = m23 + Q * O</EM>
</BLOCKQUOTE>
<P>

Then we have the following three equations:
</P><P>

<BLOCKQUOTE>
<EM>1 / z = M * Vs.x + N * Vs.y + O</EM><BR>
<EM>u / z = J1 * Vs.x + J2 * Vs.y + J3</EM><BR>
<EM>v / z = K1 * Vs.x + K2 * Vs.y + K3</EM>
</BLOCKQUOTE>
<P>

With these three important equations we can do all texture mapping we want.
With the first equation we can calculate <EM>1/z</EM>.  This is useful for
Z-buffering and also for calculating (<EM>u,v</EM>) from the two other
equations.
</P><P>

<A NAME="Texture Mapping Instructions"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_174.html#SEC432"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_176.html#SEC434"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_170.html#SEC425"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_171.html#SEC426"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_178.html#SEC439"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC956">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
