<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: HOWTO Create Your Own Plugin</TITLE>

<META NAME="description" CONTENT="Crystal Space: HOWTO Create Your Own Plugin">
<META NAME="keywords" CONTENT="Crystal Space: HOWTO Create Your Own Plugin">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC330"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_128.html#SEC325"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_130.html#SEC338"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_101.html#SEC205"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_109.html#SEC221"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_134.html#SEC350"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_292.html#SEC943">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 5.8.20 Create Your Own Plugin </H3>
<!--docid::SEC330::-->
<P>

Making a plugin in Crystal Space is not very hard but nevertheless
there are still a few issues that are often forgotten. Here in this
article we show you how you can write a simple plugin and use
it in your application.
</P><P>

<A NAME="SEC331"></A>
<H4> Defining your Plugin API </H4>
<!--docid::SEC331::-->
<P>

The first thing that you need to do when making a plugin is to define the
API for it.  The API is what your application is going to use to talk
to the plugin.  It is the interface to the plugin so it is very important to
get this right.  In the Crystal Space framework the Shared Class Facility
(see section <A HREF="cs_138.html#SEC354">6.2 Shared Class Facility (SCF)</A>) is used to define the API.  With this facility you create an
abstract interface containing only the methods from the API.  An abstract
class in C++ means that all methods are pure virtual.  This means that no
implementation is given; only method declarations.  The implementation will
come later in the code of the plugin.
</P><P>

This concept completely analogous to the Java interface mechanism.  The
advantage of using this paradigm is that you have a clear separation between
the API and the implementation.  This allows one to easily replace an
implementation of some API or even provide multiple implementations (for
example, the software and OpenGL renderers are two implementations of the same
3D rendering API).
</P><P>

Here is the API definition for our sample plugin:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#ifndef __GAME_MYAPI_H__
#define __GAME_MYAPI_H__

#include "csutil/scf.h"

class csVector3;

SCF_VERSION (iMyApi, 0, 0, 1);

/**
* This is the API for our plugin. I recommend
* to use better comments then this one here in a
* real situation.
*/
struct iMyApi : public iBase
{
/// Do something.
virtual void DoSomething (int param, const csVector3&#38; v) = 0;
/// Get something.
virtual int GetSomething () const = 0;
};

#endif // __GAME_MYAPI_H__
</pre></td></tr></table></P><P>

The above text should be put in a header file. Let's put it in
`<TT>myapi.h</TT>'.
</P><P>

First we include `<TT>csutil/scf.h</TT>'. This is a Crystal Space header
for SCF which we need to get the definition of `<SAMP>iBase</SAMP>' and the
definition of the <CODE>SCF_VERSION()</CODE> macro.
</P><P>

Then we declare `<SAMP>csVector3</SAMP>' as a class. We do this so that we
can later use `<SAMP>csVector3</SAMP>' as a parameter in one of the API methods.
We do not need the complete definition of `<SAMP>csVector3</SAMP>' since we
are going to define the method so that it passes the vector by
reference.
</P><P>

After this we use the <CODE>SCF_VERSION()</CODE> macro to define the version
of this interface. This versioning can be used to query for
specific versions of an interface. This can be useful later when you
want to extend the API without breaking existing apps. The version
has three parts: major, minor, and micro.
</P><P>

Finally we define the API by making a structure that inherits from
`<SAMP>iBase</SAMP>'.  We use `<SAMP>struct</SAMP>' instead of `<SAMP>class</SAMP>' simply because, for
structures, the default visibility is `<SAMP>public</SAMP>' instead of `<SAMP>private</SAMP>'
as for classes.  This is just a convenience.  There is no other difference
between a `<SAMP>struct</SAMP>' or a `<SAMP>class</SAMP>' in C++.
</P><P>

The name `<SAMP>iMyApi</SAMP>' is not random.  Crystal Space uses this naming
convention (starting a name with `<SAMP>i</SAMP>') for SCF interfaces so that it
is easy to see that they refer to SCF interfaces.
</P><P>

We inherit from `<SAMP>iBase</SAMP>' because it is the basis of all SCF
interfaces.  All SCF interfaces need to inherit from `<SAMP>iBase</SAMP>'.  This
will ensure that we have reference counting (more on that later) and also takes
care of the other internal SCF issues.
</P><P>

In that structure we define two methods: <CODE>DoSomething()</CODE> and
<CODE>GetSomething()</CODE>. Note that every method is defined as follows:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>virtual <small>...</small> = 0;
</pre></td></tr></table></P><P>

The `<SAMP>= 0</SAMP>' means that we will not give an implementation here. The
implementation will be provided by the plugin (see later).
</P><P>

Note that it is good practice to use `<SAMP>const</SAMP>' wherever applicable.  In the
declaration of <CODE>GetSomething()</CODE> we added `<SAMP>const</SAMP>' at the end to
indicate that this method will not change the object.  This is useful for two
reasons:
</P><P>

<OL>
<LI>
It serves as documentation for the API user.
<LI>
A good compiler might be able to do some optimizations if it knows that the
method will not modify the object.
</OL>
<P>

<A NAME="SEC332"></A>
<H4> Creating the Plugin Implementation (header) </H4>
<!--docid::SEC332::-->
<P>

After you defined the API for your plugin it is now time to actually
make the plugin implementation. First you define a header called
`<TT>myplug.h</TT>' with the following contents:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#ifndef __GAME_MYPLUG_H__
#define __GAME_MYPLUG_H__

#include "iutil/comp.h"
#include "csgeom/vector3.h"
#include "myapi.h"

struct iObjectRegistry;

/**
* This is the implementation for our API and
* also the implementation of the plugin.
*/
class MyPlugin : public iMyApi
{
private:
  iObjectRegistry* object_reg;
  csVector3 store_v;

public:
  SCF_DECLARE_IBASE;

  MyPlugin (iBase* parent);
  virtual ~MyPlugin ();
  bool Initialize (iObjectRegistry* iobject_reg);

  virtual void DoSomething (int param, const csVector3&#38; v);
  virtual int GetSomething () const;

  struct Component : public iComponent
  {
    SCF_DECLARE_EMBEDDED_IBASE (MyPlugin);
    virtual bool Initialize (iObjectRegistry* object_reg)
      { return scfParent-&#62;Initialize (object_reg); }
  } scfiComponent;
};

#endif // __GAME_MYPLUG_H__
</pre></td></tr></table></P><P>

This requires a little explanation.  The CRYSTAL SPACE framework requires
that every SCF class implement the `<SAMP>iComponent</SAMP>' interface.  This
interface has a single method, <CODE>Initialize()</CODE>, with which the class will
be initialized after it is instantiated.  This gives the instance a chance to
perform various initialization operations and it also provides the instance
with a pointer to the global object registry.
</P><P>

But, our plugin also needs to implement its own native `<SAMP>iMyApi</SAMP>' interface.
So here is a situation where the same class needs to implement two interfaces
at the same time.  There are basically two ways to do this: multiple
inheritance, or via use of an embedded SCF class.  We use the second case
here since it tends to be more portable and works better with older compilers
which have trouble supporting multiple inheritance.
</P><P>

In the example above the class `<SAMP>MyPlugin</SAMP>' inherits from
`<SAMP>iMyApi</SAMP>'. The methods from `<SAMP>iMyApi</SAMP>' are implemented directly in
`<SAMP>MyPlugin</SAMP>'. To do that the method declarations from `<SAMP>iMyApi</SAMP>' are
copied to `<SAMP>MyPlugin</SAMP>' except that the `<SAMP>= 0</SAMP>' is removed. To indicate
that this class represents an implementation of an SCF interface
we additionally need the <CODE>SCF_DECLARE_IBASE()</CODE> macro. This macro
will take care of declaring the <CODE>DecRef()</CODE> and <CODE>IncRef()</CODE> functions
to take care of reference counting. In addition the macro also
declares <CODE>QueryInterface()</CODE> so that it is possible to request
other interfaces (like `<SAMP>iComponent)</SAMP>' from this class. You don't need
to worry much about this.
</P><P>

Note that `<SAMP>MyPlugin</SAMP>' needs a constructor that accepts an `<SAMP>iBase*</SAMP>'
parameter. Otherwise SCF will not be able to intantiate this class.
</P><P>

To implement `<SAMP>iComponent</SAMP>' we add an inner class called `<SAMP>Component</SAMP>'.
This new class will inherit directly from `<SAMP>iComponent</SAMP>' which allows
`<SAMP>MyPlugin</SAMP>' to implement `<SAMP>iComponent</SAMP>' indirectly.  Since this is an
embedded interface we now need the <CODE>SCF_DECLARE_EMBEDDED_IBASE()</CODE> macro.
This macro takes care of the fact that this interface actually belongs to the
parent class (which is given as a parameter).  One thing it does is declare a
variable of type `<SAMP>MyPlugin</SAMP>' which is called `<SAMP>scfParent</SAMP>'.  Through
that variable the method implementations of the embedded interface can access
the main class.  After declaring the class `<SAMP>Component</SAMP>' we immediately
create an instance of this called `<SAMP>scfiComponent</SAMP>'.  You can call it
whatever you like.  This name is just a convention in Crystal Space.
</P><P>

Sometimes embedded classes are also made friend of the main
class so that they can access the private information. In this case
this is not needed. The only thing that `<SAMP>Component</SAMP>' has is an
<CODE>Initialize()</CODE> method which immediately transfers control to
the parent's <CODE>Initialize()</CODE> method.
</P><P>

<A NAME="SEC333"></A>
<H4> Creating the Plugin Implementation (source) </H4>
<!--docid::SEC333::-->
<P>

Now we create the main source file containing the implementation
of our plugin. Let's call this `<TT>myplug.cpp</TT>':
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include "cssysdef.h"
#include "myplug.h"
#include "iutil/objreg.h"
#include "iutil/plugin.h"

CS_IMPLEMENT_PLUGIN

SCF_IMPLEMENT_IBASE (MyPlugin)
  SCF_IMPLEMENTS_INTERFACE (iMyApi)
  SCF_IMPLEMENTS_EMBEDDED_INTERFACE (iComponent)
SCF_IMPLEMENT_IBASE_END

SCF_IMPLEMENT_EMBEDDED_IBASE (MyPlugin::Component)
  SCF_IMPLEMENTS_INTERFACE (iComponent)
SCF_IMPLEMENT_EMBEDDED_IBASE_END

SCF_IMPLEMENT_FACTORY (MyPlugin)

MyPlugin::MyPlugin (iBase* parent)
{
  SCF_CONSTRUCT_IBASE (parent);
  SCF_CONSTRUCT_EMBEDDED_IBASE (scfiComponent);
  object_reg = 0;
}

MyPlugin::~MyPlugin ()
{
  SCF_DESTRUCT_EMBEDDED_IBASE (scfiComponent);
  SCF_DESTRUCT_IBASE ();
}

bool MyPlugin::Initialize (iObjectRegistry* iobject_reg)
{
  object_reg = iobject_reg;
  return true;
}

void MyPlugin::DoSomething (int param, const csVector3&#38; v)
{
  // Just some behavior.
  if (param == 1)
    store_v = v;
  else
    store_v = -v;
}

int MyPlugin::GetSomething () const
{
  return (int)store_v.x + (int)store_v.y + (int)store_v.z;
}

</pre></td></tr></table></P><P>

The first macro is <CODE>CS_IMPLEMENT_PLUGIN()</CODE>. This indicates to the
CRYSTAL SPACE framework that this module will end up as a plugin
(as opposed to an application or library). On some platforms this
actually makes a difference; on others it does not.  For best portability,
you should use this macro in exactly one C++ file within each plugin
module.
</P><P>

The first <CODE>SCF_IMPLEMENT_IBASE()</CODE> describes what interfaces the class
`<SAMP>MyPlugin</SAMP>' implements.  This section says that `<SAMP>MyPlugin</SAMP>' implements
`<SAMP>iMyApi</SAMP>' directly and `<SAMP>iComponent</SAMP>' through embedding.
</P><P>

The second <CODE>SCF_IMPLEMENT_EMBEDDED_IBASE()</CODE> lists the interfaces
implemented by the class `<SAMP>MyPlugin::Component</SAMP>' (the embedded class).
`<SAMP>MyPlugin::Component</SAMP>' only implements `<SAMP>iComponent</SAMP>'.
</P><P>

It is important to correctly use the above macros.  These macros will ensure
that the implementation for <CODE>IncRef()</CODE>, <CODE>DecRef()</CODE>, and
<CODE>QueryInterface()</CODE> are provided by your custom class.
</P><P>

The <CODE>SCF_IMPLEMENT_FACTORY()</CODE> says that C++ class `<SAMP>MyPlugin</SAMP>'
represents an SCF factory which allows SCF to instantiate objects of
this class.  In addition to some other administrative tasks, this macro defines
a function capable of instantiating an object of class `<SAMP>MyPlugin</SAMP>'.  Note
that one plugin module can in fact define several distinct SCF classes.
In that case you need multiple <CODE>SCF_IMPLEMENT_FACTORY()</CODE> lines; one for
each SCF class.
</P><P>

<CODE>SCF_IMPLEMENT_<small>...</small>()</CODE> and <CODE>SCF_IMPLEMENT_FACTORY()</CODE>) are general
SCF macros.  As such they are not specifically related to plugin modules;
but rather help to define SCF classes.
</P><P>

In the constructor of `<SAMP>MyPlugin</SAMP>' you must call
<CODE>SCF_CONSTRUCT_IBASE()</CODE> for the main interface and
<CODE>SCF_CONSTRUCT_EMBEDDED_IBASE()</CODE> for each embedded interface.  These
macros will ensure that the object is initialized correctly (i.e. reference
count set to 1 and so on).  Likewise, in the destructor, you must call the
corresponding <CODE>SCF_DESTRUCT_IBASE()</CODE> and
<CODE>SCF_DESTRUCT_EMBEDDED_IBASE()</CODE> macros.
</P><P>

The rest of the plugin is very straightforward. It is important
to realize that you should do most initialization of the plugin
in the <CODE>Initialize()</CODE> function and not in the constructor. The reason
for this is that at construction time you cannot depend on the entire
Crystal Space framework being ready. Also when <CODE>Initialize()</CODE> is
called you get a pointer to the object registry which is essential
for locating other modules and plugins loaded by the Crystal Space
framework.
</P><P>

This should conclude the implementation of the plugin.
</P><P>

<A NAME="SEC334"></A>
<H4> Telling SCF About Your Plugin </H4>
<!--docid::SEC334::-->
<P>

SCF discovers plugins automatically and dynamically.  It determines which
plugin modules implement which SCF classes by consulting meta-information
associated with each plugin.  The meta-information file for your plugin must
have the same basename as your built plugin module, but with extension
`<TT>.csplugin</TT>'.  For example, if the example plugin is built with the name
`<TT>myplugin.dll</TT>' (Windows) or `<TT>myplugin.so</TT>' (Unix), then the associated
meta-information file should be named `<TT>myplugin.csplugin</TT>'.  The
meta-information file is a structured XML-format document, and can contain
any information relevant to the plugin module.  SCF expects to find a node
named `<SAMP>scf</SAMP>', which contains SCF-related information about the plugin
module.
</P><P>

The `<TT>myplugin.csplugin</TT>' meta-information file for our example plugin module
might look like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#60;?xml version="1.0"?&#62;
&#60;!-- myplugin.csplugin --&#62;
&#60;plugin&#62;
  &#60;scf&#62;
    &#60;classes&#62;
      &#60;class&#62;
        &#60;name&#62;crystalspace.mygame.myplugin&#60;/name&#62;
        &#60;implementation&#62;MyPlugin&#60;/implementation&#62;
        &#60;description&#62;My Special Game Plugin&#60;/description&#62;
        &#60;requires&#62;
          &#60;class&#62;crystalspace.graphics3d.&#60;/class&#62;
        &#60;/requires&#62;
      &#60;/class&#62;
    &#60;/classes&#62;
  &#60;/scf&#62;
&#60;/plugin&#62;
</pre></td></tr></table></P><P>

Each SCF class exported by the plugin should be presented in a
<CODE>&#60;class&#62;</CODE> node within the <CODE>&#60;classes&#62;</CODE> group.  Each class has a
<CODE>&#60;name&#62;</CODE>, which is the SCF&#62; name of the class; an
<CODE>&#60;implementation&#62;</CODE>, which is the name of the C++ class implementing the
SCF&#62; class; a <CODE>&#60;description&#62;</CODE>; and optionally a <CODE>&#60;requires&#62;</CODE>
node, which lists the other SCF&#62; classes upon which this class depends.
Any number of classes may appear in the <CODE>&#60;requires&#62;</CODE> group.  If your
plugin depends only upon a certain type of class, rather than a specific
SCF class, then you list only the prefix portion of the desired class
type, as shown in this example (where we desire any 3D renderer).
</P><P>

<A NAME="SEC335"></A>
<H4> Compiling the Plugin </H4>
<!--docid::SEC335::-->
<P>

Depending on the compiler that you use I refer you to the
HOWTO's on the subject of compiling an external application. There
is a template makefile provided which also works for plugins. That's
by far the easiest way to get this compiled.
</P><P>

<A NAME="SEC336"></A>
<H4> Loading the Plugin in your Application </H4>
<!--docid::SEC336::-->
<P>

First include the header defining the API of the plugin:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include "myapi.h"
</pre></td></tr></table></P><P>

Do <EM>not</EM> include the `<TT>myplug.h</TT>' header file! This is implementation
specific and you should not use the implementation of the plugin
directly. Doing this invalidates the entire reason to use plugins
in the first place.
</P><P>

To load the plugin there are a few possibilities. First you
can load the plugin manually using <CODE>CS_LOAD_PLUGIN()</CODE> like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csRef&#60;iPluginManager&#62; plugin_mgr = 
  CS_QUERY_REGISTRY (object_reg, iPluginManager);
csRef&#60;iMyApi&#62; myapi = CS_LOAD_PLUGIN (plugin_mgr,
  "crystalspace.mygame.myplugin", iMyApi);        
</pre></td></tr></table></P><P>

This will query the plugin manager from the object registry.
This is the module that is responsible for loading and unloading
plugins.
</P><P>

Then it will use the plugin manager to load your plugin. Note that
this can fail. You should always check the returned value to see if
it is different from `<SAMP>0</SAMP>'.
</P><P>

Another way to load the plugin is through <CODE>RequestPlugins()</CODE> which
is called at initialization time:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>if (!csInitializer::RequestPlugins (object_reg,
     CS_REQUEST_VFS,
     CS_REQUEST_SOFTWARE3D,
     CS_REQUEST_ENGINE,
     <small>...</small>
     CS_REQUEST_PLUGIN("crystalspace.mygame.myplugin", iMyApi),
     CS_REQUEST_END))
{
  <small>...</small>
}
<small>...</small>

csRef&#60;iMyApi&#62; myapi = CS_QUERY_REGISTRY (object_reg, iMyApi);
</pre></td></tr></table></P><P>

This way has several advantages.  First it makes sure that the user can
override your plugin at the command line or in the configuration file (if you
have one for your game).  In cases where there are multiple possible
implementations for the same API this can be important.  It is by doing
this that it is possible to switch between software and OpenGL renderers with
the command line or via configuration file.
</P><P>

Secondly it registers the plugin with the object registry so that
it is easier to find your module later. This way other plugins
can find your plugin by doing a query on the object registry.
</P><P>

<A NAME="SEC337"></A>
<H4> Using the Plugin in Your Application </H4>
<!--docid::SEC337::-->
<P>

After loading the plugin you can use the plugin by just
calling the methods defined in the API:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>myapi-&#62;DoSomething (1, csVector3 (2, 3, 4));
printf ("%d\n", myapi-&#62;GetSomething ());
</pre></td></tr></table></P><P>

This should print out 9.
<A NAME="HOWTO Simple Map Example"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_128.html#SEC325"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_130.html#SEC338"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_101.html#SEC205"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_109.html#SEC221"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_134.html#SEC350"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_292.html#SEC943">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
