<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: Simple Creating Mesh</TITLE>

<META NAME="description" CONTENT="Crystal Space: Simple Creating Mesh">
<META NAME="keywords" CONTENT="Crystal Space: Simple Creating Mesh">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC5.3.3"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_5.3.2.html#SEC5.3.2"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_5.4.html#SEC5.4"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_5.2.html#SEC5.2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_5.3.html#SEC5.3"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_5.4.html#SEC5.4"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs__1.html#SEC_1">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 5.3.3 Creating a Mesh from a Factory </H3>
<!--docid::SEC5.3.3::-->
<P>

To create a mesh just add the following code in
<CODE>Simple::CreateSprites()</CODE> (before `<SAMP>return true</SAMP>' and after
the code we just added to load the mesh factory):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>void Simple::CreateSprites ()
{
  <small>...</small>

  // Add the sprite to the engine.
  csRef&#60;iMeshWrapper&#62; sprite (engine-&#62;CreateMeshWrapper (
        imeshfact, "MySprite", room,
        csVector3 (-3, 5, 3)));
  csMatrix3 m; m.Identity (); m *= 5.;	// Don't do this scale in your own code!!!
  sprite-&#62;GetMovable ()-&#62;SetTransform (m);
  sprite-&#62;GetMovable ()-&#62;UpdateMove ();
  csRef&#60;iSprite3DState&#62; spstate (
    SCF_QUERY_INTERFACE (sprite-&#62;GetMeshObject (), iSprite3DState));
  spstate-&#62;SetAction ("default");
  sprite-&#62;SetZBufMode (CS_ZBUF_USE);
  sprite-&#62;SetRenderPriority (engine-&#62;GetObjectRenderPriority ());
}
</pre></td></tr></table></P><P>

The easiest way to create a mesh is to use <CODE>engine-&#62;CreateMeshWrapper()</CODE>.
This will take care of using the given mesh factory to create the mesh, give
it a name, and correctly place it at the given position in the world.
The name of a mesh can be useful for scripting so that a script can refer
to objects with their names.
</P><P>

Moving meshes (and things) is done through the <CODE>iMovable</CODE> interface to
which you can get a reference by doing <CODE>sprite-&#62;GetMovable()</CODE>.  The calls
to <CODE>SetTransform()</CODE> and <CODE>SetPosition()</CODE> set up a transformation
matrix and vector to correctly place the mesh in the room.  In this
particular case we use the identity matrix as a transform and scale it with
five to make the sprite five times bigger.
After doing movement (either updating the sectors or the position) you
<EM>must</EM> call <CODE>movable-&#62;UpdateMove()</CODE> to change internal data
structures (i.e. the engine may use this to recalculate visibility
information).
</P><P>

<EM>WARNING</EM>: The code above actually scaled the object by giving it
a transformation matrix which is multiplied with 5. Don't do this in your
own code. Many subsystems in Crystal Space (like the collision detection
system, the visibility culling system and the lighting system) don't work
properly with scaled objects. Instead scale your object using
<CODE>HardTransform()</CODE>.
</P><P>

If you read the mesh object documentation (see see section <A HREF="cs_7.7.html#SEC7.7">7.7 Mesh Object Plug-In System</A>)
carefully you will see that in order to control visual attributes
of mesh objects you will have to get the <EM>state</EM> interface for
either the object or the factory. In this example we query
`<SAMP>iSprite3DState</SAMP>' from the mesh in order to set the default action.
An action is a set of frames and is used to control animation. In our
simple example the sprite has only one frame so there is not much animation
to see.
</P><P>

The calls to <CODE>SetZBufMode()</CODE> and <CODE>SetRenderPriority()</CODE> are not
strictly required since the values set here are default for meshes anyway.
But the two lines serve as an example on how to set other values for these.
<CODE>SetZBufMode()</CODE> sets the Z-buffer mode that the engine will use to
render this object. With `<SAMP>CS_ZBUF_USE</SAMP>' this means that the Z-buffer
will be used fully. Other values are `<SAMP>CS_ZBUF_FILL</SAMP>' (only fill the
Z-buffer), `<SAMP>CS_ZBUF_TEST</SAMP>' (only test the Z-buffer), or `<SAMP>CS_ZBUF_NONE</SAMP>'
(ignore the Z-buffer). `<SAMP>CS_ZBUF_USE</SAMP>' is a good default for objects
in a room. `<SAMP>CS_ZBUF_FILL</SAMP>' is usually used for the outside walls of
a sector.
</P><P>

<CODE>SetRenderPriority()</CODE> controls when this object is rendered in this
sector. By default there are four render priorities: <EM>sky</EM>, <EM>wall</EM>,
<EM>object</EM>, and <EM>alpha</EM>. Every object can be put in a render
priority queue. Objects in lower render priorities will be rendered before
objects in higher render priorities. In addition some render priority queues
sort objects internally based on some other criteria. For example, the
`<SAMP>alpha</SAMP>' render priority will render all objects in that queue
from back to front. You can create your own additional render queues if
you want. The default render priority is <EM>object</EM> which you can
get with the call <CODE>engine-&#62;GetObjectRenderPriority()</CODE>. Most objects
with Z-buffer mode equal to `<SAMP>CS_ZBUF_USE</SAMP>' are placed in the
`<SAMP>object</SAMP>' render priority queue.
</P><P>

For more information on render priorities and Z-buffer mode you can look
at the HOWTO on this subject (see section <A HREF="cs_5.8.12.html#SEC5.8.12">5.8.12 Render Priorities and Objects in Sectors</A>).
</P><P>

This concludes the second Simple tutorial.
You can now go on to the next tutorial (see section <A HREF="cs_5.4.html#SEC5.4">5.4 Simple Tutorial 3: Map Loading</A>)) to learn
how you can load a map from a file instead of creating your rooms
programmatically.
<A NAME="Tutorial Simple Map"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_5.3.2.html#SEC5.3.2"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_5.4.html#SEC5.4"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_5.2.html#SEC5.2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_5.3.html#SEC5.3"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_5.4.html#SEC5.4"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs__1.html#SEC_1">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
