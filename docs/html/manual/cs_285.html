<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: Release Notes 17</TITLE>

<META NAME="description" CONTENT="Crystal Space: Release Notes 17">
<META NAME="keywords" CONTENT="Crystal Space: Release Notes 17">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC943"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_284.html#SEC934"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC953"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_277.html#SEC822"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_277.html#SEC822"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC953"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC953">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H2> C.8 Release Notes from 0.16 to 0.17 </H2>
<!--docid::SEC943::-->
<P>

This section documents the major changes between versions 0.16 and 0.17 of of
Crystal Space.
</P><P>

<A NAME="SEC944"></A>
<H3> Signature Change: NextFrame(elapsed_time/current_time) </H3>
<!--docid::SEC944::-->
<P>

<CODE>csSystemDriver::NextFrame()</CODE> no longer accepts `<SAMP>elapsed_time</SAMP>' and
`<SAMP>current_time</SAMP>' arguments, so you have to change the prototype of your own
subclassed version of <CODE>NextFrame()</CODE> and call the following three lines in
the order below (only if you need the elapsed and current time, of course):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>void MySubclass::NextFrame()
{
  SysSystemDriver::NextFrame();
  cs_time elapsed_time, current_time;
  GetElapsedTime(elapsed_time,current_time);
  <small>...</small>
</pre></td></tr></table></P><P>

<A NAME="SEC945"></A>
<H3> Signature Change: HandleEvent(csEvent) </H3>
<!--docid::SEC945::-->
<P>

The argument of <CODE>csSystemDriver::HandleEvent()</CODE> has changed from a
`<SAMP>csEvent*</SAMP>' parameter to an `<SAMP>iEvent*</SAMP>'.  Update your subclassed
versions if present.
</P><P>

<A NAME="SEC946"></A>
<H3> Materials Versus Textures </H3>
<!--docid::SEC946::-->
<P>

Crystal Space 0.17 supports <EM>materials</EM> in the sense that the API is
ready for it.  There is no real material support though.  A material currently
just corresponds with a texture.  Here are a few short remarks about the
changes:
</P><P>

<UL>
<LI>
<CODE>csTextureHandle()</CODE> was renamed to <CODE>csTextureWrapper()</CODE>.
<P>

<LI>
New class: <CODE>csMaterialWrapper</CODE>
<P>

<LI>
The methods <CODE>SetTexture()</CODE> and <CODE>GetTexture()</CODE> were renamed to
<CODE>SetMaterial()</CODE> and <CODE>GetMaterial()</CODE>, respectively, in many places.
<P>

<LI>
The methods
<CODE>SetTextureHandle()</CODE> and <CODE>GetTextureHandle()</CODE> were renamed to
<CODE>SetMaterialWrapper()</CODE> and <CODE>GetMaterialWrapper()</CODE>, respectively.
</UL>
<P>

In general, in most places where you used to use <CODE>SetTexture()</CODE> or
<CODE>GetTexture()</CODE> you now need to use the material versions.  There are few
places where you deal directly with textures.  The material system sits on top
of the texture system and is what you should use in most cases.
</P><P>

`<SAMP>csWorld</SAMP>' now has a <CODE>GetMaterials()</CODE> function which you probably
should use wherever you used <CODE>GetTextures()</CODE> in the past.
</P><P>

In the loader you can find a new function, <CODE>csLoader::FindMaterial()</CODE>,
which will find a material with the given name.  If not found it tries to find
a texture with of the same name and, if found, will automatically then create
a material from that texture.
</P><P>

The <CODE>csLoader::LoadTexture()</CODE> method is a bit special.  As before, it
loads a texture (and returns a `<SAMP>csTextureWrapper</SAMP>') but it also adds a
material with the same name to the material list.  You can then fetch that
material from that list with code similar to the following:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csLoader::LoadTexture(world,"myTexture","/lib/std/stone4.gif");
csMaterialWrapper* m =
  world-&#62;GetMaterials()-&#62;FindByName("myTexture");
</pre></td></tr></table></P><P>

<A NAME="SEC947"></A>
<H3> Collision Detection Plugin </H3>
<!--docid::SEC947::-->
<P>

This is a very significant change.  The RAPID collision detection system
has been completely removed from the engine and is now available through a
plug-in module.  This change will most likely require the most complicated
changes to your code.
</P><P>

The first thing you need to add to your application is code to load the
plugin.  You can do this with the following code:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>char const* p = Config-&#62;GetStr (
  "YourGame",
  "COLLDET_PLUGIN",
  "crystalspace.colldet.rapid");
collide_system =
  LOAD_PLUGIN(this, p, "CollDet", iCollideSystem);
if (!collide_system)
{
  Printf(MSG_FATAL_ERROR,
    "No Collision Detection plugin found!\n");
  return false;
}
</pre></td></tr></table></P><P>

This code loads the rapid collision detection plugin by default (which is the
only one we have now) but it also reads an entry from your config file so that
the user can possibly change it.  If you don't want that then you can just
hardcode the `<SAMP>p</SAMP>' pointer with the name of the RAPID plugin.
</P><P>

Note that you need to store the value of `<SAMP>collide_system</SAMP>' some place
where it can be accessed by the routines that need to do the collision
detection.
</P><P>

Then the class `<SAMP>csRAPIDCollider</SAMP>' has been removed from csengine.  Instead
there is a new class, `<SAMP>csCollider</SAMP>'.  This class encapsulates an
`<SAMP>iCollider</SAMP>' (which is something that is returned from
`<SAMP>collide_system</SAMP>').  This is the easiest way to use the new collision
detection system as it more closely resembles what was possible with
`<SAMP>csRAPIDCollider</SAMP>'.  To make a `<SAMP>csCollider</SAMP>' you can use the following
code:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>iPolygonMesh* mesh =
  QUERY_INTERFACE(object, iPolygonMesh);
csCollider* collider =
  new csCollider(*object, collide_system, mesh);
</pre></td></tr></table></P><P>

`<SAMP>object</SAMP>' can be a sector, sprite, thing, or your own object that supports
the `<SAMP>iPolygonMesh</SAMP>' interface.  The new collider will be attached (through
the `<SAMP>csObject</SAMP>' system) to the object.  This is similar to what happened
with the old `<SAMP>csRAPIDCollider</SAMP>' class.
</P><P>

To do collision detection you need to find the colliders (or have them stored
somewhere) and then you can do:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>bool rc = collide_system-&#62;Collide(
  col1-&#62;GetCollider(), trans1,
  col2-&#62;GetCollider(), trans2);
</pre></td></tr></table></P><P>

Or:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>bool rc = col1-&#62;Collide(*object2, trans1, trans2);
</pre></td></tr></table></P><P>

With `<SAMP>col1</SAMP>' and `<SAMP>col2</SAMP>' are the colliders (`<SAMP>csCollider</SAMP>') and
`<SAMP>object2</SAMP>' is the second object.  `<SAMP>trans1</SAMP>' and `<SAMP>trans2</SAMP>' are the
respective transformations.
</P><P>

Note that before you call this you probably want to initialize the collision
system like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>collide_system-&#62;ResetCollisionPairs();
collide_system-&#62;SetOneHitOnly(<VAR>true</VAR>/<VAR>false</VAR>);
</pre></td></tr></table></P><P>

The argument for the second function depends on whether or not you
are interested in receiving more than one hit.
</P><P>

Note that <CODE>ResetCollisionPairs()</CODE> is important. Every call
to <CODE>Collide()</CODE> will add additional collision pairs to this array.
So you have to reset it if you are no longer interested in that.
</P><P>

Note that <CODE>csRAPIDCollider::Report()</CODE> is gone. If you want that
functionality you have to do it on your own (which is not difficult).
</P><P>

<A NAME="SEC948"></A>
<H3> Texture Mapping Changes </H3>
<!--docid::SEC948::-->
<P>

The way engine defines and uses texturing has changed.  There are four polygon
texturing types now:
</P><P>

<DL COMPACT>
<DT><CODE>POLYTXT_NONE</CODE>
<DD>No texturing.  Useful when using materials without textures.  It defines no
texturing parameters at all thus saves memory.
<P>

<DT><CODE>POLYTXT_FLAT</CODE>
<DD>Flat-shading.  Only the angle between light and polygon normal is considered
if `<SAMP>CS_POLY_LIGHTING</SAMP>' flag is set, and entire polygon is painted with one
lighting value.  Every vertex has an U/V pair associated.
<P>

<DT><CODE>POLYTXT_GOURAUD</CODE>
<DD>Every polygon vertex has a color and those colors are interpolated across
scanlines.
<P>

<DT><CODE>POLYTXT_LIGHTMAP</CODE>
<DD>A polygon which has an associated lightmap and a texture plane.
</DL>
<P>

Now it is possible to define and use objects which have flat-color but still
receive light with Gouraud as well as without Gouraud interpolation; in
general this open a whole new area for experimenting.
</P><P>

In practice this means that `<SAMP>csGouraudShaded</SAMP>' is gone and has been
replaced with `<SAMP>csPolyTexGouraud</SAMP>'.  `<SAMP>csLightMapped</SAMP>' has also gone and
is replaced with `<SAMP>csPolyTexLightMap</SAMP>'.
</P><P>

<A NAME="SEC949"></A>
<H3> Sound Changes </H3>
<!--docid::SEC949::-->
<P>

Merged sound buffers into sound sources.  We now have 3D and non-3D sound
sources.  Non-3D sources are what were formerly sound buffers.  As a parameter
to `<SAMP>Renderer-&#62;CreateSource()</SAMP>' you can indicate if you want a 3D or non-3D
source.
</P><P>

The sound loader is now a plugin and must be loaded as such.  It uses the
`<SAMP>iSoundLoader</SAMP>' interface.  A loaded sound data block is represented by
`<SAMP>iSoundData</SAMP>'.
</P><P>

If you use standard Crystal Space libraries to load sounds, this is all you
need to be aware of.  Otherwise you should also know how to load a sound
without `<SAMP>csParser</SAMP>'.
</P><P>

To load a sound the sound loader now needs some information describing the
format of the sound.  This information can be queried from the sound renderer.
Also, a sound can be optionally be loaded as <EM>stream</EM>.  This is currently
not useful for anything, but will instead affect performance and memory in a
negative way.  It is intended as a future option to load background music.
All member functions of `<SAMP>iSoundData</SAMP>' are intended for private use (of
course you may use them, but I don't think they are useful).  To load a sound,
perform the following steps.
</P><P>

<OL>
<LI>
Load the file buffer from a VFS path.  See section <A HREF="cs_159.html#SEC393">7.2 Virtual File System (VFS)</A>.
<P>

<LI>
Ask the sound renderer for the format descriptor (`<SAMP>csSoundFormat</SAMP>').
<P>

<LI>
Pass both the file data and the format to the sound loader, using `<SAMP>false</SAMP>'
for streaming (the default).  After that, you may delete the file data.
</OL>
<P>

<A NAME="SEC950"></A>
<H3> Thing and Sprite Changes (csMovable) </H3>
<!--docid::SEC950::-->
<P>

The movement system of Things and Sprites has been merged into one class
called `<SAMP>csMovable</SAMP>'.  Thus, all functions such as <CODE>SetPosition()</CODE>,
<CODE>SetTransform()</CODE>, and so on, have been removed from `<SAMP>csThing</SAMP>' and
`<SAMP>csSprite</SAMP>'.  Instead there is a function <CODE>GetMovable()</CODE> (both for
Things and Sprites) which returns the `<SAMP>csMovable</SAMP>' for that object.  There
is also a new function called <CODE>csMovable::UpdateMove()</CODE>--which resembles
the original <CODE>csThing::Transform()</CODE> somewhat--which you <EM>must</EM> call
after updating the position and/or transformation of the movable which belongs
to the object.
</P><P>

In addition to the changes related to `<SAMP>csMovable</SAMP>' the linked list of sky
and thing objects in a sector has also been replaced by a `<SAMP>csVector</SAMP>' and
things are now also kept in a global list in the `<SAMP>csWorld</SAMP>', just like
sprites.  This means that sprites and things look a lot more like each other
now with regards to movement and placement in sectors.  This means that
functions such as <CODE>AddThing()</CODE>, <CODE>GetNumThings()</CODE>,
<CODE>RemoveThing()</CODE> and <CODE>GetFirstThing()</CODE> are now gone, as are the
similar methods for sky objects.  Instead, you should work through the new
public `<SAMP>skies</SAMP>' and `<SAMP>things</SAMP>' vectors.  In addition to this the
<CODE>GetNext()</CODE> and <CODE>GetParent()</CODE> functions have been removed from
`<SAMP>csPolygonSet</SAMP>'.
</P><P>

Given the old code to operate on things:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csThing* thing = new csThing(world);
sector-&#62;AddThing(thing);
thing-&#62;SetPosition(csVector3(0,0,3));
thing-&#62;SetTransform(csMatrix3());
thing-&#62;Transform();
<small>...</small>
sector-&#62;RemoveThing(thing);
delete thing;
</pre></td></tr></table></P><P>

It will need to be converted to the following:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csThing* thing = new csThing(world);
world-&#62;things.Push(thing);
csMovable&#38; move = thing-&#62;GetMovable();
move.SetSector(sector);
move.SetPosition(csVector3(0,0,3));
move.SetTransform(csMatrix3());
move.UpdateMove();
<small>...</small>
world-&#62;RemoveThing(thing);
</pre></td></tr></table></P><P>

Given the old to operate on sprites:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csSprite3D* sprite = new csSprite3D(world);
world-&#62;sprites.Push(sprite);
sprite-&#62;MoveToSector(sector);
sprite-&#62;SetPosition(csVector3(0,0,3));
sprite-&#62;SetTransform(csMatrix3());
</pre></td></tr></table></P><P>

It will need to be transformed to:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csSprite3D* sprite = new csSprite3D(world);
world-&#62;sprites.Push(sprite);
csMovable&#38; move = sprite-&#62;GetMovable();
move.SetSector(sector);
move.SetPosition(csVector3(0,0,3));
move.SetTransform(csMatrix3());
move.UpdateMove();
</pre></td></tr></table></P><P>

Especially note the new call to <CODE>UpdateMove()</CODE>.
</P><P>

<A NAME="SEC951"></A>
<H3> API Changes: csCamera </H3>
<!--docid::SEC951::-->
<P>

The function <CODE>SetFOV()</CODE> now needs an extra parameter which is the width
of the display.  This is needed for calculating the angle of the FOV
(<EM>field of view</EM>).  In addition, there are now new <CODE>SetFOVAngle()</CODE>
and <CODE>GetFOVAngle()</CODE> functions.  <CODE>GetFOVAngle()</CODE> used to be in
<CODE>csRenderView()</CODE>.
</P><P>

<A NAME="SEC952"></A>
<H3> API Changes: csWorld </H3>
<!--docid::SEC952::-->
<P>

Here is a list of the more significant API changes to `<SAMP>csWorld</SAMP>'.
</P><P>

<UL>
<LI>
Added <CODE>csWorld::FindLight(char const* name)</CODE>.
<P>

<LI>
Removed <CODE>csWorld::NewSector()</CODE>.  Use <CODE>world-&#62;CreateCsSector()</CODE>
instead.
<P>

<LI>
Removed <CODE>csWorld::GetThing()</CODE>.  Use <CODE>world-&#62;things.FindByName()</CODE>
instead.
<P>

<LI>
Removed the method <CODE>csWorld::GetSpriteTemplate()</CODE>.  Instead, use this
expression: <CODE>world-&#62;sprite_templates.FindByName()</CODE>
<P>

<LI>
Removed the method <CODE>csWorld::GetThingTemplate()</CODE>.  Instead, use this
expression: <CODE>world-&#62;thing_templates.FindByName()</CODE> instead.
<P>

<LI>
Added <CODE>csWorld::UnlinkCollection()</CODE> and
<CODE>csWorld::RemoveCollection()</CODE>.
<P>

<LI>
Added <CODE>csWorld::GetBeginDrawFlags()</CODE>.  This is a very important function
that you <EM>must</EM> invoke when calling <CODE>iGraphics3D::BeginDraw()</CODE> in
your application just before you give control to the engine for drawing.
</UL>
<P>

<A NAME="Index"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_284.html#SEC934"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC953"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_277.html#SEC822"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_277.html#SEC822"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC953"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC953">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
