<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: Simple Camera</TITLE>

<META NAME="description" CONTENT="Crystal Space: Simple Camera">
<META NAME="keywords" CONTENT="Crystal Space: Simple Camera">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC177"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_78.html#SEC176"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_80.html#SEC178"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_71.html#SEC159"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_75.html#SEC173"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_81.html#SEC179"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_287.html#SEC964">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 5.2.4 The Camera </H3>
<!--docid::SEC177::-->
<P>

In Crystal Space there is an interface called `<SAMP>iView</SAMP>' which
encapsulates both `<SAMP>iCamera</SAMP>' and `<SAMP>iClipper2D</SAMP>' instances.
In principle you can use those classes directly but using `<SAMP>iView</SAMP>' is
easier.  Now, edit `<TT>simple.h</TT>' to make use of `<SAMP>iView</SAMP>':
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre><small>...</small>
class Simple
{
private:
  <small>...</small>
  csRef&#60;iView&#62; view;
  <small>...</small>
  void ProcessFrame ();
  void FinishFrame ();
  <small>...</small>
</pre></td></tr></table></P><P>

Then, edit `<TT>simple.cpp</TT>' and make the following changes at the end of
our <CODE>Application()</CODE> function:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>bool Simple::Application ()
{
  <small>...</small>
  view.AttachNew(new csView (engine, g3d));
  iGraphics2D* g2d = g3d-&#62;GetDriver2D ();
  view-&#62;SetRectangle (0, 0, g2d-&#62;GetWidth (), g2d-&#62;GetHeight ());
  <small>...</small>
  view-&#62;GetCamera ()-&#62;SetSector (room);
  view-&#62;GetCamera ()-&#62;GetTransform ().SetOrigin (csVector3 (0, 5, -3));

  return true;
}
</pre></td></tr></table></P><P>

So, first we create a view for our world and a paritulcar 3D renderer.
The view has a current sector which is passed to the camera and is set by
<CODE>SetSector()</CODE>.  The camera also has a position in that sector which you
can set by first getting the camera with <CODE>GetCamera()</CODE> and then setting
the position (which is a `<SAMP>csVector3</SAMP>') with <CODE>SetPosition()</CODE>.  The
view also holds a clipping region which corresponds to the area on the window
that is going to be used for drawing the world.  Crystal Space supports convex
polygons as viewing areas, but in this case we use a simple rectangle
the same size as the window.  We set this viewing rectangle with
<CODE>SetRectangle()</CODE>.
</P><P>

The call to create a new view is a bit special. See the discussion
on smart pointers for a detailed discussion (see section <A HREF="cs_111.html#SEC227">5.8.1 Correctly Using Smart Pointers</A>).
</P><P>

Now, this still isn't enough.  We have a camera but the camera is not used.
We have to write code that actually draws the screen. We will do this
in the functions <CODE>ProcessFrame()</CODE> and <CODE>FinishFrame()</CODE>. Note that
Crystal Space is event driven so the actual drawing needs to be triggered
by the event handler. Add the following code somewhere in the source file:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>void Simple::ProcessFrame ()
{
  // Tell 3D driver we're going to display 3D things.
  if (!g3d-&#62;BeginDraw(
    engine-&#62;GetBeginDrawFlags() | CSDRAW_3DGRAPHICS))
    return;

  // Tell the camera to render into the frame buffer.
  view-&#62;Draw ();
}

void Simple::FinishFrame ()
{
  g3d-&#62;FinishDraw ();
  g3d-&#62;Print (0);
}
</pre></td></tr></table></P><P>

Drawing the screen is done in two steps. First there is the part that
is done in <CODE>ProcessFrame()</CODE>. Here, we will actually fill the display.
In this case we let the engine do most of that work by calling
<CODE>view-&#62;Draw()</CODE>. But, in principle, you can do any kind of drawing here.
</P><P>

In <CODE>ProcessFrame()</CODE> we first have to indicate to the 3D rasterizer that
we want to start drawing 3D graphics.  This call makes sure that the
needed buffers are set up and
performs all necessary initialization. The engine often needs extra settings
for this as well so you <EM>must</EM> call <CODE>engine-&#62;GetBeginDrawFlags()</CODE> to
get these flags and bitwise-or them with the ones that you want.
</P><P>

The second part is in <CODE>FinishFrame()</CODE> where we actually dump the
frame to the screen. The reason this is split is that other components
(plugins) in Crystal Space may choose to listen to events and draw additional
things on top of the 3D view rendered in <CODE>ProcessFrame()</CODE>. When a frame
needs to be rendered, the Crystal Space framework will send four messages:
</P><P>

<UL>
<LI>
`<SAMP>cscmdPreProcess</SAMP>' is sent first. This allows plugins to preprocess
things before drawing can happen.
<P>

<LI>
`<SAMP>cscmdProcess</SAMP>' follows. In this pass the application will render.
<P>

<LI>
`<SAMP>cscmdPostProcess</SAMP>' is after that. This is the pass that can be used
by external components to render on top of the view rendered by the
application.
<P>

<LI>
`<SAMP>cscmdFinalProcess</SAMP>' is last. In this pass the application will display
the frame on screen.
</UL>
<P>

Compile and run this example.  For the first time you should see something: A
solid wall.  Congratulations, you have created your first almost useful
Crystal Space application.
</P><P>

<A NAME="Simple Locomotion"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_78.html#SEC176"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_80.html#SEC178"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_71.html#SEC159"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_75.html#SEC173"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_81.html#SEC179"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_287.html#SEC964">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
