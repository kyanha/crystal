<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: Internal Workings</TITLE>

<META NAME="description" CONTENT="Crystal Space: Internal Workings">
<META NAME="keywords" CONTENT="Crystal Space: Internal Workings">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC476"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_196.html#SEC470"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_198.html#SEC490"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_164.html#SEC403"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_166.html#SEC408"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_198.html#SEC490"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_292.html#SEC941">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 7.6.14 The Engine Internals Explained </H3>
<!--docid::SEC476::-->
<P>

<EM>Written by Jorrit Tyberghein,
<A HREF="mailto:jorrit.tyberghein@uz.kuleuven.ac.be">jorrit.tyberghein@uz.kuleuven.ac.be</A>. Last updated 30 April 2004.</EM>
</P><P>

This section explains, in some detail, how the engine works internally.
This information is mainly for people who are interested in learning
how the Crystal Space engine works internally and for people who want
to contribute to the engine proper. The sources for the 3D engine can be found
in `<TT>CS/plugins/engine/3d</TT>'.
</P><P>

Note: This discussion is specific to how the engine works in relation
to the new renderer. The old renderer is still in Crystal Space at this moment
but this discussion does not bear upon it.
</P><P>

<A NAME="SEC477"></A>
<H4> Engine Data Structures </H4>
<!--docid::SEC477::-->
<P>

The following sections explain the various data structures that
are used in the engine. Many of these data structures are subclasses of
`<SAMP>csObject</SAMP>', which means that you can use them in your game to attach
other game specific objects.
</P><P>

<A NAME="SEC478"></A>
<H4> Engine Data Structures: csEngine </H4>
<!--docid::SEC478::-->
<P>

At the core of everything there is the `<SAMP>csEngine</SAMP>' class which implements
the publicly viewable `<SAMP>iEngine</SAMP>' interface.  The engine class implements
the following interfaces:
</P><P>

<UL>
<LI>
<CODE>iEngine</CODE>: The main entry point for the engine.
<LI>
<CODE>iObject</CODE>: Allows attachment of game-specific data.
</UL>
<P>

The engine class maintains the following lists of different types of objects
or operations:
</P><P>

<UL>
<LI>
<CODE>sectors</CODE>: Class `<SAMP>csSector</SAMP>', interface `<SAMP>iSector</SAMP>'. As explained
in other parts of this manual, a sector is simply an infinite region of space.
There is always at least one sector.
<P>

<LI>
<CODE>mesh_factories</CODE>: Class `<SAMP>csMeshFactoryWrapper</SAMP>', interface
`<SAMP>iMeshFactoryWrapper</SAMP>'. Mesh factory wrappers contain templates for making
objects. A factory is not visible itself but you can create mesh objects
from a factory and place them into sectors. Note that children of hierarchical
mesh factories are not in this list.
<P>

<LI>
<CODE>meshes</CODE>: Class `<SAMP>csMeshWrapper</SAMP>', interface `<SAMP>iMeshWrapper</SAMP>'. These
are the actual mesh objects. Mesh objects are normally placed in sectors but
every mesh will also be present in this list so that the engine can perform
maintenance on them. A mesh object that is not in any sector, but only
in this list, will not be visible. Note that children of hierarchical
mesh objects are not in this list.
<P>

<LI>
<CODE>collections</CODE>: Class `<SAMP>csCollection</SAMP>', interface `<SAMP>iCollection</SAMP>'. A
collection is a simple container for other objects (meshes, lights, etc.).
This can be useful for scripts.
<P>

<LI>
<CODE>camera_positions</CODE>: Class `<SAMP>csCameraPosition</SAMP>', interface
`<SAMP>iCameraPosition</SAMP>'. If you define start positions in your map file, then
they will be placed into this list.
<P>

<LI>
<CODE>regions</CODE>: Class `<SAMP>csRegion</SAMP>', interface `<SAMP>iRegion</SAMP>'.  Regions
provide a way to organize your objects.  Every object (mesh, factory, material,
light, sector, etc.) can be placed into a region. Note that a region is not
a geometrical concept. You can use one region to contain all materials,
and another to contain all mesh objects, for example. On the other hand, it is
probably most useful to have regions that represent geometrical areas which
you can load and unload from the engine (useful for making huge maps).
<P>

<LI>
<CODE>textures</CODE>: Class `<SAMP>csTextureWrapper</SAMP>', interface
`<SAMP>iTextureWrapper</SAMP>'.  A texture is a processed image that can be used by the
renderer.
<P>

<LI>
<CODE>materials</CODE>: Class `<SAMP>csMaterialWrapper</SAMP>', interface
`<SAMP>iMaterialWrapper</SAMP>'.  A material is a surface attribute for a mesh object.
A material usually uses at least one texture but it is also possible to have
materials that do not utilize textures at all.
<P>

<LI>
<CODE>halos</CODE>: Class `<SAMP>csLightHalo</SAMP>', interface `<SAMP>iHalo</SAMP>'.  Halos and lens
flares are in this list.  This list contains all halos that were visible during
frame rendering. After the entire frame has been rendered the engine uses
this list to draw all halos that were visible.
<P>

<LI>
<CODE>shared_variables</CODE>: Class `<SAMP>csSharedVariable</SAMP>', interface
`<SAMP>iSharedVariable</SAMP>'. The engine maintains a list of variables that can
be used for the engine sequence manager and also for controlling LOD
(level of detail).
<P>

<LI>
<CODE>cleanup</CODE>: This is an array that keeps track of items that the engine must
clean up (delete) when the engine itself is destroyed.
<P>

<LI>
<CODE>render_priorities</CODE>: This is a list of all render priorities supported by
the engine. Render priorities control in which order objects
in a sector must be rendered.
<P>

<LI>
<CODE>want_to_die</CODE>: This is a set of all `<SAMP>iMeshWrapper</SAMP>' objects
that want to die the next frame. The purpose of this lists is for mesh
objects to schedule their own destruction (this can be useful for an
explosion mesh object for example). The mesh object cannot destroy itself
since it would then remove its own instance and this would be problematic.
</UL>
<P>

In addition, the engine also maintains the following important variables:
</P><P>

<UL>
<LI>
<CODE>Strings</CODE>: Interface `<SAMP>iStringSet</SAMP>'.  The string set interface is used
for converting strings to numerical identifiers.  The renderer and shader
systems uses these identifiers for tagging types of items since comparison of
numerical identifiers is faster than comparison of string identifiers.
<P>

<LI>
<CODE>cache_mgr</CODE>: Interface `<SAMP>iCacheManager</SAMP>'.  This is the default cache
manager maintained by the engine.  The cache manager is responsible for storing
data that is hard to compute.  Mesh objects and other plugins may use the cache
manager to store, for example, lightmaps and other stuff.
<P>

<LI>
<CODE>defaultRenderLoop</CODE>: Interface `<SAMP>iRenderLoop</SAMP>'. The default renderloop
controls how objects are rendered in a sector in combination with shaders.
More on that later. Note that sectors can override the default renderloop.
<P>

<LI>
<CODE>renderLoopManager</CODE>: Interface `<SAMP>csRenderLoopManager</SAMP>'.  The renderloop
manager is responsible for creating renderloops.
<P>

<LI>
<CODE>render_context</CODE>: Interface `<SAMP>iTextureHandle</SAMP>'.  This is used while
rendering on a texture (i.e.  when using <CODE>iGraphics3D::SetRenderTarget()</CODE>
is in effect).
<P>

<LI>
<CODE>default_shader</CODE>: Interface `<SAMP>iShader</SAMP>'.  This is the default shader
that is used on all materials which do not otherwise specify a shader.
<P>

<LI>
<CODE>top_clipper</CODE>: Class `<SAMP>csRenderView</SAMP>'.  During rendering of a frame
this variable points at the top level clipper.  More on how `<SAMP>csRenderView</SAMP>'
works later.
</UL>
<P>

<A NAME="SEC479"></A>
<H4> Engine Data Structures: csSector </H4>
<!--docid::SEC479::-->
<P>

A sector is one of the most important data structures in the engine.
It is a container for other objects (meshes and lights).
The sector class implements the following interfaces:
</P><P>

<UL>
<LI>
<CODE>iSector</CODE>: The main entry point for the sector.
<LI>
<CODE>iObject</CODE>: Allows attachment of game-specific data.
</UL>
<P>

The sector maintains the following lists:
</P><P>

<UL>
<LI>
<CODE>meshes</CODE>: Interface `<SAMP>iMeshWrapper</SAMP>'.  This is a list of all mesh
objects that are visible in this sector.  Note that a mesh can be in multiple
sectors at the same time (if it is crossing a portal boundary).
<P>

<LI>
<CODE>camera_meshes</CODE>: Interface `<SAMP>iMeshWrapper</SAMP>'.  This list contains all
meshes that have the `<SAMP>CS_ENTITY_CAMERA</SAMP>' flag set.  These meshes have to be
treated a bit differently (more on that later).
<P>

<LI>
<CODE>portal_meshes</CODE>: Interface `<SAMP>iMeshWrapper</SAMP>'.  This is a set of meshes
that have portals which leave from this sector.  By using this set you can
quickly find all sectors that are reachable from this sector (through portals).
<P>

<LI>
<CODE>lights</CODE>: Interface `<SAMP>iLight</SAMP>'.  This is a list of all lights in this
sector.
<P>

<LI>
<CODE>visibleMeshCache</CODE>: Class `<SAMP>csSector::visibleMeshCacheHolder</SAMP>'.  This
is a special list of caches for visibility.  More on this later.
<P>

<LI>
<CODE>usedMeshLists</CODE>: Class `<SAMP>csRenderMeshList</SAMP>'.  This is a list of data
structures which need to be cleaned up when the sector itself is destroyed.
More on this later.
</UL>
<P>

In addition, the sector also maintains the following important variables:
</P><P>

<UL>
<LI>
<CODE>dynamic_ambient_color</CODE>: Class `<SAMP>csColor</SAMP>'.  This is the current
dynamic ambient color that is added to all mesh objects in this sector.
<P>

<LI>
<CODE>renderloop</CODE>: Interface `<SAMP>iRenderLoop</SAMP>'.  The optional renderloop for
this sector.  If null, then the engine's renderloop will be used.
<P>

<LI>
<CODE>culler</CODE>: Interface `<SAMP>iVisibilityCuller</SAMP>'.  Every sector has a
visibility culler; usually an instance of either <EM>Frustvis</EM> or
<EM>Dynavis</EM>.  Frustvis is the default culler.
<P>

<LI>
<CODE>lights::kdtree</CODE>: Class `<SAMP>csKDTree</SAMP>'.  The <EM>kdtree</EM> helps to find
lights based upon some box in the sector.  Every light is added to this tree
with a <EM>bbox</EM> (bounding box) that is calculated from the center of the
light and the influence radius.
</UL>
<P>

<A NAME="SEC480"></A>
<H4> Engine Data Structures: csMeshFactoryWrapper </H4>
<!--docid::SEC480::-->
<P>

A `<SAMP>csMeshFactoryWrapper</SAMP>' is a wrapper class which the engine uses to keep
track of <CODE>iMeshObjectFactory</CODE> instances (these represent the real mesh
object factories), and also stores some engine-specific information.
The mesh factory wrapper class implements the following interfaces:
</P><P>

<UL>
<LI>
<CODE>iMeshFactoryWrapper</CODE>: The main entry point for the factory wrapper.
<LI>
<CODE>iObject</CODE>: Allows attachment of game-specific data.
</UL>
<P>

A mesh factory wrapper maintains the following important variables:
</P><P>

<UL>
<LI>
<CODE>meshFact</CODE>: Interface `<SAMP>iMeshObjectFactory</SAMP>'.  This is the actual mesh
object factory represented by this wrapper.
<P>

<LI>
<CODE>parent</CODE>: Interface `<SAMP>iMeshFactoryWrapper</SAMP>'.  Mesh factories can be
hierarchical.  If they are, then this variable will point to the parent.
Otherwise it is null.
<P>

<LI>
<CODE>transform</CODE>: Class `<SAMP>csReversibleTransform</SAMP>'.  This transform is only
used if this factory is a child of another factory.  In that case it is the
relative position of this child relative to the parent.  This is used when
instantiating mesh objects from a hierarchical factory to set up the initial
transforms.
<P>

<LI>
<CODE>children</CODE>: Class `<SAMP>csMeshFactoryFactoryList</SAMP>'.  If this is a
hierarchical mesh factory, then the children are listed here.
<P>

<LI>
<CODE>static_lod</CODE>: Class `<SAMP>csStaticLODFactoryMesh</SAMP>'.  If this is a
hierarchical factory with static LOD (level of detail), then this field
contains more information about that.
</UL>
<P>

<A NAME="SEC481"></A>
<H4> Engine Data Structures: csMeshWrapper </H4>
<!--docid::SEC481::-->
<P>

A `<SAMP>csMeshWrapper</SAMP>' is a wrapper class for the engine which allows it to
keep track of an `<SAMP>iMeshObject</SAMP>' instance (real mesh objects), and also
stores some engine-specific information.  The mesh wrapper class implements the
following interfaces:
</P><P>

<UL>
<LI>
<CODE>iMeshWrapper</CODE>: The main entry point for the mesh object wrapper.
<LI>
<CODE>iObject</CODE>: Allows attachment of game-specific data.
<LI>
<CODE>iVisibilityObject</CODE>: Used by the visibility culling plugin.  Mesh wrappers
can be registered with the visibility culler that lives in a sector.
<LI>
<CODE>iImposter</CODE>: Not yet implemented, but will be used for an imposter system.
</UL>
<P>

A mesh object wrapper maintains the following important variables:
</P><P>

<UL>
<LI>
<CODE>meshobj</CODE>: Interface `<SAMP>iMeshObject</SAMP>'. This is the actual mesh object
represented by this wrapper.
<P>

<LI>
<CODE>Parent</CODE> and <CODE>csParent</CODE>: Interface `<SAMP>iMeshWrapper</SAMP>' and class
`<SAMP>csMeshWrapper</SAMP>'.  If the mesh is part of a hierarchical mesh, then these
fields will point at the parent mesh.
<P>

<LI>
<CODE>children</CODE>: Class `<SAMP>csMeshMeshList</SAMP>'.  This is a list of children if
this is a hierarchical mesh object.
<P>

<LI>
<CODE>factory</CODE>: Interface `<SAMP>iMeshFactoryWrapper</SAMP>'.  Points a the factory
from which this mesh originated (optional).
<P>

<LI>
<CODE>movable</CODE>: Class `<SAMP>csMovable</SAMP>'.  This important field contains
information about where the mesh actually resides.  It maintains a list of
sectors (a mesh can reside in multiple sectors at once) and a current position
and transform.  It is also aware of the hierarchical nature of meshes so that
you can ask the real position and the position relative to the parent.
<P>

<LI>
<CODE>zbufMode</CODE> Class `<SAMP>csZBufMode</SAMP>'.  The z-buffer mode to use for
rendering this object (zfill, zuse, ztest, etc.).
<P>

<LI>
<CODE>render_priority</CODE>: Type `<SAMP>int</SAMP>'.  This is a number indicating this
mesh's render priority.
<P>

<LI>
<CODE>static_lod</CODE>: Class `<SAMP>csStaticLODMesh</SAMP>'.  If this mesh is the parent
for a static LOD (level of detail) mesh, then this structure will contain
more information about that.
<P>

<LI>
<CODE>light_info</CODE>: Interface `<SAMP>iLightingInfo</SAMP>'.  Some meshes implement this
interface.  The engine very often requires a pointer to the mesh's
implementation of this interface.  As an optimization, it therefore maintains a
pointer to that interface here in order to avoid <CODE>SCF_QUERY_INTERFACE()</CODE>,
which is somewhat time-consuming.
<P>

<LI>
<CODE>shadow_receiver</CODE>: Interface `<SAMP>iShadowReceiver</SAMP>'.  Some meshes
implement this interface.  Again, as an optimization, a pointer to this
information is maintained.
<P>

<LI>
<CODE>portal_container</CODE>: Interface `<SAMP>iPortalContainer</SAMP>'.  A portal container
is a special type of mesh which is maintained by the engine itself and which
contains portals to other sectors.  This interface can also be obtained from
the mesh object via <CODE>SCF_QUERY_INTERFACE()</CODE>, but it is also maintained
here as an optimization.
<P>

<LI>
<CODE>relevant_lights</CODE>: Interface `<SAMP>iLight</SAMP>'.  This is used for dynamic
lighting calculation, and will contain a list of all lights that currently
affect this mesh.
<P>

<LI>
<CODE>relevant_lights_ref</CODE>: Class `<SAMP>csMeshWrapper::LightRef</SAMP>'.  This is a
mirror of `<SAMP>relevant_lights</SAMP>'.  It uses `<SAMP>csWeakRef</SAMP>' as a trick for
detecting if a light has been removed or changed.  (Weak references are
automatically set to null as soon as the object to which the weak reference
points is deleted.)
<P>

<LI>
Several imposter variables: not yet implemented.
</UL>
<P>

<A NAME="SEC482"></A>
<H4> Engine Data Structures: csRegion </H4>
<!--docid::SEC482::-->
<P>

A region is a collection of objects.  It utilizes `<SAMP>csObject</SAMP>' to hold all
objects that are in the region.  The region class implements the following
interfaces:
</P><P>

<UL>
<LI>
<CODE>iRegion</CODE>: The main entry point for the region.
<LI>
<CODE>iObject</CODE>: Allows attachment of game-specific data.
</UL>
<P>

<A NAME="SEC483"></A>
<H4> Engine Data Structures: csTextureWrapper </H4>
<!--docid::SEC483::-->
<P>

A texture wrapper is an engine object which keeps track of the real
textures from the renderers (`<SAMP>iTextureHandle</SAMP>').
The texture wrapper class implements the following interfaces:
</P><P>

<UL>
<LI>
<CODE>iTextureWrapper</CODE>: The main entry point for the texture wrapper.
<LI>
<CODE>iObject</CODE>: Allows attachment of game-specific data.
</UL>
<P>

A texture wrapper maintains the following important variables:
</P><P>

<UL>
<LI>
<CODE>image</CODE>: Interface `<SAMP>iImage</SAMP>'.  This is the object which contains the
original image data from disk.  After <EM>preparing</EM> this texture to make it
suitable the renderer, the image is released (unless keep_image is true).
<P>

<LI>
<CODE>keep_image</CODE>: Type `<SAMP>bool</SAMP>'.  To prevent `<SAMP>image</SAMP>' from being
cleared, set this to true.  Note that this increases memory usage of a single
texture, often dramatically, so only do this if the original image data will be
needed at a later time.
<P>

<LI>
<CODE>handle</CODE>: Interface `<SAMP>iTextureHandle</SAMP>'.  This is the texture handle as
returned by the renderer (via the <CODE>iTextureManager</CODE> interface).
</UL>
<P>

<A NAME="SEC484"></A>
<H4> Engine Data Structures: csMaterialWrapper </H4>
<!--docid::SEC484::-->
<P>

A material wrapper is an engine object which keeps track of the real
materials from the renderers (`<SAMP>iMaterialHandle</SAMP>').
The material wrapper class implements the following interfaces:
</P><P>

<UL>
<LI>
<CODE>iMaterialWrapper</CODE>: The main entry point for the material wrapper.
<LI>
<CODE>iObject</CODE>: Allows attachment of game-specific data.
</UL>
<P>

A material wrapper maintains the following important variables:
</P><P>

<UL>
<LI>
<CODE>material</CODE>: Interface `<SAMP>iMaterial</SAMP>'.  This is the original
representation of the material from which the <CODE>iMaterialHandle</CODE> was
generated.
<P>

<LI>
<CODE>matEngine</CODE>: Interface `<SAMP>iMaterialEngine</SAMP>'.  This points to the
engine-specific material class (`<SAMP>csMaterial</SAMP>', which implements both
`<SAMP>iMaterial</SAMP>' and `<SAMP>iMaterialEngine</SAMP>').  The reason for the presence of
this variable is that `<SAMP>iMaterial</SAMP>' is an interface that is not specific to
the engine so it is not possible to maintain engine-specific information there
(such as a reference to an `<SAMP>iTextureWrapper</SAMP>').  Instead, such information
is maintained in the `<SAMP>iMaterialEngine</SAMP>' interface.
<P>

<LI>
<CODE>handle</CODE>: Interface `<SAMP>iMaterialHandle</SAMP>'.  This is the actual material
handle as returned by the renderer (via the `<SAMP>iTextureManager</SAMP>' interface).
</UL>
<P>

<A NAME="SEC485"></A>
<H4> Engine Data Structures: csMovable </H4>
<!--docid::SEC485::-->
<P>

The movable class is used by the `<SAMP>csMeshWrapper</SAMP>' class to keep track
of the mesh's current location.
The movable class implements the following interfaces:
</P><P>

<UL>
<LI>
<CODE>iMovable</CODE>: The main entry point for the movable.
</UL>
<P>

A movable maintains the following important variables:
</P><P>

<UL>
<LI>
<CODE>obj</CODE>: Class `<SAMP>csReversibleTransform</SAMP>'.  The world-to-object transform
for the mesh represented by this movable.  For this transform <EM>This</EM>
represents object space and <EM>Other</EM> represents world space.
<P>

<LI>
<CODE>is_identity</CODE>: Type `<SAMP>bool</SAMP>'.  If the `<SAMP>obj</SAMP>' transform is an
identity transform (i.e.  neither moves nor rotates the object) then it is
possible to perform various optimizations.
<P>

<LI>
<CODE>sectors</CODE>: Class `<SAMP>csMovableSectorList</SAMP>'.  This is a list of sectors in
which the mesh object resides In many cases a mesh will only reside in only one
sector, but it is possible for a mesh to be in several sectors at once if the
mesh happens to cross a portal boundary.  Note that the application is
responsible for adding a mesh to sectors.  The engine will never do so.
<P>

<LI>
<CODE>listeners</CODE>: Interface `<SAMP>iMovableListener</SAMP>'.  This is an array of
listeners (pieces of code) interested in knowing when the movable changes (i.e.
when the mesh moves).
<P>

<LI>
<CODE>parent</CODE>: Interface `<SAMP>iMovable</SAMP>'.  If the mesh is being used in a
hierarchical mesh object, then this will point to the movable of the parent
mesh.
<P>

<LI>
<CODE>object</CODE>: Class `<SAMP>csMeshWrapper</SAMP>'. This is the mesh for the movable.
<P>

<LI>
<CODE>updatenr</CODE>: Type `<SAMP>long</SAMP>'.  One way to get notified about movable
updates is to register as a listener.  The listener will be called whenever the
movable is updated.  Another way is to keep track of the current
`<SAMP>updatenr</SAMP>'.  This number is updated every time the movable is updated.
</UL>
<P>

<A NAME="SEC486"></A>
<H4> Engine Data Structures: csLight </H4>
<!--docid::SEC486::-->
<P>

The light class is the representation of a light. A light lives in a sector.
The light class implements the following interfaces:
</P><P>

<UL>
<LI>
<CODE>iLight</CODE>: The main entry point for the light.
<LI>
<CODE>iObject</CODE>: Allows attachment of game-specific data.
</UL>
<P>

A light maintains the following important variables:
</P><P>

<UL>
<LI>
<CODE>light_id</CODE>: Type `<SAMP>char*</SAMP>'.  This is a 16-byte string (MD5 hash)
which is used for caching light data.  It is, hopefully, unique for a given
light since it is calculated from various light settings such as the position,
radius, sector, etc.
<P>

<LI>
<CODE>childnode</CODE>: Class `<SAMP>csKDTreeChild</SAMP>'.  Lights are represented in a
KD-tree that lives in the sector (see above).  This child object is the
representation of the light in that tree.
<P>

<LI>
<CODE>sector</CODE>: Interface `<SAMP>iSector</SAMP>'. The current sector of the light.
<P>

<LI>
<CODE>center</CODE>: Class `<SAMP>csVector3</SAMP>'. The current position of the light.
<P>

<LI>
<CODE>color</CODE>: Class `<SAMP>csColor</SAMP>'. The current color of the light.
<P>

<LI>
<CODE>halo</CODE>: Class `<SAMP>csHalo</SAMP>'.  If the light has a halo, then this field
contains a pointer to that structure.
<P>

<LI>
<CODE>dynamic_type</CODE>: Type `<SAMP>int</SAMP>'.  This represents the type of the light
(dynamic, static, etc.).
<P>

<LI>
<CODE>attenunation</CODE>: Type `<SAMP>int</SAMP>'.  This is the kind of attenunation that
the light uses.
<P>

<LI>
<CODE>attenuationvec</CODE>: Class `<SAMP>csVector3</SAMP>'.  If the attenuation is CLQ
based, then this will be the vector.
<P>

<LI>
<CODE>influenceRadius</CODE>: Type `<SAMP>float</SAMP>'.  This is the influence radius of the
light.  Beyond this distance the light has almost no effect.
<P>

<LI>
<CODE>lightnr</CODE>: Type `<SAMP>uint32</SAMP>'.  This number is used to detect light
changes.  It will be updated whenever the light is moved or otherwise changes.
<P>

<LI>
<CODE>light_cb_vector</CODE>: Interface `<SAMP>iLightCallback</SAMP>'.  This is another way
to get notified of light changes.
<P>

<LI>
<CODE>lightinginfos</CODE>: Interface `<SAMP>iLightingInfo</SAMP>'.  This is a hash set with
lighting <EM>info</EM>'s which this light is currently affecting.  When the light
color changes (without the light moving) the light class simply notifies every
element of this set.
</UL>
<P>

<A NAME="SEC487"></A>
<H4> Engine Data Structures: csPortalContainer </H4>
<!--docid::SEC487::-->
<P>

This is the representation of a portal container. It
is the only mesh object that is implemented directly in the engine itself.
A portal container is a collection of portals (i.e. every polygon in the
portal container is a portal to another sector).
The portal container class implements the following interfaces:
</P><P>

<UL>
<LI>
<CODE>iMeshObject</CODE>: A portal container is a mesh object.
<LI>
<CODE>iPortalContainer</CODE>: The portal container-specific API (this
is the state interface of the mesh object).
<LI>
<CODE>iShadowReceiver</CODE>: A portal container can receive shadows (and pass
them along to the destination sectors).
</UL>
<P>

A portal container maintains the following important variables:
</P><P>

<UL>
<LI>
<CODE>portals</CODE>: Class `<SAMP>csPortal</SAMP>'.  This is a list of all portals in the
portal container.
<P>

<LI>
<CODE>data_nr</CODE>: Type `<SAMP>uint32</SAMP>'.  This number is increased with each
significant change to the portal container.
<P>

<LI>
<CODE>vertices</CODE>: Class `<SAMP>csVector3</SAMP>'.  This is an array of vertices that are
used by the portals in this container.  These vertices are in object space.
<P>

<LI>
<CODE>world_vertices</CODE>: Class `<SAMP>csVector3</SAMP>'.  This is an array of vertices in
world space.
<P>

<LI>
<CODE>camera_vertices</CODE>: Class `<SAMP>csVector3</SAMP>'.  This is an array of vertices
in camera space.
<P>

<LI>
<CODE>meshwrapper</CODE>: Class `<SAMP>csMeshWrapper</SAMP>'.  A pointer back to the mesh
wrapper containing this portal container.
</UL>
<P>

<A NAME="SEC488"></A>
<H4> Engine Data Structures: csRenderView </H4>
<!--docid::SEC488::-->
<P>

This is a temporary data structure that is used during rendering. It will
be discussed in more detail in the section about drawing a frame. Here is a
brief summary of the class.
The renderview class implements the following interfaces:
</P><P>

<UL>
<LI>
<CODE>iRenderView</CODE>: The main entry point for the render view.
</UL>
<P>

The renderview class maintains the following important variables:
</P><P>

<UL>
<LI>
<CODE>context_id</CODE>: Type `<SAMP>uint32</SAMP>'.  This is a field that is incremented
with each new <CODE>csRenderView</CODE> instance (and also when a new render context
is created), and is used so the engine can detect if two render contexts are
the same (comparing on pointers is not valid since render contexts are reused).
<P>

<LI>
<CODE>ctxt</CODE>: Class `<SAMP>csRenderContext</SAMP>'.  This is the current render context.
There is one `<SAMP>csRenderView</SAMP>' instance that is used through the entire
rendering of a frame but every time a portal is traversed a new
`<SAMP>csRenderContext</SAMP>' instance is created.
<P>

<LI>
<CODE>original_camera</CODE>: Interface `<SAMP>iCamera</SAMP>'.  This points at the original
camera which was used when starting the rendering (i.e.  the top level camera).
Normally, this camera will be constant unless there is a space warping portal
(a portal that changes space; for example, a mirror).  In that case a new
camera is created for the new render context.
</UL>
<P>

<A NAME="SEC489"></A>
<H4> Drawing a Frame </H4>
<!--docid::SEC489::-->
<P>

When rendering a frame the base entry point is <CODE>iEngine::Draw()</CODE>. However,
most applications do not call this function directly. Most applications will
invoke <CODE>iView::Draw()</CODE> instead.
</P><P>

<CODE>iEngine::Draw()</CODE> accepts two arguments: the camera to use, and the
2D clipping area. When this function is called then engine will perform the
following steps in the order shown:
</P><P>

<UL>
<LI>
`<SAMP>current_framenumber</SAMP>' is incremented so that the engine and other
plugins can check the current frame number to update per-frame caches, for
example.
<P>

<LI>
<CODE>csEngine::ControlMeshes()</CODE> is called. This function checks
all meshes that want to die (the `<SAMP>csEngine::want_to_die</SAMP>' set) and destroys
them.
<P>

<LI>
A `<SAMP>csRenderView</SAMP>' instance is created and initializated with the
current camera and clipper.
<P>

<LI>
A few <CODE>iGraphics3D</CODE> methods are invoked to ensure that the clipper is
set up correctly, among other things.
<P>

<LI>
The engine checks if the sector has a renderloop. If so, it will use it.
Otherwise it will use the default renderloop in the engine.
It will call <CODE>iRenderLoop::Draw()</CODE>, which will be described below.  The
upshot of this method invocation is the recursive drawing of everything
visible.
<P>

<LI>
Halos are drawn.
<P>

<LI>
The clipper in <CODE>iGraphics3D</CODE> is reset.
</UL>
<P>

<CODE>iRenderLoop::Draw()</CODE> is called for every sector in the recursion.  It
will first be invoked by <CODE>csEngine::Draw()</CODE>, and it will also be called
again whenever portal traversal occurs (see below).  The following operations
are performed by this function in the order shown:
</P><P>

<UL>
<LI>
<CODE>csRenderView::SetupClipPlanes()</CODE> is invoked. This function will
set up the clipping planes for the current 2D portal boundary (2D clipper) and
the current camera (view frustum). The far plane and near clipping planes
are also added if needed.
<P>

<LI>
Many of the shaders depend on <EM>shader variables</EM>.
A stack of shader variables is maintained at each level. At the lowest
level there is the renderloop. Here the variables from the shader manager
itself are pushed onto the stack.  Presently, there are no variables at this
level, but in the future one can imagine variables such as the current frame
number, and other globals.  <CODE>iShaderManager::PushVariables()</CODE> performs
this operation.
<P>

<LI>
<CODE>csSector::PrepareDraw()</CODE> is invoked. This function will first make
sure the visibility culler plugin for the sector is present. Then, it will
set the current sector on the `<SAMP>csRenderView</SAMP>'. Next, it will call all
<EM>callbacks</EM> that are interested in hearing when this sector is traversed.
One of the most important things this function does however, is move all
meshes that have the `<SAMP>CS_ENTITY_CAMERA</SAMP>' flag set so that their center
point is at the camera position.
<P>

<LI>
It loops over all steps
in this renderloop and perform them one by one. Each renderstep will
render all meshes in the sector using some shader type (more on this later).
This is the place where the meshes in this sector are actually rendered.
It is also during rendering of meshes that portals are actually traversed.
Note that, typically, only one renderstep will have portal traversal enabled.
<P>

<LI>
After doing all rendering of this sector the shader variables that were added
here are popped from the stack.
<P>

<LI>
All halos in this sector are added to the engine queue so that the
engine can draw them after render recursion ends.
</UL>
<P>

What actually occurs during invocation of the rendersteps depends upon how the
renderloop is set up, and upon how many rendersteps there are.  What follows is
an explanation of the default case of a single render step that uses the
<EM>old-renderer compatibility</EM> shader type (this is the renderloop that is
created by <CODE>iEngine::CreateDefaultRenderLoop()</CODE>).  This render step is
designed to be compatible with old renderer style maps that use lightmaps
without no special shaders.  It uses `<SAMP>CS_ZBUF_MESH</SAMP>' for this render step
which means that the z-buf mode of the mesh itself will be used.  It also
disables Z-offset since there will only be one step.  Z-offset is used to make
sure that, when using multi-texturing, the polygons end up at exactly the same
Z-distance (i.e. no z fighting occurs).  The first step is always rendered
using disabled z-offset.  Subsequent steps should enable it to make sure they
will render nicely on the previously rendered base.  This render step also
enables portal traversal.
</P><P>

<CODE>iRenderStep::Perform()</CODE> resides in the generic render step plugin which
is located in the source tree at `<TT>CS/plugins/engine/renderloop/stdsteps</TT>'.
This function performs the following tasks in the order shown:
</P><P>

<UL>
<LI>
Obtains a list of all visible meshes (via <CODE>iSector::GetVisibleMeshes()</CODE>)
from the sector.  A later section will go into this step in more detail.
<P>

<LI>
After getting a `<SAMP>csRenderMeshList</SAMP>' with all visible meshes, they are
sorted based upon render priority (and for some render priorities it will also
sort on distance from the camera--i.e. alpha render priority).  In addition
it will also sort on shaders so that meshes using the same shader are put
together (this is more efficient for the renderer).
<P>

<LI>
Shader variables are added to the variable stack (remember
we first had the shader variables from the shader manager itself, now we
add another level of variables on that stack).  Presently, the only variables
added are the fog parameters of the current sector.
<P>

<LI>
The sorted and visible meshes are rendered. It will collect
all meshes with the same shader and then call <CODE>RenderMeshes()</CODE>.
<CODE>RenderMeshes()</CODE> will first set the current settings for this step
(like z-offset). Then it will get the number of passes for the given
shader and render all meshes with that shader with the given pass. Note
that the shader will also add variables to the stack at this point; in
particular variables about the current object to camera transformation and
the current material.
<P>

<LI>
If `<SAMP>portaltraversal</SAMP>' is enabled and the mesh is a portal container (this
is indicated by `<SAMP>csRenderMesh</SAMP>' having a portal field that is not null),
then the portal will be traversed by invoking
<CODE>iPortalContainer::Draw()</CODE>. More on this later, but this is the important
place where the recursion through portals occurs.
<P>

<LI>
The settings for this step are restored.
</UL>
<P>

One very important function that is called from within <CODE>iRenderStep::Perform()</CODE>
is <CODE>iSector::GetVisibleMeshes()</CODE>. This function is responsible for finding all
meshes that are visible. To calculate this the sector will use the visibility
culler that is in every sector. At this moment we have two possible implementations
for that visibility culler: `<SAMP>Frustvis</SAMP>' and `<SAMP>Dynavis</SAMP>'. Frustvis will do
frustum culling alone. That means that every object that is in the view frustum
is considered visible. Dynavis will do frustum culling and also try to find out which
objects are visible and which are not by using an occlusion buffer. There is another
chapter explaining the differences a bit more and also how dynavis works internally.
Here we only explain what happens in short. The <CODE>GetVisibleMeshes()</CODE> function
will do the following things:
</P><P>

<UL>
<LI>
First in every sector we maintain a list of visible mesh lists. The reason for this
is that sometimes GetVisibleMeshes() is called multiple times in one frame and
we don't want to redo the visibility culling as that can be expensive (especially
in the case of Dynavis). So we keep a cache of visible mesh lists and every entry
in that cache (i.e. every list of meshes in that cache) has an associated current
frame number and context id number. These two numbers are used to check if the
cached list can be used for the given frame and context. If there is no such
cached list then we must proceed to the next step. Otherwise we return the cached
list that matches the frame and context id.
<P>

<LI>
If there is no matching list in the cache we find a slot in the list of cached
mesh lists which was for another frame. We know that that list will never be used
again since that frame has already been rendered (it is in the past). So if we find
such an entry we reuse that list and recalculate the visibility culler (we call
<CODE>iVisibilityCuller::VisTest()</CODE>.
<P>

<LI>
If we can't find an entry we can reuse we add a new entry to the cache and we
populate it with the visible meshes by again calling <CODE>iVisibilityCuller::VisTest()</CODE>.
</UL>
<P>

The <CODE>iVisibilityCuller::VisTest()</CODE> function will internally use a KD-tree
to traverse the objects in the sector and for all visible objects it will call
the <CODE>iVisibilityCullerListener</CODE> callback that was given as a parameter of the
<CODE>VisTest()</CODE> call. I will go into more detail in the actual implementation of
<CODE>VisTest()</CODE> for both Frustvis and Dynavis in later sections.
</P><P>

The <CODE>ObjectVisible()</CODE> function in the callback is a function that resides
in the sector again (the culler itself is implemented in another plugin). ObjectVisible
will mark the given object as visible by adding all <CODE>csRenderMesh</CODE> instances
as returned by the visible <CODE>iMeshObject</CODE> (through the
<CODE>iMeshObject::GetRenderMeshes()</CODE> call) to the list of visible meshes that we
are building. In addition to that it will also do something special if the mesh
is a hierarchical mesh that uses static lod. In that case it will calculate which
of the children should be visible for the given distance to the camera (and other
potential factors) and it will mark that child as visible too.
</P><P>

It is important to note that there is an important difference between normal
hierarchical meshes and static lod meshes with regards to the visibility culler.
Both are implemented using hierarchical meshes but in case of a normal hierarchical
mesh all children are registered to the visibility culler as seperate meshes. That
means that every mesh in a hierarchical mesh is considered a seperate entity for
the visibility culler and is also tested for visibility on its own (so a child
of a hierarchical mesh can be visible even if the parent is not visible). For a static
lod mesh the situation is completely different. There the children are not registered
to the visibility culler but instead the mesh object will mark the right child as visible
when it itself is visible. That means that you must always make sure that with static
lod the parent is a mesh that is at least as big as the biggest child. Usually a nullmesh
with an appropriate box is used for that purpose.
</P><P>

@@@TODO: explain iPortalContainer::Draw()
@@@TODO: explain Frustvis::VisTest()
@@@TODO: explain Dynavis::VisTest()
</P><P>

<A NAME="csParser"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_196.html#SEC470"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_198.html#SEC490"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_164.html#SEC403"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_166.html#SEC408"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_198.html#SEC490"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_292.html#SEC941">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
