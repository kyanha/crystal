<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: SCF Using</TITLE>

<META NAME="description" CONTENT="Crystal Space: SCF Using">
<META NAME="keywords" CONTENT="Crystal Space: SCF Using">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC356"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_139.html#SEC355"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_141.html#SEC357"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_135.html#SEC351"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_138.html#SEC354"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_149.html#SEC370"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_288.html#SEC939">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 6.2.2 Using SCF </H3>
<!--docid::SEC356::-->
<P>

The only include header file you need to include to utilize SCF
functionality is `<TT>scf.h</TT>'.  It contains a number of macros and functions
that you will need for easier use of SCF.  If you plan to use SCF in
your own project without utilizing Crystal Space, you will also need to include
`<TT>scf.cpp</TT>' in your main application, and `<TT>scfimp.cpp</TT>' in both your
main application and each plugin module.  However, projects based upon Crystal
Space can simply link with the `<TT>csutil</TT>' library which contains the
SCF implementation.
</P><P>

Much basic functionality of SCF is provided by a central object.  It can
be accessed as `<SAMP>iSCF::SCF</SAMP>' and is of type `<SAMP>iSCF*</SAMP>' (which is also a
valid SCF interface).  This object is global and can be accessed from
<EM>anywhere</EM>, even from dynamic libraries (plugin modules).  It is used by
several parts of SCF.  Note that this object is only available after
calling <CODE>scfInitialize()</CODE>, the main initialization function of SCF.
In typical use, howerver, you rarely need to interact directly with
`<SAMP>iSCF::SCF</SAMP>'.  Instead, you invoke several convenient SCF macros which
interact with `<SAMP>iSCF::SCF</SAMP>' on your behalf.
</P><P>

All SCF classes should be derived from the basic interface `<SAMP>iBase</SAMP>'.
This interface declares the bare minimum set of methods which all SCF
classes should provide:
</P><P>

<DL COMPACT>
<DT><CODE>void IncRef()</CODE>
<DD>This function should be called each time you get a new reference to a object
and store it for a long-time usage.  Rather than invoking this method manually,
you can use a smart-pointer to automate reference counting
(see section <A HREF="cs_110.html#SEC222">5.8.1 Correctly Using Smart Pointers</A>).
<P>

<DT><CODE>void DecRef()</CODE>
<DD>Call this function to decrement the object's reference count.  When the
reference count reaches zero, the object is deleted automatically, provided
that it is not an interface embedded within another object,  <A HREF="cs_141.html#SCF Embedded Interfaces">SCF Embedded Interfaces</A>.  There should be one matching <CODE>DecRef()</CODE> for each
<CODE>IncRef()</CODE> invocation.
<P>

<DT><CODE>void AddRefOwner(iBase**)</CODE>
<DD>Call this function to set up a <EM>weak reference</EM> to the object .  A weak
reference is one which is invalidated automatically when the referenced object
is destroyed.  This is useful in cases when some object wants to hold a pointer
to an SCF object without actually owning a reference to the SCF
object.  Owning a reference prevents the SCF object from being destroyed,
whereas holding a weak reference merely says that you are interested in this
object as long as it is alive, but that you don't want to forcibly keep it
alive.  The argument to this method is a pointer to a variable which can hold a
pointer to an SCF object.  Rather than invoking this method manually, you
typically would use a weak-reference template to automate the reference
management (`<TT>CS/include/csutil/weakref.h</TT>').
<P>

<DT><CODE>void RemoveRefOwner(iBase**)</CODE>
<DD>Call this function to remove a weak reference to the object.
<P>

<DT><CODE>iBase* QueryInterface(scfInterfaceID InterfaceID, int Version); This</CODE>
<DD>method will return a pointer to an interface or to an embedded interface,
(see  <A HREF="cs_141.html#SCF Embedded Interfaces">SCF Embedded Interfaces</A>).  The <EM>Interface ID</EM> is synonymous to
the name of the interface.  In previous versions of SCF this method used
to accept a string containing the name of the interface.  This has been
replaced by the <EM>ID</EM> for performance reasons.  You can get the ID of
an interface by invoking <CODE>iSCF::SCF-&#62;GetInterfaceID(name)</CODE>.
</DL>
<P>

To simplify things even further, `<TT>scf.h</TT>' provides several macros that
provide default declarations and default implementations of these
methods.  The `<SAMP>SCF_DECLARE_IBASE</SAMP>' macro will declare these methods
within any class definition that is derived from `<SAMP>iBase</SAMP>'.  The
<CODE>SCF_IMPLEMENT_IBASE()</CODE> macro will add the default implementation of these
methods to your module.  Finally, the <CODE>SCF_IMPLEMENT_FACTORY()</CODE> macro will
implement the factory function for your class which returns new instances of
the class to callers.
</P><P>

Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>// Abstract interface file (itest.h)
struct iTest : public iBase
{
  <small>...</small>
};

// Concrete implementation header (test.h)
class Test : public iTest
{
public:
  SCF_DECLARE_IBASE;
};

// Concrete implementation source (test.cpp)
SCF_IMPLEMENT_FACTORY(Test)

SCF_IMPLEMENT_IBASE(Test)
</pre></td></tr></table></P><P>

In reality, we need a few more macros because the <CODE>QueryInterface()</CODE>
function is not static--it depends upon the interfaces implemented by given
object.  In fact, <CODE>SCF_IMPLEMENT_IBASE()</CODE> defines <CODE>IncRef()</CODE>,
<CODE>DecRef()</CODE>, <CODE>AddRefOwner()</CODE>, <CODE>RemoveRefOwner()</CODE>, and the
beginning of the <CODE>QueryInterface()</CODE> function, but not the end of that
function (i.e. the closing brace).  That's because you have to use an
additional macro called <CODE>SCF_IMPLEMENTS_INTERFACE()</CODE> which will add the
code required to support all implemented interface inside
<CODE>QueryInterface()</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>SCF_IMPLEMENT_FACTORY(Test)

SCF_IMPLEMENT_IBASE(Test)
  SCF_IMPLEMENTS_INTERFACE(iTest)
SCF_IMPLEMENT_IBASE_END
</pre></td></tr></table></P><P>

The <CODE>SCF_DECLARE_IBASE()</CODE> macro also defines a few member variables:
`<SAMP>scfRefCount</SAMP>', `<SAMP>scfWeakRefOwners</SAMP>', and `<SAMP>scfParent</SAMP>'.
`<SAMP>scfRefCount</SAMP>' is the accumulator for external references to this object
and is used by <CODE>IncRef()</CODE> and <CODE>DecRef()</CODE> methods.
<CODE>scfWeakRefOwners</CODE> maintains the list of weak reference owners, if any.
The `<SAMP>scfParent</SAMP>' variable points to the parent object, if any, and is also
used by <CODE>IncRef()</CODE> and <CODE>DecRef()</CODE>.  Objects are chained together in a
tree-like fashion, and an call to <CODE>IncRef()</CODE> will also call
<CODE>scfParent-&#62;IncRef()</CODE>; same with <CODE>DecRef()</CODE>.  The root of the chain
is the class factory, that is, an object that is used to create objects of a
specific class.  The object tree looks like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>ClassFactory
    => Object
        => Embedded interface
        => Embedded interface
            => Sub-embedded interface
</pre></td></tr></table></P><P>

Thus, if we call the <CODE>IncRef()</CODE> method for <EM>Sub-embedded interface</EM>,
we also will increment reference count for <EM>Object</EM> and
<EM>ClassFactory</EM>.
</P><P>

You also should call <CODE>SCF_CONSTRUCT_IBASE(<VAR>parent</VAR>)</CODE> inside your class
constructor, this macro will initialize `<SAMP>scfRefCount</SAMP>' to zero and
`<SAMP>scfParent</SAMP>' to <VAR>parent</VAR>.  The constructor of many SCF classes
should receive at least one argument of type `<SAMP>iBase*</SAMP>', which it should
pass along to the <CODE>SCF_CONSTRUCT_IBASE()</CODE> macro.  It is also valid to
specify `<SAMP>NULL</SAMP>' as the parent if the instance should have no parent.
Likewise, you should call <CODE>SCF_DESTRUCT_IBASE()</CODE> inside your class
destructor.  This will reverse the initialization performed by the
corresponding <CODE>SCF_CONSTRUCT_IBASE()</CODE> invocation.
</P><P>

<A NAME="SCF Multiple Interfaces"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_139.html#SEC355"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_141.html#SEC357"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_135.html#SEC351"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_138.html#SEC354"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_149.html#SEC370"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_288.html#SEC939">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
