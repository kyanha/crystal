<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: HOWTO Collision Detection</TITLE>

<META NAME="description" CONTENT="Crystal Space: HOWTO Collision Detection">
<META NAME="keywords" CONTENT="Crystal Space: HOWTO Collision Detection">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC231"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_110.html#SEC223"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_112.html#SEC239"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_101.html#SEC206"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_109.html#SEC222"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_134.html#SEC351"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_285.html#SEC941">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 5.8.2 Doing Collision Detection </H3>
<!--docid::SEC231::-->
<P>

Collision detection in CS is one of the more complicated issues. In this
section I give a quick description of all the classes and interfaces in CS
and what you should do to use them.
</P><P>

<A NAME="SEC232"></A>
<H4> Loading the `<SAMP>iCollideSystem</SAMP>' </H4>
<!--docid::SEC232::-->
<P>

The basis of the collision detection system is the `<SAMP>iCollideSystem</SAMP>'.
This is an interface which is implemented by some collision detection plugin.
At this moment we have implementations of RAPID and OPCODE collision
detection systems.
</P><P>

To load a collision detection system you can use the following code:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csRef&#60;iPluginManager&#62; plugmgr =
  CS_QUERY_REGISTRY (object_reg, iPluginManager);
csRef&#60;iConfigManager&#62; config =
  CS_QUERY_REGISTRY (object_reg, iConfigManager);
const char* p = config-&#62;GetStr ("MyGame.Settings.CollDetPlugin",
  	"crystalspace.collisiondetection.opcode");
csRef&#60;iCollideSystem&#62; cd_sys =
  CS_LOAD_PLUGIN (plugmgr, p, iCollideSystem);
if (!cd_sys)
{
  csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
	"crystalspace.application.myapp",
  	"No Collision Detection plugin found!");
  return false;
}
</pre></td></tr></table></P><P>

This is a very general example.  It will first get the preferred collision
detection plugin from the config file.  If the config file doesn't specify it
then it will use 'crystalspace.collisiondetection.rapid' which is the only one
we have at the moment.  If you don't want to let the users choose another
plugin then you can also hardcode the string.  The cd_sys should be stored
somewhere central (i.e. your application class).
</P><P>

<A NAME="SEC233"></A>
<H4> Initializing Geometry </H4>
<!--docid::SEC233::-->
<P>

Before you can use the collision detection system you have to make
instances of `<SAMP>iCollider</SAMP>'. Only the collide system can do that. To
create an `<SAMP>iCollider</SAMP>' you have to give an instance of `<SAMP>iPolygonMesh</SAMP>'.
Several meshes in CS implement `<SAMP>iPolygonMesh</SAMP>'. If you have special
geometry on your own you can make your own classes to implement
`<SAMP>iPolygonMesh</SAMP>'. Here is some code on how to initialize the collider
for a mesh:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csRef&#60;iCollider&#62; MyGame::InitCollider (iMeshWrapper* mesh)
{
  iPolygonMesh* polmesh = mesh-&#62;GetMeshObject ()-&#62;GetObjectModel ()
	-&#62;GetPolygonMeshColldet ();
  if (polmesh)
  {
    csRef&#60;iCollider&#62; cd = cd_sys-&#62;CreateCollider (polmesh);
    return cd;
  }
  else
  {
    return 0;
  }
}
</pre></td></tr></table></P><P>

After that you need to store the returned collider somewhere so you
can easily retrieve it later when you want to do the collision detection.
Usually in a game you have entity classes which will have a pointer to the
mesh. In that case you can easily store the collider in that entity class.
</P><P>

However, you can also use the `<SAMP>iObject</SAMP>' system to attach your collider
to the mesh itself. An easy way to do this is to use the
<CODE>csColliderWrapper</CODE> class that you can find in the <CODE>cstool</CODE>
library. <CODE>csColliderWrapper</CODE> is a subclass of <CODE>csObject</CODE> which
means that you can attach this object to any other <CODE>csObject</CODE>.
<CODE>csColliderWrapper</CODE> additionally holds a pointer to an <CODE>iCollider</CODE>.
This means that you can create a <CODE>csColliderWrapper</CODE> to hold your
<CODE>iCollider</CODE> for some mesh object and then you can attach
that <CODE>csColliderWrapper</CODE> to the mesh object itself. To do this
use the following code instead of the <CODE>InitCollider()</CODE> routine
above:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>bool MyGame::InitCollider (iMeshWrapper* mesh)
{
  iPolygonMesh* polmesh = mesh-&#62;GetMeshObject ()-&#62;GetObjectModel ()
	-&#62;GetPolygonMeshColldet ();
  if (polmesh)
  {
    new csColliderWrapper(mesh-&#62;QueryObject(), cd_sys, polmesh);
    return true;
  }
  else
  {
    return false;
  }
}
</pre></td></tr></table></P><P>

This example creates a new instance of <CODE>csColliderWrapper</CODE> which
is automatically stored with the <CODE>iObject</CODE> that belongs
with the given mesh. So there is no need to store it otherwise. Later
on you can retrieve the collider for some mesh by doing:
</P><P>

The function <CODE>csColliderHelper::InitializeCollisionWrapper()</CODE>
does this work for you and also takes care of a lot of finer details
that are ignored in the example above (like improved memory usage and
performance by sharing the colliders if a factory mesh is used). In addition
<CODE>csColliderHelper::InitializeCollisionWrappers()</CODE>
initializes all collider wrappers for all objects in the engine.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csColliderWrapper* colwrap = 
  csColliderWrapper::GetColliderWrapper(mesh-&#62;QueryObject ());
iCollider* collider = colwrap-&#62;GetCollider();
</pre></td></tr></table></P><P>

<A NAME="SEC234"></A>
<H4> The Player Collider </H4>
<!--docid::SEC234::-->
<P>

Depending on the game your player might have a representation of
geometry or not. If it doesn't you will have to make your own version
of `<SAMP>iPolygonMesh</SAMP>' to create a collider for the player. Even if
your player has geometry (i.e. a 3D sprite) it is sometimes still preferable
to create your own special geometry for the player. The reason is
gravity. When you would just use one collider for the player you can have
problems moving around because the player would not be able to jump over
even the tiniest elevation in height. Sometimes the edge between adjacent
polygons can even cause the player to collide with that other polygon due
to numerical inprecision. To solve this problem it is best to make one
collider that is used for gravity only and another collider that is used
to test if you can move around. The gravity collider will be used only
to test if the player can go downwards or upwards. To avoid not being able
to go over small height elevations, the player collider should float slightly
above the ground.
</P><P>

The best way to make the gravity collider is to make your own implementation
of `<SAMP>iPolygonMesh</SAMP>'. This is very efficient. To keep the returned
collider I recommend storing them somewhere in the player class or else the
main game class.
</P><P>

<A NAME="SEC235"></A>
<H4> Doing Collision Detection </H4>
<!--docid::SEC235::-->
<P>

When everything is set up it is time to do collision detection. To test
for collisions you use the <CODE>Collide</CODE> function in `<SAMP>iCollideSystem</SAMP>'.
This will test the collisions between two colliders. The result of this
will be true or false and in addition the collide system will keep a list
of all triangle pairs for the hits. Those triangle pairs can be used to
decide what to do on collision (i.e. slide on a wall for example).
</P><P>

Because collision detection works on two objects at a time it is a good
idea to have some system on top of the collision detection system that
detects when it is useful to do collision detection. You can use a bounding
sphere for that. Also you should only do collision detection if the object
moves.
</P><P>

Note! Don't forget to call <CODE>ResetCollisionPairs</CODE> before doing collision
detection! Otherwise the internal table of collision pairs will grow
forever.
</P><P>

<A NAME="SEC236"></A>
<H4> Sliding Along Walls (this section is in beta) </H4>
<!--docid::SEC236::-->
<P>

For detecting collision between a mesh and the static world, it is better
to use the <CODE>CollidePath</CODE> method of `<SAMP>iCollideSystem</SAMP>'. Its use
is similar to <CODE>Collide</CODE> but it takes arrays of `<SAMP>iCollider</SAMP>''s
and `<SAMP>csReversibleTransform</SAMP>''s. It also takes a `<SAMP>csVector3</SAMP>'
(passed by reference). This is the translation vector of the movement
that the mesh wants to take (<CODE>CollidePath</CODE> is called before the
movement occurs). The interface is detailed further in the public API docs.
</P><P>

The translation vector is modified to reflect the distance that the mesh
was able to move before it collided with the world. So you should move
the mesh that far, and subtract the new vector from the original vector,
to get the distance still to go. We will call this <CODE>V</CODE>.
</P><P>

Use <CODE>GetCollisionPairs</CODE> to get the triangle that was collided with.
It is described by the points <CODE>a2, b2, c2</CODE> in the
`<SAMP>csCollisionPair</SAMP>' structure. Then use those points to create a
`<SAMP>csPlane3</SAMP>'. We will call this <CODE>P</CODE>.
</P><P>

We want to give our vector a new direction so that it is on <CODE>P</CODE>.
The cross-product (<CODE>V % P.Normal()</CODE>) of the two will give a vector
which is on the plane, but perpendicular to the vector that we want.
Taking the cross-product again (now <CODE>(V % P.Normal()) % P.Normal()</CODE>)
will give the vector we want.
</P><P>

Now we try to move the mesh along this new vector. Hopefully there will be
no collision this time, but if there is we must do the whole thing over
again. Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>void Player::Move (csVector3 move)
{
  csVector3 old (move);
  while (collsys-&#62;CollidePath (player_collider, player_transform, move,
         world_colliders, world_transforms) != 1)
  {
    player_transform-&#62;Translate (move);
    csCollisionPair *pair = collsys-&#62;GetCollisionPairs ();
    csPlane3 wall (pair-&#62;a2, pair-&#62;b2, pair-&#62;c2);
    csVector3 newmove (old - move);
    old = move; move = newmove;
    move %= wall.Normal();
    move %= wall.Normal();
  }
  player_transform-&#62;Translate (move);
}
</pre></td></tr></table></P><P>

This example is limited in that it will run into an infinite loop if the
player walks into a corner, but it serves as an example.
</P><P>

<A NAME="SEC237"></A>
<H4> Limitation of RAPID and OPCODE </H4>
<!--docid::SEC237::-->
<P>

The current RAPID and OPCODE collision detection implementations
have one important limitation. They assume that the transform from object
to world space will not change the size of the object. i.e. you cannot scale the
object using the object to world transformation (which is kept in the
`<SAMP>iMovable</SAMP>') and expect collision detection to be ok. The only way
aroud this limitation is to use <CODE>HardTransform()</CODE> to transform
the object space vertices itself. But this can of course not be used
dynamically as you would have to recalculate the collider every time
the object changes.
</P><P>

<A NAME="SEC238"></A>
<H4> Include Files </H4>
<!--docid::SEC238::-->
<P>

The include files useful for this section are:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include "iutil/object.h"
#include "iutil/plugin.h"
#include "igeom/collider.h"
#include "igeom/polymesh.h"
#include "iengine/mesh.h"
#include "cstool/collider.h"
</pre></td></tr></table><A NAME="HOWTO Mesh LightAnim"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_110.html#SEC223"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_112.html#SEC239"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_101.html#SEC206"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_109.html#SEC222"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_134.html#SEC351"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_285.html#SEC941">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
