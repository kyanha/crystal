<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: MacOS/X Cocoa Frame Buffer</TITLE>

<META NAME="description" CONTENT="Crystal Space: MacOS/X Cocoa Frame Buffer">
<META NAME="keywords" CONTENT="Crystal Space: MacOS/X Cocoa Frame Buffer">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC803"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_268.html#SEC802"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_270.html#SEC804"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_264.html#SEC798"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_265.html#SEC799"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_271.html#SEC805"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_288.html#SEC939">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H4> 8.1.1.4 Cocoa Frame Buffer </H4>
<!--docid::SEC803::-->
<P>

This section describes the frame buffer format managed by the low-level
Cocoa-based 2D driver and the manner in which the pixel data is manipulated.
This discussion does not pertain to the OpenGL or CoreGraphics drivers.
</P><P>

With few exceptions, most NextStep, OpenStep, and MacOS/X Server 1.0 (Rhapsody)
installations are configured for <EM>true-color</EM> rather than palletized color.
However, true-color is rather relative in the case of the Cocoa-based 2D
graphics driver since the `<SAMP>NSBitmapImageRep</SAMP>' class supports only a limited
number of configurations for image data.  Historically, on NextStep, these
configurations were limited to:
</P><P>

<BLOCKQUOTE>
<TABLE>
<TR><TD>2-bit gray </TD><TD> <CODE>NX_TwoBitGrayDepth</CODE></TD>
</TR>
<TR><TD>8-bit gray </TD><TD> <CODE>NX_EightBitGrayDepth</CODE></TD>
</TR>
<TR><TD>8-bit color </TD><TD> <CODE>NX_EightBitRGBDepth</CODE> (via RGB palette)</TD>
</TR>
<TR><TD>12-bit color </TD><TD> <CODE>NX_TwelveBitRGBDepth</CODE></TD>
</TR>
<TR><TD>24-bit color </TD><TD> <CODE>NX_TwentyFourBitRGBDepth</CODE></TD>
</TR></TABLE>
</BLOCKQUOTE>
<P>

OpenStep and MacOS/X Server 1.0 (Rhapsody) took a stab at providing more
comprehensive color depth support, but in their released state, these
facilities provided little additional assistance and consequently are not
discussed further.
</P><P>

At the lowest level, the WindowServer itself supports additional configurations
and adjusts appropriately to the underlying hardware.  Historically, the
high-level Cocoa API, however, did not have access to this information
(without resorting to private and unsupported API), and consequently did
not make use of it.  Furthermore, even in 8-bit color mode the application had
neither access to, nor knowledge of the palette.  In this case the 8-bit number
is simply an opaque color value of which no further interpretation can be made.
</P><P>

To further complicate matters, in order to achieve decent video performance,
image data sent to the WindowServer needs to be specially formatted, as
discussed in the video optimizations section,
<A HREF="cs_268.html#SEC802">8.1.1.3 Cocoa Video Optimization</A>.  In particular, for optimal
performance, 12-bit and 24-bit data must include an alpha channel and all alpha
bits must be set to one.
</P><P>

Unfortunately the Crystal Space software renderer is unable to produce image
data in a format usable by the WindowServer when video performance is a
concern.  This is unfortunate since it means that the Cocoa-based 2D driver
must itself massage the data into a format suitable to `<SAMP>NSBitmapImageRep</SAMP>'
and the WindowServer.  This can be a time consuming operation.
</P><P>

Crystal Space's software renderer is unable to produce the proper image format
for several reasons.
</P><P>

<UL>
<LI>
The rendering engine has no facilities for forcing certain unused bits to
conform to a certain value.  In this case the alpha bits need to be set to one.
<P>

<LI>
The rendering engine does not support the common `<SAMP>NSBitmapImageRep</SAMP>' pixel
configurations.  For instance, the software renderer has modes for only 8-bit,
15-bit, and 16-bit, but not the 12-bit RGB data which is expected by the
Cocoa image classes.
<P>

<LI>
For performance reasons of its own, the software renderer is hard-coded to
produce pixel data in the format NBGR for big-endian and NRGB for
little-endian (as seen from a CPU register perspective), where `N'
represents unused and potentially uninitialized bits.  Neither of these pixel
formats is suitable for the Cocoa image classes.
</UL>
<P>

The upshot is that even though the `<SAMP>NSBitmapImageRep</SAMP>' class supports
true-color data and Crystal Space is capable of generating true-color data, the
formats are incompatible from the perspective of a Cocoa-based 2D driver.
</P><P>

There are at least a couple of solutions to the problem of pixel-format
mismatch between Crystal Space's software renderer and `<SAMP>NSBitmapImageRep</SAMP>':
</P><P>

<UL>
<LI>
Parameterize the software renderer's hard-coded constants such that those
constants can be modified at compile-time, and then build several versions of
the renderer, each geared for a particular pixel format.  To some extent, this
approach has already been implemented for a few fixed 8-, 15-, 16-, and 32-bit
pixel formats, however extending it to handle the many existing (and potential
future) MacOS/X formats could become quickly nightmarish, as well as lead to
bloat.
<P>

One other obstacle to this approach is that on 32-bit RGB big-endian
hardware, the `<SAMP>NSBitmapImageRep</SAMP>' expects the pixel data to occupy the
high-byte of the longword which represents each pixel.  Historically, the
software renderer has had trouble dealing with pixel data which occupies the
high-byte since most programmers working on the renderer only test it with
pixel formats which do not occupy that byte.  As a consequence, it is common
for breakage to occur as changes are made to the renderer.  Although the
maintainer of the Cocoa-based driver has painstakingly eradicated all known
bugs of this nature in the software renderer, the framework is still quite
fragile and breaks easily.
</P><P>

<LI>
Allow the renderer to generate pixel data in one of its hard-coded formats and
then massage the data into a format suitable for `<SAMP>NSBitmapImageRep</SAMP>' and
the WindowServer in a post-processing step just before sending it off to the
WindowServer.  The downside to this approach is that post-processing can be
time-consuming as well as memory intensive since such processing often involves
copying the pixel data from one frame-buffer to another.  (The double
frame-buffer requirement is a limitation of the way in which many Crystal Space
applications deal with the frame-buffer.  These applications expect that the
frame-buffer data will remain valid and unmodified from frame to frame, thus
massaging the data in-place is not a viable approach.) The benefit of the
post-processing approach, on the other hand, is that it is much less fragile
than parameterizing the renderer.
</UL>
<P>

The Cocoa-based driver employs the second approach since it is more robust and
reliable.  In the interest of video performance, whenever possible, the driver
attempts to perform as much of the time-consuming post-processing work in a
one-time initialization step.  The additional benefit of performing some of the
time-consuming work in an initialization step is that the actual
post-processing step becomes somewhat simplified.
</P><P>

The Cocoa-based 2D driver is automatically configured to generate 32-bit
RGB image data when running on machines configured for 24- or 32-bit
RGBA display.  Conversion of Crystal Space 32-bit RGB:888 data to
RGBA:8888 needed by `<SAMP>NSBitmapImageRep</SAMP>' and the WindowServer is
encapsulated in the class `<SAMP>CocoaFrameBuffer32</SAMP>'.  Just prior to flushing
the image data to the display, `<SAMP>CocoaFrameBuffer32</SAMP>' transmutes the pixel
data into a format suitable for `<SAMP>NSBitmapImageRep</SAMP>'.  It also ensures that
the alpha byte is set to <CODE>0xff</CODE>, as explained in the video optimizations
section, <A HREF="cs_268.html#SEC802">8.1.1.3 Cocoa Video Optimization</A>.
</P><P>

The 2D driver is automatically configured to generate 15-bit RGB image
data when running on machines configured for 12-, 15-, or 16-bit RGBA
display (or some other unrecognized configuration).  Conversion of Crystal
Space 15-bit RGB:555 data to RGBA:4444 needed by
`<SAMP>NSBitmapImageRep</SAMP>' and the WindowServer is encapsulated in the class
`<SAMP>CocoaFrameBuffer15</SAMP>'.  In order to avoid time-consuming bit manipulation
of image data, this class generates a translation table which equates each
possible RGB:555 color value with the corresponding RGBA:4444 color.
The alpha nybble of the translated color contains <CODE>0x0f</CODE> as explained in
the video optimizations section, <A HREF="cs_268.html#SEC802">8.1.1.3 Cocoa Video Optimization</A>.  To
translate incoming RGB:555 data to RGBA:4444,
`<SAMP>CocoaFrameBuffer15</SAMP>' enumerates over each color value in the incoming
image data, looks up its corresponding RGBA:4444 value in the translation
table and outputs that color.  This technique is both simple and reasonably
efficient.
</P><P>

<A NAME="MacOS/X Dynamic Linking"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_268.html#SEC802"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_270.html#SEC804"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_264.html#SEC798"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_265.html#SEC799"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_271.html#SEC805"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_288.html#SEC939">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
