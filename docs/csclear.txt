This readme covers the Crystal Space Common Layered Animation Resource, or
the CrystalClear Project.  All of the source code that is officially part of
the project is copyrighted under the terms of the GNU Library General Public 
License (LGPL).  See ../COPYING for details.

The goal of the CrystalClear project is to help speed development of 3D games
based on the Crystal Space engine, by Jorrit Tyberghein and others.  The 
ability to replace a component library of the system with another allows for
3D games of even different genres to share code in a consistent way.  By using
the LGPL, this opens the way for allowing even commercial games to be 
developed with the CrystalClear libraries, and contribute to their development.

There may be other libraries that are not officially part of the CrystalClear
project, but are CrystalClear compliant and may be used interchangeably with
the equivalent libraries within the project.  These libraries will have their
own licensing terms; you will need to check with the documentation of those
libraries.

More information on the CrystalClear project can be found at
http://php.indiana.edu/~mdlong/crystalclear/

More information about Crystal Space can be found at
http://crystal.linuxgames.com/

It is recommended that you join the mailing lists for both projects if you
wish to become actively involved with the development of CrystalClear.
Details on how to join can be found on their respective homepages.

Currently, the CrystalClear code consists of the following:
===========================================================
The Entity layer
================

EntityManager
-------------
ccentman - The ccEntityManager is the standard implementation for the 
	   IEntityManager interface.  It controls loading and keeping
	   track of Entities, which are high level interfaces for
	   game 'entities' such as monsters, player-characters, etc.

Entities
--------
	Entities will be game player characters, npcs, and objects.  They
	will be part of the game application and interact directly with the
	engine.  See below for a sketch of the Entity hierachy.


The Impulse Layer
=================

ImpulseManager
--------------
ccimman - The ccImpulsemanager is the standard implementation for the
	  IImpulseManager interface.  It controls various ImpulseHandlers
	  and routes messages, called impulses, to them.

Plugins
-------
ccinput - Th ccInputPlugin converts keyboard and mouse csEvents into CrystalClear
          impulses.  The developer may choose to use csEvents directly, but
	  this is provided to allow a consistent messaging interface.

ccphysic - The ccPhysicsPlugin is a low level collision ImpulseTarget.  Responds
	   to collision impulses, currently only in a limited fashion.  Plan to add
	   an interface for controlling world physics, gravity and other forces.

Applications
============
cctest - The CrystalClear test application.  This is under heavy development.
	 Currently you can load a level, and move around.  There is now limited
	 collision detection and gravity, as well.

	 There are two sets of controls:
	 Traditional:
		Arrow keys:  Up/Down move forward and backwards, left/right 
			     turn in those directions.
	        Page Up/Dn:  Look up/down.
	 Mouse look:  (Right handed)
		s - Move forward
		x - Move backwards
	        a - Strafe left
		d - Strafe right
		ENTER - "Space jump", you can jump into the air and jump again
	                 multiple times, since you no longer move in the 
			 exact direction you are looking, but along the floor.
		Mouse - Moves viewpoint according to mouse motions (Freelook)
		Left button - Move forward
		Right button - Release mouse capture while held down
		   The mouse is recaptured when it is released and it
		   goes back over the window.
		TAB - Toggle the console.  Type 'help' to get a list of console 
		      commands

========================================================

The CrystalClear source code is now integrated with the Crystal Space source
code.  It should build along with the rest of CS unless you specify otherwise.

More code is on the way, just be patient.  Or if you don't want to be patient,
look at the layers specification on the CrystalClear homepage and start
implementing the libraries for it, or help with existing libraries.

Here is the current plan for the entity hierarchy

Here's a quick over view of the CrystalClear Entity hierarchy.  The tree 
shows the inheritance chain, and a more detailed description of each subclass
follows.  Each class can be subclassed, either in C++ code or by scripts from
a CrystalClear scripting plugin, depending on the scripting language and it's
plugin.

Entity
 |
 |-Actor
 |  |
 |  +-Pawn
 |
 |-Effect
 |
 |-Path
 |
 +-Trigger

Entity
------
Has basic get/set coordinates member functions.  Can only be moved around in a
limited fashion, i.e. no high level movement functions builtin at this level.

Subclasses of Entity
--------------------
Actor - An entity that can be moved around in space and in direction.
	Has member functions for manipulating direction, smooth movement, etc.	
Effect - Special effects entities, such as smoke or fire.  Possibly could be 
	 used for data display and user interface.  HUDs, menus, consoles, 
	 etc.  Any special effects that need a lot of mobility should be 
	 Actors instead.
Path - A pathfinder Entity.
Trigger - Marker point.  Can respond to other Entity's interaction.  Could 
	  also be used to create paths and starting points.

Subclasses of Actor
-------------------
Pawn - Player, monsters, etc.  A Player/Non-player character.
       Other Actors that can be picked up an used by a Pawn.  This 
       includes weapons, armor, and "subparts" of an Actor that
       can be removed and dropped, as well as things such as 
       ammo boxes, which would always exist separate from a Pawn.

Random IRC notes:

[22:40:12] <azverkan> :as far as entity implementation, assume that
[22:40:22] <azverkan> :C++ can implement an Entity
[22:40:29] <azverkan> :Python can implement an Entity
[22:40:42] <azverkan> :Python can derive from a C++ implementation of an Entity
[22:41:14] <azverkan> :C++ can derive from a Python entity with a fairly large speed hit
[22:41:53] <azverkan> :so I will probably drop C++ derive from Python
[22:43:00] <azverkan> :basically all that need be done is we add a python module that autogenerates dynamic execution code for the Python derived Entity in the C++ source and the Python entity will instantate that object at runtime and connect to it
[22:43:23] <azverkan> :so to sum up
[22:43:45] <azverkan> :for each C++ entity, you need to
[22:43:49] <azverkan> :1) compile it 
[22:44:03] <azverkan> :2) generate a script wrapper for it
[22:44:41] <azverkan> :2 is only needed if you want a scripted object
