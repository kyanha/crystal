@c -*-texinfo-*-
@node About Deferred, Using Deferred, Deferred Rendering, Deferred Rendering
@subsubsection About Deferred Rendering
@cindex aboutdeferred

@subsubheading What is Deferred Rendering?

Deferred shading is a rasterization based rendering method that separates the
rendering of geometry from the process of lighting that geometry. In the
traditional approach to rasterization (commonly referred to as forward shading)
the rendering and lighting of geometry are done in tandem. As a result, using
forward shading tends to limit the number of light sources that can affect a
single object. However, with deferred shading the cost of adding a light to a
scene is independent of the number of objects in a scene. This property allows
for a scene to contain significantly more dynamic light sources before
performance becomes an issue.

@subsubheading Implementing Deferred Rendering

From a high-level deferred shading works in two main passes. In the first pass
all geometry in a scene is drawn to a set of buffers referred to collectively as
the @emph{GBuffer} (short for Geometry Buffer). During this pass the
@emph{GBuffer} is filled with the information needed to evaluate the lighting
equation. This information includes as a minimum the surface normal, surface position
(stored as depth and reconstructed when needed) and shininess. In the second pass
the filled @emph{GBuffer} is used to evaluate the lighting equation for each light
in the scene. The contribution from each light is added to, what is commonly
referred to as, the accumulation buffer. At the start of the second pass the
accumulation buffer is initialized to all black. During the pass the accumulation
buffer will be filled with lighting information from each light. By the end of
the pass the accumulation buffer will contain enough information to compute
the final image.

To compute the lighting equation for a light source we must determine what
pixels in the final image are affected by that light. To do this we take
advantage of the rasterization capabilities of the GPU by rendering light proxy
geometry. This proxy geometry is a mesh that approximates the size, shape, and
position of the light source we are considering. As an example, we might use a
cone mesh to approximate a spot light or a sphere mesh to approximate a point
light. Ideally we want the proxy geometries approximation be as tight as
possible so we do not needlessly consider pixels that are not affected by the
light. The light proxy geometry is rendered using a shader (@pxref{Shaders})
that reads data from the @emph{GBuffer}, computes the lighting equation, and
outputs the result to the accumulation buffer at each pixel.

@subsubheading Difference between Deferred Rendering Techniques

Crystal Space implements two different deferred rendering techniques.
The first and more traditional one is deferred shading. In this technique
the @emph{GBuffer} contains all information that is needed to compute the
final image is stored in a single pass over the geometry and there's only
one accumulation buffer to which the results from each light are added.
The second technique is deferred lighting which only uses a minimal @emph{GBuffer}
containing the information needed to accumulate the results of each light,
but not enough information to compute the final image. Most noteably neither
the diffuse nor the specular color are stored as they don't vary for a pixel
so they are not needed to accumulate the irradiance.
The cost of this small @emph{GBuffer} is that two accumulation buffers are
needed (one for diffuse, one for specular light) and that a second pass
over the geometry after the accumulation is required in which all extra
information (such as diffuse and specular color, ambient, etc.) is fetched
and the final image is produced.

@subsubheading Considerations when Using Deferred Shading

Despite the benefits in lighting that deferred shading provides there are
multiple issues that should be considered when choosing this rendering method:

@itemize @bullet
@item The first issue to consider is the hardware requirements necessary to
implement deferred shading efficiently. At a minimum the hardware must support
programmable shaders. Although, hardware support for shaders that can output to
multiple buffers and enough memory to hold 3 to 4 full resolution buffers is
ideal. Overtime, as hardware improves, this will become less of an issue
However, depending on your requirements, using deferred shading may limit you
potential target base.

@item The second issues to consider is that deferred shading does not support
semitransparent (alpha blended) objects. This is inherent to the method itself
because of the data stored in the @emph{GBuffer}. Most notably surface normals
and surface positions cannot be blended in any meaningful way. The most common
solution to this problem (and the one Crystal Space takes) is to render the
semitransparent objects using forward shading after all deferred shading is
completed. As a result, semitransparent objects will have to use a more
traditional lighting scheme.

@item The third issues to consider is that deferred shading does not (at the
time of this writing) have widespread support for hardware based antialiasing.
More specifically, the Crystal Space implementation of deferred shading does not
currently support hardware based antialiasing even if hardware support is
present. 
@end itemize
