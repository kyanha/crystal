@c -*-texinfo-*-
@node Shader Conditions and Processing Instructions Reference, , Shader Variables, Shaders
@subsubsection Shader Conditions and Processing Instructions Reference

@subheading General Syntax

Shader conditions and processing instructions are specified via @sc{xml} 
processing instructions, that is @code{<?...?>}.  Some instructions only
consists of a single instruction, others consist of a pair and enclose a
block of @sc{xml}.  All tags opened in such a block must be properly closed
according to the node hierarchy, and all closing tags must be matched by
an opening tag inside such a block.

@subheading Shader Processing Instructions

Shader processing instructions are evaluated at parse time; notably, a shader
condition as described below does @emph{not} influence whether a processing
instruction is processed or not.  In order to visually distinguish the 
parse-time evaluated processing instructions from the run-time evaluated
conditions, all processing instructions start with an uppercase letter by
convention.

@subsubheading Templates

Syntax for template definition:
@example
<?Template [TemplateName] @{ParameterName@} @{ParameterName@} ...?>
@{@sc{xml}@}
<?Endtemplate?>
@end example

Syntax for template invokation:
@example
<?[TemplateName] @{Parameter@} @{Parameter@} ...?>
@end example  

A template is available for invokation after the closing @code{Endtemplate}.

If a template is defined with a name of an already existing definition, the
new definition overrides the old definition after the closing @code{Endtemplate}.

If a template definition is parsed. template invokations inside template 
definitions are immediately expanded.  However, note that @emph{nested} 
template definitions are not parsed unless the containing template is invoked.
This means that nested template invokations are not immediately expanded.

Templates support parameters.  Each parameter has a name, and placeholders in 
the template contents block are substituted with the parameter's values.
A placeholder has the form @samp{$Parameter$} or @samp{$"Parameter$}.  The
first form substitutes the placeholders with the verbatim parameter value.
The second form substitutes the placeholders with a ``quoted'' string:
it is formatted such that it can be passed as a parameter to a template
invokation, preserving contained spaces (see below).  
To specify a single dollar sign in the contents block use @samp{$$}.

The parameter values specified in the template invokation are associated with
the definition's parameter names by position.  Parameter values are 
space-separated.  To specify a parameter that contains spaces, the string
must be surrounded by quotes.  A quote character in such a quoted string is
represented as @samp{\"}, a backslash character as @samp{\\}.

Syntax for weak template definition:
@example
<?TemplateWeak [TemplateName] @{ParameterName@} @{ParameterName@} ...?>
@{@sc{xml}@}
<?Endtemplate?>
@end example

Weak templates behave the same way as ``normal'' templates, except in the case
of a definition with the name as an already existing definition: the new
definition is ignored.

@subsubheading Generators

Syntax for generation:
@example
<?Generate [Variable] [Start] [End] @{Step@} ?>
@{@sc{xml}@}
<?Endgenerate?>
@end example

@samp{Generate} instructions let internally run a counter, starting at 
@samp{Start}, adding @samp{Step} on each iteration, until the counter
is greater (for a positive @samp{Step}) respectively smaller (for a 
negative @samp{Step}) than @samp{End}. Each iteration replicates the
contents block.

If @samp{Step} is not specified, it defaults to @code{1} if 
@samp{Start} <= @samp{End} or to @code{-1} if @samp{Start} > @samp{End}.
@samp{Step} = @code{0}, @samp{Step} > @code{0} and @samp{Start} > @samp{End},
@samp{Step} < @code{0} and @samp{Start} <= @samp{End} result in an error. 

Certain placeholders in the contents block, in the same form as placeholders
for a @samp{Template} parameter with the name of @samp{Variable} will be
replaced with the counter value of an iteration.

(Semantically, using a @samp{Generate} instruction is equivalent to defining
a template with a single parameter named @samp{Variable}, with the same 
contents as the @samp{Generate} instruction, and invoking it once for each 
value of the counter, iterating as described above.) 

@subsubheading Inclusions

Syntax for inclusion:
@example
<?Include [Filename] ?>
@end example  

@samp{Filename} is the @sc{vfs} path to the file to be included.  The file
needs to be an @sc{xml} file with a node @code{include} at the root.  All
contents of this @code{include} node will treated as if appearing in the 
including document at the point of the @samp{Include} processing instruction.
Shader processing instructions and shader conditions will be handled normally.

@subsubheading Static Conditions

@subheading Shader Conditions

