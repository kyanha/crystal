@c -*-texinfo-*-
@node Memory Debugger, Platform Details, VFS, Anatomy
@section Crystal Space Memory Debugger
@cindex Memory Debugger

By Andrew Zabolotny (@email{bit@eltech.ru}).

@menu
* MemDbg Goals:: Memory debugging tool goals:
* MemDbg Usage:: Usage
* MemDbg mapfile:: Map file format
* Memdbg HowWorks:: How it works
@end menu

@node MemDbg Goals, MemDbg Usage, Memory Debugger, Memory Debugger
@subsection Memory debugging tool goals:

@itemize @bullet
@item
Help find memory leaks. In a such complex program like Crystal Space Engine
it is often very hard to find memory leaks analytically. Most often you even
won't observe that a memory leak occured, unless the leak is quite
significant.

@item
Help find situations when a memory block is used after being freed. This
doesn't happen too often, but if it happens, its quite dangerous.

@item
Help find usage of uninitialized memory.

@item
Help find situations when programs writes outside the bounds of the allocated
memory block.

@item
Help gather some memory usage information about the program.
@end itemize

@node MemDbg Usage, MemDbg mapfile, MemDbg Goals, Memory Debugger
@subsection Usage

To enable memory debugger you should first of all compile in debug mode. Not
that it is impossible to use it in optimize mode (in fact, I've used it a
couple of times in this mode) but you will get hex addresses instead of file
name / function name / line number information.

Next, you don't need to recompile the engine from scratch, like you used to
do with the old memory debugger (that used @code{CHK()} macros). You just
work as usual and if you need the memory debugger, you recompile with the
@code{MEMDBG} variable set to 1, for example this way:
@example
make walk mode=debug MEMDBG=1
@end example
This will just compile @file{memdbg.cpp} and link all other object files and
libraries with this one. Linking against this file automatically enables the
memory debugger.

Now you should create a map file for your executable. A map file is a text
file that contains information about source files, functions and line numbers
of your programs. For a file format reference see the following section.

The map file is created with the @file{bin/memdbg.sh} script. You do it this
way:
@example
bin/memdbg.sh ./walktest [options]
@end example
This will create a file called @file{memdbg.map}. You also can provide some
options after giving the name of executable. These options tells memory
debugger what tasks to perform. Here is a summary on each option (character
case is significant!):
@table @code
@item a
@emph{Fill memory after allocation with garbage?} This is highly recommended
as it is not too expensive but allows to detect cases when memory is used
without being initialized first.

@item f
@emph{Do we want to fill freed memory with garbage and leave it non-freed?}
@emph{WARNING:} This is quite expensive in memory terms!}

@item d
@emph{Do we want debugger breakpoints when detecting serious erros?} The
debugger will break inside operator new or delete right before exiting back
to user program. By stepping a few you can detect the place where error
occured.

@item v
@emph{Do we want memory debugger to print an information string each time new
or delete is called?} It is recommended you to redirect stdout when using
this flag as output to console will immensely slow down your program.

@item s
@emph{Do we want a summary sheet at the end of program?} The sheet will list
the summary number of memory allocations, memory frees, the peak memory
consumption and lots of other useful information.

@item l
@emph{Do we want a list of unfreed memory blocks at the end of program?} The
list will also contain the location where the corresponding memory block was
allocated.

@item b
@emph{Detect writes past the block bounds?} This is implemented by allocating
slightly bigger blocks than actually requested, and by filling those
inter-block spaces with some well-known value. When block is freed, the space
between blocks is checked to contains same well-known value.

@item L
@emph{Redirect (append) output from console to a log file called}
@file{memdbg.log}.
@end table

Default options are: @code{aslbL} @*
To enable extensive checking use: @code{aslbLf} @*
Enable all options: @code{aslbLfdv}

Thus, to disable everything except the log file and the summary, you type:
@example
bin/memdbg.sh ./walktest sL
@end example

After you created the map file, just run your program as usual. If your
program doesn't have a separate stdout stream (such as on DOS, OS/2, Windows,
Mac) it is recommended that you always use log file; if you didn't you can
still redirect the stdout to a file using the stdout redirection, if it is
possible (@samp{./walktest >logfile}).

If you will want later to change debugging options, you can load the map file
into any text editor (that will handle such large files) and change the first
line (that starts with a capital O).

If you did everything correctly, you should get similar references to
locations:
@example
+--------+----------+- Unfreed memory blocks ---------------------------------
|  size  |  address |location where block was allocated
+--------+----------+---------------------------------------------------------
|     239|   0x89970|file /home/andy/CS/memdbg/test.cpp:28, func main
@end example

If you get such text:
@example
+--------+----------+- Unfreed memory blocks----------------------------------
|  size  |  address |location where block was allocated
+--------+----------+---------------------------------------------------------
|     200|   0x32b70|unknown (0x10239)
|     239|   0x87f50|unknown (0x10189)</font></pre>
@end example
This means that the map file is either incorrect, or does not contain
location information about the above addresses. However, this does not
invalidate the usefulness of the memory debugger, it just makes reading of
the log file more complex. Usually each compiler system provides a way to
find out the source module and the line number that is closest to given
address; for GNU set of development tools this is done with the
@file{addr2line} tool; you also can do it with @file{gdb}.

@node MemDbg mapfile, Memdbg HowWorks, MemDbg Usage, Memory Debugger
@subsection Map file format

Map file has a very simple format. Currently the map file is created by
piping @file{nm} program output through an AWK script, but you can write
other tools that create @file{.map} files. That's why I'll describe the
format of map file in details. Even more details you can gather from the
source code, as always :-)

The map file is a plain text file; lines that start with @samp{#} or @samp{;}
are ignored. Otherwise each line starts with an letter that identifies which
type of information is presented on that line. Here is a list of all
identificators, what they mean and what information is expected on that line:
@table @code
@item O [string]
Memory Debugger [O]ptions. Example:
@example
O aslbL
@end example

@item S [hexnum] [string]
[S]ource module start. The @code{[hexnum]} parameter defines the start
address of the object module in hexadecimal; the @code{[string]} is just the
source file name. Example:
@example
S 10038 /home/andy/CS/memdbg/test.cpp
@end example

@item F [hexnum] [string]
[F]unction start. The @code{[hexnum]} parameter defines the hexadecimal
function address; the @code{[string]} is the function name. Example:
@example
F 10370 output(char const *,...)
@end example

@item L [hexnum] [decnum]
This denotes a line number. The @code{[hexnum]} parameter is the hexadecimal
address of the line, the @code{[decnum]} is the line number (in decimal).
Example:
@example
L 10071 11
@end example

@item D [hexnum] [hexnum] A|F
(Advanced users only :-) This command is not written by @file{memdbg.sh}
script, it is inserted manually by you using a editor. The first hexadecimal
number is the address of memory block, the second is the address inside your
executable, A or F means to invoke a debug breakpoint either during allocation
of free of that block. On x86 this is the @samp{int 3} instruction. This
feature can be used to track very specific bugs... I'll let your imagination
work here :-) Example:
@example
D 32b70 10370 A
@end example
@end table

The addresses for S,F,L keywords should be sorted in increasing order, i.e.
memdbg supposes that all lines are pre-sorted by increasing value of their
address. Otherwise you will get very strange line references (or hex
addresses like at the end of previous chapter).

@node Memdbg HowWorks, , MemDbg mapfile, Memory Debugger
@subsection How it works
Here are some technical details about the functioning of the memory debugger.
This can help understand you more detailed how it works, and I think this can
help you use the debugger in a more productive fashion (also it will help you
to not expect wonders from memory debugger :-)

In each @code{new()} or @code{delete()} call, we check whenever we have been
initialized. If not, we call the initialization function that parses the
@file{.map} file, sets the debugging options and so on. When program exits
(this is done by declaring a dummy static variable at the very end of memory
debugger module and the shutdown function being called from his destructor)
the memory debugger checks for unfreed memory block, displays statistics and
so on.

The only trick used in memory debugger is used to get the address from where
@code{new}/@code{delete} has been called. This is a processor-dependent issue,
alas we can't do it in a platform-independent way. To support doing this on
different platforms we define a macro called @code{GET_CALL_ADDRESS(x)}. We
pass the first argument of the procedure we're invoking
@code{GET_CALL_ADDRESS} from and we get the address from were we were called
in a variable called @samp{addr}.

Here are details on how we're doing it on different platforms:
@table @emph
@item Intel x86
These processors use a stack for passing arguments, and the same stack is
used to push the return address. Since all machines uses a top-to-bottom
stack (i.e. stack increases in the direction of lower addresses), and also
since ANSI C standard requires that the addresses of function arguments
increase (that is, if you're defining a function
@code{void some(int a, int b)} you can be absolutely sure that address of b
is higher than address of a) it is a good guess to suppose that on most
computers as of today upon the invocation of the @code{new()} and
@code{delete()} routines the stack will look like this:
@example
+-----------------+ higher addresses
|       arg2      |        ^
+-----------------+        |
|       arg1      |        |
+-----------------+        |
|  return address |        |
+-----------------+ lower addresses
@end example

This means that if we take the address of first argument of the procedure
and go one machine word back, we'll get the address of the
@samp{return address} word. Now we peek it from there and voila! we have the
return address. This is embedded into a macro that looks like this:
@example
#define GET_CALL_ADDRESS(firstarg)  \
  address addr = ((address *)&firstarg) [-1];
@end example
(@samp{address} is a shortcut for @samp{void *} type).

@item An almost cross-platform solution
Fortunately for us, GCC versions above 2.8.0 have a extremely useful for our
goals built-in function called @samp{__builtin_return_address}. If we invoke
it with the (0) argument, it returns right what we need: the address from
where our procedure was called. Thus, an almost-cross-platform
@code{GET_CALL_ADDRESS} is implemented this way:
@example
#if (__GNUC__ >= 2) && (__GNUC_MINOR__ >= 8)
#  define GET_CALL_ADDRESS(firstarg)  \
     address addr = (address)__builtin_return_address (0);
#endif
@end example
Thus, if you can't get memdbg to work, you should find a newer GCC; this
should always help.
@end table

