@c -*-texinfo-*-
@node OS2 details, BeOS details, NeXT details, Platform_Details
@subsection Detailed information for OS/2

The OS/2 port of CrystalSpace has a number of specific features that should
be mentioned, so that you can better understand sourcecode and/or make
modifications, if you need them. If you do, you should make them available
to the public, as stated by the LGPL. @xref{License}.

@menu
* OS2 DIVE:: DIVE
* OS2 DIVE features:: DIVE features
* OS2 Mouse and Kbd:: Mouse and keyboard
* OS2 Crashes:: Mysterious crashes
* OS2 Contributors:: Contributors
@end menu

@node OS2 DIVE, OS2 DIVE features, OS2 details, OS2 details
@subsubsection DIVE

The current implementation requires DIVE, so the application is compiled as a
PM application. This is done by default (@file{bin/os2link.cmd} creates
automatically a @file{.def} file). If you want to compile the application as
a console application, you have to link it with the
@code{$(DO.LINK.CONSOLE.EXE)} macro (have a look at
@file{apps/scfreg/scfreg.mak}).

Other thing you should keep in mind is that DIVE library (@file{libDIVE.cpp})
uses a couple of resources, so you should not forget to link the resources to
your application. Resources can be found in @file{libDIVE.rc}; this is added
to linker dependencies for PM programs in CSDIVE driver makefile, so you also
don't need to worry about it (but is still useful to know :-)

There is one not too pleasant feature related to DIVE (or to acceleration
hardware specifics?). If DIVE image should be rescaled (i.e. the scale ratio
is not 1:1) DIVE is almost TWICE (!) slower if DIVE window (the client
rectangle, not the window border) is not on a two-aligned bound (at least
such an effect I've got on my Matrox Mystique). If you get low frame rates,
try moving the window by one pixel left/right.

To fix this if you use WINDOWX/WINDOWY keywords in @file{cryst.cfg} file or
@samp{-pos <x>x<y>} command-line switch, the computed X value will be rounded
to nearest divisor of 2. However, if you manually move the window it can fall
on a odd bound and you'll get twice lower frame rates.

You can use WINDOWWIDTH and WINDOWHEIGHT keywords in @file{cryst.cfg} file to
define start window width and height (client window width and height, not
counting borders and titlebar). If you won't define it, the DIVE window will
be rescaled to the maximum possible integer factor such that window won't be
larger than screen. For example, a 320x200 window in 1152x864 resolution will
be automatically rescaled at startup to 960x600.

@node OS2 DIVE features, OS2 Mouse and Kbd, OS2 DIVE, OS2 details
@subsubsection DIVE features

Here is a short list of implementation features related to DIVE:
@itemize @bullet
@item
DIVE contexts can be created with following pixel formats:

@itemize @minus
@item
@code{FOURCC_LUT8}
@item
@code{FOURCC_R565}
@item
@code{FOURCC_R664}
@item
@code{FOURCC_R555}
@item
@code{FOURCC_BGR4}
@end itemize

If you use @code{DEPTH=8} in CrystalSpace configuration file, or use
@code{-depth 8} command-line parameter, CrystalSpace will start with
@code{FOURCC_LUT8} pixel format, regardless of what PM screen depth you
have. If you choose 15, 16 or 32 bit color depth, the format will be
chosen as follows:

@itemize @minus
@item
If you selected 32-bit mode, and current screen depth is 32 bits,
current pixel format is used. @emph{SEE NOTE BELOW!}

@item
If screen pixel depth is @code{FOURCC_R565}, @code{FOURCC_R664},
@code{FOURCC_R555}, that pixel format is used.

@item
If you use @samp{-depth 15} or @code{DEPTH=15} parameters, FOURCC_R555
pixel format will be used.

@item Otherwise the list of DIVE supported pixel formats is scanned. The
most wanted mode is @code{R5-G6-B5 mode}, if it is not available
@code{R6-G6-B4} mode is choosen, if it is not available,
@code{R5-G5-B5} mode is choosen. If no 16- or 15-bit mode is available,
code falls back to 256-color mode.
@end itemize

NOTE: Due to a bug (or a misimplemented feature, to say so) in OS/2 DIVE
library, you can't use 32-bit modes with the stock @file{DIVE.DLL} library.
You have to patch it first so that it won't reject @code{BGR4} pixel format
when creating image buffers.

WARNING: This is a Bad Fix (tm) however I didn't had other choice. It works
for me with Matrox Mystique and Matrox Millenium ][ video cards, but I
don't guarantee it will work for you:

Go to @file{\MMOS2\DLL}. Take the @file{DIVE.DLL} library. Unpack it, if it
is packed (@samp{lxlite /x dive.dll}). Now find the following sequence of
bytes inside it:
@example
83 C2 08 41 83 F9 [10]
@end example
This sequence happens only once in my @file{DIVE.DLL}; I hope this is true
for your @file{DIVE.DLL} as well. Now change the @samp{10} that I took into
square brackets with @samp{16}. That's all.

Note that you will likely get wrong results if your current pixel format is
NOT low-endian 32-bit (i.e. @code{BGR4}). That's not my fault.

@item
DIVE windows can be rescaled to arbitrary sizes. Rescaling is done
automatically by DIVE, as well as color conversion. Note that if EnDIVE is
available, you better use the same pixel format as your PM does, since most
cards (my Matrox Mystique, for example) supports in hardware EITHER color
conversion OR rescaling, but not both (although I can be wrong here, but
that was my impression).

@item
Although DIVE does not (transparently) allow blitting only a portion of
backbuffer to screen, there is still a solution. The key is to call each
time @code{DiveSetupBlitter} with same parameters as usual, but clipping
first all rectangles returned by @code{GpiQueryRegionRects} against the
rectangle you want to update. Look in @file{libDIVE.cpp}
(@code{diveWindow::SetupBlitter}) for more details.

@item
Although docs states that @code{DiveSetupBlitter} is a longplay operation,
I think if you should update only a small part of screen it is still faster
to use it (for example, @code{CSWS} mostly needs to update only the portion
of screen around mouse cursor). @code{DiveSetupBlitter} is not called
multiple times if update region does not change, so if you always call
@code{Graphics2D::Print} with a constant argument (or NULL for entire area),
it won't be called more often than in the @samp{classic} situation.

@item
There is an @samp{almost full-screen DIVE} mode of operation available. To
activate/deactivate it you can press @kbd{ALT-HOME} (like in DOS windows
:-). In this mode window is resized so that window borders and window title
will fall outside of physical screen, and DIVE window occupies entire
screen. The bad side is that you get not too high frame rates in this mode
(for example, on Matrox Mystique a window 320x200x256 rescaled to
1152x864x64K can be updated only about 15 times per second).

@item
The system menu on CrystalSpace window is replaced by a more
application-specific menu. There are some useful options there (also
available through hot-keys, for example @kbd{CTRL-ALT-1} rescales window to
1:1 scale, @kbd{CTRL+ALT+2} to 2:1 and so on). The menu definition is
contained in @file{libDIVE.rc}. If you need some additional entries, you
can add them directly to resource file.
@end itemize

NOTE: If you're running 16bpp or 32bpp on Matrox cards, make sure you
disabled the @samp{Enable EnDIVE in 16bpp and 32bpp} checkbox in the Matrox
settings notebook. This is a real performance killer! (fps drops twice on my
Matrox II AGP, for example!)

@node OS2 Mouse and Kbd, OS2 Crashes, OS2 DIVE features, OS2 details
@subsubsection Mouse and keyboard

I was too lazy to intercept system event queue, so code generates all
CrystalSpace events from events that are passed to DIVE window. As a
consequence, there are some (minor) flaws:

@itemize @bullet
@item
  If you press a mouse button inside CrystalSpace window, then move the mouse
  outside the window and release button, CrystalSpace won't receive the
  @samp{mouse button released} event, since OS/2 passes mouse events to a
  window only if mouse is over that window. Theoretically this can be fixed
  by capturing mouse when any mouse button is pressed and releasing mouse
  when all mouse buttons will be released. I didn't have time to do it, and
  anyway it is not so important I think.

@item
  If you press a key inside the window, then activate another window and
  release it, the same happens as with mouse buttons. Keyboard events are
  passed by OS/2 only to active windows. To avoid this, the default
  @samp{focus change} handler in @code{csSystemDriver} class calls
  @code{Keyboard->Reset} and @code{Mouse->Reset} if focus goes away.
  @code{Keyboard::Reset} clears all @samp{Key pressed} flags and emmits
  corresponding @code{csevKeyUp} events. @code{Mouse::Reset} clears all
  @samp{button down} flags and emmits corresponding events too.
@end itemize

By default Crystal Space Windowing System will use builtin OS/2 mouse
pointers whenever possible (there are three cursors that do not have their
counterparts in OS/2 and will be emulated in software). This behaviour can be
controlled by the @samp{SYS_MOUSE_CURSOR = @{yes|no@}} parameter in config
file. If set to @samp{yes}, system mouse pointers will be used when
available; if set to @samp{no}, mouse pointers will be drawn by CrystalSpace
as 2D sprites. This is slower but more precise. Theoretically
@code{csGraphics2D::SetMousePointer} can be implemented to construct a OS/2
pointer from @samp{native} CrystalSpace textures, but I was too lazy for
this.

@node OS2 Crashes, OS2 Contributors, OS2 Mouse and Kbd, OS2 details
@subsubsection Mysterious crashes

If you just compiled WALKTEST or MAZED or some other executable (or even
SCFREG), run it and get misterious exits or crashes during startup, it could
be caused by the following problem:

I had a precompiled version of the JPEG and PNG dynamic libraries that were
compiled with @code{-Zcrtdll}. And compiled Crystal Space with @code{-Zsys},
i.e. without EMX C runtime DLLs. For some reason this combination doesn't
work until C/C++ compilers and company are resident in memory (if you're
using @samp{set GCCLOAD}). So you should either recompile everything with
@code{-Zsys}, or recompile everything with @code{-Zcrtdll}, or do a
@samp{emxload -q} before running such executables.

@node OS2 Contributors, , OS2 Crashes, OS2 details
@subsubsection Contributors

For the moment, there is only one contributor :-) If you have any
problems/questions related to OS/2 port, mail them to me, Andrew Zabolotny
(@email{bit@@eltech.ru}).

You also may want to check the PGCC for OS/2 home page
(@uref{http://goof.com/pcg/os2}), which I'm maintaining. You also may want to
use PGCC for CrystalSpace since it better optimizes for Pentium and alike
than regular GCC.
