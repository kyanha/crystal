@c -*-texinfo-*-
@node CSWS
@section Crystal Space Windowing System (@sc{csws})
@cindex CSWS
@cindex Libraries,CSWS
@cindex Windowing System

@table @emph
@item The Goal
The main goal of Crystal Space Windowing System (@sc{csws}) is to provide a
clean, effective and cross-platform base for creating CrystalSpace-related
utilites. Currently there is only one such utility under development:
CrystalSpace maze editor.

@item Overall concepts
There is nothing new in CSWS regarding the window system. All base
conceptions for building such an system were invented far ago, at least when
first X-windows system was built (at MIT(?)) or even earlier.

The system is event-based, events are generated by hardware (mouse, keyboard)
or software (components can send messages to each other). Event-system is
system-dependent as well as graphics subsystem. They were developed first
as part of CrystalSpace itself, then some modifications were made to better
fit @sc{csws} requirements. @sc{csws} itself is completely
system-independent, i.e. you can easily develop programs that will compile
and work with no problems under any system supported by CrystalSpace.

Since Crystal Space always uses buffered visuals, the screen repainting is
always done on the invisible page. This means flickering on redraw is
almost impossible in @sc{csws}, while it is common on usual GUIs with
bad-written programs. If visual has more than one backbuffer (like OS/2
port), the image is automatically re-syncronized on all back-buffers.

Other CrystalSpace-specific feature is the division of event processing into
@emph{frames}. Since CrystalSpace is a animation engine it operates in terms
of frames, i.e. when the frame begins, all pending events in queue are
processed, then all invalid components are redrawn, and at last the image is
blitted onto the screen.
@end table

@node CSWS Basics
@subsection Basic concepts

@table @emph
@item Coordinate system
Coordinate system is based on most-used (wrong :-) system when top-left
corner is (0,0) and bottom-right corner is (width, height). It would be
better to use the @samp{right} coordinate system used, for examplem, in OS/2
and OpenGL but most programmers are already common with the @samp{wrong}
system.

Most CSWS functions works with rectangles (@code{csRect} class). The
@code{csRect} class has four data fields: @code{xmin}, @code{xmax},
@code{ymin}, @code{ymax} which are self-explanatory. Here is a example of
rectangle (@code{xmin = 0}, @code{ymin = 0}, @code{xmax = 3},
@code{ymax = 2}):
@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --##########--+--+--
     #//|//|//#  |  |
 1 --#--+--+--#--+--+--
     #//|//|//#  |  |
 2 --##########--+--+--
     |  |  |  |  |  |
 3 --+--+--+--+--+--+--
     |  |  |  |  |  |
...--+--+--+--+--+--+--
@end example

Vertical line @samp{X=3} and horizontal line @samp{Y=2} does NOT belong to
the rectangle. The hashed pixels belong to the rectangle. So, if you have two
windows: (0, 0) - (3, 2) and (3, 0) - (6, 2) they do NOT overlap.

@item Palette
@sc{csws} has been designed to operate transparently independent of screen
geometry or number of colors. To allow normal operation in different pixel
format conditions colors are kept in a dynamically-built table which is
referenced through indexes in that table. To allow different palettes for
windowing system each component does not use colors directly when drawing,
instead each component has a pointer to a table which contains color values.
So, for example, a component can have a palette which's first element is used
as background color, second is used to display text in window and so on. By
changing only the palette table we can change at once how all these
components are looking.

There is a number of pre-defined colors called @code{cs_Color_XXX}, for
example @code{cs_Color_Black}, @code{cs_Color_White} etc. Components does not
draw with @code{cs_Color_XXX} constants, they just indicate the index into
their palette. All standard component palettes are contained in
@file{cswspal.cpp} and @file{cswspal.h} files.
@end table

@node CSWS Components
@subsection Components

The base class for windowing system is @code{csComponent}. @code{csComponent}
is a very complex class with lots of built-in functionality. This allows for
easier creation of new components for specific needs. Most @code{csComponent}
methods are virtual, allowing to override them as needed. There are some
basic methods, which are described below. Other methods are described as
needed during this document.

@table @code
@item csComponent::Draw ()
Each component should know how to paint itself. When windowing system thinks
a part of a component image or entire component image is invalid (for example,
when a window is moved from the top of other components), it adds that
rectangle to the @samp{dirty} rectangle of the component. The dirty rectangle
is initially empty, then all invalid rectangles are added to it. At the end
of each frame windowing system sends a broadcast event with @code{cscmdRedraw}
command code. When component catches this event, it calls Redraw method which
in turn calls @code{csComponent::Draw}. After @code{csComponent::Draw} returns
control, the dirty rectangle is emptied again.

All draw operations are clipped first against dirty rectangle and then
against all component childs and neightbours. So drawing inside a component
does not change even a pixel in other components, even if component is
partialy covered by other components.

There is a number of drawing operations that you can use. Other operations
can be synthesized from existing. All coordinates used for drawing are
component-origin related, so (0,0) corresponds to component top-left corner.

@table @code
@item Line (x1, y1, x2, y2, colorindex)
Draw a line from (x1, y1) to (x2, y2). Example: @code{Line (0, 0, 3, 3)}
produces the following output:
@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--+--+--+--+--+--
     |//|  |  |  |  |
 1 --+--#--+--+--+--+--
     |  |//|  |  |  |
 2 --+--+--#--+--+--+--
     |  |  |//|  |  |
 3 --+--+--+--#--+--+--
     |  |  |  |//|  |
...--+--+--+--+--+--+--
@end example

@item Box (xmin, ymin, xmax, ymax, colorindex)
Draw a filled box that is closed between lines @code{(X >= xmin)},
@code{(X < xmax)}, @code{(Y >= ymin)} and @code{(Y < ymax)}. Example:
@code{Box (0, 0, 3, 2)} will produce the following output:
@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--#--#--+--+--+--
     |//|//|//|  |  |
 1 --#--#--#--+--+--+--
     |//|//|//|  |  |
 2 --+--+--+--+--+--+--
     |  |  |  |  |  |
...--+--+--+--+--+--+--
@end example

@item Text (x, y, foregroundindex, backgroundindex, textstring)
Display a text string starting from (x, y) with color @samp{foregroundindex}
and background @samp{backgroundindex}. If backgroundindex == -1, the text is
drawn transparently. To determint text width and height you can use the
@code{TextWidth (textstring)} and @code{TextHeight ()} functions. There is a
number of built-in CSWS fonts, they can be used by calling
@code{SetFont (cs_Font_XXXX)}. Note that both @code{TextWidth()} and
@code{TextHeight()} depends on current font.

@item Sprite2D (sprite2d, x, y, w, h)
(you can ommit w,h to use normal sprite size). Draw a 2D sprite or bitmap.
@samp{sprite2d} is a object of @code{csPixmap} class. Sprite can have
transparent colors, this way you can define @code{holes} in textures.

@item Rect3D (xmin, ymin, xmax, ymax, darkindex, lightindex)
Draw a 3D-looking rectangle. This method just draws four lines to form a
non-filled rectangle. Example: Rect3D (0, 0, 4, 4);
@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--#--#--#--+--+--
     |LL|LL|LL|DD|  |
 1 --#--+--+--#--+--+--
     |LL|  |  |DD|  |
 2 --#--+--+--#--+--+--
     |LL|  |  |DD|  |
 3 --#--#--#--#--+--+--
     |LL|DD|DD|DD|  |
 4 --+--+--+--+--+--+--
     |  |  |  |  |  |
@end example

@item ObliqueRect3D (xmin, ymin, xmax, ymax, cornersize, darkindex, lightindex)
Draw a rectangle with oblique corners of given size. Example:
@code{ObliqueRect3D (0, 0, 10, 7, 3)}.
@example
     0  1  2  3  4  5  6  7  8  9 ...
     |  |  |  |  |  |  |  |  |  |  |
 0 --+--+--#--#--#--#--#--#--#--#--+--
     |  |  |LL|LL|LL|LL|LL|LL|LL|DD|
 1 --+--#--+--+--+--+--+--+--+--#--+--
     |  |LL|  |  |  |  |  |  |  |DD|
 2 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 3 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 4 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 5 --#--+--+--+--+--+--+--+--#--+--+--
     |LL|  |  |  |  |  |  |  |DD|  |
 6 --#--#--#--#--#--#--#--#--+--+--+--
     |LL|DD|DD|DD|DD|DD|DD|DD|  |  |
...--+--+--+--+--+--+--+--+--+--+--+--
@end example

@item SetClipRect (xmin, ymin, xmax, ymax)
Define a local clipping rectangle for subsequent drawing operations. For
example, when drawing a button you may want to set clipping rectangle after
drawing button borders so that button text accidentally won't draw over its
borders even if it does not fit. To disable clipping you can define a empty
rectangle (@code{SetClipRect (0, 0, 0, 0)});
@end table

@item csComponent::HandleEvent (csEvent &Event)
This is the main component's entry point for handling windowing system
events. Each time user presses a key, moves mouse etc windowing system
generates a event and sends it to appropiate component. The normal event flow
is top-down, i.e. the root window receives events first, then passes them if
appropiate to its childs which passes it to their respective childs and so
on. However, there are some basical constraints on event flow that you should
know about:

@itemize @bullet
@item
HandleEvent should return a boolean value that states whenever this object
used the event or not. If the event has been used, no other component will
receive it anymore, otherwise windowing system looks for other appropiate
candidates for this event. The only exception from this rule are broadcast
events that are sent to all childs independently of the fact that component
@samp{eaten} event or not.

@item
Mouse events are received only by the topmost component mouse pointer is over
and its parents. If other behaviour is desired, a component should capture
the mouse by calling @code{app->CaptureMouse (this)} - in this case mouse
events are sent by application object directly to the object that captured
the mouse, bypassing normal event flow. To revert to normal mode of operation
component should call @code{app->CaptureMouse (NULL)}.

@item
Keyboard events are sent only to components from @samp{focus chain}.
@xref{CSWS Focus Chain}. If a different behaviour is desired, component
should capture keyboard events by calling @code{app->CaptureKeyboard (this)}.
To disable capturing keyboard events component should call
@code{app->CaptureKeyboard (NULL)}.

@item
Command events are not sent to child windows. A reply to command event is
normally expected from the component it has been sent to, not from any of its
childs. Moreover, re-sending command events to childs can be dangerous since
the event can be sent by one of its childs, and the application can get
caught in an endless loop. Re-sending command events to parents is a normal
practice, for example all menus re-send command events to their parents since
commands are usually sent to menus by their childs (menu items or even
sub-menus).

@item
Broadcast events are the only type of events that are guaranteed to reach
every object in a subtree of components.
@end itemize

There is another method called
@code{csComponent::PreHandleEvent (csEvent &Event)} which is much like
@code{HandleEvent} except that it is called for each event pulled from event
queue before @code{HandleEvent}, and without rules above, i.e. any component
can preprocess any hardware-generated event before it is sent along normal
event handling chain. This can be used for popup menus, hot keys and so on.
If @code{PreHandleEvent} returns true, the event is considered @samp{eaten}
and is discarded. Be careful with this feature to avoid interfering with
normal component functions.

And last method related to event processing is
@code{csComponent::PostHandleEvent (csEvent &Event)}. It is called when no
component handled the event and it is called for all components in
@code{parent->children} order. It can be used to process events that nobody
wants, for example it is used to process hotkeys on buttons (if active
component is for example, a input line, and user presses @key{A} key it
should be entered into input text, while if active component is a non
text-hungry component (for example, a listbox) the @key{A} key can be used by
some button to activate itself).

@item Data csComponent fields
@code{csComponent} class has a number of data fields. The most important is
@table @code

@item csRect bound;
which defines the physical bounds of the component. All drawing operations
happens inside and are clipped to this bound. Component does not have control
over any other pixel outside this bound. The bounds are defined relative to
parent's origin. For example, if we have a component with bounds
@code{(xmin = 20, ymin = 10, xmax = 100, ymax = 50)} and it has a
child @code{(10, 10, 30, 40)} then its real (physical) pixel coordinates are
@code{(20+10, 10+10, 20+30, 10+40)}. A child is always clipped to the bounds
of all its parents (however, there is a exception from this rule).

@item int state;
Contains the state flags of the component. There are two types of state flags
(although @sc{csws} does not make a difference between them) - dynamic flags
and option flags. Option flags usually define some static aspect of component
- for example, whenever component is selectable (i.e. if it can become the
focused element), or it is partially transparent (see irregularily-shaped
components) etc. Dynamic flags often changes during component's life, for
example component visibility flag, @samp{component focused} flag and so on.
The component state flags starts with the @code{CSS_} prefix.

You should never change manually state flags. Instead, there are two methods
for this: @code{SetState (mask, state)} and @code{GetState (mask)}. For
example, if component is not selectable and you want to make it selectable,
call @code{component.SetState (CSS_SELECTABLE, true)}. The SetState method is
virtual and is often overriden to execute some specific functions when
component state changes. For example, default @code{SetState} handler shows
or hides the component if @code{CSS_VISIBLE} flag state changes.

@item csRect dirty;
Contains the @samp{dirty} rectangle. If it is non-empty, the dirty area of
component is redrawn just before the end-of-frame.

@item int DragStyle;
Contains a combination of bits (@code{CS_DRAG_XXX}) that defines which sides
of component can be dragged with mouse when you call first the
@code{csComponent::Drag method}. By default it is equal to @code{CS_DRAG_ALL}.
Note that if component won't call @code{csComponent::Drag} you won't be able
to resize the component even if DragStyle will be equal to @code{CS_DRAG_ALL}.

@item csApp *app;
This is the @samp{main} application object, the root of entire window tree.
It is a descendant of @code{csApp} class which is a superclass of
@code{csComponent}. @code{csApp} has some application-global methods such as
@code{CaptureMouse}, @code{CaptureKeyboard}, it contains the global mouse
pointer object and many other.

@item csComponent *parent;
Contains the parent component. Components are chained into a tree, each
component knows its neightbours (through @samp{next} and @samp{prev} fields),
each parent knows its focused child, and can traverse its list of childs by
starting from focused, then going to @code{focused->next} and so on.

@item csComponent *prev, *next;
Contains the next and previous neightbours in parent's child list. They are
never NULL, chains are always closed. If a component is the only child of
another, its next and prev fields points to himself.

@anchor{CSWS Focus Chain}
@item csComponent *focused;
This is the focused child component. For example, keyboard events are sent
only to components in @samp{focused} chain, i.e. to @code{app},
@code{app->focused}, @code{app->focused->focused} and so on. If component
does not have any child components, focused is NULL. This is the only
possible case when @code{focused} can be NULL.

@item csComponent *top;
This is the top component in Z-order. Mouse events are processed in Z-order
unlike keyboard events. The focused event is not neccessarily the top
component, although usually this is true. If component has
@samp{CSS_TOPSELECT} flag set, when user activates (focuses) a component, it
is made the topmost, however if it has this flag reset, its Z-order does not
change.

@item int id;
This is component's identifier. This is a user-definable value, but it is
expected to be unique within all childs of a parent component. You can search
for child components with given ID by calling
@code{parent->GetChild(int find_id)}.
@end table

@node CSWS Events
@subsection Events
There are several event types (other event types can be defined as needed,
but existing set covers all current CSWS needs). There is the base event
class called csEvent. It has several public data fields, the mostly used is
Type which contains the event type. There are following currently defined
event types:

@table @code
@item csevNothing
@samp{Empty} event, mostly used internally by CSWS.

@item csevKeyDown
Key has been pressed event.

@item csevKeyUp
Key has been released event. On @code{KeyUp} and @code{KeyDown} events the
following data fields in event object are also valid:
@table @code
@item Key.Code
Contains code of key that has been pressed or released. It can be a literal
value (@samp{A}, @samp{z}, @samp{ }) or one of predefined @code{CSKEY_XXX}
values (@code{CSKEY_UP}, @code{CSKEY_ESC}, @code{CSKEY_SPACE},
@code{CSKEY_ENTER} etc).

@item Key.ShiftKeys
Contains the state of shift keys at time when this event has been generated.
Note that it not neccessarily is the same as current key state. To decode its
value you should use the pre-defined @code{CSMASK_XXX} constants, for example:
@example
if (Event.Key.ShiftKeys == CSMASK_ALT)
@{
  ... ALT + Event.Key.Code pressed ...
@}
@end example
or:
@example
if (Event.Key.ShiftKeys & CSMASK_ALT)
@{
  ... (<I>at least</I> ALT) + Event.Key.Code pressed ...
@}
@end example

Also there is a bit in @code{ShiftKeys} called @code{CSMASK_FIRST} that is
set only when key is pressed for first time. With this you can separate
actual key presses from autorepeated keyboard events.
@end table

@item csevMouseMove
@samp{Mouse has been moved} event.

@item csevMouseDown
@samp{A mouse button has been pressed} event.

@item csevMouseUp
@samp{A mouse button has been released} event. On all mouse events the
following data fields in event object are also valid:
@table @code
@item Mouse.x, Mouse.y
The screen position where mouse event happened. Mouse position is always
converted to component coordinate system, i.t.
@code{Mouse.x == 0 && Mouse.y == 0} means that mouse is at component top-left
system.

@item Button
Mouse button number, counting from 1. Not valid for @samp{mouse moved} event.

@item Key.ShiftKeys
Contains the state of shift keys at time when this event has been generated.
See above for comments on shift keys.
@end table

@item csevCommand
A command event. Command events are generated by windowing system components,
not by hardware. For example, when a button is pressed, it sends a command
event with some command code to its parent component. There is only one data
field for this type of events called @code{Info} of type @samp{void *}. It
can point to any event-related information.

@item csevBroadcast
Broadcast events are much like command events, except that no component can
intercept (@samp{eat}) it, and they are feed to all child, grandchild etc
components in a component tree (starting from the component that received
first this event).
@end itemize

To check if the event is generated by keyboard, you can use the predefined
@code{IS_KEYBOARD_EVENT(Event)} macro. To check for mouse events, you can use
the @code{IS_MOUSE_EVENT(Event)} macro.

@node CSWS Clipping
@subsection Clipping

Clipping is the process of removing parts of output covered by other
components. @sc{CSWS} has full clipping implemented for all existing graphics
primitives. There is no drawing operation that can influence other component's
image (except transparent windows). @xref{CSWS Transparent}. Clipping is
performed in the following way: First primitive is clipped against
@samp{dirty} rectangle (to cut off excessive output), then it is clipped
against all its neightbours, then against @samp{clip parent} window and all
its neightbours and so on.

@node CSWS Clip Parents
@subsubsection Clip Parents

All components have a @samp{parent} component and a @samp{clipparent}
component. What they are used for? Usually @samp{clipparent} is equal to
@samp{parent} so there is no difference between them. But in some rare cases
there is a need to perform clipping in a different way. For example, popup
menus that belong to a window usually should not be clipped against that
window, but rather to the parent of parent window or even clipped only to
desktop. In this case you should assign a different clip parent to that
component. This can be performed by using @code{InsertClipChild()} method.
For example, to make a menu clip to application's bounds, you should call
@example
app->InsertClipChild (menu);
@end example
You should not assign directly to @samp{clipparent} variable since
@code{InsertClipChild} does many extra work, for example it inserts the
so-called @samp{clip child} into component's clip child list, removes
component from former clipparent's @samp{clip child} list and so on.

@node CSWS Transparent
@subsubsection Partially transparent components

You can set a state flag called @code{CSS_TRANSPARENT} to mark
semi-transparent components. Transparent components works differently in the
following ways:
@itemize @bullet
@item
When a part of such a component is invalidated, the same area of parent
component is invalidated as well.

@item
Mouse events for such components are considered @samp{eaten} only if
component's @code{HandleEvent} method returned TRUE. Otherwise, the event is
sent to the component placed one level below the transparent area.

@item
Parent's window output is not clipped against transparent childs. Instead of
this, child's area covered by output is invalidated.
@end itemize

@node CSWS Tutorial
@subsection Quick Tutorial

In the following I will try to explain how to build simple applications using
Crystal Space Windowing System. I hope you will understand enough to start
writing your own applications; I also hope you will get a deeper knowledge of
@sc{csws} during your development (or lab) sessions.

@node CSWS Simple
@subsubsection A simple application

The simplest possible application should do the following:
@itemize @bullet
@item
Create an application object (@code{csApp})

@item
Run the application (run the main event processing loop)

@item
Finish the application (delete the object)
@end itemize

Let's try:
@example
#include "csws/csws.h"

int main (int argc, char* argv[])
@{
  csApp app ("CSWS test application", argc, argv);

  if (app.InitialSetup ())
    app.Loop ();
@}
@end example

Pretty simple, eh? So the result is as well :-) We got a gray background, a
mouse and nothing more. What the program does:

@itemize @bullet
@item
First, it creates a @code{csApp} object called @samp{app}. To initialize the
application you pass three parameters: the window title (for system that
support a window title) and argument vector passed to @code{main()} so that
Crystal Space low-level layer can eat such arguments as @samp{-mode},
@samp{-depth} and so on.

@item
The next step is to call @code{InitialSetup()} method. The @code{csApp}'s
@code{InitialSetup()} method does nothing except returning true, but you
probably will want to override it to initialize your application there.
Create a popup menu, insert it into the desktop, add some windows, read
configuration files etc.

@item
And finally we run the main application loop. The event consuming loop does
the following: while there are events in input queue: read an event, pass it
to HandleEvent method. If there weren't any events in the loop, call
@code{Idle()} method to give some time slices to other running applications
(if @code{csSystemDriver::Sleep()} method is implemented properly). If some
window needs redrawing, it is redrawn. After this the screen is updated and
everything starts again from the beginning.

@item
If you observe, our above program does not delete the @code{csApp} object.
That's because it is a automatic variable and not a pointer, so its
automatically deleted when program finishes. If you would use a pointer, you
should explicitely delete the app pointer with @code{delete} command.
@end itemize

