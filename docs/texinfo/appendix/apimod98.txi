@c -*-texinfo-*-
@node Release Notes 98, Release Notes 96, Release Notes, Release Notes
@appendixsec Release Notes from 0.96 to 0.98
@cindex Release Notes

This section documents the major changes between versions 0.96 and 0.98 of of
Crystal Space.

@subheading Polygon Texture Mapping Changes
@cindex @code{iPolygon3D}
@cindex @code{iPolyTexNone}
@cindex @code{iPolyTexGouraud}
@cindex @code{iPolyTexFlat}
@cindex @code{iPolyTexLightMap}
@cindex shading

The following interfaces have been removed: @samp{iPolyTexNone},
@samp{iPolyTexGouraud}, @samp{iPolyTexFlat}, and  @samp{iPolyTexLightMap}.
The combined @sc{api} from @samp{iPolyTexNone} and the @samp{iPolyTexLightMap}
have moved to @samp{iPolygon3D} itself.

@code{iPolygon3D::SetTextureType()} and @code{GetTextureType()} have been
removed.  Instead use:

@itemize @bullet
@item
@code{iPolygon3D::EnableTextureMapping()}
@item
@code{iPolygon3D::IsTextureMappingEnabled()}
@end itemize

@code{iPolygon3D::GetPolyTexType()} has been removed.

The @samp{<shading>} keyword in polygons in map files now accepts a boolean
value instead of @samp{NONE}, @samp{FLAT}, @samp{GOURAUD}, or @samp{LIGHTMAP}.
With this you can enable/disable lightmapping.

If you want gouraud shaded polygons you should use the @file{genmesh}
mesh object plugin instead.

@subheading Bezier Curve Changes
@cindex Bezier Curve Changes
@cindex @code{iCurveTemplate}
@cindex @code{iCurve}
@cindex @code{iBezierState}
@cindex @code{iBezierFactoryState}

The notion of curve templates has been reworked. @samp{iCurveTemplate} has
been removed and it's functionality has moved to @samp{iCurve} itself.
As a consequence of this change the bezier addon loader has been removed.
Also curves have been seperated from the thing plugin and now live in the
@file{bezier} plugin. So, a curve like this in the past:

@example
<addon>
  <plugin>crystalspace.mesh.loader.thing.bezier</plugin>
  <params>
    <name>b1</name>
    <material>mosaic</material>
    <v>0</v> <v>1</v> <v>2</v>
    <v>3</v> <v>4</v> <v>5</v>
    <v>6</v> <v>7</v> <v>8</v>
  </params>
</addon>
<meshfact name="tunnel">
  <plugin>crystalspace.mesh.loader.factory.thing</plugin>
  <params>
    <curvecenter x="0" y="0" z="0" />
    <curvescale>80</curvescale>
    <curvecontrol x="5" y="2" z="0" u="1" v="0" />
    @dots{}
    <curve name="bez">b1</curve>
  </params>
</meshfact>
@end example

@noindent
should now become (note the new plugin line):

@example
<meshfact name="tunnel">
  <plugin>crystalspace.mesh.loader.factory.bezier</plugin>
  <params>
    <curvecenter x="0" y="0" z="0" />
    <curvescale>80</curvescale>
    <curvecontrol x="5" y="2" z="0" u="1" v="0" />
    @dots{}
    <curve name="b1">
      <material>mosaic</material>
      <v>0</v> <v>1</v> <v>2</v>
      <v>3</v> <v>4</v> <v>5</v>
      <v>6</v> <v>7</v> <v>8</v>
    </curve>
  </params>
</meshfact>
@end example

On the @sc{api} side nothing much changes except that when you use
the bezier mesh plugin you need to use @samp{iBezierState} and
@samp{iBezierFactoryState}.

The @samp{iThingEnvironment} no longer has code to maintain bezier curve
templates.

@subheading iThingState and iPolygon3D Changes
@cindex @code{iThingState}
@cindex @code{iThingFactoryState}
@cindex @code{iPolygon3D}
@cindex @code{iObject}
@cindex @code{iMeshObject}
@cindex @code{iMeshObjectFactory}

The interfaces @samp{iPolygon3D} and @samp{iThingState} no longer inherit from
@samp{iObject}, thus the @code{QueryObject()} function has been removed.
Polygons can still have names though.  Added @code{SetName()} and
@code{GetName()} for that.

@samp{iPolygon3D} has been split into @samp{iPolygon3D} and
@samp{iPolygon3DStatic}. The static version contains all static data that
can be put in a factory. Several functions like
@code{iThingState::CreatePolygon()} will now return @samp{iPolygon3DStatic}.

@samp{iThingState} has been split into @samp{iThingState} and
@samp{iThingFactoryState}. A thing mesh no longer implements both a mesh
object and a mesh object factory. Instead things now work like usual
mesh objects where @code{iMeshObjectType::NewFactory()} creates a
factory that implements @samp{iThingFactoryState} and
@code{iMeshObjectFactory::NewInstance()} creates an instance that implements
@samp{iThingState}. The engine convenience functions to create a thing
mesh will automatically create both the factory and mesh so you don't
have to worry about that. You can use @code{iThingState::GetFactory()}
from a thing mesh object to get the @samp{iThingFactoryState} so you can
build the polygons. Note that @code{SCF_QUERY_INTERFACE()} of
@samp{iThingFactoryState} no longer works on a thing mesh object. You must
use @code{GetFactory()}.

@subheading Polygon Planes
@cindex @code{iPolyTxtPlane}
@cindex @code{iThingEnvironment}

Polygon planes are removed. So it is no longer possible to use
the plane addon loader to define texture mapping for a polygon outside
of the polygon itself. To fix this you must specify all texture mapping
information in the @samp{texmap} statement of the polygon. @file{map2cs}
now correctly outputs polygons like this (no longer outputs planes) and
@file{levtool} can convert old style maps to new format like this:

@example
levtool -planes yourmap.zip
@end example

@samp{iThingEnvironment} no longer has code to maintain polygon texture
mapping planes.

The plane loader and saver addons have been removed from the thing
loader plugin.

Removed @samp{iPolyTxtPlane} interface. Added
@code{iPolygon3DStatic::GetTextureSpace()} function to get texture space
definition for polygon.

@subheading Portal Changes
@cindex @code{iPortal}

Several methods in @samp{iPortal} have changed slightly. For example,
@code{SetMirror()} now expects a plane instead of a polygon.

@subheading Datatype Changes

The @samp{csSome}, @samp{csConstSome} and @samp{uint} types have been removed.
Use @samp{void*}, @samp{const void*} and @samp{unsigned int} instead.

@subheading csHashMap Changes
@cindex @code{csHashMap}
@cindex @code{csHashIterator}
@cindex @code{csGlobalHashIterator}

@samp{csHashIterator} can no longer iterate over all objects. To do that
you need to use @samp{csGlobalHashIterator}.

@subheading Procedural Textures

Instead of only built-in types, procedural textures have been moved into 
plugins. That means that the @samp{<type>} token now works the same way
as the @samp{<plugin>} token for meshes. That is, either specify a full
class ID (e.g. @samp{crystalspace.proctex.loader.fire}), or a shortcut
specified in the @samp{<plugins>} token of the world. To simulate the
old @samp{<type>} behaviour, paste the following lines into a map's 
@samp{<plugin>} section:

@example
<plugin name="dots">crystalspace.texture.loader.dots</plugin>
<plugin name="fire">crystalspace.texture.loader.fire</plugin>
<plugin name="water">crystalspace.texture.loader.water</plugin>
<plugin name="plasma">crystalspace.texture.loader.plasma</plugin>
@end example

This requires that you move the @samp{<plugin>} block in front of the 
@samp{<textures>} block, as otherwise the shortcuts won't be recognised.

The behaviour of procedural textures also differs as a material of the same
name was created along with the texture; this isn't the case any more, you
have to create a material which uses the procedural texture manually.

In addition, the loader now doesn't distinguish between normal and procedural
textures any more, both are loaded with the same @samp{<texture>} block. The 
syntax recognized is a combination of both old @samp{<texture>} and 
@samp{<proctex>} tokens---so renaming all @samp{<proctex>} to @samp{<texture>}
tags is sufficient to convert a level (apart from fixing the @samp{<type>}
tokens.)

@subheading Regions
@cindex @code{iRegion}
@cindex @code{iEngine}
@cindex @code{iLoader}

Region handling has changed considerably. The engine no longer has the
concept of a current region. The engine still manages all regions though.
Objects also no longer register themselves to the current region. It is
the responsability of the object creator to do that. The standard loader
has support for adding objects to a region now.

The following functions have been removed from @samp{iEngine}:

@itemize
@item
@code{SelectRegion()}
@item
@code{GetCurrentRegion()}
@item
@code{AddToCurrentRegion()}
@end itemize

There is one new function @code{iEngine::CreateRegion()} which will create
a new region.

In @samp{iLoader} the functions @code{LoadMapFile()} and
@code{ThreadedLoadMapFile()} now expect an optional pointer to a region
in addition with a boolean to restrict searching to that region.

In addition to all these changes the @samp{<region>} keyword in map files is no
longer supported.

@subheading Mesh Objects/Factories and iPolygonMesh

Some mesh factories used to support the querying of the @samp{iPolygonMesh}
interface (e.g. Thing, Sprite3D, Genmesh). Due to the way this was 
implemented internally this caused leaks. So, querying @samp{iPolygonMesh} 
directly from the object is now discouraged. Although it may still work in 
some cases, this feature may be dropped without further notice and may not 
work in all cases. 

Similar for mesh objects. Querying @samp{iPolygonMesh} is discouraged here,
as well.

Instead, if you want the polygon mesh from an object, use the
@code{GetObjectModel()} method from the @samp{iMeshObject} interface;
respectively query for the @samp{iObjectModel} interface in case of a factory,
and utilize one of the @code{GetPolygonMeshXXX()} methods, depending on what
you need (the old interface query returned the collision detection mesh.) This
has also the advantages that you can get different meshes for different
purposes (currently, visibility culling and collision detection in addition the
the base mesh), and that those meshes can be overridden by user-defined meshes
(e.g. if the collision detection mesh needs to have a shape different from the
visible mesh.)

In @samp{iPolygonMesh} the @code{IsDeformable()} method has been replaced
with the more general @code{GetFlags()}. In addition to that @code{Cleanup()}
is removed and instead @code{Lock()} and @code{Unlock()} are added.

@samp{iPolygonMesh} now has @code{GetTriangles()} and @code{GetTriangleCount()}.
Check out the @sc{api} docs for implementation details.

@subheading Iterator Changes
@cindex @code{iVisibilityObjectIterator}
@cindex @code{iLightIterator}
@cindex @code{iSectorIterator}
@cindex @code{iObjectIterator}
@cindex @code{iObjectRegistryIterator}
@cindex @code{iStreamIterator}
@cindex @code{csTypedObjectIterator}
@cindex @code{csModelDataActionIterator}
@cindex @code{csModelDataPolygonIterator}
@cindex @code{csModelDataTextureIterator}
@cindex @code{csModelDataMaterialIterator}
@cindex @code{csModelDataObjectIterator}
@cindex @code{csNodeIterator}

Changed the following iterators to conform to the following iterator standard:

@example
bool iterator->HasNext() // returns true if there are more items.
T* iterator->Next()      // returns next element or 0.
void Reset()             // resets iterator (not all implement this).
@end example

@itemize
@item
@code{iVisibilityObjectIterator}
@item
@code{iLightIterator}
@item
@code{iSectorIterator}
@item
@code{iObjectIterator}
@item
@code{iStreamIterator}
@item
@code{iObjectRegistryIterator}
@item
@code{csTypedObjectIterator}
@item
@code{csModelDataActionIterator}
@item
@code{csModelDataPolygonIterator}
@item
@code{csModelDataTextureIterator}
@item
@code{csModelDataMaterialIterator}
@item
@code{csModelDataObjectIterator}
@item
@code{csNodeIterator}
@end itemize

@subheading @sc{aws} Changes

@code{iAWS::CreateCustomCanvas()} was removed.  To set up the @sc{aws} with a
cavas, use @code{iAWS::SetupCanvas()} instead. 

@subheading csPArray Removed
@cindex @code{csPArray}
@cindex @code{csArray}

@samp{csPArray} has been removed in favor of the @code{csArray<>} template.
So, use @code{csArray<T*>} instead of @code{csPArray<T>}.

@subheading csStrVector and iStrVector Removed
@cindex @code{csStrVector}
@cindex @code{iStrVector}
@cindex @code{csStringArray}
@cindex @code{iStringArray}
@cindex @code{FindFiles}
@cindex @code{MountRoot}

@samp{csStrVector} has been removed in favor of @samp{csStringArray}.
This means that functions like @code{iVFS::MountRoot()} and
@code{iVFS::FindFiles()} now return an @samp{iStringArray}.

@subheading csVector and csBasicVector Removed
@cindex @code{csVector}
@cindex @code{csBasicVector}
@cindex @code{csArray}
@cindex @code{csRefArray}
@cindex @code{csPDelArray}

@samp{csVector} and @samp{csBasicVector} have been removed. Instead you
should use one of the templated arrays: @code{csArray<>}, @code{csPDelArray<>},
or @code{csRefArray<>}.

If you were using a regular @samp{csVector} then this can usually be
replaced directly by @code{csArray<type*>} with @samp{type} the type you
were storing in the vector.

If you subclassed from @samp{csVector} in order to override @code{FreeItem()}
then you have to decide what to do depending on the code in @code{FreeItem()}.
If that code performed a @samp{delete} then you can use @code{csPDelArray<>}.
If that code performed a @code{DecRef()} then you can use @code{csRefArray<>}
but you still have to be careful because @code{csRefArray<>} will automatically
incref objects that are pushed on the array. In other cases you probably
need to handle deletion manually.

@samp{csVector} also allowed to override @code{Compare()} and
@code{CompareKey()} in order to drive @code{QuickSort()},
@code{FindSortedKey()}, @code{InsertSorted()}, and @code{FindKey()}.  This is
no longer possible.  Instead you can do the following transformation.  First
the old code:

@example
class MyVector : public csVector
@{
public:
  virtual ~MyVector ()
  @{
    DeleteAll ();
  @}
  virtual void FreeItem (void* item)
  @{
    delete (MyType*)item;
  @}
  virtual int Compare (void* i1, void* i2, int mode) const
  @{
    @dots{}
  @}
  virtual int CompareKey (void* i, const void* key, int mode) const
  @{
    @dots{}
  @}
@};
@end example

This could be transformed roughly to the following class:

@example
class MyVector : public csPDelArray<MyType>
@{
public:
  static int Compare (MyType const* i1, MyType const* i2)
  @{
    @dots{}
  @}
  static int CompareKey (MyType const* i, void* key)
  @{
    @dots{}
  @}
@};
@end example

In the calls to @code{InsertSorted()}, @code{FindKey()}, etc., you would then
pass in one of the static functions to use.

@subheading Array Changes
@cindex @code{csArray}
@cindex @code{csPDelArray}
@cindex @code{csRefArray}
@cindex @code{csStringArray}
@cindex @code{csGrowingArray}
@cindex @code{csDirtyAccessArray}

All arrays have been modified to inherit from @samp{csArray}. This means
that there are some slight @sc{api} changes because some methods were
not consistent with @samp{csArray}.

@samp{csGrowingArray} has been renamed to @samp{csDirtyAccessArray} in order to
better reflect its intention, which is that it publishes a method allowing the
client to obtain access to the raw memory block containing the items in
contiguous memory.  This potentially unsafe operation is not available in the
other array templates.  Use this class only in very special-purpose cases where
you need to construct a list of objects dynamically and then pass the address
of the raw memory containing those objects to some foreign function which does
not understand @code{csArray<>}.

@subheading Hash and Set Templates
@cindex @code{csHash}
@cindex @code{csSet}

The new template classes @code{csHash<>} and @code{csSet<>} are available for
use by new code; and older code will be upgraded over time to use these
template classes.  The older @samp{csHashMap} and @samp{csHashSet} classes are
now deprecated.

@subheading iEventQueue Client References
@cindex @code{csEventQueue}
@cindex @code{iEventQueue}
@cindex @code{csEvent}
@cindex @code{iEvent}
@cindex @code{csPoolEvent}
@cindex @code{csEventOutlet}
@cindex @code{iEventOutlet}
@cindex @code{csEventCord}
@cindex @code{iEventCord}

Posting an @samp{iEvent} via @code{iEventQueue::Post()} or
@code{iEventOutlet::Post()} must now @code{DecRef()} the @samp{iEvent} after
the posting the event, since @code{iEventQueue} will @code{IncRef()} the event
for itself (that is, it will claim its own reference, rather than inheriting
the reference from the caller as it did in the past).  As with all reference
counting, rather than manually invoking @code{DecRef()}, the client is
encouraged to utilize @code{csRef<>} to automate reference count management, as
illustrated below.  This means that if you are calling @code{Post()} like this:

@example
iEvent* e = new csEvent (foo, bar);
eventq->Post(e);
@end example

You should now call it like this:

@example
csRef<iEvent> e = csPtr<iEvent>(new csEvent (foo, bar));
eventq->Post(e);
@end example

Events created with @code{iEventQueue::CreateEvent()} or
@code{iEventOutlet::CreateEvent()} are unaffected by this change since the
client was already responsible for managing the event's reference count in
these cases.

@subheading New Renderer-Related Changes

The mesh object @sc{api} has changed considerably, thus we recommend looking
at the documentation on that to see how to modify your own mesh object for
the new @sc{api}.  In this section we describe @sc{api} modifications that
are relevant for user applications.

For @samp{iLight}: @code{SetRadius()}, @code{GetRadius()}, and
@code{GetSquaredRadius()} have been replaced with @code{SetInfluenceRadius()},
@code{GetInfluenceRadius()}, and @code{GetInfluenceRadiusSq()}.

For @samp{iMaterialEngine} and related: @code{GetTextureWrapper()} for
layers now expects a @samp{csStringID} instead of an integer.

@subheading @sc{scf} Changes
@cindex @sc{scf}
@cindex meta-information
@cindex plugins
@cindex @file{.csplugin} files

@noindent
@emph{Written by Eric Sunshine, @email{sunshine@@sunshineco.com}.}

The monolithic and inflexible plugin-registry database, @file{scf.cfg}, has
been eliminated.  Instead, plugin modules are now self-describing via a
meta-information resource associated with each module.  More importantly, it is
possible to access this meta-information without actually loading the plugin,
thus avoiding a time-consuming and costly operation.

A plugin's meta-information is now stored in an @sc{xml}-format file rather
than being hard-coded via the plugin's C++ code.  The meta-information file is
named after the associated plugin module, except with filename extension
@file{.csplugin}.  For instance, the meta-information for the @file{vfs.so} (or
@file{vfs.dll}) plugin will be named @file{vfs.csplugin}.

Since the meta-information is now maintained via an external resource, the
following @sc{scf} macros, which were used to export this information from the
C++ code, have been removed:

@itemize @bullet
@item
@code{SCF_EXPORT_CLASS_TABLE()}
@item
@code{SCF_EXPORT_CLASS()}
@item
@code{SCF_EXPORT_CLASS_DEP()}
@item
@code{SCF_EXPORT_CLASS_TABLE_END}
@end itemize

To deal with this change in your own code, simply remove the entire
@code{SCF_EXPORT_CLASS_TABLE()} block from the C++ code which implements the
plugin module.

Creation of the meta-information resource file involves a straight-forward
translation of the information from the obsolete @sc{scf} macros into a
structured @sc{xml}-format file.  For example:

@example
SCF_EXPORT_CLASS_TABLE(foo)
  SCF_EXPORT_CLASS(
    MyClass1,
    "myproj.myplugin.foo1",
    "My first custom foo class")
  SCF_EXPORT_CLASS_DEP(
    MyClass2,
    "myproj.myplugin.foo2",
    "My second custom foo class",
    "myproj.myplugin.bar1,myproj.myplugin.bar2")
SCF_EXPORT_CLASS_TABLE_END
@end example

This table exports two C++ classes, @samp{MyClass1} and @samp{MyClass2} under
the @sc{scf} class names @samp{myproj.myplugin.foo1} and
@samp{myproj.myplugin.foo2}, respectively.  Furthermore, the second exported
class has a dependency upon two other @sc{scf} classes,
@samp{myproj.myplugin.bar1} and @samp{myproj.myplugin.bar2}.  To convert
this to an @sc{xml}-format meta-information resource, just copy the above
values into the appropriate @sc{xml} nodes.  For instance:

@example
<?xml version="1.0"?>
<!-- myplugin.csplugin -->
<plugin>
  <scf>
    <classes>
      <class>
        <name>myproj.myplugin.foo1</name>
        <implementation>MyClass1</implementation>
        <description>My first custom foo class</description>
      </class>
      <class>
        <name>myproj.myplugin.foo2</name>
        <implementation>MyClass2</implementation>
        <description>My second custom foo class</description>
        <requires>
          <class>myproj.myplugin.bar1</class>
          <class>myproj.myplugin.bar2</class>
        </requires>
      </class>
    </classes>
  </scf>
</plugin>
@end example

The top-level node of a meta-information file is named @code{<plugin>}.  All
@sc{scf}-related information is contained within an @code{<scf>} child node.
Plugin modules can export multiple named @sc{scf} classes.  Each exported class
is represented by a @code{<class>} node within the @code{<classes>} group.  The
@code{<name>} node of a @code{<class>} is the class' @sc{scf} name.  The
@code{<implementation>} node references the C++ class which actually implements
the named @sc{scf} class.  This is the same name that is privided as an
argument to the @code{SCF_IMPLEMENT_FACTORY()} macro.  When an @sc{scf} class
depends upon other @sc{scf} classes, the dependencies are indicated via the
optional @code{<requires>} group, which contains one @code{<class>} node per
dependency.

Meta-information in the @file{.csplugin} file is extensible; it is not
restricted to @sc{scf}-only usage.  Plugin authors can choose to publish
supplementary information about plugins in addition to the @sc{scf} information
already published.  As a hypothetical example, image loading plugins might
desire to publish @dfn{image indentification} information which would allow the
image loading multiplexor to selectively request image loading plugins
@emph{on-demand}, rather than requesting all plugins unconditionally, even if
they are not needed.  Here is a possible meta-information table for a @sc{png}
image loader (with the @code{<scf>} node collapsed to @samp{@dots{}} for the
sake of illustration):

@example
<?xml version="1.0"?>
<!-- cspngimg.csplugin -->
<plugin>
  <scf>...</scf>
  <imageloader>
    <imagetype>
      <class>crystalspace.graphic.image.io.png</class>
      <identify>
        <mimetype>image/png</mimetype>
        <extension>png</extension>
        <extension>PNG</extension>
        <scan length="4" bytes="\0x89PNG"/>
     </identify>
    </imagetype>
  </imageloader>
</plugin>
@end example

In this example, the @sc{png} loader meta-information tells the multiplexor
several different ways to identify a @sc{png} image:

@itemize @bullet
@item
By checking @sc{mime} type, if available.
@item
By checking file extension, if available.
@item
By checking for the @dfn{magic} identification string @samp{\0x89PNG} in the
raw image data.
@end itemize

@noindent
If the multiplexor identifies the image as @sc{png}, only then will it actually
request the @sc{png} loader plugin.

At program launch time, @sc{scf} discovers plugins automatically by searching a
set of directories, and creates an internal database associating available
@sc{scf} class names with the plugin modules which implement them.  The
directories which @sc{scf} searches by default are:

@itemize @bullet
@item
The application resource directory as returned by @code{csGetResourceDir()}.
On most platforms, this is the same as the directory containing the
application, however, on MacOS/X, it is the @file{Resources} directory within
the Cocoa application wrapper.

@item
The directory containing the application (or containing the Cocoa application
wrapper for MacOS/X) as returned by @code{csGetAppDir()}.

@item
The installed Crystal Space resource directories as returned by
@code{csGetConfigPath()}.  This is often the value of the @samp{CRYSTAL}
environment variable, or the @samp{CrystalSpaceRoot} default setting on MacOS/X
(which is often stored within the @samp{NSGlobalDomain} domain).
@end itemize

If you would like @sc{scf} to scan additional directories, you can invoke
either of these two functions (multiple times, if necessary):

@itemize @bullet
@item
@code{scfInitialize(csPluginPaths const*)}
@item
@code{iSCF::ScanPluginsPath(char const*, bool, char const*)}
@end itemize

Finally, if you need to manually register a single plugin module with @sc{scf}
for which you know the native pathname (not a @sc{vfs} pathname), you can
invoke @code{iSCF::RegisterPlugin()}.

For those relatively rare cases when a @emph{named} @sc{scf} class is built
directly into an application, rather than being implemented via a plugin, the
class must be registered with @sc{scf} manually since @sc{scf} will not
otherwise be able to discover it automatically as is the case with named
classes exported from plugin modules.  Manual registration is accomplished with
the @code{SCF_REGISTER_STATIC_CLASS()} macro.  This macro existed previously,
but accepted a different set of arguments.  The new arguments are:

@example
SCF_REGISTER_STATIC_CLASS(
  C++Class,
  "scf.class.name",
  "description",
  "comma-separated dependency list" or NULL)
@end example

@noindent
Invoke this macro in one of the source files of your application; usually in
the source file which implements the class.  For instance:

@example
SCF_REGISTER_STATIC_CLASS(
  MyClass2,
  "myproj.myplugin.foo2",
  "My second custom foo class",
  "myproj.myplugin.bar1,myproj.myplugin.bar2")
@end example

If you used to use @code{SCF_REGISTER_STATIC_LIBRARY()} or
@code{SCF_REGISTER_STATIC_CLASS_DEP()} for this same purpose, you must now
instead use @code{SCF_REGISTER_STATIC_CLASS()}.  (A macro named
@code{SCF_REGISTER_STATIC_LIBRARY()} still exists, but it has a completely
different purpose than the original version, and is typically only used by very
low-level mechanisms, rather than by end-users.  See
@file{CS/include/csutil/scf.h} for the gory details, if you are curious.)

The Crystal Space @file{configure} script option
@samp{--enable-meta-info-embedding} controls whether or not the build system
embeds the plugin meta-information into plugin modules (if supported by the
platform), and whether or not the plugin loader looks for embedded
meta-information.  If this option is disabled, or if embedding is not supported
by the platform, then the meta-information is laid down alongside the built
plugin module (@file{.so} or @file{.dll}) in a text file with the same name as
the plugin module, except with extension @file{.csplugin}.  The
meta-information embedding option is enabled, by default.

The platform-specific plugin loaders are capable of reading embedded plugin
meta-information, as well as meta-information in stand-alone @file{.csplugin}
files.  Even when configured for embedding, the plugin loaders will still be
able to recognize and utilize external @file{.csplugin} resources.  This means
that Crystal Space-based projects with unsophisticated build systems, which are
incapable of embedding meta-information into the plugin module, can still
create usable plugins by simply placing a copy of the @file{.csplugin} file
alongside the plugin executable (@file{.so} or @file{.dll}).

External projects which are based upon Crystal Space's Jam build system
(@file{CS/mk/jam}) inherit, for free, the capability of embedding
meta-information within plugin modules (if supported by the platform).  Simply
grab the newer @file{.jam} files from @file{CS/mk/jam}, and add a few
definitions to the project's @file{Jamconfig} file.  The exact set of
definitions is platform-specific, so consult the appropriate Jam file
(@file{unix.jam}, @file{win32.jam}, or @file{macosx.jam}) to determine
precisely which which definitions are required.  Here is a list of definitions
required at the time of writing:

@table @asis
@item Unix
@code{EMBED_META = yes}@*
@code{LIBBFD.AVAILABLE = yes}@*
@code{OBJCOPY.AVAILABLE = yes}@*
@code{CMD.OBJCOPY = objcopy}

@item Windows
@code{EMBED_META = yes}

@item MacOS/X (not yet supported)
@code{EMBED_META = yes}
@end table

The @file{scfreg} tool whose job was to manipulate the monolithic @sc{scf}
plugin-registry database, @file{scf.cfg}, has been eliminated since it is no
longer required.

The @code{SCF_CREATE_INSTANCE()} macro now returns @code{csPtr<>}, for
consistency with the other @sc{scf} instantiation and query macros.  This means
that you should now assign the result of @code{SCF_CREATE_INSTANCE()} to a
@code{csRef<>}.

@subheading csSys Library Removed

The @file{cssys} library has been merged into the @file{csutil} library.  This
eliminates many problems resulting from the large number of circular
dependencies which existed between these two libraries.  From the client
viewpoint, this manifests merely as the removal of the static link library
@file{libcssys.a} (Unix) or @file{cssys.lib} (Windows).  To account for this
change, simply eliminate the reference to this library from your build scripts,
makefiles, or project files.

@subheading csString and iString Changes

The @code{csString::strlwr()} method was renamed to @code{Downcase()}.  A
complementary @code{Upcase()} method was added for completeness.  These methods
were also added to @samp{iString}.  Added a @code{Slice()} method to
@samp{iString} and @samp{csString} which copies a sub-portion of a string.
Several @samp{iString} methods which were incorrectly returning raw
@samp{iString*} or @samp{iString&} now correctly return @code{csRef<iString>}.

@subheading csMD5 Changes

A @code{csMD5(csString const&)} constructor was added to complement the
existing @code{csMD5{char const*)} constructor.  The new method
@code{csMD5::Digest:HexString()} returns a hexadecimal string representation of
the @sc{md5} digest using lowercase hexadecimal characters.
@code{csMD5::Digest::HEXString()} returns uppercase hexadecimal characters.
