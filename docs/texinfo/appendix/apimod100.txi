@c -*-texinfo-*-
@node Release Notes 100, Release Notes 98, Release Notes, Release Notes
@appendixsec Release Notes from 0.98 to 1.00
@cindex Release Notes

This section documents the major changes between versions 0.98 and 1.00 of
Crystal Space.

@subheading @code{csArray<>} Index and Size Type Change

@code{csArray<>} has been changed to use the @code{size_t} instead of
@samp{int} for array sizes and indices.  Probably, the most significant
semantic difference of this change is that @samp{size_t} is @emph{unsigned} as
opposed to @samp{int} which is @emph{signed}.

@strong{Read this paragraph carefully.} In actual code, this change may result
in nothing more than simple-looking compiler warnings. However, it may have
caused @emph{semantics} to change subtly.

This has the greatest impact in the following areas:

@subsubheading Iterating Over @code{csArray<>} Contents

For this purpose, usually, @samp{int} typed variables were used for keeping
track of the index of the current item of an array iteration.  Fixing forward
iteration over a @code{csArray<>} to instead use @samp{size_t} is simple:

@example
csArray<@dots{}> someArray;
for (int i = 0, n = someArray.Length(); i < n; i++)
@{
  @dots{}
@}
@end example

@noindent
Is changed to:

@example
@dots{}
for (size_t i = 0, n = someArray.Length(); i < n; i++)
@dots{}
@end example

Backward iteration is a bit more problematic. As mentioned before, 
@samp{size_t} is unsigned, so you do not have negative values. This can be a
problem in constructs like:

@example
csArray<@dots{}> someArray;
for (int i = someArray.Length() - 1; i >= 0; i--)
@{
  @dots{}
@}
@end example

If the @samp{int} is changed simply to a @samp{size_t}, this 
@code{for}-loop misbehaves unexpectedly. When @samp{i} becomes 0, the body 
of the loop is executed correctly. However, decrementing @samp{i} will 
@strong{not} cause @samp{i} to have a negative value---after all, @samp{size_t}
is unsigned. Instead, decreasing will make @samp{i} wrap around from 0 to
something like 0xffffffff (on 32-bit machines). Clearly, this is greater
than 0, effectively causing an infinite loop. The same thing also happens when
@samp{someArray} has no items (i.e. @samp{someArray.Length() == 0}). Here the
-1 in the initialization of @samp{i} causes wrap-around.

Possible solutions include:

@itemize @bullet
@item
Use an @code{int}-typed counter variable and cast the array length to
@samp{int}.  This is not entirely elegant, but it does the job in most cases.

@item
Re-write the loop to deal properly with the unsigned nature of @samp{size_t}:

@example
csArray<@dots{}> someArray;
for (size_t i = someArray.Length(); i-- > 0;)
@{
  @dots{}
@}
@end example

This code does the same as the @samp{int} version above, iterating from 
@samp{someArray.Length() - 1} to 0, inclusively. It also correctly works
in the case @samp{someArray.Length() == 0}. The ``trick'' is to place the 
modification of @samp{i} as a post-decrement in the loop condition. This 
way, as soon as @samp{i} becomes 0, the loop is terminated. The 
post-decrement ensures that @samp{i} has the expected value in the loop body.

@end itemize

@subsubheading Searching

Functions like @code{csArray<>::FindSortedKey()} and @code{csArray<>::Find()}
used to return -1 to signify that an item was not found.  This is still the
case, but with a twist.  Now, @samp{(size_t)-1} is returned.  For convenience,
a constant, @samp{csArrayItemNotFound}, has been added, which has this exact
value.  It can be used in comparions to make it clear what is actually being
checked.

Apropros comparisons: Recall that @samp{size_t} is @emph{unsigned}, so checking
whether an index returned by @samp{FindSortedKey()} or @samp{Find()} is 
actually a valid index by testing with @samp{>= 0} no longer works since
@samp{(size_t)-1} is always @code{>= 0}. Replace such checks with tests of
equality against @samp{csArrayItemNotFound}:

@example
csArray<@dots{}> someArray;
int index = someArray.Find (@dots{});
if (i >= 0)
@{
  /* Item found */
  @dots{}
@}
else
@{
  /* Item not found */
  @dots{}
@}
@end example

Has to be replaced with:

@example
csArray<@dots{}> someArray;
size_t index = someArray.Find (@dots{});
if (i != csArrayItemNotFound)
@{
  /* Item found */
  @dots{}
@}
else
@{
  /* Item not found */
  @dots{}
@}
@end example
