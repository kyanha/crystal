@c -*-texinfo-*-
@node ApiMods17, History, Todo, Top
@appendix Convert From One CS Release to Another
@cindex Converting API
@cindex @code{API}

@emph{Node}: This document tries to help developers do the transition from
one version of CS to another. At this moment CS is still beta so we don't
have a frozen API. Even after releasing 1.0 API changes will sometimes
be unavoidable (but we will try to minimize them). This document should
give you a head start trying to convert your application from one
version of CS to the next. Only the major changes are covered here.
If you have trouble with something that isn't discussed here you should
mail the Crystal Space mailing list and ask for help.

This version explains how to go from 0.16 to 0.17.

@heading NextFrame Prototype (elapsed_time/current_time)
@cindex NextFrame
@cindex elapsed time
@cindex current time

@code{csSystemDriver::NextFrame} no longer has the @code{elapsed_time}
and @code{current_time} parameters. So you have to change the prototype of
your own subclassed version of @code{NextFrame} and call the following
three lines in the order below (only if you need the elapsed and current
time of course):

@example
void ...::NextFrame ()
@{
  SysSystemDriver::NextFrame ();
  cs_time elapsed_time, current_time;
  GetElapsedTime (elapsed_time, current_time);
  ...
@end example

@heading HandleEvent Prototype (csEvent -> iEvent)
@cindex HandleEvent
@cindex csEvent
@cindex iEvent

The prototype of @code{csSystemDriver::HandleEvent} has changed
from a @code{csEvent} parameter to a @code{iEvent} parameter. Update your
subclassed versions if you have any.

@heading Materials versus Textures
@cindex materials
@cindex textures

CS 0.17 supports materials in the sense that the API is ready for it.
There is no real material support though. A material currently just
corresponds with a texture. Here are a few short remarks about the
changes that happened:

@itemize @bullet
@item
csTextureHandle renamed to csTextureWrapper.
@item
New csMaterialWrapper.
@item
SetTexture/GetTexture renamed to SetMaterial/GetMaterial in many places.
@item
SetTextureHandle/GetTextureHandle renamed to SetMaterialWrapper/GetMaterialWrapper.
@end itemize

In general in most places where you used to use @code{SetTexture} or @code{GetTexture}
you now need to use the material versions. There are few places where you
handle directly with textures as the material system sits on top of that
and is what you should use.

@code{csWorld} also has a @code{GetMaterials} function which you probably should
use wherever you used @code{GetTextures} in the past.

In the loader you can find a new function @code{csLoader::FindMaterial(char*)}
which will find a material with the given name. If not found it tries
to find a texture with this name and will then create a default material
from that texture.

The @code{csLoader::LoadTexture} routine is a bit special. As before it
loads a texture (and returns a @code{csTextureWrapper}) but it also adds
a material with the same name to the material list. You can then fetch
that material from that list. So something like this:

@example
csLoader::LoadTexture (world, "myTexture", "/lib/std/stone4.gif");
csMaterialWrapper* m = world->GetMaterials ()->FindByName ("myTexture");
@end example

@heading Collision Detection Plugin
@cindex collision detection
@cindex RAPID

This is a very significant change. The RAPID collision detection system
has been removed completely from the engine and is now available through
a plugin. This change will most likely cause the most complicated changes
to your code.

The first thing you need to add to your application is code to load
the plugin. You can do this with the following code:

@example
const char* p = Config->GetStr ("YourGame", "COLLDET_PLUGIN",
	"crystalspace.colldet.rapid");
collide_system = LOAD_PLUGIN (this, p, "CollDet", iCollideSystem);
if (!collide_system)
@{
  Printf (MSG_FATAL_ERROR, "No Collision Detection plugin found!\n");
  return false;
@}
@end example

This code loads the rapid collision detection plugin by default (which
is the only one we have now) but it also reads an entry from your config
file so that the user can possibly change it. If you don't want that
then you can just hardcode the @code{p} pointer to the RAPID plugin.

Note that you need to remember @code{collide_system} somewhere where
it can be accessed by the routines that need to do the collision
detection.

Then the class @code{csRAPIDCollider} has been removed from csengine.
Instead there is @code{csCollider}. This class encapsulates an @code{iCollider}
(which is something that is returned from the @code{collide_system}).
This is the easiest way to use the new collision detection system as it
more closely resembles what was possible with @code{csRAPIDCollider}.
To make a csCollider you can use the following code:

@example
iPolygonMesh* mesh = QUERY_INTERFACE (object, iPolygonMesh);
csCollider* collider = new csCollider (*object, collide_system, mesh);
@end example

@code{object} can be a sector, sprite, thing, or your own object that
supports the @code{iPolygonMesh} interface. The new collider will be
attached (through the @code{csObject} system) to the object. This is similar
to what happened with the old @code{csRAPIDCollider} class.

To do collision detection you need to find the colliders (or have
them stored somewhere) and then you can do:

@example
bool rc = collide_system->Collide (col1->GetCollider (), trans1,
	col2->GetCollider (), trans2);
@end example

or:

@example
bool rc = col1->Collide (*object2, trans1, trans2);
@end example

With @code{col1} and @code{col2} are the colliders (@code{csCollider})
and object2 is the second object. @code{trans1} and @code{trans2} are
the respective transformations.

Note that before you call this you probably want to initialize the
collision system like this:

@example
collide_system->ResetCollisionPairs ();
collide_system->SetOneHitOnly (true/false);
@end example

The argument for the second function depends on wether or not you
are interested in receiving more than one hit.

Note that @code{ResetCollisionPairs} is important. Every call
to @code{Collide} will add additional collision pairs to this array.
So you have to reset it if you are no longer interested in that.

Note that @code{csRAPIDCollider::Report} is gone. If you want that
functionality you have to do it on your own (which is not difficult).

@heading Texture Mapping Changes
@cindex texture mapping

Changed the way engine defines and uses texturing. There are
four polygon texturing types now: @code{POLYTXT_NONE} (no texturing,
useful when using materials without textures -- it defines no
texturing parameters at all thus saves memory), @code{POLYTXT_FLAT}
(flat-shading, only the angle between light and polygon
normal is considered if @code{CS_POLY_LIGHTING} flag is set, and
entire polygon is painted with one lighting value; every
vertex has an U/V pair associated), @code{POLYTXT_GOURAUD} (every
polygon vertex has a color and those colors are interpolated
across scanlines) and finally @code{POLYTXT_LIGHTMAP} (a polygon
which has an associated lightmap and a texture plane). Now
it is possible to define and use objects which have flat-color
but still receive light with Gouraud as well as without
Gouraud interpolation; in general this open a whole new area
for experimenting.

In practice this means that @code{csGouraudShaded} has gone and is
now replaced with @code{csPolyTexGouraud}. @code{csLightMapped} has also
gone and is replaced with @code{csPolyTexLightMap}.

@heading Sound Changes
@cindex sound

Merged sound buffers into sound sources. We now have 3d and non-3d sound
sources; non-3d sources are the former sound buffers. As a parameter of
@samp{Renderer->CreateSource} you can tell whether you want a 3d or non-3d
source.

The sound loader is now a plugin and must be loaded as such. It uses the
@code{iSoundLoader} interface. A loaded sound data block is represented by
@code{iSoundData}.

If you use standard CS libraries to load sounds, this is all. Otherwise you
should also know how to load a sound without @code{csParser}:

To load a sound the sound loader now needs some information describing the
format of the sound. This information can be queried from the sound renderer.
Also, a sound can be optionally be loaded as @samp{stream}. This is currently
not useful for anything, but will instead affect performance and memory in a
negative way. It is intended as a future option to load background music.
All member functions of iSoundData are intended for private use (of course
you may use them, but I don't think they are useful).
To load a sound, you have to:
@itemize @bullet
@item
Load the file buffer from the @code{vfs}.

@item
Ask the sound renderer for the format descriptor (@code{csSoundFormat}
struct).

@item
Pass both the file data and the format to the sound loader, using
@samp{false} for streaming (default). After that, you may delete the file
data.
@end itemize

@heading Thing and sprite changes (csMovable)
@cindex thing
@cindex sprite
@cindex csMovable

The movement system of things and sprites has been merged
into one class called @code{csMovable}. So all functions like
@code{SetPosition}, @code{SetTransform}, and so on have been removed
from @code{csThing} and @code{csSprite}. Instead there is a
function @code{GetMovable()} (both for things and sprites) which returns
the @code{csMovable} for that object. And there is also a new function
called @code{csMovable::UpdateMove()} (which resembles the original
@code{csThing::Transform()} somewhat) which you MUST call after updating
the position and/or transformation of the movable which belongs to the
object.

In addition to the changes related to @code{csMovable} the linked list of
sky and thing objects in a sector has also been replaced by a @code{csVector}
and things are now also kept in a global list in the @code{csWorld} just
like sprites. This means that sprites and things look a lot more like
each other now with regards to movement and placement in sectors.
This means that functions like @code{AddThing}, @code{GetNumThings},
@code{RemoveThing} and @code{GetFirstThing} are gone now (similar for the
sky versions). Instead you should work through the new public @code{skies}
and @code{things} vectors. In addition to this the @code{GetNext} and @code
{GetParent} functions have been removed from @code{csPolygonSet}.

Here is some old code to operate on things:

@example
sector->AddThing (thing);
thing->SetPosition (csVector3 (0,0,3));
thing->SetTransform (csMatrix3 ());
thing->Transform ();
...
sector->RemoveThing (thing);
delete thing;
@end example

then this will now become:

@example
thing->GetMovable ().SetSector (sector);
thing->GetMovable ().SetPosition (csVector3 (0,0,3));
thing->GetMovable ().SetTransform (csMatrix3 ());
thing->GetMovable ().UpdateMove ();
...
world->RemoveThing (thing);
@end example

or even:

@example
csMovable& move = thing->GetMovable ();
move.SetSector (sector);
move.SetPosition (csVector3 (0,0,3));
move.SetTransform (csMatrix3 ());
move.UpdateMove ();
...
world->RemoveThing (thing);
@end example

The old behaviour for sprites:

@example
sprite->MoveToSector (sector);
sprite->SetPosition (csVector3 (0,0,3));
sprite->SetTransform (csMatrix3 ());
@end example

becomes (note the new @code{UpdateMove}):

@example
csMovable& move = sprite->GetMovable ();
move.SetSector (sector);
move.SetPosition (csVector3 (0,0,3));
move.SetTransform (csMatrix3 ());
move.UpdateMove ();
@end example

