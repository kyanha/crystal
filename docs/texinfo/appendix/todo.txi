@c -*-texinfo-*-
@node Todo, ApiMods17, FAQ, Top
@appendix To-Do List

This file describes some of the missing features and shortcomings of Crystal
Space which we would like to address in the future.  The ultimate goal is to
empty this list entirely.  Note that some of the desired features in this list
are currently being implemented by some developers.  Always coordinate with
people on the mailing list first before beginning one of these tasks yourself.
@xref{Mailing Lists}.

@itemize @bullet
@item
Optimizing lighting.  Using the convex outline of objects we can still do some
optimizations.

@item
Maybe implement shadows for sprites and things using a simpler outline
version?  (For sprites we can use @sc{lod}).

@item
We also need to update the lighting on the polygons of a thing when the
thing moves. It is easy to find all dynamic lights that hit a thing at the
current location but then you also have to find all dynamic lights that hit
a thing at the new location. One way to optimize this is to keep a list of
all lights that affect a sector. For a more detailed explanation of this,

@item
As explained in the previous item we should maintain a list of static and
dynamic lights in every sector.  This not only contains all the lights of that
sector but also lights of nearby sectors which are visible from the sector.

@item
Better @sc{lod} function for sprites.  The current one doesn't preserve the
shape well enough.

@item
Generalize the engine so that it can use general gouraud shaded polygons
instead of only triangles. The 3D rasterizers can already do this.

@item
Implement halo visilibity checking in the engine instead of using the
Z-buffer.

@item
To handle portals on Things correctly, we need to Z-fill the portal polygon
after drawing (and use Z-sort or @sc{statbsp} for the portals).

@item
Continue with support for multi-sector sprites.  We need a way to quickly
update the list of sectors that every sprite is in.  Also we need to clip the
sprite (rough clip) to the portal.

@item
Consider support for multi-sector things as well.

@item
Convert the few remaining classes to @code{csClassName} name convention.

@item
Create more user documentation. Update FAQ. More tutorials.

@item
Rewrite @emph{bots} and missile using the real collision detection system.

@item
Optimize the collision detection system.

@item
Fully implement or approximate 2*@sc{src}*@sc{dst} in hardware (with gamma or
something else).

@item
Continue integration of landscape engine (@sc{ddg}) with Crystal Space.  Also
integrate dynamic sky support which is also in the @sc{ddg} engine from Alex
Pfaffe.

@item
Scripting: Make @sc{scf} interfaces for the engine.

@item
Scripting: interface with existing language, such as Python, Java, and Scheme.

@item
Option to make dynamic library for all Crystal Space libraries (which are
distinguished from plug-in modules).

@item
Curved surfaces on sector walls.

@item
Curved surfaces in sprites. There are two possiblities.  We could merge them
statically and just use the curves as a triangle generator or we could have
real @sc{lod} curves. I think the first approach is best because sprites have
@sc{lod} on their own.

@item
More types of curves. Nurbs are one example. Wavelets are another. But also
simple curves should be considered because they will be more efficient and
also very useful. One good example is simple circle shaped curves. Those
are great for archways.

@item
Implement a @samp{make install} in the makefile system.

@item
Try to use the @sc{nasm} assembler code in the Windows Visual C++ port as
well.

@item
Better world loader with support for plug-ins (to allow apps to insert game
specific data in a world file).

@item
Special effects (bumpmapping, explosions, smoke, @dots{})

@item
More configuration parameters for objects (like lightmap size for detail of
shadows).

@item
Allow flags and configuration values for objects to be set from within the
world file.

@item
Gravity configuration value for WalkTest.

@item
Automatic portal generation (used in MazeD or Crystal Space itself).

@item
Fix cleanup problems in engine.

@item
Better error handling and checking for invalid data in the engine. Maybe
make a level validator.

@item
Hierarchical objects.

@item
@sc{lod} on things.  Maybe user specified.

@item
Spotlight support.

@item
Continue cleaning up the language, the @sc{api}, and the interface to create
the world.

@item
We may want to implement animated textures.  There is a problem with lighting
though.  There are (at least) three options:

@itemize @bullet
@item
Remove the texture from the texture cache and reapply the lightmaps every time
another animation frame of the texture is choosen.  This is time-expensive but
it is an option if the texture does not change that often (for example, a
switch that can be turned on/off) or is not very large.

@item
Just ignore lighting (or only uniform lighting) on those polygons.  This is of
course easy to do and it is an option for those surfaces that don't really
need lighting (like lava surfaces).

@item
Let the texture cache perform lighting on a seperate light-texture.  This
extra light-texture is then overlayed at runtime with the animated texture.
This option is very good for rapidly animating textures but it slows down the
renderer a bit when the textures is currently not being animated.
@end itemize

All three methods are useful and can be used on other occasions, so maybe we
should try to implement them all.

@item
Portals can now affect the light color that passes through it. it would be
nice if this could also be done based on individual texel values on the
portal polygon. That way a light shining through an alpha-mapped portal
would shine on the wall with the colors of the texture on the portal.

@item
Allow animated space-warping portals.  Using these one could for example
create a train where the inside of the train is rendered as usual while the
windows are portals to a large sector or even the polygonal terrain renderer.
Every portal (window) would have a space warping matrix so that the moving of
the train (or other vehicule) can be simulated by changing that
transformation.  This would be a really cool effect.

@item
Support for 24-bit display-mode.  (32-bit is already supported.)

@item
Delay real transformation of sprites until they are visible (with a dirty
bit or something).

@item
Transform the planes of polygons only once if they are shared.

@item
Optimization with cross product as suggested by Segher Boessenkool:
@code{(a1 b2 - a2 b1)} becomes
@code{(a1 - b1) (a2 + b2) - (a1 a2) + (b1 b2)}.
@code{(a1 a2)} and @code{(b1 b2)} can be precomputed. This mainly affects
@code{which_side_2d} and maybe some other optimizations.

@item
There is no need for backface culling inside the current sector (where the
@code{::draw()} starts) provided that the sector doesn't use a @sc{bsp}.

@item
We could consider doing backface culling in world space (before
transforming to camera space). So we don't need to transform a polygon if
it is not needed. But we have to consider that the vertices of a whole
sector are transformed first. In that case we would need to postpone this
transformation of vertices and maybe use an array to indicate which
vertices have already been transformed.

@item
Allow multiple textures on a polygon (overlaying textures) which are
automatically merged by the texture cacher.

@item
Use a different lightmap size for a polygon. This is useful for very large
polygons for which shadow accuracy is not of utmost importance and also for
very small polygons where you would like to have more accurate shadows.
Default lightmap size is 16. Currently this does not need to be a power of
2 but I would not use anything else because future optimizations could
depend on this.

@item
Combine lightmaps in one texture for hardware renderers.

@item
Joystick/mouse support.

@item
Make a 3D map mode display a bit like the one in Descent.
@end itemize
