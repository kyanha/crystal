@c -*-texinfo-*-
@cindex Converting old particle systems

This section documents how to convert the various particle systems
to the new particle system in Crystal Space.

@menu
* Api100 PartConv Explo:: Explosion
* Api100 PartConv Rain:: Rain
@end menu

@node Api100 PartConv Explo, Api100 PartConv Rain, Api100 Particle system changes, Api100 Particle system changes
@subsubsection Explosion

To convert the old explosion particle system to new particles you
can use a sphere emitter with a very small radius and with particle
placement in center. Set a very small duration and a high emission rate
so that all particles will appear to be created at once. Using
a linear color effector you can obtain the fading of the particles (use
either alpha mixmode or add depending no the kind of fading you want).
Here is an example of how the old explosion can be emulated using
the new particle system (in code): Note that this is not an attempt to
make a realistic or even nice looking explosion. It is just an attempt
to emulate the ugly old explosion particle system from the past:

@example
  // Create the factory.
  csRef<iMeshFactoryWrapper> mfw = engine->CreateMeshFactory (
	"crystalspace.mesh.object.particles", "explosion");
  if (!mfw) return;

  // Create the mesh and setup material, mixmode, and color.
  csRef<iMeshWrapper> exp = engine->CreateMeshWrapper (mfw, "boing",
	sector, center));
  exp->SetZBufMode(CS_ZBUF_TEST);
  exp->SetRenderPriority (engine->GetAlphaRenderPriority ());
  exp->GetMeshObject()->SetMaterialWrapper (mat);
  exp->GetMeshObject()->SetMixMode (CS_FX_ALPHA);
  exp->GetMeshObject()->SetColor (csColor (1, 1, 0));

  // Find/load the built-in emitter factory. From this factory we
  // can access some of the standard built-in emitters.
  csRef<iParticleBuiltinEmitterFactory> emit_factory = 
      csLoadPluginCheck<iParticleBuiltinEmitterFactory> (
        object_reg, "crystalspace.mesh.object.particles.emitter", false);
  // Find/load the built-in effector factory. From this factory we
  // can access some of the standard built-in effectors.
  csRef<iParticleBuiltinEffectorFactory> eff_factory = 
      csLoadPluginCheck<iParticleBuiltinEffectorFactory> (
        object_reg, "crystalspace.mesh.object.particles.effector", false);

  // Create a sphere emitter where we will have a quick burst of
  // all the particles from the center.
  csRef<iParticleBuiltinEmitterSphere> sphereemit = emit_factory->
    CreateSphere ();
  sphereemit->SetRadius (0.1);
  sphereemit->SetParticlePlacement (CS_PARTICLE_BUILTIN_CENTER);
  sphereemit->SetPosition (csVector3 (0, 0, 0));
  sphereemit->SetInitialVelocity (csVector3 (1, 0, 0), csVector3 (3, 3, 3));
  sphereemit->SetUniformVelocity (false);
  sphereemit->SetDuration (0.1f);
  sphereemit->SetEmissionRate (1000.0f);
  sphereemit->SetInitialTTL (1.0f, 1.0f);

  // Create a lincolor effector to fade out the particles.
  csRef<iParticleBuiltinEffectorLinColor> lincol = eff_factory->
    CreateLinColor ();
  lincol->AddColor (csColor4 (1,1,1,1), 1.0f);
  lincol->AddColor (csColor4 (1,1,1,0), 0.0f);

  // Setup the real particle system and add the emitter and effector
  // we created above.
  csRef<iParticleSystem> partstate =
  	scfQueryInterface<iParticleSystem> (exp->GetMeshObject ());
  partstate->SetParticleSize (csVector2 (0.15f, 0.15f));
  partstate->SetRotationMode (CS_PARTICLE_ROTATE_VERTICES);
  partstate->SetIntegrationMode (CS_PARTICLE_INTEGRATE_BOTH);
  partstate->AddEmitter (sphereemit);
  partstate->AddEffector (lincol);

  // Make sure that the particle mesh and factories are removed
  // when all particles are gone (approx 1 second).
  Sys->Engine->DelayedRemoveObject (1100, exp);
  Sys->Engine->DelayedRemoveObject (1101, mfw);
@end example

@node Api100 PartConv Rain, , Api100 PartConv Explo, Api100 Particle system changes
@subsubsection Rain

To convert the old rain particle system to new particles you
can use a box emitter which is oriented at the top where the rain drops
should appear and which is very thin. Here you see an example of a rain
particle system in the world file:

@example
  <meshfact name="rainFact">
    <plugin>crystalspace.mesh.loader.factory.particles</plugin>
    <params>
      <particlesize x="0.02" y="0.37" />
      <minbb>
        <min x="-10" y="0" z="-5" />
        <max x="5" y="6" z="10" />
      </minbb>
      <sortmode>none</sortmode>
      <renderorientation>common</renderorientation>
      <commondirection x="0" y="1" z="0" />
      <emitter type="box">
        <emissionrate>250</emissionrate>
        <mass min="5" max="7.5" />
        <box>
          <min x="-10" y="6" z="-5" />
          <max x="5" y="6" z="10" />
        </box>
        <uniformvelocity />
        <initialvelocity x="0" y="-2.84" z="0" />
        <initialttl min="2.5" max="2.5" />
        <placement>volume</placement>
      </emitter>
      <effector type="lincolor">
        <color red="0" green="0" blue="1" time="2.5" />
      </effector>
    </params>
  </meshfact>
  @dots{}
  <meshobj name="rainfall">
    <priority>alpha</priority>
    <plugin>crystalspace.mesh.loader.particles</plugin>
    <ztest />
    <params>
      <factory>rainFact</factory>
      <mixmode> <add /> </mixmode>
      <material>raindrop</material>
    </params>
    <move>
      <v x="-10" y="0" z="10" />
    </move>
  </meshobj>
@end example

Here is how this could work in code:

@example
  csRef<iMeshFactoryWrapper> mfw = engine->CreateMeshFactory (
      "crystalspace.mesh.object.particles", "rain");
  if (!mfw) return;

  csRef<iMeshWrapper> exp = engine->CreateMeshWrapper (mfw, "custom rain",
	sector, csVector3 (0, 0, 0));

  exp->SetZBufMode(CS_ZBUF_TEST);
  exp->GetMeshObject()->SetMixMode (CS_FX_ADD);
  exp->GetMeshObject()->SetMaterialWrapper (mat);

  csRef<iParticleBuiltinEmitterFactory> emit_factory = 
      csLoadPluginCheck<iParticleBuiltinEmitterFactory> (
        Sys->object_reg, "crystalspace.mesh.object.particles.emitter", false);
  csRef<iParticleBuiltinEffectorFactory> eff_factory = 
      csLoadPluginCheck<iParticleBuiltinEffectorFactory> (
        Sys->object_reg, "crystalspace.mesh.object.particles.effector", false);

  csRef<iParticleBuiltinEmitterBox> boxemit = emit_factory->CreateBox ();
  boxemit->SetBox (bbox);
  boxemit->SetParticlePlacement (CS_PARTICLE_BUILTIN_VOLUME);
  boxemit->SetEmissionRate (num / 2.5f);
  boxemit->SetInitialMass (5.0f, 7.5f);
  boxemit->SetUniformVelocity (true);
  boxemit->SetInitialTTL (2.5f, 2.5f);
  boxemit->SetInitialVelocity (csVector3 (0, -2.84f, 0), csVector3 (0));

  csRef<iParticleBuiltinEffectorLinColor> lincol = eff_factory->
    CreateLinColor ();
  lincol->AddColor (csColor4 (.25,.25,.25,1), 2.5f);

  csRef<iParticleSystem> partstate =
  	scfQueryInterface<iParticleSystem> (exp->GetMeshObject ());
  partstate->SetMinBoundingBox (bbox);
  partstate->SetParticleSize (csVector2 (0.3f/50.0f, 0.3f));
  partstate->SetParticleRenderOrientation (CS_PARTICLE_ORIENT_COMMON);
  partstate->SetCommonDirection (csVector3 (0, 1, 0));
  partstate->AddEmitter (boxemit);
  partstate->AddEffector (lincol);
@end example

