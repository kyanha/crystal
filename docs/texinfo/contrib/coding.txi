@c -*-texinfo-*-
@node Coding Style, CVS Guide, Writing Documentation, Contributing
@section Coding Style

For consistency and ease of future maintenance, when working on Crystal Space
source code, please follow these guidelines.

@enumerate
@item
@emph{Indentation}

Indent with two (2) spaces. If you use tabs then they must be interpreted as
eight (8) spaces. This means that you should not use the tab character for
indentation since that would indent by eight characters rather than two. Also
consider avoiding tabs altogether in order to eliminate tab-related problems.
Here is an example of proper indentation:

@example
void foo()
@{
  int a;
  for (a = 0; a < 10; a++)
  @{
    int b = bar();
    if (a < b)
      printf("Hello\n");
  @}
@}
@end example

This example also illustrates how to place curly braces and where to add
spaces, for example @samp{for_(} rather than @samp{for(_}, where @samp{_}
represents whitespace in this context.  Also add sufficient whitespace between
tokens.

@item
@emph{Class and Method Naming}

Classes should be named in this fashion: @code{csThisIsAClass}. The name
starts with lower-case @samp{cs} and has every word capitalized.

Methods and functions should be named in this fashion: @code{ThisIsAMethod}.
Each word in the name is capitalized.

@item
@emph{Doc++ and Comments}

Use Doc++ comments in header files to document classes, methods, and
functions. These comments are extracted with the Doc++ tool and @sc{html}
documentation is generated from them.

@strong{Warning}: Always use Doc++ comments for a class. If you fail to do so
then Doc++ will ignore comments for methods within the class itself.

A one line Doc++ comment uses three slashes (@samp{///}) rather than two as is
typical for normal C++ comments.  Multi-line Doc++ comments are specified with
@samp{/** ...  */} rather than @samp{/* ...  */}.  Here is an example:

@example
/**
 * This class represents a blue ball.
 * Blue balls bounce higher than red balls.
 */
class csBlueBall
@{
private:
  // A private function, so no Doc++ comment here,
  // but still commented for readers of the header file.
  void PrivateFunction();

public:
  /// This is the constructor. Initializes the blue ball.
  csBlueBall();

  /**
   * This is a multi-line comment.
   * And this is the second line of the multi-line comment.
   */
  void Deflate();
@};
@end example

@item
@emph{Maximum Line Length}

In general, lines in source code should be no longer than 78 characters.  This
facilitates generation of hard-copy and works better with certain tools which
process code or text files.

@item
@emph{Multiple-Inclusion Protection for Headers}

Be certain to insert multiple-inclusion protection in all header files. These
controls should take this form:

@example
#ifndef __CS_FILENAME_H__
#define __CS_FILENAME_H__
@dots{}
#endif // __CS_FILENAME_H__
@end example

@item
@emph{@sc{scf} Interfaces}

@sc{scf} interfaces always start with a lower @samp{i}, as in
@code{iThisIsAnInterface}.

@item
@emph{Module and Library Dependencies}

Do not introduce unnecessary dependencies between libaries and modules.
Absolutely avoid introducing circular dependencies.

For instance, code in the @code{csGeom} library should never refer to code
from the @code{csEngine} library.  The other way around is okay, however,
since @code{csEngine} is at a higher level within the dependency hierarchy.

@item
@emph{Include @file{cssysdef.h}}

Always include @file{cssysdef.h} in each source file as the very first file
included.  @emph{Never} include @file{cssysdef.h} in header files.

@item
@emph{Avoid Global Objects With Constructors in Plug-In Modules}

Avoid placing global objects which require automatic construction in
dynamically loaded libraries. Some platforms fail to call the object's
constructor at the time the library is loaded. Therefore it is unsafe to rely
on such objects.

@item
@emph{Endian-ness}

Beware of code that is endian specific.  Key off of the @code{CS_BIG_ENDIAN}
or @code{CS_LITTLE_ENDIAN} macros if necessary.  Avoid unions of bit-sets
since they can result in endian-related problems. Avoid casting an
@code{int*} to a @code{short*} or a @code{char*}, or casting a @code{short*}
to a @code{char*}.

Also reading/writing binary files and sending binary messages over the
network is endian-prone. The best thing to do here is to use the @code{htons}
and @code{htonl} macros. They convert the host byte format to the network
byte format. You can also convert back from the network format to the host
format with @code{ntohs} and @code{ntohl}.

@item
@emph{Data Alignment}

Some platforms require data to be aligned in memory. The processor cannot
access a @code{long} on an odd memory address for instance. The program will
crash on this instruction. Thus you should make sure to always access
properly aligned data. The compiler already ensures the proper alignment, but
you can have problems after pointer arithmatic. This is a problem on the
Macintosh and NeXT platforms. Together with this problem you are probably
also having endian problems. Beware of code which tries to access values of
primitive types at memory locations which are not multiples of the type's
size.

@item
@emph{@sc{dos} Filename Restrictions}

Use @sc{dos}-style 8.3 filenames for files which are shared by all platforms
which run Crystal Space.  This allows the project to support @sc{dos} in
addition to platforms with less restrictive filenames.  Platform-specific
files (not intended for @sc{dos}) need not follow this restriction.

@item
@emph{Filesystem Case Sensitivity}

Some operating systems have case sensitive filenames, whereas others do not.
Bad things happen if you capitalize a file one way in @code{#include}
directive and a different way in the actual filename.  This problem many not
even be apparent on your platform, if you are using a case-insensitive file
system such as @sc{dos} or Windows.  In general, it is preferable to use
entirely lower-case filenames for files which are shared between ports.

@strong{Warning}: @file{WinCVS} has been reported to botch capitalization of
files.  Please be aware of this potential problem.

@item
@emph{Floating Points}

For some reason comparing floats to 0.0 does not give the same results
on different platform. Use a @samp{if(floatvalue < EPSILON)} instead where
@code{EPSILON} is some very small value. It is certain linux and solaris
platforms differ on this point.

Also @samp{float1 < float2} may give different results on different platforms.
@samp{float1 < float2+ERSILON} gives more dependable results. Note that these 
floating point problems are on floats that result from length computation,
such that seemingly-same floats can be slightly different due to numerical
accuracy.

@item
@emph{int i redefined?}

Some compilers do not scope the variable in a for, in a line like
@samp{for(int i=0; ...)}. They treat the @code{i} as if defined in the outer
function. Thus when you later on have a second @samp{for(int i...)} line
those compilers will give an error. Avoid this by only defining variables
once in a for statement, or else defining the variable at the top of the
function, changing the for loops to @samp{for(i=0;...)}. The Microsoft Visual
C++ compiler has this problem.

@item
@emph{Pathnames}

Pathnames are different on many platforms. Use the VFS which gives a unified
approach. To seperate folders and files, use @samp{/} in the VFS.
(Not @samp{\} or @samp{:} ). Also, always use @samp{/} in @code{#include}
statements, never @samp{\} or @samp{:}. Windows compilers often allow
@samp{\}, but other platforms never do.

@item
@emph{Black screen bugs}

Some platforms depend on the correct @code{BeginDraw()} - @code{FinishDraw()}
calls. Thus every @code{BeginDraw()} must be followed by a @code{FinishDraw()}
or nothing will be rendered. DirectX needs this, linux does not (currently)
enforce this.
@end enumerate
