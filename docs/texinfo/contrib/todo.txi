@node Todo
@section Todo

This file describes the bugs and missing features that are still in
Crystal Space. The ultimate goal is to make this file empty :-)
Note that some of the wanted features in this list are currently
being worked on by some people. Always check on the developers mailing
list first.

@itemize @bullet
@item
General todo: fix all bugs in bugs.

@item
Optimizing lighting. Using the convex outline of objects we can still do
some opts.

@item
Maybe implement shadows for sprites and things using a simpler outline
version? (for sprites we can use LOD).

@item
We also need to update the lighting on the polygons of a thing when the
thing moves. It is easy to find all dynamic lights that hit a thing at the
current location but then you also have to find all dynamic lights that hit
a thing at the new location. One way to optimize this is to keep a list of
all lights that affect a sector. For a more detailed explanation of this,

@item
Like explained in the previous paragraph we should maintain a list of
static and dynamic lights in every sector. This not only contains all the
lights of that sector but also lights of nearby sectors which are visible
from the sector.

@item
Make MazeD the best Crystal Space editor in the world :-)

@item
Better LOD function for sprites. The current one doesn't preserve the shape
well enough.

@item
Generalize the engine so that it can use general gouraud shaded polygons
instead of only triangles. The 3D rasterizers can already do this.

@item
Implement halo visilibity checking in the engine instead of using the Z
buffer.

@item
For correct portal on thing handling we need to Z fill the portal polygon
after drawing (and use Z sort or STATBSP for the portals).

@item
Continue with support for multi-sector sprites. We need a way to quickly
update the list of sectors that every sprite is in. Also we need to clip
the sprite (rough clip) to the portal.

@item
Consider support for multi-sector things as well.

@item
Convert the few remaining classes to @code{csXxxx} name convention.

@item
Create more user documentation. Update FAQ. More tutorials.

@item
Rewrite bots and missile using the real collision detection system.

@item
Optimize the collision detection system.

@item
Fully implement or approximate 2*SRC*DST in hardware (with gamma or
something else).

@item
Continue integration of landscape engine (ROAM) with CS. Also integrate
dynamic sky support which is also in the ROAM engine from Alex Pfaffe.

@item
Scripting: Make SCF interfaces (IDL) for the engine.

@item
Scripting: Ad hoc scripting language?

@item
Scripting: interface with existing language (Python, Scheme, ...)

@item
Option to make dynamic library (DLL/so) for all CS libraries.

@item
Curved surfaces on sector walls.

@item
Curved surfaces in sprites. There are two ways: we could merge them
statically and just use the curves as a triangle generator or we could have
real LOD curves. I think the first approach is best because sprites have
LOD on their own.

@item
More types of curves. Nurbs are one example. Wavelets are another. But also
simple curves should be considered because they will be more efficient and
also very useful. One good example is simple circle shaped curves. Those
are great for archways.

@item
Dynamic curve lighting. This requires some thought because lightmapping a
curve is expensive. More precalculation may help here.

@item
REMPES visibility system or at least a subset.

@item
Improve the current c-buffer system. For example, add the ability to insert
dynamic objects (i.e. sprites) into the c-buffer and use them for testing
as well.

@item
Implement a @samp{make install} in the makefile system.

@item
Try to use the NASM assembler code in the Windows/VC port as well.

@item
Better world loader with support for plug-ins (to allow apps to insert game
specific data in a world file).

@item
Special effects (bumpmapping, explosions, particles, smoke, ...)

@item
2D sprites (flat sprites).

@item
Particle system. Maybe using pixels or 2D sprites.

@item
Fix BMP loading so that it is endian correct.

@item
Fix WAV loading so that it is endian correct.

@item
More configuration parameters for objects (like lightmap size for detail of
shadows).

@item
Allow flags and config values for objects to be set from within the world
file.

@item
Gravity configuration value for WalkTest.

@item
Automatic portal generation (used in MazeD or Crystal Space itself).

@item
Fix cleanup problems in engine.

@item
Better error handling and checking for invalid data in the engine. Maybe
make a level validator.

@item
Hierarchical objects.

@item
LOD on things. Maybe user specified.

@item
Artificial Intelligence?

@item
Spotlight support.

@item
Two adjacent polygons may not have correctly connected lightmaps. In other
words: there may be a dark border when there should not be any. This
probably needs to be solved by a second pass through all the lightmaps.

@item
Full radiosity on lightmaps.

@item
Need to continue cleanup of code (we are constantly busy with this :-)

@item
Continue cleaning up the language, the API, and the interface to create the
world.

@item
Allow the choice between a fixed palette or a computed palette. Control how
the palette should be computed (adherence to the colors in the bitmaps),...

@item
We should also implement animated textures. There is a problem with
lighting though. There are (at least) three options:
@itemize @bullet
@item
Remove the texture from the texture cache and reapply the lightmaps every
time another animation frame of the texture is choosen. This is
time-expensive but it is an option if the texture does not change that
often (for example, a switch that can be turned on/off) or is not very
large.

@item
Just do no lighting (or only uniform lighting) on those polygons. This is
of course easy to do and it is an option for those surfaces that don't
really need lighting (like lava surfaces).

@item
Let the texture cache perform lighting on a seperate light-texture. This
extra light-texture is then overlayed at runtime with the animated
texture. This option is very good for rapidly animating textures but it
slows down the renderer a bit when the textures is currently not being
animated.
@end itemize
All three methods are useful and can be used on other occasions, so maybe I
should try to implement them all :-)

@item
Portals can now affect the light color that passes through it. it would be
nice if this could also be done based on individual texel values on the
portal polygon. That way a light shining through an alpha-mapped portal
would shine on the wall with the colors of the texture on the portal.

@item
Allow @samp{animated} space-warping portals. Using these one could for
example create a train where the inside of the train is rendered as usual
while the windows are portals to a large sector or even the polygonal
terrain renderer. Every portal (window) would have a space warping matrix
so that the moving of the train (or other vehicule) can be simulated by
changing that transformation. This would be a really cool effect.

@item
Support for 24-bit display-mode (32-bit is already supported).

@item
Delay real transformation of sprites until they are visible (with a dirty
bit or something).

@item
Consider rewriting parts of the texture cache in assembler. They still take
a lot of time.

@item
Transform the planes of polygons only once if they are shared.

@item
Optimization with cross product as suggested by Segher Boessenkool:
@code{(a1 b2 - a2 b1)} becomes
@code{(a1 - b1) (a2 + b2) - (a1 a2) + (b1 b2)}.
@code{(a1 a2)} and @code{(b1 b2)} can be precomputed. This mainly affects
@code{which_side_2d} and maybe some other optimizations.

@item
There is no need for backface culling inside the current Sector (where the
@code{::draw starts}) provided that the sector doesn't use a BSP.

@item
We could consider doing backface culling in world space (before
transforming to camera space). So we don't need to transform a polygon if
it is not needed. But we have to consider that the vertices of a whole
sector are transformed first. In that case we would need to postpone this
transformation of vertices and maybe use an array to indicate which
vertices have already been transformed.

@item
Allow multiple textures on a polygon (overlaying textures) which are
automatically merged by the Texture Cacher.

@item
Use a different lightmap size for a polygon. This is useful for very large
polygons for which shadow accuracy is not of utmost importance and also for
very small polygons where you would like to have more accurate shadows.
Default lightmap size is 16. Currently this does not need to be a power of
2 but I would not use anything else because future optimizations could
depend on this.

@item
Combine lightmaps in one texture for hardware renderers.

@item
Implement fast hardware versions of @code{DrawTriangleMesh()}.

@item
Joystick/mouse support.

@item
Make a map in 3D a bit like in Descent.
@end itemize
