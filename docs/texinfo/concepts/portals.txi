@c -*-texinfo-*
@node Portal Engine, Space Warping, Cameras and Matrices, Concepts
@section The Portal Engine
@cindex Portal Engine

The world in Crystal Space is defined with Sectors connected by Portals and
possibly augmented with Things. This is in a nutshell how the portal engine
works.

It is difficult to give an example if you can't use pictures (@@@@@@ include
.gif file with document containing a drawing of this example) but I will try:

Assume that you want to define a large room with a pillar in the middle of
the room. You can do this two ways: with four Sectors, or with one Sector and
one Thing. First let us define it with four Sectors:

As seen from above, the sectors would look something like this:

@example
    +-------------------+------+---------------------+
    |                   |      |                     |
    |                   |  S2  |                     |
    |                   |      |                     |
    |                   |      |                     |
    |                   +------+                     |
    |                   |      |                     |
    |       S1          |      |         S3          |
    |                   |      |                     |
    |                   +------+                     |
    |                   |      |                     |
    |                   |  S4  |                     |
    |                   |      |                     |
    |                   |      |                     |
    +-------------------+------+---------------------+
@end example

Sector S1 has eight polygons (including the top and bottom polygon and the
three polygons at the east side). The two polygons adjacent to Sectors S2 and
S4 are Portals to the respective Sectors. All the other polygons are texture
mapped as normal.

Sectors S2 and S4 have six polygons. Their west polygons are again Portals to
Sector S1. Their east polygons are Portals to Sector S3.

Sector S3 is defined as Sector S1.

Another way to define this room using just the same four Sectors as follows:

@example
    +--------------+----------------+----------------+
    |               \              /                 |
    |                \     S2     /                  |
    |                 \          /                   |
    |                  \        /                    |
    |                   +------+                     |
    |                   |      |                     |
    |       S1          |      |         S3          |
    |                   |      |                     |
    |                   +------+                     |
    |                  /        \                    |
    |                 /    S4    \                   |
    |                /            \                  |
    |               /              \                 |
    +--------------+----------------+----------------+
@end example

To the person standing in this room this makes no difference at all.

There are many other ways to define this room using the four Sectors. One
important thing to note is that four is the minimum number of Sectors that
you need to define this room (unless you use a Thing as described below). The
reason is that Sectors are convex.

An easier way to define this room is by using only one Sector and one Thing
to define the pillar:

@example
    +------------------------------------------------+
    |                                                |
    |                                                |
    |                                                |
    |                                                |
    |                   +------+                     |
    |                   |      |                     |
    |       S1          |  T1  |                     |
    |                   |      |                     |
    |                   +------+                     |
    |                                                |
    |                                                |
    |                                                |
    |                                                |
    +------------------------------------------------+
@end example

Again this makes no difference for the person standing in this room. There is
however a difference in performance. If the pillar is very large and wide the
first approach will probably be faster. If the pillar is very thin it is more
efficient to use only one Sector with one Thing.

The reason (as will be made clearer later) is that Things are drawn after the
Sectors have been drawn and thus cause overdraw.

Things are provided to make defining worlds easier. If they are small enough
they will probably also enhance performance.

With Sectors, Portals, and Things you can describe virtually any world that
you want (note that all polygons of a Sector can be Portals, even the floor
and ceiling polygons. In fact there is no special attribute for a floor or
ceiling polygon. All polygons are equivalent).

@node Sectors, Things, Portal Engine, Portal Engine
@subsection Sectors
@cindex Sectors

In this section I will describe Sectors a bit more thoroughly. As stated
before Sectors are 3D convex objects. The faces of a Sector are made up of
convex 3D polygons. The fact that Sectors need to be convex is a serious
restriction but this is solved by the use of Portals.

Sectors contain a set of vertices which can be shared by all the polygons of
the Sector.

Sectors should be closed. In other words, all polygons of the Sector must
completely cover it.

Starting with version 0.07 of Crystal Space it is possible to add a BSP to a
Sector. This is useful if you want to define non-convex Sectors. The BSP is
local to the Sector (another Sector can use another BSP if it wishes). The
Sector still uses Portals to go to another Sector.

@node Things, Polygons, Sectors, Portal Engine
@subsection Things
@cindex Things

A Thing is very similar to a Sector in many ways. In the code this is
reflected by the fact that both inherit from the same class
(@code{csPolySet}).

One of the major differences between Things and Sectors is that a Thing need
not be convex (but the polygons making up the Thing should still be convex).
Z-buffering is used to draw Things so the polygons can be oriented in any way
possible. You could for example make a Thing with several polygons which are
not even connected with each other.

Note that polygons have a visible side and an invisible side (backface
culling).

Currently polygons in Things cannot be Portals. In future I plan to fix this.
With this feature you could have very interesting effects (like a television
Thing with the screen a Portal to some Sector).

@node Polygons, Portals, Things, Portal Engine
@subsection Polygons
@cindex Polygons

Sectors and Things are made of 3D polygons. As mentioned before polygons must
be convex. The vertices of polygons are oriented clockwise. This fact is used
for backface culling; a polygon has only one visible side.

Polygons are drawn with a texture. How the texture is mapped on the polygon
depends on a transformation matrix. This is general enough so that you can
translate, rotate, scale, and mirror the texture in every possible direction.

The texture is tiled accross the polygon surface.

In a pre-computing stage three light-maps are created for every polygon (this
is explained in more detail later). Lighting is sampled in a grid 16x16
texture pixels (or texels) big. Bilineair interpolation is used by the
texture cacher to make this lighting go smooth.

The end result of this is a non-tiled lighted texture that is mapped accross
the polygon surface.

A polygon can also be a Portal (see below). Normally a Portal polygon is not
texture mapped unless the texture is semi-transparent.

@node Portals, Rendering The World, Polygons, Portal Engine
@subsection Portals
@cindex Portals

A Portal is a special kind of polygon. Portal polygons can currently only
exist in Sectors.

Instead of texture mapping a Portal polygon, the renderer will recursively
draw the Sector that this Portal points too. After this, if the texture is
semi-transparent, the texture will be mapped over the already drawn Sector.

Portals can also transform space. This feature is new since 0.07. You can use
it to implement mirrors or reflecting surfaces.

Note that when there is a Portal from Sector A to Sector B you should
probably also define a Portal from Sector B to Sector A! Adjacent polygons of
different Sectors are not shared so you need to set a Portal on each of them.
Otherwise you will have the effect that you can see from Sector A to Sector B
but not the other way around.

A special feature of Portals is that you could (in theory) have a Portal from
Sector A to Sector B. But instead of going back to Sector A from Sector B you
set the Portal to Sector C which is a Sector which has the same world space
coordinates as Sector A. This is perfectly possible (although maybe not
desirable) with Crystal Space. An important result of this is that a given
world space coordinate can belong to more than one Sector! Another corally of
this is that you always need a current Sector together with a world space
coordinate to really know where you are!

Portals in Crystal Space solve the problem of polygon sorting. All polygons
in the current Sector are certainly visible (unless they are behind the view
plane) and do not overlap, so they can just be drawn in any order without
overdraw and without conflicts. If a Portal polygon is reached all Polygons
in that other Sector are behind all the Polygons in the current Sector. In
fact Portals are an explicit form of a BSP tree. The advantages of this
approach are:

@itemize @bullet
@item
In theory it would be rather easy to make dynamic worlds. Because the Portals
are explicit it is easy to define them so that certain sectors can move and
transform in certain ways. Currently this does not work because I have not
done anything yet to make this work :-) There are also some problems with
static lighting but this is not severe if the movement is not too much.

@item
Because it is an explicit form of a BSP tree split, I think that it is more
efficient than a real BSP tree. I have not confirmed this.

@item
It is easy to define semi-transparent textures on Portals. This would be more
difficult to do with BSP trees.

@item
Space warping can be used (see above).

@item
Overdraw elimination comes for free with Portals.
@end itemize

One disadvantage I could think of:

@itemize @bullet
@item
It is probably more difficult to define worlds this way. You have to make
sure that all Sectors are convex. A BSP tree approach would solve this
automatically.
@end itemize

@node Rendering The World, , Portals, Portal Engine
@subsection Rendering The World
@cindex Rendering The World

How does the renderer use the world information to draw a scene? Here I
describe all the various steps to draw the world. The Camera and a view 2D
polygon are given as parameters (the view polygon defines what is visible on
the screen).

@itemize @bullet
@item
First the current Sector is transformed from world to camera space using the
given Camera (this means that all of the vertices are transformed).

@item
Then, for every polygon of the current Sector do the following (if there is a
BSP for this Sector then the following is also done but in back to front
order as defined by the BSP):

@itemize @bullet
@item
Perform perspective correction (division by @samp{z}) on all the vertices of
the polygon.

@item
If all of the vertices are behind the viewplane (@code{Z=EPSILON}) then the
polygon is not visible and need not be drawn.

@item
Here we perform backface culling to see if the polygon can be visible. Note
that for the current Sector all polygons are always visible but this step is
important if we are drawing the Sector behind a Portal.

@item
If all of the vertices are in front of the viewplane then the polygon is
completely visible. Skip the following step.

@item
Otherwise we need to clip the polygon against the viewplane.

@item
If the polygon is still visible after all these steps we transform the
texture mapping matrix from world->texture to camera->texture. We also
transform the plane normal of the polygon to camera space.

@item
Now we clip the polygon against the view polygon. The view polygon is a
general 2D polygon, not just a rectangle.

@item
If the resulting 2D polygon is not a Portal it is just drawn on the screen.

@item
Otherwise this routine is recursively called again with the Sector that the
Portal points to as the current Sector and the resulting clipped 2D polygon
as a new view polygon. If the texture of the Portal polygon is
semi-transparent it is drawn over the resulting image.
@end itemize

@item
After the current Sector has been drawn, do the following for every Thing in
this Sector:

@itemize @bullet
@item
First the Thing is transformed from world to camera space using the given
Camera. If all vertices are behind the viewplane the whole Thing is not
visible and we need not draw it.

@item
Otherwise, for every polygon of the Thing do the following:

@itemize @bullet
@item
Perform perspective correction (division by @samp{z}) on all the vertices of
the polygon.

@item
If all of the vertices are behind the viewplane (@code{Z=EPSILON}) then the
polygon is not visible and need not be drawn.

@item
Here we perform backface culling to see if the polygon can be visible.

@item
If all of the vertices are in front of the viewplane then the polygon is
completely visible. Skip the following step.

@item
Otherwise we need to clip the polygon against the viewplane.

@item
If the polygon is still visible after all these steps we transform the
texture mapping matrix from world->texture to camera->texture. We also
transform the plane normal of the polygon to camera space.

@item
Now we clip the polygon against the view polygon.

@item
Draw the polygon with a Z-buffering scanline drawer.
@end itemize
@end itemize
@end itemize

Before this algorithm is performed the Z-buffer is cleared once.

A consequence of this algorithm is that their is no overdraw when drawing the
Sectors. The 2D polygon clipping algorithm takes care of that. One may think
that this algorithm would be rather expensive but this does not seem to be
the case. So we eliminate overdraw when drawing all the Sectors without
having to resort to S-buffer or other similar techniques.

There is overdraw when Things are drawn. This is difficult to avoid. One
could consider another clipping algorithm but this would result in concave
polygons which our polygon drawer can't handle.

A current limitation in the drawing of Things is that a Thing can not be in
two Sectors at the same time. This limitation can be removed with various
techniques. In future I will probably have a special class of Things which
can span several Sectors at once.

