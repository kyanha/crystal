@node Config Engine
@subsection Engine Configuration
@cindex Configuration, Engine

This section describes the configuration keys used by the 3D engine.

All these options belong in the main config file for your application, for
example @file{CS/data/config/cryst.cfg}.

@subsubheading Lighting Options

@table @code
@item Engine.Lighting.Ambient.White = [0..255]
@itemx Engine.Lighting.Ambient.Red = [0..255]
@itemx Engine.Lighting.Ambient.Green = [0..255]
@itemx Engine.Lighting.Ambient.Blue = [0..255]
These keys set the amount of ambient light that is used when lighting is
calculated. This amount of light is present on all textures even if no light
source shines on them. The @samp{White} key is a added to all three color
channels. Default values are 40 units of white and 0 units for all others.

@item Engine.Lighting.LightmapSize = <power of 2>
Sets the size of the lightmap texels. The smaller this value, the more
accurate are the lighting calculations. This also increases memory
consumption and decreases the speed of the texture cache. Lighting information
will be recalculated automatically when you change this value. (default: 16)

@item Engine.Lighting.CosinusFactor = [-1..1]
Control how much the angle of the light with the polygon it hits affects
the final light value. Values ranges from -1 to 1. With -1 the polygons
will get no light at all. With 0 it will be perfect cosine rule. With 1 the
cosine is ignored and it will be like CrystalSpace was in the past. Note
that changing this value at runtime only has an effect on dynamic lights.
This option corresponds to the @code{-cosfact} commandline option and the
@samp{cosfact} console command. (default: 0)

@item Engine.Lighting.SpriteQuality = [0..3]
Set the quality of lighting for sprites, ranging from 0 (high quality) to 3
(random). (default: 1)

@item Engine.Lighting.Radiosity = <yes/no>
If this option is set to yes, the pseudo-radiosity system will be enabled.
This means that the precalculated lighting routines will also reflect light on
normal polygons (and not only on mirrors). The number of allowed
reflections depends on the @samp{Engine.Lighting.Reflections} variable. Using
this flag you get a sort of simulation of radiosity. Note that it greatly
increases the time needed for precalculated lighting. This option only has
effect in combination with the @code{-relight} commandline option. Also note
that this option is currently broken (i.e. crashes CS).

@item Engine.Lighting.Reflections = <number>
This sets the maximum number of reflections for a light beam. More exactly,
it sets how often a beam of light may hit a polygon in the same sector.
Setting this to 0 would produce totally dark polygons (apart from ambient
light). A value of 1 means that light may hit polygons but is not reflected
to other polygons. Higher values allow more reflections. This is especially
useful in combination with mirrors. If pseudo-radiosity is enabled with the
@samp{Engine.Lighting.Radiosity} key, light is also reflected from non-mirror
polygons. (default: 1)
@end table

@subsubheading Radiosity Options

@table @code
@item Engine.Lighting.Radiosity.Enable = <yes/no>
This option activates the new radiosity system. To recalculate
radiosity run walktest -relight on the level. (default: no)

@item Engine.Lighting.Radiosity.StopPriority = <float>
Internally radiosity computes a priority for each
polygon. The priority is in the range of 0..256, where 0 means nothing
to do. When the highest priority become lower then the stoppriority,
radiosity calculation will stop. (Default: 0.1)

@item Engine.Lighting.Radiosity.StopImprovement = <float>
When the highest priority becomes lower than
the highest priority at the start of calculation divided by this value
calculation will stop. (Default: 100.0)

@item Engine.Lighting.Radiosity.StopIterations = <number>
After processing this many polygons the radiosity
calculation will stop. This will prevent endless loops. If your level has 
many polygons you may need to increase the value. (Default: 10000)

@item Engine.Lighting.Radiosity.SourcePatchSize = <number>
This value will make radiosity calculation use
the average of NxN size patches on source polygons when shooting light 
from one polygon to another (but not on destination polygons). Increasing
the value will speed up computation considerably, while reducing quality
only slightly. Try values of 1..256, depending on the LightmapSize. 
Use only powers of two. (Default: 16)

@item Engine.Lighting.Radiosity.ColourBleed = <float>
This variable controls the amount of color emitted
by a polygon. The colour is taken by examining the texture of the polygon.
Thus a blue texture will reflect blueishly. So 0.0 will remove texture
influence, making the level render as if all white. And high values will
make colour more important. Try 0.0-4.0. 
(Default: 1.0)

@item Engine.Lighting.Radiosity.DoStaticSpecular = <yesno>
yes will turn on specular lighting using
radiosity. Since this is precalculation, only a static 'fake' specular
effect can be given. Does not seem to give huge effects, but I left
in the code so you can play with it :-). (Default: no)

@item Engine.Lighting.Radiosity.StaticSpecularAmount = <float>
The amount of specular lighting to add
when lighting. Try between 0 and 1. (Default: 0.70)

@item Engine.Lighting.Radiosity.StaticSpecularTightness = <number>
tightness of the specular highlight.  a power of 2 of this variable is 
used for speed. Thus try 0-10. (Default: 4)
@end table

