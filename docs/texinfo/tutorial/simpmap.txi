@c -*-texinfo-*-
@node Tutorial Simple Map, map2cs Tutorial, Tutorial Simple 2, Tutorials
@section Simple Tutorial 3: Map Loading
@cindex Tutorial, Simple
@cindex Simple Tutorial

This tutorial continues on tutorial one. Here we will learn how you
can load a level from a map file instead of creating the geometry
in the code.

@menu
* Simple Base Code:: Minimal Base Code
* Simple Loading The Map:: Loading The Map
* Simple Locating the Camera:: Locating the Camera
@end menu

@node Simple Base Code, Simple Loading The Map, Tutorial Simple Map, Tutorial Simple Map
@subsection Minimal Base Code

To start with we first take the code of tutorial one
and remove the code that creates geometry and initializes
the default camera position. In addition we add a new @code{LoadMap()}
function. This results in the following for @file{simple.h}:

@example
#ifndef __SIMPLE_H__
#define __SIMPLE_H__

#include <stdarg.h>

struct iEngine;
struct iLoader;
struct iGraphics3D;
struct iKeyboardDriver;
struct iVirtualClock;
struct iObjectRegistry;
struct iEvent;
struct iSector;
struct iView;

class Simple
@{
private:
  iObjectRegistry* object_reg;
  csRef<iEngine> engine;
  csRef<iLoader> loader;
  csRef<iGraphics3D> g3d;
  csRef<iKeyboardDriver> kbd;
  csRef<iVirtualClock> vc;
  iSector* room;
  csRef<iView> view;
 
  static bool SimpleEventHandler (iEvent& ev);
  bool HandleEvent (iEvent& ev);
  void SetupFrame ();
  void FinishFrame ();
  bool LoadMap ();

public:
  Simple (iObjectRegistry* object_reg);
  ~Simple ();

  bool Initialize ();
  void Start ();
@};

#endif // __SIMPLE_H__
@end example

Similarly for @file{simple.cpp}:

@example
#include "cssysdef.h"
#include "cssys/sysfunc.h"
#include "iutil/vfs.h"
#include "csutil/cscolor.h"
#include "cstool/csview.h"
#include "cstool/initapp.h"
#include "simpmap.h"
#include "iutil/eventq.h"
#include "iutil/event.h"
#include "iutil/objreg.h"
#include "iutil/csinput.h"
#include "iutil/virtclk.h"
#include "iengine/sector.h"
#include "iengine/engine.h"
#include "iengine/camera.h"
#include "iengine/light.h"
#include "iengine/statlght.h"
#include "iengine/texture.h"
#include "iengine/mesh.h"
#include "iengine/movable.h"
#include "iengine/material.h"
#include "imesh/thing/polygon.h"
#include "imesh/thing/thing.h"
#include "imesh/object.h"
#include "ivideo/graph3d.h"
#include "ivideo/graph2d.h"
#include "ivideo/txtmgr.h"
#include "ivideo/texture.h"
#include "ivideo/material.h"
#include "ivideo/fontserv.h"
#include "igraphic/imageio.h"
#include "imap/parser.h"
#include "ivaria/reporter.h"
#include "ivaria/stdrep.h"
#include "csutil/cmdhelp.h"

CS_IMPLEMENT_APPLICATION

// The global pointer to simple
Simple *simple;

Simple::Simple (iObjectRegistry* object_reg)
@{
  Simple::object_reg = object_reg;
@}

Simple::~Simple ()
@{
@}

void Simple::SetupFrame ()
@{
  // First get elapsed time from the virtual clock.
  csTicks elapsed_time = vc->GetElapsedTicks ();
  
  // Now rotate the camera according to keyboard state
  float speed = (elapsed_time / 1000.0) * (0.03 * 20);

  iCamera* c = view->GetCamera();
  if (kbd->GetKeyState (CSKEY_RIGHT))
    c->GetTransform ().RotateThis (CS_VEC_ROT_RIGHT, speed);
  if (kbd->GetKeyState (CSKEY_LEFT))
    c->GetTransform ().RotateThis (CS_VEC_ROT_LEFT, speed);
  if (kbd->GetKeyState (CSKEY_PGUP))
    c->GetTransform ().RotateThis (CS_VEC_TILT_UP, speed);
  if (kbd->GetKeyState (CSKEY_PGDN))
    c->GetTransform ().RotateThis (CS_VEC_TILT_DOWN, speed);
  if (kbd->GetKeyState (CSKEY_UP))
    c->Move (CS_VEC_FORWARD * 4 * speed);
  if (kbd->GetKeyState (CSKEY_DOWN))
    c->Move (CS_VEC_BACKWARD * 4 * speed);

  // Tell 3D driver we're going to display 3D things.
  if (!g3d->BeginDraw(
    engine->GetBeginDrawFlags() | CSDRAW_3DGRAPHICS))
    return;

  // Tell the camera to render into the frame buffer.
  view->Draw ();
@}

void Simple::FinishFrame ()
@{
  g3d->FinishDraw ();
  g3d->Print (NULL);
@}

bool Simple::HandleEvent (iEvent& ev)
@{
  if (ev.Type == csevBroadcast && ev.Command.Code == cscmdProcess)
  @{
    simple->SetupFrame ();
    return true;
  @}
  else if (ev.Type == csevBroadcast &&
    ev.Command.Code == cscmdFinalProcess)
  @{
    simple->FinishFrame ();
    return true;
  @}
  else if (ev.Type == csevKeyDown && ev.Key.Code == CSKEY_ESC)
  @{
    iEventQueue* q = CS_QUERY_REGISTRY (object_reg, iEventQueue);
    if (q)
    @{
      q->GetEventOutlet()->Broadcast (cscmdQuit);
      q->DecRef ();
    @}
    return true;
  @}

  return false;
@}

bool Simple::SimpleEventHandler (iEvent& ev)
@{
  return simple->HandleEvent (ev);
@}

bool Simple::Initialize ()
@{
  if (!csInitializer::RequestPlugins (object_reg,
  	CS_REQUEST_VFS,
	CS_REQUEST_SOFTWARE3D,
	CS_REQUEST_ENGINE,
	CS_REQUEST_FONTSERVER,
	CS_REQUEST_IMAGELOADER,
	CS_REQUEST_LEVELLOADER,
	CS_REQUEST_REPORTER,
	CS_REQUEST_REPORTERLISTENER,
	CS_REQUEST_END))
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
	"Can't initialize plugins!");
    return false;
  @}

  if (!csInitializer::SetupEventHandler(
    object_reg, SimpleEventHandler))
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
	"Can't initialize event handler!");
    return false;
  @}

  // Check for commandline help.
  if (csCommandLineHelper::CheckHelp (object_reg))
  @{
    csCommandLineHelper::Help (object_reg);
    return false;
  @}

  // The virtual clock.
  vc = CS_QUERY_REGISTRY (object_reg, iVirtualClock);
  if (!vc)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
	"Can't find the virtual clock!");
    return false;
  @}

  // Find the pointer to engine plugin
  engine = CS_QUERY_REGISTRY (object_reg, iEngine);
  if (!engine)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
	"No iEngine plugin!");
    return false;
  @}

  loader = CS_QUERY_REGISTRY (object_reg, iLoader);
  if (!loader)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
    	"No iLoader plugin!");
    return false;
  @}

  g3d = CS_QUERY_REGISTRY (object_reg, iGraphics3D);
  if (!g3d)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
    	"No iGraphics3D plugin!");
    return false;
  @}

  kbd = CS_QUERY_REGISTRY (object_reg, iKeyboardDriver);
  if (!kbd)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
    	"No iKeyboardDriver plugin!");
    return false;
  @}

  // Open the main system. This will open all the previously
  // loaded plug-ins.
  if (!csInitializer::OpenApplication (object_reg))
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
    	"Error opening system!");
    return false;
  @}

  view = csPtr<iView> (new csView (engine, g3d));
  iGraphics2D* g2d = g3d->GetDriver2D ();
  view->SetRectangle (0, 0, g2d->GetWidth (), g2d->GetHeight ());

  iTextureManager* txtmgr = g3d->GetTextureManager ();
  txtmgr->SetPalette ();
  return true;
@}

void Simple::Start ()
@{
  csDefaultRunLoop (object_reg);
@}

/*---------------*
 * Main function
 *---------------*/
int main (int argc, char* argv[])
@{
  iObjectRegistry* object_reg = csInitializer::CreateEnvironment (argc, argv);
  if (!object_reg) return -1;
  simple = new Simple (object_reg);

  if (simple->Initialize ())
    simple->Start ();

  delete simple;
  csInitializer::DestroyApplication (object_reg);

  return 0;
@}
@end example

One important note in the code above: we removed the following line:

@example
  engine->SetLightingCacheMode (0);
@end example

That's because when we are loading from map file we actually want
the lighting information to be read from the cache (if present).
That's because relighting a map can be a time-consuming process.

@node Simple Loading The Map, Simple Locating the Camera, Simple Base Code, Tutorial Simple Map
@subsection Loading The Map
@cindex loading a map
@cindex vfs
@cindex mount point

Here we add the code to load a map. In this example we will load the
@samp{flarge} map which is included with Crystal Space.

In the second tutorial we already mentioned @sc{vfs} (@pxref{VFS}). This
is important in this case too since we are going to load the map from
the virtual filesystem. To do this we first add the new @code{LoadMap()}
routine right before the @code{Initialize()} function:

@example
bool Simple::LoadMap ()
@{
  // Set VFS current directory to the level we want to load.
  csRef<iVFS> VFS (CS_QUERY_REGISTRY (object_reg, iVFS));
  VFS->ChDir ("/lev/flarge");
  // Load the level file which is called 'world'.
  if (!loader->LoadMapFile ("world"))
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
    	"Couldn't load level!");
    return false;
  @}
  engine->Prepare ();

  iTextureManager* txtmgr = g3d->GetTextureManager ();
  txtmgr->SetPalette ();
  return true;
@}
@end example

This code will first use @code{iVFS::ChDir()} to set the current
directory in the virtual file system to @file{/lev/flarge}. In the
case of @samp{flarge} this @sc{mount point} is already created in the
config file @file{vfs.cfg}. If this is not the case for your own levels
you can either modify @file{vfs.cfg} or else call @code{iVFS::Mount()}
to map a physical file path (can be a @sc{zip} archive file as well)
to a virtual directory.

The call to @code{iLoader::LoadMapFile()} will take the given filename
(in this case @file{world}) and open it from the current @sc{vfs}
directory. Then it will parse that file and create the geometry which
is specified there.

If this is succesful then you must call @code{iEngine::Prepare()} to
make sure that all lightmaps are correctly loaded from the cache
and other necessary setup work is done (i.e. textures are registered
and so on).

We additionally change the last part of @code{Initialize()} to
this:

@example
bool Simple::Initialize (int argc, const char* const argv[])
@{
  @dots{}

  view = csPtr<iView> (new csView (engine, g3d));
  iGraphics2D* g2d = g3d->GetDriver2D ();
  view->SetRectangle (0, 0, g2d->GetWidth (), g2d->GetHeight ());

  if (!LoadMap ()) return false;
  return true;
@}
@end example

So first we create our view but doesn't yet set the current sector.
@code{LoadMap()} will do that based on the loaded level.

@node Simple Locating the Camera, , Simple Loading The Map, Tutorial Simple Map
@subsection Locating the Camera

@samp{flarge} contains a number of sectors and various objects, and those
are now all loaded in memory. However this is not enough. We also have
to set the camera to some sector and position in that world. In the
previous tutorials we simply used the sector that we just created
and a fixed position in that sector (keep in mind that in Crystal
Space a position in space is always defined as a sector in combination
with a position). When loading a map we can't work that way because
we don't know which sectors are in the map (unless we make an application
that can only read one level, but that's not very flexible) and we
also don't know where we can safely put our camera. In the map files
it is possible to specify one or more starting positions. We will
query the engine for such a starting position and initialize our
view (camera) to that. This happens with the following code:

First add the following to the include section:

@example
#include "iengine/campos.h"
@end example

Then add the following after @code{engine->Prepare()} in @code{LoadMap()}:

@example
  // Find the starting position in this level.
  csVector3 pos (0, 0, 0);
  if (engine->GetCameraPositions ()->GetCount () > 0)
  @{
    // There is a valid starting position defined in the level file.
    iCameraPosition* campos = engine->GetCameraPositions ()->Get (0);
    room = engine->GetSectors ()->FindByName (campos->GetSector ());
    pos = campos->GetPosition ();
  @}
  else
  @{
    // We didn't find a valid starting position. So we default
    // to going to room called 'room' at position (0,0,0).
    room = engine->GetSectors ()->FindByName ("room");
  @}
  if (!room)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
      	"Can't find a valid starting position!");
    return false;
  @}
  view->GetCamera ()->SetSector (room);
  view->GetCamera ()->GetTransform ().SetOrigin (pos);

  iTextureManager* txtmgr = g3d->GetTextureManager ();
  txtmgr->SetPalette ();
  return true;
@}
@end example

First we see how many camera positions there were defined in the
map by using @code{iEngine::GetCameraPositionCount()}. If this is 0
then the map didn't define a starting position. In that case we will
assume there is a sector called 'room' and we will start the camera
at (0,0,0) in that sector. But otherwise we will use the first
starting position defined in the map.

This is all. After adding this code this application will now load
the 'flarge' map and display it so you can run around in this level.

