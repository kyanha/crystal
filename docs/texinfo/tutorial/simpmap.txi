@c -*-texinfo-*-
@node Tutorial Simple Map, map2cs Tutorial, Tutorial Simple 2, Tutorials
@section Simple Tutorial 3: Map Loading
@cindex Tutorial, Simple
@cindex Simple Tutorial

This tutorial continues on tutorial one. Here we will learn how you
can load a level from a map file instead of creating the geometry
in the code.

@menu
* Simple Base Code:: Minimal Base Code
* Simple Loading The Map:: Loading The Map
* Simple Locating the Camera:: Locating the Camera
@end menu

@node Simple Base Code, Simple Loading The Map, Tutorial Simple Map, Tutorial Simple Map
@subsection Minimal Base Code

To start with we first take the code of tutorial one
and remove the code that creates geometry. This results in the following
for @file{simple.h}:

@example
#ifndef __SIMPLE_H__
#define __SIMPLE_H__

#include <stdarg.h>
#include "cssys/sysdriv.h"

struct iEngine;
struct iLoader;
struct iGraphics3D;
struct iSector;
struct iView;

class Simple : public SysSystemDriver
@{
  typedef SysSystemDriver superclass;
private:
  iEngine* engine;
  iLoader* loader;
  iGraphics3D* g3d;
  iSector* room;
  iView* view;
 
public:
  Simple ();
  virtual ~Simple ();

  virtual bool Initialize (int argc, const char* const argv[],
    const char *iConfigName);
  virtual bool HandleEvent (iEvent&);
  virtual void NextFrame ();
@};

#endif // __SIMPLE_H__
@end example

Similarly for @file{simple.cpp}:

@example
#include "cssysdef.h"
#include "cssys/system.h"
#include "csutil/cscolor.h"
#include "cstool/csview.h"
#include "cstool/initapp.h"
#include "simpmap.h"
#include "iutil/objreg.h"
#include "iengine/sector.h"
#include "iengine/engine.h"
#include "iengine/camera.h"
#include "iengine/light.h"
#include "iengine/texture.h"
#include "iengine/mesh.h"
#include "iengine/movable.h"
#include "iengine/material.h"
#include "imesh/object.h"
#include "imesh/thing/polygon.h"
#include "imesh/thing/thing.h"
#include "ivideo/graph3d.h"
#include "ivideo/graph2d.h"
#include "ivideo/txtmgr.h"
#include "ivideo/texture.h"
#include "ivideo/material.h"
#include "imap/parser.h"
#include "ivaria/reporter.h"

CS_IMPLEMENT_APPLICATION

Simple *System;

Simple::Simple ()
@{
  view = NULL;
  engine = NULL;
  loader = NULL;
  g3d = NULL;
@}

Simple::~Simple ()
@{
  if (view) view->DecRef ();
  if (engine) engine->DecRef ();
  if (loader) loader->DecRef();
  if (g3d) g3d->DecRef ();
@}

void Cleanup ()
@{
  csPrintf ("Cleaning up...\n");
  delete System;
@}

bool Simple::Initialize (int argc, const char* const argv[],
  const char *iConfigName)
@{
  if (!superclass::Initialize (argc, argv, iConfigName))
    return false;

  iObjectRegistry* object_reg = GetObjectRegistry ();
  csInitializeApplication (object_reg);

  // Find the pointer to engine plugin
  engine = CS_QUERY_REGISTRY (object_reg, iEngine);
  if (!engine)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple1",
    	"No iEngine plugin!");
    exit (1);
  @}

  loader = CS_QUERY_REGISTRY (object_reg, iLoader);
  if (!loader)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple1",
    	"No iLoader plugin!");
    exit (1);
  @}

  g3d = CS_QUERY_REGISTRY (object_reg, iGraphics3D);
  if (!g3d)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple1",
    	"No iGraphics3D plugin!");
    exit (1);
  @}

  // Open the main system. This will open all the previously
  // loaded plug-ins.
  if (!Open ())
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple1",
    	"Error opening system!");
    Cleanup ();
    exit (1);
  @}

  // Setup the texture manager
  iTextureManager* txtmgr = g3d->GetTextureManager ();
  txtmgr->SetVerbose (true);

  // Initialize the texture manager
  txtmgr->ResetPalette ();

  csReport (object_reg, CS_REPORTER_SEVERITY_NOTIFY,
    	"crystalspace.application.simple1",
	"Simple Crystal Space Application version 0.1.");

  view = new csView (engine, g3d);
  view->GetCamera ()->SetSector (room);
  view->GetCamera ()->GetTransform ().SetOrigin (pos);
  iGraphics2D* g2d = g3d->GetDriver2D ();
  view->SetRectangle (0, 0, g2d->GetWidth (), g2d->GetHeight ());

  txtmgr->SetPalette ();
  return true;
@}

bool Simple::HandleEvent (iEvent& Event)
@{
  if (superclass::HandleEvent (Event))
    return true;

  if (Event.Type == csevKeyDown && Event.Key.Code == CSKEY_ESC)
  @{
    Shutdown = true;
    return true;
  @}

  return false;
@}

void Simple::NextFrame ()
@{
  superclass::NextFrame ();
  // First get elapsed time from the system driver.
  csTicks elapsed_time, current_time;
  GetElapsedTime (elapsed_time, current_time);
  
  // Now rotate the camera according to keyboard state
  float speed = (elapsed_time / 1000.0) * (0.03 * 20);

  iCamera* c = view->GetCamera();
  if (GetKeyState (CSKEY_RIGHT))
    c->GetTransform ().RotateThis (VEC_ROT_RIGHT, speed);
  if (GetKeyState (CSKEY_LEFT))
    c->GetTransform ().RotateThis (VEC_ROT_LEFT, speed);
  if (GetKeyState (CSKEY_PGUP))
    c->GetTransform ().RotateThis (VEC_TILT_UP, speed);
  if (GetKeyState (CSKEY_PGDN))
    c->GetTransform ().RotateThis (VEC_TILT_DOWN, speed);
  if (GetKeyState (CSKEY_UP))
    c->Move (VEC_FORWARD * 4 * speed);
  if (GetKeyState (CSKEY_DOWN))
    c->Move (VEC_BACKWARD * 4 * speed);

  // Tell 3D driver we're going to display 3D things.
  if (!g3d->BeginDraw (
      engine->GetBeginDrawFlags () | CSDRAW_3DGRAPHICS))
      return;

  // Tell the camera to render into the frame buffer.
  view->Draw ();

  // Drawing code ends here.
  g3d->FinishDraw ();
  // Display the final output.
  g3d->Print (NULL);
@}

/*---------------*
 * Main function
 *---------------*/
int main (int argc, char* argv[])
@{
  srand (time (NULL));

  // Create our main class.
  System = new Simple ();

  // We want at least the minimal set of plugins
  System->RequestPlugin (
    "crystalspace.kernel.vfs:VFS");
  System->RequestPlugin (
    "crystalspace.font.server.default:FontServer");
  System->RequestPlugin (
    "crystalspace.graphic.image.io.multiplex:ImageLoader");
  System->RequestPlugin (
    "crystalspace.graphics3d.software:VideoDriver");
  System->RequestPlugin (
    "crystalspace.engine.3d:Engine");
  System->RequestPlugin (
    "crystalspace.level.loader:LevelLoader");

  // Initialize the main system. This will load all needed plug-ins
  // (3D, 2D, network, sound, ...) and initialize them.
  if (!System->Initialize (argc, argv, NULL))
  @{
    csReport (System->GetObjectRegistry (), CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple1",
    	"Error initializing system!");
    Cleanup ();
    exit (1);
  @}

  // Main loop.
  System->Loop ();

  // Cleanup.
  Cleanup ();

  return 0;
@}
@end example

One important note in the code above: we removed the following line:

@example
  engine->SetLightingCacheMode (0);
@end example

That's because when we are loading from map file we actually want
the lighting information to be read from the cache (if present).
That's because relighting a map can be a time-consuming process.

@node Simple Loading The Map, Simple Locating the Camera, Simple Base Code, Tutorial Simple Map
@subsection Loading The Map
@cindex loading a map
@cindex vfs
@cindex mount point

Here we add the code to load a map. In this example we will load the
@samp{flarge} map which is included with Crystal Space.

In the second tutorial we already mentioned @sc{vfs} (@pxref{VFS}). This
is important in this case too since we are going to load the map from
the virtual filesystem. To do this we first add the following code
right before the creation of the view:

@example
bool Simple::Initialize (int argc, const char* const argv[],
  const char *iConfigName)
@{
  @dots{}
  csReport (object_reg, CS_REPORTER_SEVERITY_NOTIFY,
    	"crystalspace.application.simple1",
  	"Simple Crystal Space Application version 0.1.");

  // Set VFS current directory to the level we want to load.
  VFS->ChDir ("/lev/flarge");
  // Load the level file which is called 'world'.
  if (!loader->LoadMapFile ("world"))
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple1",
    	"Couldn't load level!");
    Cleanup ();
    exit (1);
  @}

  engine->Prepare ();
  csReport (object_reg, CS_REPORTER_SEVERITY_NOTIFY,
    	"crystalspace.application.simple1",
  	"Loaded.");

  @dots{}
@end example

This code will first use @code{iVFS::ChDir()} to set the current
directory in the virtual file system to @file{/lev/flarge}. In the
case of @samp{flarge} this @sc{mount point} is already created in the
config file @file{vfs.cfg}. If this is not the case for your own levels
you can either modify @file{vfs.cfg} or else call @code{iVFS::Mount()}
to map a physical file path (can be a @sc{zip} archive file as well)
to a virtual directory.

The call to @code{iLoader::LoadMapFile()} will take the given filename
(in this case @file{world}) and open it from the current @sc{vfs}
directory. Then it will parse that file and create the geometry which
is specified there.

If this is succesful then you must call @code{iEngine::Prepare()} to
make sure that all lightmaps are correctly loaded from the cache
and other necessary setup work is done (i.e. textures are registered
and so on).

@node Simple Locating the Camera, , Simple Loading The Map, Tutorial Simple Map
@subsection Locating the Camera

@samp{flarge} contains a number of sectors and various objects, and those
are now all loaded in memory. However this is not enough. We also have
to set the camera to some sector and position in that world. In the
previous tutorials we simply used the sector that we just created
and a fixed position in that sector (keep in mind that in Crystal
Space a position in space is always defined as a sector in combination
with a position). When loading a map we can't work that way because
we don't know which sectors are in the map (unless we make an application
that can only read one level, but that's not very flexible) and we
also don't know where we can safely put our camera. In the map files
it is possible to specify one or more starting positions. We will
query the engine for such a starting position and initialize our
view (camera) to that. This happens with the following code:

First add the following to the include section:

@example
#include "iengine/campos.h"
@end example

Then add the following somewhere before the creation of the view:

@example
  // Find the starting position in this level.
  csVector3 pos (0, 0, 0);
  if (engine->GetCameraPositionCount () > 0)
  @{
    // There is a valid starting position defined in the level file.
    iCameraPosition* campos = engine->GetCameraPosition (0);
    room = engine->FindSector (campos->GetSector ());
    pos = campos->GetPosition ();
  @}
  else
  @{
    // We didn't find a valid starting position. So we default
    // to going to room called 'room' at position (0,0,0).
    room = engine->FindSector ("room");
  @}
  if (!room)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple1",
      	"Can't find a valid starting position!");
    Cleanup ();
    exit (1);
  @}
@end example

First we see how many camera positions there were defined in the
map by using @code{iEngine::GetCameraPositionCount()}. If this is 0
then the map didn't define a starting position. In that case we will
assume there is a sector called 'room' and we will start the camera
at (0,0,0) in that sector. But otherwise we will use the first
starting position defined in the map.

This is all. After adding this code this application will now load
the 'flarge' map and display it so you can run around in this level.

