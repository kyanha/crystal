@c -*-texinfo-*-
@node Tutorial Simple 2, Tutorial Simple Map, Tutorial Simple, Tutorials
@section Simple Tutorial 2: Sprites
@cindex Tutorial, Simple, Sprite, VFS, Texture
@cindex Simple Tutorial 2

This tutorial continues on the Simple Tutorial (@pxref{Tutorial Simple}).
In this tutorial we explain a bit about @sc{vfs}, texture management and
how you can add a simple sprite to the simple application.

Crystal Space has the concept of mesh factories and meshes. A mesh is basically
some kind of 3D object. Crystal Space supports several kinds of meshes. In
the previous tutorial we used the thing mesh to create the geometry of
our room. In this tutorial we will use the 3D sprite mesh. A mesh
factory is like a blue-print for a mesh (or sprite). It defines how the mesh
looks and how it animates. Before you can use a mesh you need to have a
mesh factory. Once you have a mesh factory you can create multiple
meshes from this.  @xref{MeshObject}.

In this example we are going to load a mesh factory from disk.  If you have
the standard Crystal Space distribution then you have the file
@file{CS/data/standard.zip}.  In that archive file there is a file called
@samp{sprite1} which contains the definition of our mesh factory.  Extract
it (by using, for instance, the command @samp{unzip -x standard.zip sprite1})
and examine it to see how mesh factories for 3D sprites are defined (mesh
factories for other types of meshes can look different).

But how are we actually going to get that file out of that @sc{zip} archive
from within the Simple application?  This is in fact very easy because Crystal
Space supports the concept of @sc{vfs}.  Take a look at the @sc{vfs}
documentation (@pxref{VFS}) to learn how it works.  Suffice it to say that
@file{standard.zip} is an archive that is, by default, mounted onto the
@sc{vfs} path @file{/lib/std}.  You can see all the mounted @sc{vfs} paths in
the @file{CS/vfs.cfg} file (and you can add more).  So, this means that our
sprite file can be found at the path @file{/lib/std/sprite1}.

If you look at the @file{sprite1} file you can see that it refers to a material
named @samp{spark}.  So we'll have to load that material as well.  This can
also be found in @file{standard.zip} at the path @file{/lib/std/spark.png}.

@menu
* Simple Loading Material:: Loading a Material in Memory
* Simple Loading Mesh Factory:: Loading a Mesh Factory in Memory
* Simple Creating Mesh:: Creating a Mesh from a Factory
@end menu

@node Simple Loading Material, Simple Loading Mesh Factory, Tutorial Simple 2, Tutorial Simple 2
@subsection Loading a Material in Memory
@cindex Tutorial Simple Loading Material
@cindex Simple Loading Material, Tutorial

To make this example a little more interesting the material is going to be
loaded @emph{after} the other setup of the texture manager has been done.
This is not really needed but it illustrates how a game might load materials
dynamically later when the application is already running.  So first we edit
@file{simple.cpp} and add the following in @code{Simple::Initialize()}
(between @code{txtmgr->SetPalette()} and @samp{return true}):

@example
bool Simple::Initialize(int argc, char const* const argv[],
  char const* iConfigName)
@{
  @dots{}
  txtmgr->SetPalette ();

  // Load a texture for our sprite.
  iTextureWrapper* txt = loader->LoadTexture ("spark",
  	"/lib/std/spark.png");
  if (txt == NULL)
  @{
    Printf (CS_MSG_FATAL_ERROR, "Error loading texture!\n");
    Cleanup ();
    exit (1);
  @}
  txt->Register (txtmgr);
  txt->GetTextureHandle()->Prepare ();
  iMaterialWrapper* mat =
    engine->GetMaterialList ()->FindByName ("spark");
  mat->Register (txtmgr);
  mat->GetMaterialHandle ()->Prepare ();

  return true;
@}
@end example

This code first loads a texture in our engine with
@code{iLoader::LoadTexture()}.  The second argument is the file name for our
texture (@sc{vfs} path) and the first argument is how that texture should be
named in the engine.  In this case we use @samp{spark} for that because that's
how the @file{sprite1} definition wants it.

If this loading succeeds we need to register our texture with the
texture manager. This is because we didn't put the loading of our texture
before the @code{engine->Prepare()} call (which takes care of this
registering automatically). The lines @code{txt->Register()} and
@code{Prepare()} can be used at any time while the
application is running to dynamically load additional textures. The
first call to @code{Register()} registers the texture with the texture
manager so that it is aware of this texture. The second call makes
sure that the texture can really be used for 3D rendering by mapping
it to the internal format used by the 3D rasterizer. If you plan to
dynamically add a lot of textures in one step then you should call
@code{Register()} once for every texture and then do
@code{txtmgr->PrepareTextures()} instead. This will be more efficient.

After the texture has been created we still have to create and register
a material. The engine works with materials. The material in this case
is simply a wrapper on top of the texture. But you could also add detail
textures.

@node Simple Loading Mesh Factory, Simple Creating Mesh, Simple Loading Material, Tutorial Simple 2
@subsection Loading a Mesh Factory in Memory
@cindex Tutorial Simple Loading Mesh Factory
@cindex Simple Loading Mesh Factory, Tutorial

Now that we have our material we can use it to load the mesh factory.
Edit @file{simple.cpp} and add the following code in
@code{Simple::Initialize()} (before @samp{return true} and after
the code we just added to load the material):

@example
bool Simple::Initialize (int argc, const char* const argv[],
  const char *iConfigName)
@{
  @dots{}
  // Load a sprite template from disk.
  iMeshFactoryWrapper* imeshfact = loader->LoadMeshObjectFactory (
  	"/lib/std/sprite1");
  if (imeshfact == NULL)
  @{
    Printf (CS_MSG_FATAL_ERROR, "Error loading mesh object factory!\n");
    Cleanup ();
    exit (1);
  @}

  return true;
@}
@end example

This example uses @code{iLoader::LoadMeshObjectFactory()} to load the
mesh factory from the given location. The name of the mesh factory
will be 'box' as that is the name given in the file @file{sprite1} itself.

This is all there is to it. After this call the mesh factory is loaded
in the engine and can be used to create meshes. This is what we'll do
in the next section.

@node Simple Creating Mesh, , Simple Loading Mesh Factory, Tutorial Simple 2
@subsection Creating a Mesh from a Factory
@cindex Tutorial Simple Creating Mesh
@cindex Simple Creating Mesh, Tutorial

First we need to add an additional include to the include section:

@example
#include "imesh/sprite3d.h"
@end example

To create a mesh just add the following code in
@code{Simple::Initialize} (before @code{return true} and after
the code we just added to load the mesh factory):

@example
bool Simple::Initialize (int argc, const char* const argv[],
  const char *iConfigName)
@{
  @dots{}

  // Add the sprite to the engine.
  iMeshWrapper* sprite = engine->CreateMeshObject (
  	imeshfact, "MySprite", room,
	csVector3 (-3, 5, 3));
  csMatrix3 m; m.Identity (); m *= 5.;
  sprite->GetMovable ()->SetTransform (m);
  sprite->GetMovable ()->UpdateMove ();
  iSprite3DState* spstate =
    SCF_QUERY_INTERFACE (sprite->GetMeshObject (), iSprite3DState);
  spstate->SetAction ("default");
  imeshfact->DecRef ();
  spstate->DecRef ();
  sprite->DeferUpdateLighting (CS_NLIGHT_STATIC|CS_NLIGHT_DYNAMIC, 10);

  return true;
@}
@end example

The easiest way to create a mesh is to use @code{engine->CreateMeshObject()}.
This will take care of using the given mesh factory to create the mesh, give
it a name, and correctly place it at the given position in the world.
The name of a mesh can be useful for scripting so that a script can refer
to objects with their names.

Moving meshes (and things) is done through the @code{iMovable} interface to
which you can get a reference by doing @code{sprite->GetMovable()}.  The calls
to @code{SetTransform()} and @code{SetPosition()} set up a transformation
matrix and vector to correctly place the mesh in the room.  In this
particular case we use the identity matrix as a transform and scale it with
five to make the sprite five times bigger.
After doing movement (either updating the sectors or the position) you
@emph{must} call @code{movable->UpdateMove()} to change internal data
structures (i.e. the engine may use this to recalculate visibility information).

If you read the mesh object documentation (see @pxref{MeshObject})
carefully you will see that in order to control visual attributes
of mesh objects you will have to get the @emph{state} interface for
either the object or the factory. In this example we query
@code{iSprite3DState} from the mesh in order to set the default action.
An action is a set of frames and is used to control animation. In our
simple example the sprite has only one frame so there is not much animation
to see.

Whenever you are done with some interface you obtained through
@code{SCF_QUERY_INTERFACE()} you should release the pointer with @code{DecRef()}.

The last call to @code{DeferUpdateLighting} is interesting. If you don't
call this then the sprite will be black. This call tells the engine
to update lighting on this sprite as soon as it is being rendered. You
need to call this function again when lights move or when the object
itself moves. Note that this function is not very expensive. It will only
recalculate lighting when the object is really visible.

This concludes the second Simple tutorial.
You can now go on to the next tutorial (@pxref{Tutorial Simple Map})) to learn
how you can load a level from a file instead of creating your rooms in
the code.
