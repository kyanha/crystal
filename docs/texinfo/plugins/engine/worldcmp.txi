@c -*-texinfo-*-
@node World Components, Portal Engine, csEngine, csEngine
@subsection Components of a World
@cindex World, Components

This section describes the objects used to build a world.  This is useful to
understand the format of the Crystal Space map file
(@pxref{XML File Format}).  To understand this you should know the basics of
the @ref{Portal Engine}.  This section describes the components of the world
independent from the file format, so it is also useful if you want to build a
world from within your program.

The world is built up from the following objects:

@itemize @bullet
@item
@dfn{Sectors}. For details, see the portal engine discussion
(@pxref{Portal Engine}). Basically sectors define a region of space
that can contain several geometrical objects. As opposed to earlier
versions of Crystal Space, a sector does not itself represent geometry.
Instead all geometry in a sector is made from @dfn{Mesh Objects}.
Theoretically a sector is infinite although in practice it is usually
logically bounded by sector walls or a sky object.

@item
@dfn{Mesh Objects}. See the mesh object section for more specific information
about them (@pxref{MeshObject}). Mesh objects represent geometry in some
sector. Everything you can see (walls, actors, particle systems, @dots{}) is
represented by some kind of mesh object. This is a very important concept
in the Crystal Space engine. Mesh objects can also be hierarchical.
A mesh object can have several children which in turn can also have children
and so on. The children of a mesh object are positioned relative to the
parent. So when you move the parent the children will automatically move
with the parent.

@item
@dfn{Mesh Object Factories}. Mesh object factories are objects that
can be used to create mesh objects that inherit characteristics
from their mesh factory. Basically a mesh object factory is like
a blue-print for creating a mesh object. Mesh factories can also
be hierarchical like mesh objects.

@item
@dfn{Portals}. Again see the portal discussion (@pxref{Portal Engine}) but
the idea is that sectors are normally totally independent regions of
space unless you connect them through portals. Portals are currently implemented
inside the @dfn{Thing Mesh Object}. There you can assign a portal to some
sector to a single polygon.

@item
@dfn{Light Sources}.  There are different ways how light is applied to objects
to increase performance.  @xref{Lighting}.

@item
@dfn{Collection Objects}.  These are simply groups of other objects. Do not
confuse them with hierarchical objects.

@item
@dfn{Regions}. A region is also a collection of objects but the purpose
is different (as opposed to collections). A region can contain textures,
materials, mesh objects, mesh factories, lights, collections, sectors,
@dots{}. Regions are useful when you want to load/unload big parts of a world
dynamically. This can be used in cases where the world is too big to fit
in memory and you want to use dynamic loading.

@item
@dfn{Key/value Pairs}. A key/value pair is a
@{@var{key},@var{value}@} tuple describing some game specific concept.
Key/value tuples are represented by a pair of strings. If you have
built levels for Quake before, you are probably familiar with this concept
from Quake's @dfn{Entities}. Almost all objects in the Crystal Space
engine support these key/value pairs so you can attach this kind of
information to anything. Crystal Space itself will not use this information
but your game can query it and perform the appropriate actions.
In theory it is up to your program as to how these key-value tuples
are interpreted.  However, Crystal Space has set some standards to make life
easier for level designers and also to make levels as portable as possible
between different Crystal Space games.  @xref{Keylist Standards}.

@item
@dfn{Nodes}. A node represents a point in space. The engine itself will not
use nodes but a game can use them to represent game specific data.
@end itemize

The @dfn{Thing Mesh Object} is probably the most important mesh object
as it can be used to define how the basic structure of your world looks
like. Here is a list of concepts that are related to @dfn{Things}:

@itemize @bullet
@item
@dfn{Polygons}. @dfn{Things} are made from polygons. To define such an
object you enumerate all polygons that make up the geometry of such thing.

@item
@dfn{Portals}. As mention above portals are a special case of
polygons that point to some other sector (or sometimes the same
sector in case of a mirror).

@item
@dfn{Texture Planes}. Polygons in a thing are texture mapped
using a transformation from object to texture space. A texture
plane describes this transformation. You can directly specify texture
planes but more usually you use uv mapping coordinates to do this.

@end itemize

@anchor{Keylist Standards}
@subsubheading Keylist Standards
@cindex Keylist Standards

This section describes some guidelines for key/value tuples.

The most important key is the @samp{classname} key.  It tells the program the
type of an object.  All the following guidelines are set for special object
classes.  If you don't agree with them, you should use different classnames.

The following classnames are standardized:

@noindent
@@@@@@FIXME: @emph{Write this.}

