@c -*-texinfo-*-

@node MacOS/X Details, , Platform Details, Platform Details
@subsection MacOS/X
@cindex MacOS/X Details

@emph{Written by Eric Sunshine, @email{sunshine@@sunshineco.com}.  Copyright
@copyright{} 1999, 2000, 2001, 2002 by Eric Sunshine.  Last updated
21 December 2002.}

Crystal Space was ported to MacOS/X by Eric Sunshine.  If you have questions or
comments about this port, please contact Eric Sunshine at
@email{sunshine@@sunshineco.com}.  Matt Reda added OpenGL, CoreGraphics, and
CoreAudio drivers to the MacOS/X port.  If you have questions or comments about
these drivers, please contact Matt Reda at @email{mreda@@mac.com} or Eric
Sunshine.

This section contains comprehensive and detailed implementation information
about the MacOS/X port of Crystal Space.  Configuration, compilation,
installation, and usage instructions are also available, @ref{MacOS/X}.

@menu
* MacOS/X Contents:: Contents
* MacOS/X Run-Loop:: Run-Loop
* MacOS/X Cocoa Video Optimization:: Cocoa Video Optimization
* MacOS/X Cocoa Frame Buffer:: Cocoa Frame Buffer
* MacOS/X Dynamic Linking:: Dynamic Linking
@end menu

@node MacOS/X Contents, MacOS/X Run-Loop, MacOS/X Details, MacOS/X Details
@subsubsection Contents
@cindex MacOS/X Contents

The root components of the MacOS/X port of Crystal Space are contained within
these directories:

@itemize @bullet
@item @code{CS/libs/cssys/macosx}
@item @code{CS/plugins/sound/driver/coreaudio}
@item @code{CS/plugins/video/canvas/macosx/cocoa}
@item @code{CS/plugins/video/canvas/macosx/common}
@item @code{CS/plugins/video/canvas/macosx/coregraphics}
@item @code{CS/plugins/video/canvas/macosx/opengl}
@end itemize

Functionally, this port is comprised of two types of platform-specific modules:

@itemize @bullet
@item
The core components which provide low-level platform-specific functionality to
the Crystal Space engine.  These files and resources are located in
@file{CS/libs/cssys/macosx}.

@item
The platform-specific audio and video driver modules.  The files and resources
comprising audio and video plugins reside in the appropriate subdirectories of
@file{CS/plugins}, as indicated above.
@end itemize

The core components provide low-level, platform-specific functionality which
Crystal Space requires.  This includes interfaces to the underlying operating
system as well as higher-level event-loop processing as provided by Cocoa's
@samp{NSApplication} class.  The files comprising this module are:

@table @code
@item OSXAssistant.h
Two files share this name.  The first file resides in
@file{CS/include/cssys/macosx} and declares the abstract @samp{iOSXAssistant}
interface.  This interface declares methods which may be useful to canvases, as
well as methods which are used by the Objective-C application delegate.  The
second file resides in @file{CS/libs/cssys/macosx} and declares
@samp{OSXAssistant} which is a concrete subclass implementing the
@samp{iOSXAssistant} interface.

@item OSXAssistant.cpp
Concrete implementation of the @samp{iOSXAssistant} interface.

@item OSXDelegate.m
@itemx OSXDelegate.h
Implements an Objective-C application delegate.  It is responsible for handling
application-wide Cocoa events and provides convenience facilities for event
interpretation on behalf of plugin modules such as 2D drivers which are the
focus of keyboard and mouse events.

@item OSXLoadLibrary.m
@itemx OSXLoadLibrary.h
Functions which provide dynamic linking facilities of plugin modules.

@item OSXDynamicLibrary.cpp
A thin C++ wrapper over the Objective-C plugin loading facilities.  The
interface between the C++ and Objective-C facilities is implemented via a
pure-C bridge, thus allowing Crystal Space's C++ Shared Class Facility
(@pxref{SCF}) to successfully load plugin modules via the Objective-C dynamic
linking facility.

@item OSXMenu.m
@itemx OSXMenu.h
A utility which generates the application's main menu from information
contained in a configuration file (@file{CS/data/macosx.cfg}).

@item OSXConfigFile.cpp
@itemx OSXConfigFile.h
A thin pure-C wrapper over Crystal Space's C++ configuration file class.  This
wrapper allows the Objective-C @file{OSXMenu} implementation to utilize the
C++ configuration class.

@item OSXTime.cpp
Platform-specific implementation of @code{csGetTicks()} and @code{csSleep()}.

@item OSXUsername.m
Platform-specific functionality for retrieving the username of the logged-in
user.

@item OSXGetUsername.cpp
@itemx OSXGetUsername.h
Implementation of Crystal Space's @code{csGetUsername()} function.  This is a
C++ cover over the functionality provided by @file{OSXUsername.m}.

@item OSXInstPath.m
Platform-specific functionality for retrieving and interpreting the
configuration option @samp{CrystalSpaceRoot}.

@item OSXInstallPath.cpp
@itemx OSXInstallPath.h
Implementation of Crystal Space's @code{csGetInstallPath()} function.  This is
a C++ cover over @file{OSXInstPath.m}, and also provides additional
functionality (such as checking the @samp{CRYSTAL} environment variable).

@item csosdefs.h
Platform-specific definition of operating system services which allows Crystal
Space to access such services in a uniform manner from platform to platform.
Located in @file{CS/include/cssys/macosx}.

@item macosx.cfg
A configuration file which defines platform-specific settings such as the menu
layout appropriate for the application.  This file is actually located in the
@file{CS/data/config} directory which is typically mounted at the virtual
location @file{/config/} (@pxref{VFS}).
@end table

The directory @file{CS/plugins/video/canvas/macosx/cocoa} contains the MacOS/X
Cocoa-based 2D canvas which provides 2D graphics capability to the Crystal
Space engine.  Unlike the lower-level CoreGraphics and OpenGL 2D drivers, this
driver employs only very high-level Cocoa @sc{api} and is consequently more
portable, though slower.  This module is responsible for providing a
hardware-specific frame-buffer into which Crystal Space can draw.  It is also
responsible for actually displaying the frame-buffer in a manner which is
appropriate for the given platform.  The files comprising the Cocoa 2D graphics
library are:

@table @code
@item CocoaDriver2D.cpp
@itemx CocoaDriver2D.h
Defines the class @samp{CocoaDriver2D} which provides an Cocoa-based 2D drawing
surface to Crystal Space.  This is the sole interface through which Crystal
Space communicates with the Cocoa 2D graphics services.

@item CocoaDelegate2D.m
@itemx CocoaDelegate2D.h
Implements the Objective-C portion of the Cocoa-based 2D driver.  This class
is responsible for managing the window and view into which Crystal Space draws.
It is also the window's delegate object.

@item CocoaView.m
@itemx CocoaView.h
An Objective-C subclass of Cocoa's @samp{NSView} class.  This is the view where
the rendered scene from Crystal Space is actually displayed.  This class also
forwards received keyboard and mouse events to the shared @samp{iOSXAssistant}
instance for interpretation and handling.

@item CocoaFrameBuffer.h
An abstract 2D frame buffer class which defines the interface of objects which
are capable of converting a raw Crystal Space frame buffer into an
@code{NSImage}-format frame buffer.

@item CocoaFrameBuffer15.cpp
@item CocoaFrameBuffer15.h
A concrete subclass of @samp{CocoaFrameBuffer} which can convert Crystal Space
@sc{rgb}:555 to MacOS/X @sc{rgba}:4444.

@item CocoaFrameBuffer32.cpp
@item CocoaFrameBuffer32.h
A concrete subclass of @samp{CocoaFrameBuffer} which can convert Crystal Space
@sc{rgb}:888 to MacOS/X @sc{rgba}:8888.

@item CocoaMemory.m
@itemx CocoaMemory.h
Utility functions for manipulation of page-aligned memory blocks for the
@samp{CocoaFrameBuffer} subclasses.
@end table

@node MacOS/X Run-Loop, MacOS/X Cocoa Video Optimization, MacOS/X Contents, MacOS/X Details
@subsubsection Run-Loop
@cindex MacOS/X Run-Loop

The typical Crystal Space application assumes that the programmer has full
control over the application's run-loop.  With most ports of Crystal Space,
this is not a problem since the main run-loop is generally implemented in this
fashion:

@example
bool csDefaultRunLoop(iObjectRegistry*)
@{
  while (!shutdown)
    event_queue->Process();
@}
@end example

With Cocoa, on the other hand, the main run-loop is not accessible to the
programmer and is essentially a black-box.  A simple-minded implementation of
the above functionality for Cocoa might look like this:

@example
bool csDefaultRunLoop(iObjectRegistry*)
@{
  [NSApp run];
@}
@end example

This code launches the Cocoa run-loop but does not address the problem of
periodically processing Crystal Space's event queue.  To solve this problem
@samp{OSXDelegate} artificially injects @dfn{application-defined} events into
the Cocoa event queue and then triggers an invocation of
@code{iEventQueue::Process()} for each such received event.  A single
application-defined event is injected into the event queue in order to begin
the process, and then an event is injected into the queue after each invocation
of @code{iEventQueue::Process()}.

Note that @code{csDefaultRunLoop()} is provided as a convenience for
applications which do not otherwise supply their own run-loop.  Existing Cocoa
applications which already employ the @code{NSApplication}'s black-box run-loop
should not invoke @code{csDefaultRunLoop()}; but should instead arrange to have
@code{iEventQueue::Process()} invoked on a periodic basis via some other
mechanism.

@node MacOS/X Cocoa Video Optimization, MacOS/X Cocoa Frame Buffer, MacOS/X Run-Loop, MacOS/X Details
@subsubsection Cocoa Video Optimization
@cindex MacOS/X Cocoa Video Optimization

This section describes video optionization techniques which have been
implemented for the high-level Cocoa-based 2D driver.  This discussion does not
pertain to the OpenGL or CoreGraphics drivers.

The OpenGL renderer provides the best video performance when
hardware-acceleration is available.  When it is not available, the software
renderer coupled with the CoreGraphics driver provides the next best solution.
As a fallback option there is also a pure Cocoa-based driver which restricts
itself to very high-level Cocoa @sc{api}.  Since the Cocoa-based driver does
not employ lower-level facilities, such as OpenGL or CoreGraphics, it is slower
than those alternatives but it is also more likely to function correctly in
unexpected configurations or in the unusual event that the other two drivers
can not be used.  The pure Cocoa driver is used together with the software
renderer, and only when explicitly requested with the command-line option
@samp{--canvas=crystalspace.graphics2d.cocoa}.  It is never used by default.
Alternately, it can be requested via the configuration file
@file{CS/data/config/user.cfg} with the following property entry.

@example
Global.Video.Software.Canvas = crystalspace.graphics2d.cocoa
@end example

The Cocoa-based graphics driver had its origins on the NextStep operating
system using slow NeXT hardware which was not specially optimized for
game-level graphics performance.  Most of the optimizations employed in this
driver are based upon characteristics of NeXT hardware and are thus probably
not terribly relevant to today's hardware.

Unlike programs on some other platforms, NextStep and OpenStep applications did
not have direct access to the display hardware (except via the highly private
``Interceptor'' @sc{api}), therefore achieving reasonable video performance was
a challenge.  The YellowBox @sc{api} featured in MacOS/X Server 1.0 (Rhapsody)
saw the introduction of the @samp{NSDirectBitmap}, @samp{NSDirectPalette}, and
@samp{NSDirectScreen} classes which were intended to allow lower-level access
to the display hardware, however their interfaces were not fully developed at
that time, and were thus mostly unusable.  Only with the advent of MacOS/X has
access to hardware-level acceleration become possible with the introduction of
the public CoreGraphics and OpenGL @sc{api}s.

With the high-level Cocoa-based driver all drawing to the display is performed
by a separate program called the @dfn{WindowServer}.  Whenever an applications
needs to draw to the screen, it actually sends drawing commands across an
@sc{ipc} connection to the WindowServer, and the WindowServer performs the
drawing on the application's behalf.  This negatively impacts video performance
in essentially three ways.

@itemize @bullet
@item
Inter-process communication (@sc{ipc}) between the application and the
WindowServer is performed serially and tends to be a bottle-neck.  Furthermore,
@sc{ipc} is generally slower than direct memory access.

@item
Image data resides in different address spaces since the application and
WindowServer are separate processes.  This means that the image data must
somehow be copied from one address space to the other.  Copying large amounts
of data is typically very time-consuming.

@item
Since the application does not own the frame-buffer, it also does not have
access to the frame-buffer's data format.  This means that after receiving the
image data, the WindowServer generally has to rearrange it so that it matches
the format of the frame-buffer.  This can be a particularly time-consuming
operation since it may require quite a lot of bit-fiddling over quite a lot of
bytes.  For instance, the application may supply image data in the format
@sc{rrrrggggbbbbaaaa}, which may need to be converted to @sc{rrrrrggggggbbbbb}
by the WindowServer.  A further constraint is that the Cocoa
@samp{NSBitmapImageRep} class typically only understands a limited number of
pixel formats, so even if the frame-buffer's precise format is known, there is
no guarantee that @samp{NSBitmapImageRep} will support it.
@end itemize

The Cocoa-based 2D driver implements video optimizations discussed in the
@cite{NextStep 3.0 WindowServer Release Notes} in order to work around these
problems as much as possible.  The implemented optimizations are:

@itemize @bullet
@item
Image data is aligned on a page boundary, allowing it to be sent to the
WindowServer as out-of-band data in a Mach message.  This is very fast since
the data need only be mapped into the WindowServer's address space rather than
actually being copied.  Page-alignment is guaranteed by using
@code{NSAllocateMemoryPages()}.

@item
Image samples are organized in a meshed format.

@item
Data for each pixel includes alpha information.

@item
12-bit @sc{rgb} data is stored in 16-bits with alpha nybble set to @code{0x0f}.
24-bit @sc{rgb} data is stored in 32-bits with alpha byte set to @code{0xff}.

@item
The image's ``@code{rowbytes} modulo 16'' equals the destination buffer's
``@code{rowbytes} modulo 16'' and the source data pointer is cacheline-aligned
(16 byte aligned) with the destination data pointer.  This is accomplished by
using a Retained-mode window and aligning the left edge of the destination
view on an x-coordinate which is a multiple of 8 for 12-bit color depth, and a
multiple of 4 for 24-bit color depth.

@item
The Cocoa @samp{NSView} subclass which displays the image uses the identity
transform.  That is, it is not flipped, scaled, rotated, etc.

@item
The method @code{-[NSBitmapImageRep draw]} is used to blit the image in the
destination view.  This ensures that the image data is passed to to the
WindowServer as out-of-band data in a Mach message via the proprietary
@samp{nextimage} PostScript operator.
@end itemize

The bulk of these these optimizations were geared toward traditional NeXT
(@code{m68k}) hardware and probably have little or no significance on modern
hardware.  In some cases using these optimizations on original NeXT hardware,
could result in a very dramatic improvement in video performance.

Some further optimizations are employed which are not discussed in the
WindowServer release notes.  These include:

@itemize @bullet
@item
Disabling PostScript @dfn{clipping} in the view in which the image is
displayed.  (This item was applicable to only NextStep.  In Cocoa clipping can
not be disabled.)

@item
Allocating a @dfn{graphics state} (or `gstate', in original PostScript
terminology) for the view.  This saves valuable time whenever focusing on the
view, though at the expense of memory.  Without the allocated graphics state
cache, the view would otherwise have to perform certain time-consuming
preparation tasks each time before drawing.

@item
The window which displays the view is `Retained' rather than `Buffered'.  This
means that drawing occurs directly on-screen rather than going into a
backing-store which would then have to be flushed to the screen with an
expensive memory copy as an extra step.
@end itemize

It is worth noting that none of the aforementioned video optimizations deal
with 2-bit gray, 8-bit gray, or 8-bit color.  Consequently this implementation
does not even attempt to perform any optimization in these cases and simply
hands the WindowServer 12-bit color data and lets the WindowServer massage it
as appropriate.  The upshot is that for displays other than 12- and 24-bit
@sc{rgb}, video performance will probably suffer since the WindowServer will
have to massage and dither color data itself.  It is further worth noting,
though, that the majority of NextStep, OpenStep and MacOS/X Server 1.0
(Rhapsody) installations on NeXT and Intel hardware used either 12- or 24-bit
@sc{rgb} frame buffers so the actual impact of this limitation may not have
been particularly severe.

@node MacOS/X Cocoa Frame Buffer, MacOS/X Dynamic Linking, MacOS/X Cocoa Video Optimization, MacOS/X Details
@subsubsection Cocoa Frame Buffer
@cindex MacOS/X Cocoa Frame Buffer

This section describes the frame buffer format managed by the low-level
Cocoa-based 2D driver and the manner in which the pixel data is manipulated.
This discussion does not pertain to the OpenGL or CoreGraphics drivers.

With few exceptions, most NextStep, OpenStep, and MacOS/X Server 1.0 (Rhapsody)
installations are configured for @dfn{true-color} rather than palletized color.
However, true-color is rather relative in the case of the Cocoa-based 2D
graphics driver since the @samp{NSBitmapImageRep} class supports only a limited
number of configurations for image data.  Historically, on NextStep, these
configurations were limited to:

@quotation
@multitable @columnfractions .15 .85
@item 2-bit gray @tab @code{NX_TwoBitGrayDepth}
@item 8-bit gray @tab @code{NX_EightBitGrayDepth}
@item 8-bit color @tab @code{NX_EightBitRGBDepth} (via @sc{rgb} palette)
@item 12-bit color @tab @code{NX_TwelveBitRGBDepth}
@item 24-bit color @tab @code{NX_TwentyFourBitRGBDepth}
@end multitable
@end quotation

OpenStep and MacOS/X Server 1.0 (Rhapsody) took a stab at providing more
comprehensive color depth support, but in their released state, these
facilities provided little additional assistance and consequently are not
discussed further.

At the lowest level, the WindowServer itself supports additional configurations
and adjusts appropriately to the underlying hardware.  Historically, the
high-level Cocoa @sc{api}, however, did not have access to this information
(without resorting to private and unsupported @sc{api}), and consequently did
not make use of it.  Furthermore, even in 8-bit color mode the application had
neither access to, nor knowledge of the palette.  In this case the 8-bit number
is simply an opaque color value of which no further interpretation can be made.

To further complicate matters, in order to achieve decent video performance,
image data sent to the WindowServer needs to be specially formatted, as
discussed in the video optimizations section,
@ref{MacOS/X Cocoa Video Optimization}.  In particular, for optimal
performance, 12-bit and 24-bit data must include an alpha channel and all alpha
bits must be set to one.

Unfortunately the Crystal Space software renderer is unable to produce image
data in a format usable by the WindowServer when video performance is a
concern.  This is unfortunate since it means that the Cocoa-based 2D driver
must itself massage the data into a format suitable to @samp{NSBitmapImageRep}
and the WindowServer.  This can be a time consuming operation.

Crystal Space's software renderer is unable to produce the proper image format
for several reasons.

@itemize @bullet
@item
The rendering engine has no facilities for forcing certain unused bits to
conform to a certain value.  In this case the alpha bits need to be set to one.

@item
The rendering engine does not support the common @samp{NSBitmapImageRep} pixel
configurations.  For instance, the software renderer has modes for only 8-bit,
15-bit, and 16-bit, but not the 12-bit @sc{rgb} data which is expected by the
Cocoa image classes.

@item
For performance reasons of its own, the software renderer is hard-coded to
produce pixel data in the format @sc{nbgr} for big-endian and @sc{nrgb} for
little-endian (as seen from a @sc{cpu} register perspective), where `@sc{n}'
represents unused and potentially uninitialized bits.  Neither of these pixel
formats is suitable for the Cocoa image classes.
@end itemize

The upshot is that even though the @samp{NSBitmapImageRep} class supports
true-color data and Crystal Space is capable of generating true-color data, the
formats are incompatible from the perspective of a Cocoa-based 2D driver.

There are at least a couple of solutions to the problem of pixel-format
mismatch between Crystal Space's software renderer and @samp{NSBitmapImageRep}:

@itemize @bullet
@item
Parameterize the software renderer's hard-coded constants such that those
constants can be modified at compile-time, and then build several versions of
the renderer, each geared for a particular pixel format.  To some extent, this
approach has already been implemented for a few fixed 8-, 15-, 16-, and 32-bit
pixel formats, however extending it to handle the many existing (and potential
future) MacOS/X formats could become quickly nightmarish, as well as lead to
bloat.

One other obstacle to this approach is that on 32-bit @sc{rgb} big-endian
hardware, the @samp{NSBitmapImageRep} expects the pixel data to occupy the
high-byte of the longword which represents each pixel.  Historically, the
software renderer has had trouble dealing with pixel data which occupies the
high-byte since most programmers working on the renderer only test it with
pixel formats which do not occupy that byte.  As a consequence, it is common
for breakage to occur as changes are made to the renderer.  Although the
maintainer of the Cocoa-based driver has painstakingly eradicated all known
bugs of this nature in the software renderer, the framework is still quite
fragile and breaks easily.

@item
Allow the renderer to generate pixel data in one of its hard-coded formats and
then massage the data into a format suitable for @samp{NSBitmapImageRep} and
the WindowServer in a post-processing step just before sending it off to the
WindowServer.  The downside to this approach is that post-processing can be
time-consuming as well as memory intensive since such processing often involves
copying the pixel data from one frame-buffer to another.  (The double
frame-buffer requirement is a limitation of the way in which many Crystal Space
applications deal with the frame-buffer.  These applications expect that the
frame-buffer data will remain valid and unmodified from frame to frame, thus
massaging the data in-place is not a viable approach.) The benefit of the
post-processing approach, on the other hand, is that it is much less fragile
than parameterizing the renderer.
@end itemize

The Cocoa-based driver employs the second approach since it is more robust and
reliable.  In the interest of video performance, whenever possible, the driver
attempts to perform as much of the time-consuming post-processing work in a
one-time initialization step.  The additional benefit of performing some of the
time-consuming work in an initialization step is that the actual
post-processing step becomes somewhat simplified.

The Cocoa-based 2D driver is automatically configured to generate 32-bit
@sc{rgb} image data when running on machines configured for 24- or 32-bit
@sc{rgba} display.  Conversion of Crystal Space 32-bit @sc{rgb}:888 data to
@sc{rgba}:8888 needed by @samp{NSBitmapImageRep} and the WindowServer is
encapsulated in the class @samp{CocoaFrameBuffer32}.  Just prior to flushing
the image data to the display, @samp{CocoaFrameBuffer32} transmutes the pixel
data into a format suitable for @samp{NSBitmapImageRep}.  It also ensures that
the alpha byte is set to @code{0xff}, as explained in the video optimizations
section, @ref{MacOS/X Cocoa Video Optimization}.

The 2D driver is automatically configured to generate 15-bit @sc{rgb} image
data when running on machines configured for 12-, 15-, or 16-bit @sc{rgba}
display (or some other unrecognized configuration).  Conversion of Crystal
Space 15-bit @sc{rgb}:555 data to @sc{rgba}:4444 needed by
@samp{NSBitmapImageRep} and the WindowServer is encapsulated in the class
@samp{CocoaFrameBuffer15}.  In order to avoid time-consuming bit manipulation
of image data, this class generates a translation table which equates each
possible @sc{rgb}:555 color value with the corresponding @sc{rgba}:4444 color.
The alpha nybble of the translated color contains @code{0x0f} as explained in
the video optimizations section, @ref{MacOS/X Cocoa Video Optimization}.  To
translate incoming @sc{rgb}:555 data to @sc{rgba}:4444,
@samp{CocoaFrameBuffer15} enumerates over each color value in the incoming
image data, looks up its corresponding @sc{rgba}:4444 value in the translation
table and outputs that color.  This technique is both simple and reasonably
efficient.

@node MacOS/X Dynamic Linking, , MacOS/X Cocoa Frame Buffer, MacOS/X Details
@subsubsection Dynamic Linking
@cindex MacOS/X Dynamic Linking

On most platforms, symbols are private to a plugin module unless explicitly
exported.  However, on MacOS/X, symbols in plugin modules are typically public
by default.  Prior to MacOS/X 10.1, symbols in plugins existed in a @dfn{flat
namespace} shared by the application and all plugin modules.  This means that
it was possible for symbols defined in one plugin to conflict with those
defined in the application or in other plugins.  As of MacOS/X 10.1, Apple
introduced the concept of @dfn{two-level namespace}, in which symbols for a
plugin exist within that plugin's own namespace, thus eliminating the problem
of symbolic conflicts between plugins and the application, or plugins and other
plugins.

On other platforms, where plugin symbols are private by default, plugin modules
are themselves link against any required static libraries in order to satisfy
external symbolic references.  Historically, this differed from pre-10.1
MacOS/X in which it was customary to link the application against any libraries
which might have been required by plugin modules, rather than linking the
plugin modules, themselves, against the libraries.  There are a couple problems
with this older approach.

@itemize @bullet
@item
It is not always possible to know ahead of time which static libraries will be
required by a set of plugin modules since those modules may come from
independent sources.  Thus, it is neither practical nor always possible to
link the application against the correct set of static libraries.  As a
corollary, this often means having to add special cases to otherwise general
makefiles in order to specify an extended set of static libraries when invoking
the static linker to build the application's executable image.

@item
Even though an application may be linked against a static library for the
purpose of making that library available to a plugin module, often the
application itself makes no reference to symbols within the library.  In order
to force the linker to actually incorporate the library into the application
some artificial mechanism for forcing references to symbols within the library
must be invented.  Often this involves employing special switches when
invoking the linker or manually faking hard symbolic references within the
source code itself.

@item
It is highly fragile and often problematic since even a small change to the
external symbolic references of a plugin module may require that the
application be relinked against a different set of static libraries.
@end itemize

The approach used by other platforms, where plugin modules are linked directly
against any static libraries which they require, has several advantages.

@itemize @bullet
@item
Plugin modules are self-contained since external symbolic references have
already been satisfied, thus there is no need for the application to attempt to
satisfy those references.

@item
An application needs to be linked only against the set of libraries which it
requires.  There is no need to try to fathom the set of libraries which
@emph{might} one day be required by plugin modules.  As a corollary there is
no need to invent artificial mechanisms for forcing libraries to be linked into
the application which are not required by the application itself.

@item
It is much more robust since a change in the symbolic requirements of any
given plugin module will not require re-linking of the application against
a new set of libraries.
@end itemize

Prior to the introduction of two-level namespaces with MacOS/X 10.1, in order
to avoid the fragility of flat namespaces, and in order to avoid having to
invent special case solutions to work around these problems, the MacOS/X port
of Crystal Space emulated the model of dynamic linking used on other platforms.
This was accomplished by linking plugin modules against the static libraries
which they require, rather than linking those libraries into the application.

The one major pitfall which makes employment of this approach difficult in a
flat namespace, is that of symbolic conflicts where the same symbol is defined
in more than one place.  This problem can occur, for instance, when more than
one plugin module links with the same static library, and when both a plugin
module and the application link against the same static library.  To work
around this problem, the MacOS/X port takes advantage of @sc{dyld}'s
@samp{NSLinkEditErrorHandlers} which allows the loader to ignore duplicate
symbols at load time.

Although this special manual symbol management is not required with two-level
namespaces, the functionality is nevertheless retained for backward
compatibility with older MacOS/X releases.
