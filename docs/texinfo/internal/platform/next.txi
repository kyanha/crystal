@c -*-texinfo-*-

@c Unforunately, TeX does not grok this macro in @cindex or @section, etc. :-(
@macro NeXT{}
@sc{n}e@sc{xt}
@end macro

@node NeXT Details, OS2 Details, Platform Details, Platform Details
@subsection MacOS/X Server, OpenStep, NextStep
@cindex @sc{n}e@sc{xt} Details
@cindex MacOS/X Server Details
@cindex OpenStep Details
@cindex NextStep Details

@emph{Written by Eric Sunshine, @email{sunshine@@sunshineco.com}.  Copyright
@copyright{} 1999, 2000 by Eric Sunshine.  Last updated 22 December 2000.}

This section contains comprehensive and detailed implementation information
about the MacOS/X Server, OpenStep 4.2, and NextStep 3.3 ports of Crystal
Space.  Configuration, compilation, installation, and usage instructions are
also available, @ref{NeXT}.

Crystal Space was ported to MacOS/X Server, OpenStep, and NextStep by Eric
Sunshine in February of 1999.  If you have questions or comments about this
port, please contact Eric Sunshine at @email{sunshine@@sunshineco.com}.

This project may be built for any of the architectures which are supported by
the standard developer tools, as summarized below.

@quotation
@multitable @columnfractions .20 .30 .30
@item @emph{Platform} @tab @emph{Architectures} @tab @emph{Tested}
@item MacOS/X Server @tab @code{i386 ppc} @tab @code{i386 ppc}
@item OpenStep @tab @code{i386 m68k sparc} @tab @code{i386 m68k}
@item NextStep @tab @code{i386 m68k sparc hppa} @tab @code{i386 m68k sparc}
@end multitable
@end quotation

It is possible to build multi-architecture binaries (@sc{mab}) by using the
standard Apple/@NeXT{} makefile variable @samp{TARGET_ARCHS} on the
command-line.  For a full discussion of this facility see the compilation
instructions.  @xref{NeXT Architectures}.

This implementation makes use of public AppKit @sc{api} to interface with the
Window Server for all animation and event handling.  It does not make use of
the private, undocumented, and unsupported Interceptor library.

A future version of the MacOS/X Server port may make use of the new public
@sc{api} for direct frame-buffer access provided by the @samp{NSDirectBitmap},
@samp{NSDirectPalette}, and @samp{NSDirectScreen} classes.

@menu
* NeXT Directories:: Directories
* NeXT Files:: Files
* NeXT Run-Loop:: Run-Loop
* NeXT Video Optimization:: Video Optimization
* NeXT Frame Buffer:: Frame Buffer
* NeXT Dynamic Linking:: Dynamic Linking
* NeXT Notes:: Final Notes
@end menu

@node NeXT Directories, NeXT Files, NeXT Details, NeXT Details
@subsubsection Directories
@cindex @sc{n}e@sc{xt} Directories

The root components of this port of Crystal Space are contained within these
directory hierarchies:

@itemize @bullet
@item @code{CS/libs/cssys/next}
@item @code{CS/plugins/video/canvas/next}
@end itemize

@noindent
Relative to each directory, in platform-specific subdirectories, are the the
files comprising the associated MacOS/X Server, OpenStep, and NextStep
components.  The contents of the subdirectories of @file{CS/libs/cssys/next}
and @file{CS/plugins/video/canvas/next} are summarized below.

@quotation
@multitable @columnfractions .12 .88
@item @emph{Directory}
@tab @emph{Contents}
@item @code{shared}
@tab Resources common to MacOS/X Server, OpenStep & NextStep
@item @code{macosxs}
@tab Resources specific to MacOS/X Server
@item @code{openstep}
@tab Resources specific to OpenStep & MacOS/X Server
@item @code{nextstep}
@tab Resources specific to NextStep
@end multitable
@end quotation

Functionally, this port is comprised of two distinct system-dependent modules:

@itemize @bullet
@item
The core components which provide low-level platform-specific functionality to
the Crystal Space engine.  These files and resources are located in
platform-specific subdirectories of @file{CS/libs/cssys/next}.  For instance,
files specific to the OpenStep port reside in
@file{CS/libs/cssys/next/openstep}, whereas files common to all three
platforms reside in @file{CS/libs/cssys/next/shared}.

@item
The library which provides 2D graphics capability into which Crystal Space
renders its images.  These files and resources are located in
platform-specific subdirectories of @file{CS/plugins/video/canvas/next}.  For
instance, files specific to the NextStep port reside in
@file{CS/plugins/video/canvas/next/nextstep}, whereas files common to all
three platforms reside in @file{CS/plugins/video/canvas/next/shared}.
@end itemize

@node NeXT Files, NeXT Run-Loop, NeXT Directories, NeXT Details
@subsubsection Files
@cindex @sc{n}e@sc{xt} Files

This port of Crystal Space makes use of a number of platform-specific
makefiles which are located in @file{CS/libs/cssys/next}.  A makefile exists
for each target platform.

@quotation
@multitable @columnfractions .17 .83
@item @code{macosxs.mak}
@tab Defines MacOS/X Server-specific build attributes.
@item @code{openstep.mak}
@tab Defines OpenStep-specific build attributes.
@item @code{nextstep.mak}
@tab Defines NextStep-specific build attributes.
@item @code{next.mak}
@tab Common to all three platforms; controls the build.
@end multitable
@end quotation

An additional makefile, @file{CS/plugins/video/canvas/next/next2d.mak}, is
common to all three platforms and controls the build process for the 2D
display driver.

The core components provide low-level platform-specific functionality which
Crystal Space requires.  This includes interfaces to the underlying operating
system as well as higher-level event-loop processing as provided by the
AppKit's @samp{Application} and @samp{NSApplication} classes.  The files
comprising this module are:

@table @code
@item NeXTSystemDriver.h
Defines @samp{NeXTSystemDriver} and its subclass @samp{SysSystemDriver} which
all ports of Crystal Space must supply.  This is the sole interface through
which Crystal Space accesses platform-specific functionality.

@item NeXTSystemDriver.cpp
Implements methods of @samp{NeXTSystemDriver} which are common to MacOS/X
Server, OpenStep, and NextStep.

@item NeXTSystemLocal.cpp
Implements methods of @samp{NeXTSystemDriver} which are particular to a
specific platform; either MacOS/X Server, OpenStep, or NextStep.

@item NeXTSystemInterface.h
Declares a pure @sc{scf} interface named @samp{iNeXTSystemDriver} for
accessing @samp{NeXTSystemDriver} from other modules via the @sc{scf}
facility.  @xref{SCF}.

@item NeXTDelegate.cpp
@itemx NeXTDelegate.h
An Objective-C class which acts as the delegate to both the @samp{Application}
(or @samp{NSApplication}) object and the animation window.  This object is
responsible for handling AppKit events and forwarding them to Crystal Space
via @samp{NeXTSystemProxy}.  Termination requests by the user on the AppKit
side are also forwarded.

@item NeXTLoadLibrary.cpp
Functions which provide dynamic linking facilities for MacOS/X Server,
OpenStep, and NextStep.

@item NeXTMenu.cpp
@itemx NeXTMenu.h
A utility which generates the application's main Menu from @sc{ini}-style
configuration information.

@item NeXTMenu.cfg
An @sc{ini}-style configuration file which defines a menu layout appropriate
to the platform.  This file is actually located in the virtual directory
@file{/config/}, which is typically mounted at the physical location
@file{CS/data/config}.

@item NeXTTime.cpp
Platform-specific implementation of @code{csSystemDriver::Time()} which works
on MacOS/X Server, OpenStep, and NextStep.

@item malloc.h
A header which works around Crystal Space's misuse of the deprecated
@file{<malloc.h>} header.

@item csosdefs.h
Implementation of platform-specific operating system functionality.  Allows
Crystal Space to treat the operating system services abstractly.  Located in
@file{CS/include/cssys/next} and included by @file{CS/include/cssysdef.h}.
@end table

The @NeXT{} 2D graphics library in @file{CS/plugins/video/canvas/next}
provides 2D graphics capability to the Crystal Space engine.  This library is
responsible for providing a hardware-specific frame-buffer into which Crystal
Space can draw.  It is also responsible for actually displaying the
frame-buffer in a manner which is appropriate for the given platform.  The
files comprising the 2D graphics library are:

@table @code
@item NeXTDriver2D.h
Defines the class @samp{NeXTDriver2D} which provides 2D drawing surface to
Crystal Space.  This is the sole interface through which Crystal Space
communicates with the 2D graphics services.

@item NeXTDriver2D.cpp
Implements methods of @samp{NeXTDriver2D} which are common to MacOS/X Server,
OpenStep, and NextStep.

@item NeXTLocal2D.cpp
Implements methods of @samp{NeXTDriver2D} which are particular to a specific
platform; either MacOS/X Server, OpenStep, or NextStep.

@item NeXTView.cpp
@itemx NeXTView.h
An Objective-C subclass of the AppKit's @samp{View} (or @samp{NSView} class.
This is the view where the animation is actually displayed.  Forwards events
to @samp{NeXTDelegate} which propagates them up to Crystal Space.

@item NeXTFrameBuffer.cpp
@itemx NeXTFrameBuffer.h
A mostly abstract 2D frame buffer class which defines the interface of objects
which are capable of converting a raw Crystal Space frame buffer into a
@NeXT{}-format frame buffer.

@item NeXTFrameBuffer15.cpp
@item NeXTFrameBuffer15.h
A concrete subclass of @samp{NeXTFrameBuffer} which can convert Crystal Space
@sc{rgb}:555 to @NeXT{} @sc{rgba}:4444.

@item NeXTFrameBuffer32.cpp
@item NeXTFrameBuffer32.h
A concrete subclass of @samp{NeXTFrameBuffer} which can convert Crystal Space
@sc{rgb}:888 to @NeXT{} @sc{rgba}:8888.
@end table

@node NeXT Run-Loop, NeXT Video Optimization, NeXT Files, NeXT Details
@subsubsection Run-Loop
@cindex @sc{n}e@sc{xt} Run-Loop

The design of Crystal Space assumes that the programmer has full control over
the application's run-loop.  It further assumes that the run-loop is
re-entrant.  The Crystal Space Windowing System, or @sc{csws} (@pxref{CSWS}),
for instance, recursively invokes the run-loop each time it initiates a modal
session, such as when a modal panel is placed on-screen.

With most ports of Crystal Space, this is not a problem since the main
run-loop is generally implemented in this fashion:

@example
SysSystemDriver::Loop() @{
    while (!done) @{
        ProcessEvents(); // @r{For platform-specific event handling.}
        CheckKeyboard();
        CheckMouse();
        NextFrame();     // @r{Tell engine to render the next frame.}
    @}
@}
@end example

In this simple form it is generally safe to call @code{Loop()} recursively.
Even if there is some risk involved with recursive invocations, such
situations can usually be handled specially since the run-loop is under
programmer control.

With the AppKit, on the other hand, the main run-loop is not accessible to the
programmer and is essentially a black-box.  Furthermore, the application's
@samp{-run} method which encapsulates the run-loop is not re-entrant.  In
other words, the naive implementation of @code{Loop()} as shown below does not
work properly when called recursively.

@example
SysSystemDriver::Loop() @{
    [NXApp run];
@}
@end example

This makes it difficult to conform to Crystal Space's assumptions about the
run-loop.  Consequently it was necessary to work around the AppKit's
limitation on recursive invocation of the application's run-loop.

To do so, a category was introduced which extends the AppKit's application
class with the introduction of a method named @samp{-runRecursively:}.  This
method, as the name implies, provides the capability of recursive run-loop
invocation by patching and overriding the default run-loop behavior.  The
implementation of this method is contained in @file{NeXTSystemProxy.cpp}.

In the long run, it may be desirable to re-engineer Crystal Space so that it
runs as a client in a surrounding application framework, rather than forcing
the application environment into the subordinate position.  This would be more
in line with today's ``windowed'' computing environments where most
application specific functionality is contained within a generic application
framework.  The current design is geared more toward outmoded command-line
environments, such as @sc{dos} or Unix, where the program can simply take
control of the entire environment without regard to other outside factors.

@node NeXT Video Optimization, NeXT Frame Buffer, NeXT Run-Loop, NeXT Details
@subsubsection Video Optimization
@cindex @sc{n}e@sc{xt} Video Optimization

Unlike programs on some other platforms, OpenStep and NextStep applications do
not have direct access to the display hardware, thus video performance
suffers.  As MacOS/X Server and MacOS/X evolve, they may include facilities
for accessing display hardware directly, but at this time these facilities
have not been finalized.

Under MacOS/X Server, OpenStep, and NextStep, all drawing to the display is
performed by a separate program called the WindowServer.  Whenever an
applications needs to draw to the screen, it actually sends drawing commands
across an @sc{ipc} connection to the WindowServer and the WindowServer
performs the drawing on the application's behalf.  This negatively impacts
video performance in essentially three ways.

@itemize @bullet
@item
Inter-process communication (@sc{ipc}) between the application and the
WindowServer is performed serially and tends to be a bottle-neck.
Furthermore, @sc{ipc} is generally slower than direct access.

@item
Image data resides in different address spaces since the application and
WindowServer are separate processes.  This means that the image data must be
copied from one address space to the other.  Copying large amounts of data is
typically very time-consuming.

@item
Since the application does not own the frame-buffer, it also does not have
access to the frame-buffer's data format.  This means that after receiving the
image data, the WindowServer generally has to rearrange it so that it matches
the format of the frame-buffer.  This can be a particularly time-consuming
operation since it may require quite a lot of bit-fiddling over quite a lot of
bytes.  For instance, the application may supply image data in the format
@sc{rrrrggggbbbbaaaa}, which may be converted to @sc{rrrrrggggggbbbbb} by the
WindowServer.
@end itemize

This port of Crystal Space implements video optimizations discussed in the
@cite{NextStep 3.0 WindowServer Release Notes} in order to work around these
problems as much as possible.  The optimizations are:

@itemize @bullet
@item
Image data is aligned on a page boundary, allowing it to be sent to the window
server as out-of-band data in a Mach message.  This is very fast since the
data need only be mapped into the WindowServer's address space rather than
actually copied.  Such alignment is guaranteed by using
@code{NSAllocateMemoryPages()} on MacOS/X & OpenStep, and @code{vm_allocate()}
on NextStep.

@item
Image samples are organized in a meshed format.

@item
Data for each pixel includes alpha information.

@item
12-bit @sc{rgb} data is stored in 16-bits with alpha nybble set to
@code{0x0f}.@*
24-bit @sc{rgb} data is stored in 32-bits with alpha byte set to @code{0xff}.

@item
The image's ``@code{rowbytes} modulo 16'' equals the destination buffer's
``@code{rowbytes} modulo 16'' and the source data pointer is cacheline-aligned
(16 byte aligned) with the destination data pointer.  This is accomplished by
using a Retained-mode window and aligning the left edge of the destination
View on an x-coordinate which is a multiple of 8 for 12-bit color depth, and a
multiple of 4 for 24-bit color depth.

@item
The view displaying the image uses the identity transform.  That is, it is not
flipped, scaled, rotated, etc.

@item
On MacOS/X Server and OpenStep, @code{-[NSBitmapImageRep draw]} is used to
draw the image in the destination view.  On NextStep, @code{-[NXBitmapImageRep
draw]} (which is a cover for @code{NXDrawBitmap()}) is used.  This ensures
that the image data is passed to to the WindowServer as out-of-band data in a
Mach message via the proprietary @samp{nextimage} PostScript operator.
@end itemize

Many of these optimizations are actually geared toward traditional @NeXT{}
(@code{m68k}) hardware and may not be as effective on other platforms such as
Intel.  In some cases using these optimizations on original @NeXT{} hardware,
can result in a very dramatic improvement in video performance.  In all cases,
it is presumed that the WindowServer has been hand-optimized to perform well
on each platform when presented with data meeting these prerequisites.
Therefore following these guidelines seem sensible even for non-@NeXT{}
hardware.

Some further optimizations are employed which are not discussed in the
WindowServer release notes.  These include:

@itemize @bullet
@item
Disabling PostScript @dfn{clipping} in the view in which the image is
displayed.  (Not applicable to MacOS/X Server or OpenStep, since clipping can
not be disabled via the AppKit @sc{api} on these platforms.)

@item
Allocating a PostScript @dfn{gstate} for the view.  This saves valuable time
whenever focusing on the view, though at the expense of memory.  Without the
gstate the view has to perform certain time-consuming actions each time it is
focused upon.

@item
The Window which displays the view is Retained rather than Buffered.  This
means that drawing occurs directly on-screen rather than going to a
backing-store which would then need be flushed to the screen with an expensive
memory copy.
@end itemize

It is worth noting that none of the aforementioned video optimizations deal
with 2-bit gray, 8-bit gray, or 8-bit color.  Consequently this implementation
does not even attempt to perform any optimization in these cases and simply
hands the WindowServer 12-bit color data and lets the WindowServer massage it
as appropriate.  The upshot is that for displays other than 12- and 24-bit
@sc{rgb}, video performance will probably suffer since the WindowServer will
have to massage and dither color data itself.  It is further worth noting,
though, that the majority of OpenStep and NextStep installations on Intel and
@NeXT{} hardware use either 12- or 24-bit @sc{rgb} frame buffers so the actual
impact of this limitation may not be particularly severe.

@node NeXT Frame Buffer, NeXT Dynamic Linking, NeXT Video Optimization, NeXT Details
@subsubsection Frame Buffer
@cindex @sc{n}e@sc{xt} Frame Buffer

With few exceptions, most MacOS/X Server, OpenStep, and NextStep are
configured for @dfn{true-color} rather than palettized color.  However,
true-color is rather relative in this case since the AppKit supports only a
limited number of configurations for image data.  In particular, these are:

@quotation
@multitable @columnfractions .15 .85
@item 2-bit gray @tab @code{NX_TwoBitGrayDepth}
@item 8-bit gray @tab @code{NX_EightBitGrayDepth}
@item 8-bit color @tab @code{NX_EightBitRGBDepth} (via @sc{rgb} palette)
@item 12-bit color @tab @code{NX_TwelveBitRGBDepth}
@item 24-bit color @tab @code{NX_TwentyFourBitRGBDepth}
@end multitable
@end quotation

MacOS/X Server and OpenStep take a stab at providing more comprehensive color
depth support, but in their current state, these facilities provide little
additional assistance and, consequently, are not discussed further.

At the lowest level, the WindowServer itself supports additional
configurations and adjusts appropriately to the underlying hardware.  The
high-level application, however does not have access to this information
(without resorting to private and unsupported @sc{api}), and consequently can
not make use of it.  Furthermore, even in 8-bit color mode the application has
neither access to, nor knowledge of the palette.  In this case the 8-bit
number is simply an opaque color value allowing no further interpretation.

To further complicate matters, in order to achieve decent video performance,
image data sent to the WindowServer needs to be specially formatted, as
discussed in the video optimizations section, @ref{NeXT Video Optimization}.
In particular, for optimal performance, 12-bit and 24-bit data must include an
alpha channel and all alpha bits must be set to one.

Unfortunately Crystal Space is unable to produce image data in a format usable
by the WindowServer when video performance is a concern.  This is unfortunate
since it means that this port must itself massage the data into a format
suitable to the WindowServer, which can be a time consuming operation.
Crystal Space is unable to produce the proper image format for two reasons.

@itemize @bullet
@item
The rendering engine has no facilities for forcing certain unused bits to
conform to a certain value.  In this case the alpha bits need to be set to
one.  It does have facilities for masking off the appropriate unused bits, but
this is insufficient since the alpha bits would be uninitialized.

@item
The rendering engine does not support all of the common AppKit display modes.
For instance, the engine can generate 8-bit, 15-bit, and 16-bit, but not the
12-bit @sc{rgb} data which is quite common on MacOS/X Server, OpenStep, and
NextStep platforms.
@end itemize

The upshot is that even though MacOS/X Server, OpenStep, and NextStep support
true-color data and Crystal Space is capable of generating true-color data,
the formats are incompatible.

One solution to the problem is to allow Crystal Space to generate 15-bit or
16-bit true-color data and then have port-specific code massage it into an
appropriate format immediately before passing it to the WindowServer for each
animation frame.  However in the interest of video performance, this is
probably a sub-optimal solution since it tends to be quite time-consuming.
Rather than performing the time-consuming massaging of image data prior to
flusing it to the display, this port attempts to perform most of the
time-consuming work during a one-time initialization phase which simplifies
conversion from Crystal Space format image data to WindowServer format data,
as well as enhancing the speed of the operation.

Crystal Space is automatically configured to generate 32-bit @sc{rgb} image
data when running on MacOS/X Server, OpenStep, and NextStep machines
configured for 24-bit @sc{rgba} display.  Conversion of Crystal Space 32-bit
@sc{rgb}:888 data to @sc{rgba}:8888 needed by the WindowServer is encapsulated
in the class @samp{NeXTFrameBuffer32}.  This class instructs the Crystal Space
renderer to generate @sc{rgb} data in the first three bytes of a four-byte
pixel entity.  Just prior to flushing the image data to the display,
@samp{NeXTFrameBuffer32} places @code{0xff} in every fourth byte to satisfy
the requirement that the alpha byte be set to @code{0xff}, as explained in the
video optimizations section, @ref{NeXT Video Optimization}.  This technique is
both simple and efficient and achieves the objective admirably.

Crystal Space is automatically configured to generate 15-bit @sc{rgb} image
data when running on machines configured for 12-bit @sc{rgba} display.
Conversion of Crsytal Space 15-bit @sc{rgb}:555 data to @sc{rgba}:4444 needed
by the WindowServer is encapsulated in the class @samp{NeXTFrameBuffer15}.  In
order to avoid time-consuming bit manipulation of image data, this class
generates a translation table which equates each possible @sc{rgb}:555 color
value with the corresponding @sc{rgba}:4444 color.  The alpha nybble of the
translated color contains @code{0x0f} as explained in the video optimizations
section, @ref{NeXT Video Optimization}.  To translate incoming @sc{rgb}:555
data to @sc{rgba}:4444, @samp{NeXTFrameBuffer15} enumerates over each color
value in the incoming image data, looks up its corresponding @sc{rgba}:4444
value in the translation table and outputs that color.  This technique is both
simple and reasonably efficient.

@node NeXT Dynamic Linking, NeXT Notes, NeXT Frame Buffer, NeXT Details
@subsubsection Dynamic Linking
@cindex @sc{n}e@sc{xt} Dynamic Linking

On MacOS/X Server, OpenStep, and NextStep, symbol management within plug-in
modules (also known as @dfn{dynamically loaded libraries}) is handled
differently than on most other platforms and operating systems.  On most
platforms, symbols are private to a plug-in module unless explicitly exported.
On MacOS/X Server, OpenStep, and NextStep, all symbols are public by default.
This difference of symbolic semantics can have detrimental side-effects.

On other platforms, plug-in modules are themselves linked against any required
static libraries in order to satisfy external symbolic references.  On MacOS/X
Server, OpenStep, and NextStep, on the other hand, the application is
typically linked against any libraries which may be required by plug-in
modules rather than linking the plug-in modules against the required
libraries.  There are a couple problems with this approach.

@itemize @bullet
@item
It is not always possible to know ahead of time which static libraries will be
required by a set of plug-in modules since those modules may come from
independent sources.  Thus, it is neither practical nor always possible to
link the application against the correct set of static libraries.  As a
corollary, this often means having to add special cases to otherwise general
makefiles in order to specify an extended set of static libraries when
invoking the static linker.

@item
Even though an application may be linked against a static library for the
purpose of making that library available to a plug-in module, often the
application itself makes no reference to symbols within the library.  In order
to force the linker to actually incorporate the library into the application
some artificial mechanism for forcing references to symbols within the library
must be invented.  Often this involves employing special switches when
invoking the linker or manually faking hard symbolic references within the
source code itself.

@item
It is highly fragile and often problematic since even a small change to the
external symbolic references of a plug-in module may require that the
application be relinked against a different set of static libraries.
@end itemize

The approach used by other platforms where plug-in modules are linked directly
against any static libraries which they require has several advantages.

@itemize @bullet
@item
Plug-in modules are self-contained since external symbolic references have
already been satisfied, thus there is no need for the application to attempt
to satisfy those references.

@item
An application needs to be linked only against the set of static libraries
which it requires.  There is no need to try to fathom the set of libraries
which @emph{might} one day be required by plug-in modules.  As a corollary
there is no need to invent artificial mechanisms for forcing libraries to be
linked into the application which are not required by the application itself.

@item
It is much more robust since a change in the symbolic requirements of any
given plug-in module will not require re-linking of the application against
a new set of libraries.
@end itemize

In order to avoid the fragility of the standard MacOS/X Server, OpenStep, and
NextStep dynamic linking model, and in order to avoid having to invent special
case solutions to work around these problems, this port of Crystal Space
attempts to emulate the model of dynamic linking used on other platforms.
This is accomplished by linking plug-in modules against the static libraries
which they require, rather than linking those libraries into the application.

The one major pitfall which makes employment of this approach difficult, is
that of symbolic conflicts where the same symbol is defined in more than one
place.  This problem can occur when more than one plug-in module links with
the same static library, and when both a plug-in module and the application
link against the same static library.  This port uses a couple different
solutions to work around this problem depending upon the exact platform in
question, as summarized below.

@itemize @bullet
@item
The NextStep port emulates private plug-in symbols by actually stripping away
all public (resolved) symbols, except for the @sc{scf} @code{GetClassTable()}
hook (@pxref{SCF}), from the plug-in module at build time.  This technique
provides fairly decent insurance against symbolic conflicts at plug-in load
time even when multiple plug-ins have been linked against the same static
libraries.  The only big drawback to this approach is that it makes symbolic
debugging of plug-in modules impossible.  The stripping away of symbols is
performed by a specially crafted build rule in the NextStep makefile,
@file{CS/libs/cssys/next/nextstep.mak}.

An attempt was made to utilize the alternate approach of parsing the error
stream from @sc{rld} at plug-in load time, invoking @code{rld_forget_symbol()}
for each symbolic conflict, and then attempting a reload, but the @sc{rld}
run-time (being sufficiently buggy) would actually crash within
@code{rld_forget_symbol()} when this approach was employed.

@item
The MacOS/X Server and OpenStep ports emulate private plug-in symbols by
taking advantage of @sc{dyld}'s @samp{NSLinkEditErrorHandlers} which allows
the loader to ignore duplicate symbols at load time, thus there is no need to
strip them away at build time as is done with the NextStep port.  This
approach has the advantage that symbolic debugging capability of plug-in
modules is retained.
@end itemize

@node NeXT Notes, , NeXT Dynamic Linking, NeXT Details
@subsubsection Final Notes
@cindex @sc{n}e@sc{xt} Notes

This section details future plans as well as problems or potential problems
with the MacOS/X Server, OpenStep, and NextStep ports of Crystal Space.
Consult this section if you want to know what direction this port is taking.

@cindex @sc{n}e@sc{xt} Future Plans
@subsubheading Future Plans

This is a list of items which are planned for future releases of this project:

@itemize @bullet
@item
I have discovered that OpenStep does not reliably return images with the same
bits-per-sample when @code{-[NSBitmapImageRep initWithFocusedViewRect:]} is
used.  Thus, I see no reason to rely on the Window Server's suggestion for
preferred depth any longer.  May as well simplify the code by once again using
@code{+[NSWindow defaultDepthLimit]}.

@item
Consider flushing only part of the frame buffer to the display upon invocation
of @code{csGraphics2D::Print()} rather than the entire frame buffer.  Be
careful, though.  The current technique of flushing the entire frame buffer
takes advantage of out-of-line data in Mach messages, so it is very fast.

@item
Re-write event handling so that it no longer relies on a timer to drive
animation.  The problem with using the timer are:

@itemize @minus
@item
It places an upper limit on the frame rate.
@item
On slow machines it can fire frequently enough to put a strangle hold on the
user event queue, since the run loop checks for timer events before checking
for user events.
@end itemize

A good way to re-engineer this may be to place an @dfn{application defined}
event in the event queue at the end of each animation frame, then have the
application event trigger the next animation frame.  Since the event will be
placed at the tail of the event queue, it will not smother out user events.

@item
Possibly implement sound support.
@end itemize

@cindex @sc{n}e@sc{xt} Bugs
@subsubheading Bugs

This is a list of known problems with the current release of this project:

@itemize @bullet
@item
It is not currently possible to launch the Crystal Space demonstration
applications by double-clicking on them in the Viewer application in MacOS/X
Server, or from the the Workspace Manager's File Viewer on OpenStep and
NextStep.  This problem is a result of a limitation of Viewer and Workspace
Manager applications.  When the Crystal Space demonstration applications are
launched, they expect to find the configuration files @file{scf.cfg} and
@file{vfs.cfg} in the @dfn{current directory}--which is generally the same
directory in which the Crystal Space applications reside.  Unfortunately,
neither Viewer nor Workspace Manager provide the necessary information for
Crystal Space to locate these administrative files.  Therefore, at this time,
all Crystal Space applications @emph{must} be launched from the command-line.
@end itemize

@unmacro NeXT
