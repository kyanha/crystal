<html>
<head>
<title>PlaneShift 3DSMax Exporters</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<h1>PlaneShift 3DSMax Exporters</h1>
<p>Author: Luca Pancallo (pancallo@netscape.net)</p>
<p>Disclaimer: Don't build a new game! Join the crew at http://www.planeshift.it 
  to build THE game :)</p>
<p>Level Exporter Version 34<br>
  Lights Exporter Version 03 (This script is for PS engine only, can't work in 
  CS walktest)<br>
  Sprite Exporter Version 05<br>
  Fix Materials Version 04</p>
<p>3DSMax 5.0 (same scripts should still work on 3DSMax 4.0)</p>
<h2>Installation</h2>
<p>3DSMax exporters should arrive in a zip with this content:</p>
<ul>
  <li>exportCSP.mcr (level exporter)</li>
  <li>exportSprite.mcr (animated sprite exporter)</li>
  <li>fixMaterials.mcr (used to fix the duplicate material generated by the convertion 
    between Maya and 3dsMax)</li>
  <li>showMap.mcr (used to turn on/off the display of materials in the viewports)</li>
  <li>PSMaxMenus5.mnu (menus to show exporters in Max interface)</li>
</ul>
<p>1) Copy all the *.mcr files to &lt;3dsMax Install Dir&gt;/ui/macroscripts</p>
<p>2) Copy PSMaxMenus5.mnu to &lt;3dsMax Install Dir&gt;/ui (if you have 3dsMax 
  4.0 don't import this menu definition, but add them manually)</p>
<p>3) Launch 3dsmax, go to Customize-&gt;Customize User Interface. Select the 
  &quot;Menus&quot; tab and click on &quot;Load...&quot;. Select the PSMaxMenus5.mnu 
  file.</p>
<p>4) Close 3dsmax and open it again. You should now have a PlaneShift menu in 
  the main bar.</p>
<p>&nbsp;</p>
<h2>Modeling a level to be exported</h2>
<p>To be sure that the level you are modeling will be exported correctly, you 
  must follow this guidelines.</p>
<h3>1. Room Properties</h3>
<p>Set the sector name by clicking on File&gt;File Properties. Select the Custom 
  Tab, enter this data:</p>
<p>Name: roomname<br>
  Type: Text<br>
  Value: &lt;enter the roomname, e.g. laanxinside&gt;</p>
<p>Click on Add.</p>
<h3>2. Starting Position</h3>
<p>Every sector in CS has a starting position, this is where the player will appear. 
  To set that we use the position of a 'Camera' object placed in the Max scene.</p>
<p>Click on Create-&gt;Cameras, select 'Target', place the camera where you want 
  the starting position to be. If multiple cameras are present, the exporter uses 
  the first one.</p>
<h3>3. Lights</h3>
<p>The converter supports:</p>
<ul>
  <li>ambient light</li>
  <li>positional lights</li>
</ul>
<p>You can set the <b>ambient light</b> for your sector adding properties to the 
  max level. Clicking on File&gt;File Properties. Select the Custom Tab, enter 
  this data:</p>
<p>Name: red / Type: Text / Value: &lt;enter the value from 0 to 1&gt;<br>
  Name: green / Type: Text / Value: &lt;enter the value from 0 to 1&gt;<br>
  Name: blue / Type: Text / Value: &lt;enter the value from 0 to 1&gt;</p>
<p>If you do not specify these values, the engine will use it's default of red=0.2 
  green=0.2 blue=0.2</p>
<p>To add <b>positional lights</b> you should add 'Omni' lights. There are the 
  only ones supported by the exporter. To place a new light click on Create-&gt;Lights-&gt;Omni.<br>
</p>
<p>To have the same effect in PlaneShift and in 3DSMax you should define your 
  omni light with these parameters:<br>
  Under &quot;General Parameters&quot; you should have&quot;Diffuse&quot; and 
  &quot;Specular&quot; checked, &quot;Ambient Only&quot; UNchecked.</p>
<p><b>Color:</b><br>
  Colors can be defined in the RBG or HSV sections of the light.</p>
<p><b>Multiplier:</b><br>
  Mutiplier is supported. Normal light intensity in PlaneShift can go from 0 to 
  1, if multiplier is used then it can go beyond 1.</p>
<p></p>
<p><b>Range:</b><br>
  The maximum range of the light is defined by the value of &quot;Far Attenuation 
  End&quot; in Attenuation menu. This is considered also if you no attenuation 
  is used (see below).</p>
<p><b>No Attenuation:</b><br>
  If in section &quot;Near Attenuation&quot; the checkbox &quot;Use&quot; is NOT 
  checked and in section &quot;Far Attenuation&quot; the checkbox &quot;Use&quot; 
  is NOT checked, then the light will be defined in PlaneShift with parameter 
  &quot;No Attenuation&quot;, so light will be costant up to the maximum radius.<br>
</p>
<p><b>Dynamic Lights:</b><br>
  Lights can have a dynamically changing color. If this is the case, read the 
  &quot;Export Lights&quot; chapter or more info on how to define hue changes.</p>
<p><b>Lightmap cell size:</b><br>
  Every illuminated object has a lightmap associated. A pixel in the lightmap 
  is created for every cellsize x cellsize pixels of texture size.<br>
  Example: Using a size of 32, 1 pixel in the lightmap will be created every 32x32 
  pixel in the texture.<br>
  Bigger cellsize means that less lumels are created to describe the illumination 
  of an illuminated polygon this means less used ram but less defined shadows.</p>
<p>You can set the Lightmap cell size value with this procedure:</p>
<ul>
  <li> 
    <p> Clicking on File&gt;File Properties. Select the Custom Tab</p>
  </li>
  <li> 
    <p>Enter this data:</p>
    <p>Name: lightmapsize<br>
      Type: Text<br>
      Value: &lt;enter the size, e.g. 16 or 32&gt;</p>
  </li>
  <li>
    <p>Click on Add.</p>
  </li>
</ul>
<p>If this entry is not specified the engine will use CS default (that is 16).</p>
<p><b>Auto On/Off based on Threshold:<br>
  </b>Lights can be turned automatically on or off based on the value of another 
  light (controller). This is used to turn on house/street lights at night and 
  turn them off at sunrise. To enable this feature you must abide to these constraints:<br>
  - the light that will turn on/off must <b>not</b> be dynamic, it should have 
  a fixed light color during the day/night cycle.<br>
  - the controller light must be named 'crystal' and should be dynamic. This light 
  will be affected by other factors like rain. So depending on its intensity value 
  will control the on/off of other lights.<br>
  - there must be only one controller light for each sector.<br>
  - All lights that should turn on/off must have these parameters set in the Custom 
  Properties tab:</p>
<p>TURNONOFF_R=0.2<br>
  TURNONOFF_G=0.2<br>
  TURNONOFF_B=0.2<br>
  TURNONOFF_FADE=1000</p>
<p>for RGB range is from 0 to 1, fade is expressed in msecs.</p>
<p>In the example above lights will turn off when the 'crystal' light is &gt;0.2 
  and will turn on when the 'crystal' light is &lt;0.2</p>
<p>Lights with same RGB threshold values are packed in one event for the game, 
  so performances will be better if you give lights same threshold values.</p>
<p><b>Lightning:</b> The engine now support a brief sequence that simulates a 
  lightning, this sequence will be triggered randomly by the server in all the 
  sectors with the lightining property set. To enable it :</p>
<ul>
  <li> 
    <p> Click on File&gt;File Properties. Select the Custom Tab</p>
  </li>
  <li> 
    <p>Enter this data:</p>
    <p>Name: lightning<br>
      Type: Text<br>
      Value: yes</p>
  </li>
  <li> Click on Add.</li>
</ul>
<p>&nbsp;</p>
<h3>4. Objects</h3>
<p>There are a number of supported CS properties that you can set in 3dsmax. Just 
  select the object and right-click to open the object menu. Select &quot;Properties...&quot;, 
  then the tab &quot;User Defined&quot;. In that window you can add the properties 
  of the object. Be sure to use same case, properties are case sensitive.</p>
<p><b>Smooth</b>: changes lightmap so the object will appear more round, if the 
  object is not exposed to a light, it will not look rounded.<br>
  Default is no smooth. You can activate that with:</p>
<ul>
  <li> SMOOTH=yes</li>
</ul>
<p><b>Shadows</b>: sprites don't cast shadow. Static objects normally cast shadows. 
  You can disable shadows on static objects using that setting. Default is casting 
  shadows.<br>
</p>
<ul>
  <li>NOSHADOWS=yes </li>
</ul>
<p><b>Lighting</b>: Static objects are normally lit by the surrounding lights. 
  You can disable this and have the object shine by himself. Default is to be 
  affected by external lighting.<br>
</p>
<ul>
  <li>LIGHTING=no </li>
</ul>
<p><b>Collision Detection</b>: Normally you can't pass through objects, they will 
  collide with other objects and stop them. You can disable collision detection 
  so you can move through it. Default is collision detection yes.<br>
</p>
<ul>
  <li>COLLDET=no</li>
</ul>
<p><b>Invisible faces:</b> You can set some faces to be invisible in CS. Imagine 
  you have a box, but you want 1 face to be invisible. You can surely remove that 
  face, but it seems that Dynavis works better if you keep that face and set it 
  as invisible. So Dynavis will consider the object closed, and you will have 
  the same visual effect. To set a face as invisible, create a new material with 
  texture &quot;csinvisible.tga&quot; (this IS case-sensitive) and assign it to 
  the faces you want to be invisible. Those faces will be flagged as LIGHTING=no 
  and INVISIBLE=yes.</p>
<p><b>Trasparency:</b> If an object has a trasparent texture, CS must be aware 
  of that. To give this information to CS you have to name all trasparent objects 
  with a &quot;_t_&quot; prefix. Example: _t_glass01. This is the name of Max 
  object. There is no problem in setting a different name for the texture.</p>
<p><b>Sky:</b> Sky objects must have a different rendering priority in CS, to 
  set an object as a sky object (like the bounding box of your level) name it 
  with prefix &quot;_sky_&quot;. Example: _sky_box01.</p>
<p><b>VisCull</b>: If you set this property to off the object will not be considered 
  for visibility culling purposes. Default is on.</p>
<ul>
  <li>VISCULL=no</li>
</ul>
<p><b>CullerOnly:</b> If you set this property the object will be used only for 
  culling purposes, so the object will be invisible.</p>
<ul>
  <li>CULLERONLY=yes</li>
</ul>
<p>&nbsp;</p>
<h3>5. Textures</h3>
<p>Both Standard Materials and Multi/Sub Materials are supported. The name of 
  the texture is NOT important, the exporter looks at the actual filename attached 
  to the material.</p>
<p>See Invisible Faces in the previous chapter.</p>
<p>&nbsp;</p>
<h3>6. Portals</h3>
<p>CS uses portals to connect different sectors. To add a portal to a 3dsmax scene 
  follow this guidelines:</p>
<ul>
  <li>the object name must start with &quot;_p_&quot; . For example &quot;_p_laanx1&quot; 
    is a valid portal name.</li>
  <li>it MUST be a mesh with 2 planar triangle polygons (a square similar to a 
    door is perfect).</li>
  <li>add a property to the object (see 'Objects' chapter for details on how to 
    add a property) called &quot;PORTAL&quot; that points to the roomname of the 
    sector where that portal will lead to.<br>
    Example: PORTAL=plaza</li>
</ul>
<h3>&nbsp;</h3>
<h3>7. Emitters</h3>
<p>We currently support a number of particle emitters, those are listed below. 
  To add an emitter to a 3dsmax scene select the &quot;Create&quot; tab (the one 
  you use for creating Boxes) and click on the Helpers icon. Select &quot;Point&quot; 
  helper and add that to the scene where you want to place the emitter. &quot;Point&quot; 
  has a properties page like other objects.<br>
  <br>
  All emitter use a default <b>texture</b>: raindrop.png. If you want to specify 
  a different texture you can just add a property to the Point object called MATERIAL. 
  ex.: MATERIAL=icedrop.png</p>
<p>All emitter use a default <b>mixmode</b>: add. If you want to specify a different 
  mixmode you can just add a property to the Point object called MIXMODE. Available 
  mixmodes are: add, copy, mult2, mult, alpha, transparent, keycolor, tiling. 
  ex.: MIXMODE=copy</p>
<p><b>Fire</b>: Used for torches, campfires, etc... Add ALL those properties to 
  the object</p>
<ul>
  <li>TYPE=fire</li>
  <li>NUMBER=25</li>
  <li>DROPSIZE=0.1,0.1</li>
  <li>LIGHTING=off</li>
  <li>SWIRL=1.8</li>
  <li>COLORSCALE=0.15</li>
</ul>
<p><b>Emit:</b> Can produce a great amount of effects because is highly customizable. 
  Add those properties to the object. </p>
<ul>
  <li>TYPE=emit</li>
  <li>NUMBER=250<br>
    <br>
  </li>
  <li>REGULARPARTICLES=4,0.1<br>
    (where first parameter is sides and second is radius) <br>
    or <br>
    RECTPARTICLES=4,0.1<br>
    (where first parameter is width and second is height) <br>
    <br>
  </li>
  <li>LIGHTING=off</li>
  <li>TOTALTIME=4000<br>
    <br>
  </li>
  <li>STARTPOS1=EMITSPHERE<br>
    STARTPOS2=0,0.1<br>
    or<br>
    STARTPOS1=EMITFIXED<br>
    STARTPOS2=0,0 (in this case this parameter is not used, but must be present)<br>
    or<br>
    STARTPOS1=EMITBOX<br>
    STARTPOS2=-1,-1,-1,1,1,1 (the parameter is NOT scaled! it must have final 
    coords)<br>
    <br>
  </li>
  <li>STARTSPEED=EMITBOX(-1,-1,-1,1,1,1) (the parameter is NOT scaled! it must 
    have final coords)<br>
    or<br>
    STARTSPEED=EMITFIXED(-1,-2,2)<br>
    <br>
  </li>
  <li>STARTACCEL=EMITFIXED(0,0,0)<br>
    <br>
  </li>
  <li> ATTRACTOR=Attractor02</li>
  <li>ATTRACTORFORCE=0.5<br>
    <br>
  </li>
  <li>AGING0=0,1.0,0.2,0.8,0.5,2.0,0.0,1.25<br>
    AGING1=1000,1.0,0.8,0.2,1.0,1.5,0.0,0.75<br>
    AGING2=2000,1.0,0.2,0.8,0.5,1.0,0.0,1.0<br>
    AGING3=3000,1.0,0.8,0.2,1.0,0.5,0.0,0.5<br>
    AGING4=4000,1.0,0.2,0.8,0.5,0.0,0.0,0.25</li>
</ul>
<p>The AGING part is really important, there you can set what happens to the emitter 
  during time. Here is the meaning of the fields used in AGING line:</p>
<p>AGING0=&lt;time&gt;,&lt;color red&gt;,&lt;color green&gt;,&lt;color blue&gt;,&lt;alpha&gt;,&lt;swirl&gt;,&lt;rotspeed&gt;,&lt;scale&gt;</p>
<p>An Emit <b>MUST</b> have an attractor. This is where the particles will be 
  attracted through the time cycle described in the AGING fields. In the ATTRACTOR 
  field you have to set the 3dsmax Point Object that will use that.</p>
<p><b>Aging:</b> Aging is optional and can range from 0 to 5 entries.</p>
<p><b>Attractor:</b> Used in combination with the Emit, has only one property 
  that tells the exporter that it must be not considered as a stand-alone emitter.</p>
<ul>
  <li>TYPE=hidden</li>
</ul>
<p>&nbsp;</p>
<h3>8. Genmeshes</h3>
<p>Genmeshes are used to reduce the amount of geometry CS will handle. You can 
  define a &quot;factory&quot; object (example: a stone) and then copy it in several 
  places of the level. If it's a genmesh the copies will have only the location 
  and the rotation associated, all the geometry will be identical to the &quot;factory&quot; 
  object. This saves a lot of memory.</p>
<p>To define a genmesh factory you should:</p>
<ul>
  <li>Define a valid name 
    <ul>
      <li>name it with a starting &quot;_g_&quot; prefix</li>
      <li>name it with a unique identifier that will be used on copies. eg.: &quot;_g_stone01&quot;</li>
      <li>add a &quot;_0&quot; to the end of the name to tell the exporter that 
        this is a factory.</li>
      <li>A valid factory name is: &quot;_g_stone01_0&quot;. Invalid names are: 
        &quot;_g_stone_big_0&quot;, in this case this will not be considered a 
        factory.</li>
    </ul>
  </li>
  <li>Move the factory object to 0,0,0. This will be used as a reference for the 
    position of all other instances</li>
  <li>Reset the pivot of the object to be &quot;Centered on Object&quot;</li>
</ul>
<p>Please note that the factory is NOT exported in the scene, so it will be invisible 
  in CS.</p>
<p>To define a &quot;clone&quot; or &quot;instance&quot; of a factory you should:</p>
<ul>
  <li>Copy it from the factory. This ensure that pivot is set in the right position 
    and geometry remains the same.</li>
  <li>name it with a starting &quot;_g_&quot; prefix</li>
  <li>name it with the unique identifier defined on his factory. eg.: &quot;_g_stone01&quot;</li>
  <li>add a number or any other character at the end, after a &quot;_&quot; symbol.</li>
</ul>
<p>A valid instance name is: &quot;_g_stone01_1&quot; or &quot;_g_stone01_01&quot; 
  or &quot;_g_stone01_233_23ws&quot;. </p>
<p>All genmeshes have the tiling <b>mixmode</b>.</p>
<p><b>Shadows</b>: genmeshes can have the same settings Objects have for shadows 
  (see above).</p>
<p>&nbsp;</p>
<h3>9. Thingmeshes</h3>
<p>Thingmeshes are used to reduce the amount of geometry CS will handle. You can 
  define a &quot;factory&quot; object (example: a house) and then copy it in several 
  places of the level. If it's a thingmesh the copies will have only the location, 
  rotation and texture associated, all the geometry will be identical to the &quot;factory&quot; 
  object. This saves a lot of memory. The difference with genmeshes is that thingmesh 
  instances can have a different texture from the factory, that thingmesh support 
  multiple textures and that those &quot;can receive light (check with Jorrit)&quot;.</p>
<p>To define a thingmesh factory you should:</p>
<ul>
  <li>Define a valid name 
    <ul>
      <li>name it with a starting &quot;_f_&quot; prefix</li>
      <li>name it with a unique identifier that will be used on copies. eg.: &quot;_f_house01&quot;</li>
      <li>add a &quot;_0&quot; to the end of the name to tell the exporter that 
        this is a factory.</li>
      <li>A valid factory name is: &quot;_f_house01_0&quot;. Invalid names are: 
        &quot;_f_house_big_0&quot;, in this case this will not be considered a 
        factory.</li>
    </ul>
  </li>
  <li>Move the factory object to 0,0,0. This will be used as a reference for the 
    position of all other instances</li>
  <li>Reset the pivot of the object to be &quot;Centered on Object&quot;</li>
</ul>
<p>Please note that the factory is NOT exported in the scene, so it will be invisible 
  in CS.</p>
<p>To define a &quot;clone&quot; or &quot;instance&quot; of a factory you should:</p>
<ul>
  <li>Copy it from the factory. This ensure that pivot is set in the right position 
    and geometry remains the same.</li>
  <li>name it with a starting &quot;_f_&quot; prefix</li>
  <li>name it with the unique identifier defined on his factory. eg.: &quot;_f_house01&quot;</li>
  <li>add a number or any other character at the end, after a &quot;_&quot; symbol.</li>
</ul>
<p>A valid instance name is: &quot;_f_house01_1&quot; or &quot;_f_house01_01&quot; 
  or &quot;_f_house01_233_23ws&quot;.</p>
<p><b></b></p>
<h2>Modeling a Character to be exported</h2>
<p>[TODO]</p>
<p>Just remember that:</p>
<p>you can't weld UVs of vertexes that are not in the same x,y,z coords</p>
<p>[TODO] Attach points</p>
<h2>Export Level</h2>
<p>Select PlaneShift-&gt;Export Level.</p>
<p>[TODO]</p>
<h2>Export Lights</h2>
<p>This command allows you to export the light information that will be used by 
  PS engine to render lights at different times in the day. </p>
<p>Select PlaneShift-&gt;Export Lights.</p>
<p>Please note that:</p>
<ul>
  <li>You must set the total frame number to 24 (from 0 to 23) or to 48 (from 
    0 to 47)</li>
  <li>Every frame represents a certain time of the day: 1 frame for each hour 
    starting from 0:00 am (midnight)</li>
  <li>You can add an OmniLight called &quot;ambient&quot; that represent the ambient 
    light. This light will not be exported as a normal light, the coordinates 
    it has are not relevant.</li>
  <li>The lights will be exported to a separate xml file, but those MUST be the 
    same ones present when you exported the level.</li>
</ul>
<p>The first 24 frames are used to get the light colors when the sun shines and 
  no rain is present. The frames from 25 to 48 are used to get the light colors 
  when the is heavily raining so the sun will be obscured by clouds and rain. 
  The engine uses those extreme values to find the good ones when it's raining 
  at 20%, 50%, etc...</p>
<p>If you set the animation length to be 24 frames, then shining sun condition 
  and heavy rain condition will have the same light color values.</p>
<p>&nbsp;</p>
<h2>Export Character</h2>
<p>Select PlaneShift-&gt;Export Sprite.</p>
<p>[14:17] <Talad> vextex on foor is one vertex that moves with the character.
[14:17] <Talad> those vertexes will be used to calculate displacement from one frame to the other, so it can be one random vertex of the foot. We choosed the outermost one to the back of the foot.
[14:18] <Talad> frame with foot 2 on the ground is the first frame with it on the ground
[14:19] <Talad> from that point on, the displacement is calculated on vertex 2 and not on vertex 1</p>
<p>&nbsp;</p>
<h2>Rendering Priorities</h2>
<p>In Crystal Space you can define rendering priorities for objects. Currently 
  we assign priorities with these rules:</p>
<ul>
  <li>all &quot;_t_&quot; objects have &quot;alpha&quot; priority</li>
  <li>all &quot;_sky_&quot; objects have &quot;sky&quot; priority</li>
  <li>all &quot;_p_&quot; objects have &quot;wall&quot; priority</li>
  <li>all &quot;_s_&quot; objects have &quot;object&quot; priority</li>
  <li>all others objects have &quot;object&quot; priority</li>
</ul>
<p>CS renders objects in this sequence:</p>
<ol>
  <li>sky</li>
  <li>wall</li>
  <li>object</li>
  <li>alpha</li>
</ol>
<p>&nbsp;</p>
</body>
</html>

