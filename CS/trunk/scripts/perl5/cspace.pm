# This file was automatically generated by SWIG
package cspace;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package cspacec;
bootstrap cspace;
package cspace;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package cspace;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package cspace;

*scfCompatibleVersion = *cspacec::scfCompatibleVersion;
*__modulo__ = *cspacec::__modulo__;
*__rshift__ = *cspacec::__rshift__;
*__mult_ass__ = *cspacec::__mult_ass__;
*__divide_ass__ = *cspacec::__divide_ass__;
*__div__ = *cspacec::__div__;
*fSqr = *cspacec::fSqr;
*__subtr__ = *cspacec::__subtr__;
*__add__ = *cspacec::__add__;
*__mult__ = *cspacec::__mult__;
*__eq__ = *cspacec::__eq__;
*__ne__ = *cspacec::__ne__;
*__gt__ = *cspacec::__gt__;
*__lt__ = *cspacec::__lt__;
*csDefaultRunLoop = *cspacec::csDefaultRunLoop;
*csPlatformStartup = *cspacec::csPlatformStartup;
*csPlatformShutdown = *cspacec::csPlatformShutdown;
*csPrintf = *cspacec::csPrintf;
*csFPrintf = *cspacec::csFPrintf;
*csPrintfErr = *cspacec::csPrintfErr;
*csGetTicks = *cspacec::csGetTicks;
*csSleep = *cspacec::csSleep;
*csGetUsername = *cspacec::csGetUsername;
*csGetPlatformConfigPath = *cspacec::csGetPlatformConfigPath;
*csfxInterference = *cspacec::csfxInterference;
*csfxFadeOut = *cspacec::csfxFadeOut;
*csfxFadeTo = *cspacec::csfxFadeTo;
*csfxFadeToColor = *cspacec::csfxFadeToColor;
*csfxGreenScreen = *cspacec::csfxGreenScreen;
*csfxRedScreen = *cspacec::csfxRedScreen;
*csfxBlueScreen = *cspacec::csfxBlueScreen;
*csfxWhiteOut = *cspacec::csfxWhiteOut;
*csfxShadeVert = *cspacec::csfxShadeVert;
*csfxScreenDPFX = *cspacec::csfxScreenDPFX;
*csfxScreenDPFXPartial = *cspacec::csfxScreenDPFXPartial;
*CS_IS_KEYBOARD_EVENT = *cspacec::CS_IS_KEYBOARD_EVENT;
*CS_IS_MOUSE_EVENT = *cspacec::CS_IS_MOUSE_EVENT;
*CS_IS_JOYSTICK_EVENT = *cspacec::CS_IS_JOYSTICK_EVENT;
*CS_IS_INPUT_EVENT = *cspacec::CS_IS_INPUT_EVENT;
*CS_QUERY_REGISTRY_TAG = *cspacec::CS_QUERY_REGISTRY_TAG;
*CS_LOAD_PLUGIN_ALWAYS = *cspacec::CS_LOAD_PLUGIN_ALWAYS;
*CS_FX_SETALPHA = *cspacec::CS_FX_SETALPHA;
*CS_FX_SETALPHA_INT = *cspacec::CS_FX_SETALPHA_INT;
*AUTOLOAD = *cspacec::AUTOLOAD;
*csInitializer_SetupEventHandler = *cspacec::csInitializer_SetupEventHandler;
*csInitializer_RequestPlugins = *cspacec::csInitializer_RequestPlugins;
*CS_QUERY_REGISTRY = *cspacec::CS_QUERY_REGISTRY;
*CS_QUERY_REGISTRY_TAG_INTERFACE = *cspacec::CS_QUERY_REGISTRY_TAG_INTERFACE;
*SCF_QUERY_INTERFACE = *cspacec::SCF_QUERY_INTERFACE;
*SCF_QUERY_INTERFACE_SAFE = *cspacec::SCF_QUERY_INTERFACE_SAFE;
*CS_QUERY_PLUGIN_CLASS = *cspacec::CS_QUERY_PLUGIN_CLASS;
*CS_LOAD_PLUGIN = *cspacec::CS_LOAD_PLUGIN;
*CS_GET_CHILD_OBJECT = *cspacec::CS_GET_CHILD_OBJECT;
*CS_GET_NAMED_CHILD_OBJECT = *cspacec::CS_GET_NAMED_CHILD_OBJECT;
*CS_GET_FIRST_NAMED_CHILD_OBJECT = *cspacec::CS_GET_FIRST_NAMED_CHILD_OBJECT;
*CS_REQUEST_PLUGIN = *cspacec::CS_REQUEST_PLUGIN;
*CS_REQUEST_VFS = *cspacec::CS_REQUEST_VFS;
*CS_REQUEST_FONTSERVER = *cspacec::CS_REQUEST_FONTSERVER;
*CS_REQUEST_IMAGELOADER = *cspacec::CS_REQUEST_IMAGELOADER;
*CS_REQUEST_NULL3D = *cspacec::CS_REQUEST_NULL3D;
*CS_REQUEST_SOFTWARE3D = *cspacec::CS_REQUEST_SOFTWARE3D;
*CS_REQUEST_OPENGL3D = *cspacec::CS_REQUEST_OPENGL3D;
*CS_REQUEST_ENGINE = *cspacec::CS_REQUEST_ENGINE;
*CS_REQUEST_LEVELLOADER = *cspacec::CS_REQUEST_LEVELLOADER;
*CS_REQUEST_LEVELSAVER = *cspacec::CS_REQUEST_LEVELSAVER;
*CS_REQUEST_REPORTER = *cspacec::CS_REQUEST_REPORTER;
*CS_REQUEST_REPORTERLISTENER = *cspacec::CS_REQUEST_REPORTERLISTENER;
*CS_REQUEST_CONSOLEOUT = *cspacec::CS_REQUEST_CONSOLEOUT;
*iCollideSystem_GetCollisionPairs = *cspacec::iCollideSystem_GetCollisionPairs;
*CS_VEC_FORWARD = *cspacec::CS_VEC_FORWARD;
*CS_VEC_BACKWARD = *cspacec::CS_VEC_BACKWARD;
*CS_VEC_RIGHT = *cspacec::CS_VEC_RIGHT;
*CS_VEC_LEFT = *cspacec::CS_VEC_LEFT;
*CS_VEC_UP = *cspacec::CS_VEC_UP;
*CS_VEC_DOWN = *cspacec::CS_VEC_DOWN;
*CS_VEC_ROT_RIGHT = *cspacec::CS_VEC_ROT_RIGHT;
*CS_VEC_ROT_LEFT = *cspacec::CS_VEC_ROT_LEFT;
*CS_VEC_TILT_RIGHT = *cspacec::CS_VEC_TILT_RIGHT;
*CS_VEC_TILT_LEFT = *cspacec::CS_VEC_TILT_LEFT;
*CS_VEC_TILT_UP = *cspacec::CS_VEC_TILT_UP;
*CS_VEC_TILT_DOWN = *cspacec::CS_VEC_TILT_DOWN;

############# Class : cspace::csWrapPtr ##############

package cspace::csWrapPtr;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_Ref_get = *cspacec::csWrapPtr_Ref_get;
*swig_Ref_set = *cspacec::csWrapPtr_Ref_set;
*swig_VoidPtr_get = *cspacec::csWrapPtr_VoidPtr_get;
*swig_VoidPtr_set = *cspacec::csWrapPtr_VoidPtr_set;
*swig_Type_get = *cspacec::csWrapPtr_Type_get;
*swig_Type_set = *cspacec::csWrapPtr_Type_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csWrapPtr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csWrapPtr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iBase ##############

package cspace::iBase;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*IncRef = *cspacec::iBase_IncRef;
*DecRef = *cspacec::iBase_DecRef;
*GetRefCount = *cspacec::iBase_GetRefCount;
*QueryInterface = *cspacec::iBase_QueryInterface;
*QueryInterfaceSafe = *cspacec::iBase_QueryInterfaceSafe;
*AddRefOwner = *cspacec::iBase_AddRefOwner;
*RemoveRefOwner = *cspacec::iBase_RemoveRefOwner;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iBase($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iBase_scfGetVersion;
*_DynamicCast = *cspacec::iBase__DynamicCast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iFactory ##############

package cspace::iFactory;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*CreateInstance = *cspacec::iFactory_CreateInstance;
*TryUnload = *cspacec::iFactory_TryUnload;
*QueryDescription = *cspacec::iFactory_QueryDescription;
*QueryDependencies = *cspacec::iFactory_QueryDependencies;
*QueryClassID = *cspacec::iFactory_QueryClassID;
*QueryModuleName = *cspacec::iFactory_QueryModuleName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iFactory($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iFactory_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSCF ##############

package cspace::iSCF;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SCF = *cspacec::iSCF_SCF;
*RegisterClasses = *cspacec::iSCF_RegisterClasses;
*ClassRegistered = *cspacec::iSCF_ClassRegistered;
*CreateInstance = *cspacec::iSCF_CreateInstance;
*GetClassDescription = *cspacec::iSCF_GetClassDescription;
*GetClassDependencies = *cspacec::iSCF_GetClassDependencies;
*GetPluginMetadata = *cspacec::iSCF_GetPluginMetadata;
*UnloadUnusedModules = *cspacec::iSCF_UnloadUnusedModules;
*RegisterClass = *cspacec::iSCF_RegisterClass;
*RegisterFactoryFunc = *cspacec::iSCF_RegisterFactoryFunc;
*UnregisterClass = *cspacec::iSCF_UnregisterClass;
*GetInterfaceName = *cspacec::iSCF_GetInterfaceName;
*GetInterfaceID = *cspacec::iSCF_GetInterfaceID;
*Finish = *cspacec::iSCF_Finish;
*QueryClassList = *cspacec::iSCF_QueryClassList;
*ScanPluginsPath = *cspacec::iSCF_ScanPluginsPath;
*RegisterPlugin = *cspacec::iSCF_RegisterPlugin;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSCF($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSCF_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDebugHelper ##############

package cspace::iDebugHelper;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetSupportedTests = *cspacec::iDebugHelper_GetSupportedTests;
*UnitTest = *cspacec::iDebugHelper_UnitTest;
*StateTest = *cspacec::iDebugHelper_StateTest;
*Benchmark = *cspacec::iDebugHelper_Benchmark;
*Dump = *cspacec::iDebugHelper_Dump;
*DebugCommand = *cspacec::iDebugHelper_DebugCommand;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDebugHelper($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iDebugHelper_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csColor ##############

package cspace::csColor;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_red_get = *cspacec::csColor_red_get;
*swig_red_set = *cspacec::csColor_red_set;
*swig_green_get = *cspacec::csColor_green_get;
*swig_green_set = *cspacec::csColor_green_set;
*swig_blue_get = *cspacec::csColor_blue_get;
*swig_blue_set = *cspacec::csColor_blue_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csColor(@_);
    bless $self, $pkg if defined($self);
}

*Set = *cspacec::csColor_Set;
*Clamp = *cspacec::csColor_Clamp;
*ClampDown = *cspacec::csColor_ClampDown;
*__copy__ = *cspacec::csColor___copy__;
*__add_ass__ = *cspacec::csColor___add_ass__;
*__subtr_ass__ = *cspacec::csColor___subtr_ass__;
*__mult_ass__ = *cspacec::csColor___mult_ass__;
*__eq__ = *cspacec::csColor___eq__;
*__ne__ = *cspacec::csColor___ne__;
*Add = *cspacec::csColor_Add;
*Subtract = *cspacec::csColor_Subtract;
*__add__ = *cspacec::csColor___add__;
*__subtr__ = *cspacec::csColor___subtr__;
*__mult__ = *cspacec::csColor___mult__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csColor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csColor4 ##############

package cspace::csColor4;
@ISA = qw( cspace cspace::csColor );
%OWNER = ();
%ITERATORS = ();
*swig_alpha_get = *cspacec::csColor4_alpha_get;
*swig_alpha_set = *cspacec::csColor4_alpha_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csColor4(@_);
    bless $self, $pkg if defined($self);
}

*Set = *cspacec::csColor4_Set;
*__copy__ = *cspacec::csColor4___copy__;
*__mult_ass__ = *cspacec::csColor4___mult_ass__;
*__add_ass__ = *cspacec::csColor4___add_ass__;
*__subtr_ass__ = *cspacec::csColor4___subtr_ass__;
*__eq__ = *cspacec::csColor4___eq__;
*__ne__ = *cspacec::csColor4___ne__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csColor4($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csCommandLineHelper ##############

package cspace::csCommandLineHelper;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*Help = *cspacec::csCommandLineHelper_Help;
*CheckHelp = *cspacec::csCommandLineHelper_CheckHelp;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csCommandLineHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csCommandLineHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csStringSet ##############

package cspace::csStringSet;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csStringSet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csStringSet($self);
        delete $OWNER{$self};
    }
}

*__copy__ = *cspacec::csStringSet___copy__;
*Request = *cspacec::csStringSet_Request;
*Contains = *cspacec::csStringSet_Contains;
*Delete = *cspacec::csStringSet_Delete;
*Empty = *cspacec::csStringSet_Empty;
*Clear = *cspacec::csStringSet_Clear;
*GetSize = *cspacec::csStringSet_GetSize;
*IsEmpty = *cspacec::csStringSet_IsEmpty;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iString ##############

package cspace::iString;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetData = *cspacec::iString_GetData;
*__ne__ = *cspacec::iString___ne__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iString($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iString_scfGetVersion;
*__seq__ = *cspacec::iString___seq__;
*__string__ = *cspacec::iString___string__;
*__sv__ = *cspacec::iString___sv__;
*__av__ = *cspacec::iString___av__;
*length = *cspacec::iString_length;
*__add__ = *cspacec::iString___add__;
*__concat__ = *cspacec::iString___concat__;
*__concat_ass__ = *cspacec::iString___concat_ass__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csString ##############

package cspace::csString;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csString(@_);
    bless $self, $pkg if defined($self);
}

*__eq__ = *cspacec::csString___eq__;
*__seq__ = *cspacec::csString___seq__;
*__string__ = *cspacec::csString___string__;
*__sv__ = *cspacec::csString___sv__;
*__av__ = *cspacec::csString___av__;
*length = *cspacec::csString_length;
*__add__ = *cspacec::csString___add__;
*__concat__ = *cspacec::csString___concat__;
*__concat_ass__ = *cspacec::csString___concat_ass__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csVector2 ##############

package cspace::csVector2;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *cspacec::csVector2_x_get;
*swig_x_set = *cspacec::csVector2_x_set;
*swig_y_get = *cspacec::csVector2_y_get;
*swig_y_set = *cspacec::csVector2_y_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csVector2(@_);
    bless $self, $pkg if defined($self);
}

*Description = *cspacec::csVector2_Description;
*Set = *cspacec::csVector2_Set;
*Get = *cspacec::csVector2_Get;
*Norm = *cspacec::csVector2_Norm;
*SquaredNorm = *cspacec::csVector2_SquaredNorm;
*Rotate = *cspacec::csVector2_Rotate;
*IsLeft = *cspacec::csVector2_IsLeft;
*__add_ass__ = *cspacec::csVector2___add_ass__;
*__subtr_ass__ = *cspacec::csVector2___subtr_ass__;
*__mult_ass__ = *cspacec::csVector2___mult_ass__;
*__divide_ass__ = *cspacec::csVector2___divide_ass__;
*__add__ = *cspacec::csVector2___add__;
*__subtr__ = *cspacec::csVector2___subtr__;
*__mult__ = *cspacec::csVector2___mult__;
*__div__ = *cspacec::csVector2___div__;
*__eq__ = *cspacec::csVector2___eq__;
*__ne__ = *cspacec::csVector2___ne__;
*__lt__ = *cspacec::csVector2___lt__;
*__gt__ = *cspacec::csVector2___gt__;
*__abs__ = *cspacec::csVector2___abs__;
*__av__ = *cspacec::csVector2___av__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csVector2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csVector3 ##############

package cspace::csVector3;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *cspacec::csVector3_x_get;
*swig_x_set = *cspacec::csVector3_x_set;
*swig_y_get = *cspacec::csVector3_y_get;
*swig_y_set = *cspacec::csVector3_y_set;
*swig_z_get = *cspacec::csVector3_z_get;
*swig_z_set = *cspacec::csVector3_z_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csVector3(@_);
    bless $self, $pkg if defined($self);
}

*Description = *cspacec::csVector3_Description;
*Cross = *cspacec::csVector3_Cross;
*__add_ass__ = *cspacec::csVector3___add_ass__;
*__subtr_ass__ = *cspacec::csVector3___subtr_ass__;
*Set = *cspacec::csVector3_Set;
*Get = *cspacec::csVector3_Get;
*Norm = *cspacec::csVector3_Norm;
*SquaredNorm = *cspacec::csVector3_SquaredNorm;
*Unit = *cspacec::csVector3_Unit;
*Normalize = *cspacec::csVector3_Normalize;
*IsZero = *cspacec::csVector3_IsZero;
*__add__ = *cspacec::csVector3___add__;
*__subtr__ = *cspacec::csVector3___subtr__;
*__mult__ = *cspacec::csVector3___mult__;
*__eq__ = *cspacec::csVector3___eq__;
*__ne__ = *cspacec::csVector3___ne__;
*__lt__ = *cspacec::csVector3___lt__;
*__gt__ = *cspacec::csVector3___gt__;
*__mult_ass__ = *cspacec::csVector3___mult_ass__;
*__divide_ass__ = *cspacec::csVector3___divide_ass__;
*__div__ = *cspacec::csVector3___div__;
*project = *cspacec::csVector3_project;
*__abs__ = *cspacec::csVector3___abs__;
*__av__ = *cspacec::csVector3___av__;
*__bool__ = *cspacec::csVector3___bool__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csVector3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csMatrix2 ##############

package cspace::csMatrix2;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_m11_get = *cspacec::csMatrix2_m11_get;
*swig_m11_set = *cspacec::csMatrix2_m11_set;
*swig_m12_get = *cspacec::csMatrix2_m12_get;
*swig_m12_set = *cspacec::csMatrix2_m12_set;
*swig_m21_get = *cspacec::csMatrix2_m21_get;
*swig_m21_set = *cspacec::csMatrix2_m21_set;
*swig_m22_get = *cspacec::csMatrix2_m22_get;
*swig_m22_set = *cspacec::csMatrix2_m22_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csMatrix2(@_);
    bless $self, $pkg if defined($self);
}

*Row1 = *cspacec::csMatrix2_Row1;
*Row2 = *cspacec::csMatrix2_Row2;
*Col1 = *cspacec::csMatrix2_Col1;
*Col2 = *cspacec::csMatrix2_Col2;
*Set = *cspacec::csMatrix2_Set;
*__add_ass__ = *cspacec::csMatrix2___add_ass__;
*__subtr_ass__ = *cspacec::csMatrix2___subtr_ass__;
*__mult_ass__ = *cspacec::csMatrix2___mult_ass__;
*__divide_ass__ = *cspacec::csMatrix2___divide_ass__;
*__add__ = *cspacec::csMatrix2___add__;
*__subtr__ = *cspacec::csMatrix2___subtr__;
*Transpose = *cspacec::csMatrix2_Transpose;
*GetTranspose = *cspacec::csMatrix2_GetTranspose;
*GetInverse = *cspacec::csMatrix2_GetInverse;
*Invert = *cspacec::csMatrix2_Invert;
*Determinant = *cspacec::csMatrix2_Determinant;
*Identity = *cspacec::csMatrix2_Identity;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csMatrix2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csMatrix3 ##############

package cspace::csMatrix3;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_m11_get = *cspacec::csMatrix3_m11_get;
*swig_m11_set = *cspacec::csMatrix3_m11_set;
*swig_m12_get = *cspacec::csMatrix3_m12_get;
*swig_m12_set = *cspacec::csMatrix3_m12_set;
*swig_m13_get = *cspacec::csMatrix3_m13_get;
*swig_m13_set = *cspacec::csMatrix3_m13_set;
*swig_m21_get = *cspacec::csMatrix3_m21_get;
*swig_m21_set = *cspacec::csMatrix3_m21_set;
*swig_m22_get = *cspacec::csMatrix3_m22_get;
*swig_m22_set = *cspacec::csMatrix3_m22_set;
*swig_m23_get = *cspacec::csMatrix3_m23_get;
*swig_m23_set = *cspacec::csMatrix3_m23_set;
*swig_m31_get = *cspacec::csMatrix3_m31_get;
*swig_m31_set = *cspacec::csMatrix3_m31_set;
*swig_m32_get = *cspacec::csMatrix3_m32_get;
*swig_m32_set = *cspacec::csMatrix3_m32_set;
*swig_m33_get = *cspacec::csMatrix3_m33_get;
*swig_m33_set = *cspacec::csMatrix3_m33_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csMatrix3(@_);
    bless $self, $pkg if defined($self);
}

*Row1 = *cspacec::csMatrix3_Row1;
*Row2 = *cspacec::csMatrix3_Row2;
*Row3 = *cspacec::csMatrix3_Row3;
*Col1 = *cspacec::csMatrix3_Col1;
*Col2 = *cspacec::csMatrix3_Col2;
*Col3 = *cspacec::csMatrix3_Col3;
*Set = *cspacec::csMatrix3_Set;
*__copy__ = *cspacec::csMatrix3___copy__;
*__add_ass__ = *cspacec::csMatrix3___add_ass__;
*__subtr_ass__ = *cspacec::csMatrix3___subtr_ass__;
*__divide_ass__ = *cspacec::csMatrix3___divide_ass__;
*Transpose = *cspacec::csMatrix3_Transpose;
*GetTranspose = *cspacec::csMatrix3_GetTranspose;
*GetInverse = *cspacec::csMatrix3_GetInverse;
*Invert = *cspacec::csMatrix3_Invert;
*Determinant = *cspacec::csMatrix3_Determinant;
*Identity = *cspacec::csMatrix3_Identity;
*IsIdentity = *cspacec::csMatrix3_IsIdentity;
*__add__ = *cspacec::csMatrix3___add__;
*__subtr__ = *cspacec::csMatrix3___subtr__;
*__div__ = *cspacec::csMatrix3___div__;
*__eq__ = *cspacec::csMatrix3___eq__;
*__ne__ = *cspacec::csMatrix3___ne__;
*__lt__ = *cspacec::csMatrix3___lt__;
*__mult__ = *cspacec::csMatrix3___mult__;
*__mult_ass__ = *cspacec::csMatrix3___mult_ass__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csMatrix3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csXRotMatrix3 ##############

package cspace::csXRotMatrix3;
@ISA = qw( cspace cspace::csMatrix3 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csXRotMatrix3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csXRotMatrix3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csYRotMatrix3 ##############

package cspace::csYRotMatrix3;
@ISA = qw( cspace cspace::csMatrix3 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csYRotMatrix3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csYRotMatrix3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csZRotMatrix3 ##############

package cspace::csZRotMatrix3;
@ISA = qw( cspace cspace::csMatrix3 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csZRotMatrix3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csZRotMatrix3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csXScaleMatrix3 ##############

package cspace::csXScaleMatrix3;
@ISA = qw( cspace cspace::csMatrix3 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csXScaleMatrix3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csXScaleMatrix3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csYScaleMatrix3 ##############

package cspace::csYScaleMatrix3;
@ISA = qw( cspace cspace::csMatrix3 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csYScaleMatrix3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csYScaleMatrix3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csZScaleMatrix3 ##############

package cspace::csZScaleMatrix3;
@ISA = qw( cspace cspace::csMatrix3 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csZScaleMatrix3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csZScaleMatrix3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csTransform ##############

package cspace::csTransform;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csTransform($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = cspacec::new_csTransform(@_);
    bless $self, $pkg if defined($self);
}

*Identity = *cspacec::csTransform_Identity;
*IsIdentity = *cspacec::csTransform_IsIdentity;
*GetO2T = *cspacec::csTransform_GetO2T;
*GetO2TTranslation = *cspacec::csTransform_GetO2TTranslation;
*GetOrigin = *cspacec::csTransform_GetOrigin;
*SetO2T = *cspacec::csTransform_SetO2T;
*SetO2TTranslation = *cspacec::csTransform_SetO2TTranslation;
*SetOrigin = *cspacec::csTransform_SetOrigin;
*Translate = *cspacec::csTransform_Translate;
*Other2ThisRelative = *cspacec::csTransform_Other2ThisRelative;
*Other2This = *cspacec::csTransform_Other2This;
*GetReflect = *cspacec::csTransform_GetReflect;
*__mult__ = *cspacec::csTransform___mult__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csReversibleTransform ##############

package cspace::csReversibleTransform;
@ISA = qw( cspace cspace::csTransform );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csReversibleTransform(@_);
    bless $self, $pkg if defined($self);
}

*GetT2O = *cspacec::csReversibleTransform_GetT2O;
*GetT2OTranslation = *cspacec::csReversibleTransform_GetT2OTranslation;
*GetInverse = *cspacec::csReversibleTransform_GetInverse;
*SetO2T = *cspacec::csReversibleTransform_SetO2T;
*SetT2O = *cspacec::csReversibleTransform_SetT2O;
*This2OtherRelative = *cspacec::csReversibleTransform_This2OtherRelative;
*This2Other = *cspacec::csReversibleTransform_This2Other;
*RotateOther = *cspacec::csReversibleTransform_RotateOther;
*RotateThis = *cspacec::csReversibleTransform_RotateThis;
*LookAt = *cspacec::csReversibleTransform_LookAt;
*__mult_ass__ = *cspacec::csReversibleTransform___mult_ass__;
*__mult__ = *cspacec::csReversibleTransform___mult__;
*__divide_ass__ = *cspacec::csReversibleTransform___divide_ass__;
*__div__ = *cspacec::csReversibleTransform___div__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csReversibleTransform($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csOrthoTransform ##############

package cspace::csOrthoTransform;
@ISA = qw( cspace cspace::csReversibleTransform );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csOrthoTransform(@_);
    bless $self, $pkg if defined($self);
}

*SetO2T = *cspacec::csOrthoTransform_SetO2T;
*SetT2O = *cspacec::csOrthoTransform_SetT2O;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csOrthoTransform($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csSphere ##############

package cspace::csSphere;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csSphere(@_);
    bless $self, $pkg if defined($self);
}

*GetCenter = *cspacec::csSphere_GetCenter;
*SetCenter = *cspacec::csSphere_SetCenter;
*GetRadius = *cspacec::csSphere_GetRadius;
*SetRadius = *cspacec::csSphere_SetRadius;
*Union = *cspacec::csSphere_Union;
*__add_ass__ = *cspacec::csSphere___add_ass__;
*__mult_ass__ = *cspacec::csSphere___mult_ass__;
*__div__ = *cspacec::csSphere___div__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csSphere($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPlane2 ##############

package cspace::csPlane2;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_norm_get = *cspacec::csPlane2_norm_get;
*swig_norm_set = *cspacec::csPlane2_norm_set;
*swig_CC_get = *cspacec::csPlane2_CC_get;
*swig_CC_set = *cspacec::csPlane2_CC_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPlane2(@_);
    bless $self, $pkg if defined($self);
}

*Normal = *cspacec::csPlane2_Normal;
*GetNormal = *cspacec::csPlane2_GetNormal;
*A = *cspacec::csPlane2_A;
*B = *cspacec::csPlane2_B;
*C = *cspacec::csPlane2_C;
*Set = *cspacec::csPlane2_Set;
*Classify = *cspacec::csPlane2_Classify;
*Distance = *cspacec::csPlane2_Distance;
*SquaredDistance = *cspacec::csPlane2_SquaredDistance;
*Invert = *cspacec::csPlane2_Invert;
*Normalize = *cspacec::csPlane2_Normalize;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPlane2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPlane3 ##############

package cspace::csPlane3;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_norm_get = *cspacec::csPlane3_norm_get;
*swig_norm_set = *cspacec::csPlane3_norm_set;
*swig_DD_get = *cspacec::csPlane3_DD_get;
*swig_DD_set = *cspacec::csPlane3_DD_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPlane3(@_);
    bless $self, $pkg if defined($self);
}

*Normal = *cspacec::csPlane3_Normal;
*A = *cspacec::csPlane3_A;
*B = *cspacec::csPlane3_B;
*C = *cspacec::csPlane3_C;
*D = *cspacec::csPlane3_D;
*GetNormal = *cspacec::csPlane3_GetNormal;
*Set = *cspacec::csPlane3_Set;
*Classify = *cspacec::csPlane3_Classify;
*Distance = *cspacec::csPlane3_Distance;
*Invert = *cspacec::csPlane3_Invert;
*Normalize = *cspacec::csPlane3_Normalize;
*FindPoint = *cspacec::csPlane3_FindPoint;
*ClipPolygon = *cspacec::csPlane3_ClipPolygon;
*__mult_ass__ = *cspacec::csPlane3___mult_ass__;
*__divide_ass__ = *cspacec::csPlane3___divide_ass__;
*__div__ = *cspacec::csPlane3___div__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPlane3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csMath2 ##############

package cspace::csMath2;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*WhichSide2D = *cspacec::csMath2_WhichSide2D;
*InPoly2D = *cspacec::csMath2_InPoly2D;
*Area2 = *cspacec::csMath2_Area2;
*Right = *cspacec::csMath2_Right;
*Left = *cspacec::csMath2_Left;
*Visible = *cspacec::csMath2_Visible;
*PlanesEqual = *cspacec::csMath2_PlanesEqual;
*PlanesClose = *cspacec::csMath2_PlanesClose;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csMath2(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csMath2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csIntersect2 ##############

package cspace::csIntersect2;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*PlanePolygon = *cspacec::csIntersect2_PlanePolygon;
*SegmentSegment = *cspacec::csIntersect2_SegmentSegment;
*SegmentLine = *cspacec::csIntersect2_SegmentLine;
*LineLine = *cspacec::csIntersect2_LineLine;
*SegmentPlane = *cspacec::csIntersect2_SegmentPlane;
*SegmentPlaneNoTest = *cspacec::csIntersect2_SegmentPlaneNoTest;
*PlanePlane = *cspacec::csIntersect2_PlanePlane;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csIntersect2(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csIntersect2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPoly2D ##############

package cspace::csPoly2D;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPoly2D(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPoly2D($self);
        delete $OWNER{$self};
    }
}

*__copy__ = *cspacec::csPoly2D___copy__;
*MakeEmpty = *cspacec::csPoly2D_MakeEmpty;
*GetVertexCount = *cspacec::csPoly2D_GetVertexCount;
*GetVertices = *cspacec::csPoly2D_GetVertices;
*GetVertex = *cspacec::csPoly2D_GetVertex;
*GetFirst = *cspacec::csPoly2D_GetFirst;
*GetLast = *cspacec::csPoly2D_GetLast;
*In = *cspacec::csPoly2D_In;
*MakeRoom = *cspacec::csPoly2D_MakeRoom;
*SetVertexCount = *cspacec::csPoly2D_SetVertexCount;
*AddVertex = *cspacec::csPoly2D_AddVertex;
*SetVertices = *cspacec::csPoly2D_SetVertices;
*ClipAgainst = *cspacec::csPoly2D_ClipAgainst;
*Intersect = *cspacec::csPoly2D_Intersect;
*ClipPlane = *cspacec::csPoly2D_ClipPlane;
*ExtendConvex = *cspacec::csPoly2D_ExtendConvex;
*GetSignedArea = *cspacec::csPoly2D_GetSignedArea;
*Random = *cspacec::csPoly2D_Random;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPoly2DFactory ##############

package cspace::csPoly2DFactory;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPoly2DFactory($self);
        delete $OWNER{$self};
    }
}

*Create = *cspacec::csPoly2DFactory_Create;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPoly2DFactory(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csMath3 ##############

package cspace::csMath3;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*WhichSide3D = *cspacec::csMath3_WhichSide3D;
*Visible = *cspacec::csMath3_Visible;
*Between = *cspacec::csMath3_Between;
*SetMinMax = *cspacec::csMath3_SetMinMax;
*DoubleArea3 = *cspacec::csMath3_DoubleArea3;
*Direction3 = *cspacec::csMath3_Direction3;
*CalcNormal = *cspacec::csMath3_CalcNormal;
*CalcPlane = *cspacec::csMath3_CalcPlane;
*PlanesEqual = *cspacec::csMath3_PlanesEqual;
*PlanesClose = *cspacec::csMath3_PlanesClose;
*OuterPlanes = *cspacec::csMath3_OuterPlanes;
*FindObserverSides = *cspacec::csMath3_FindObserverSides;
*SpherePosition = *cspacec::csMath3_SpherePosition;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csMath3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csMath3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csSquaredDist ##############

package cspace::csSquaredDist;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*PointPoint = *cspacec::csSquaredDist_PointPoint;
*PointLine = *cspacec::csSquaredDist_PointLine;
*PointPlane = *cspacec::csSquaredDist_PointPlane;
*PointPoly = *cspacec::csSquaredDist_PointPoly;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csSquaredDist(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csSquaredDist($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csIntersect3 ##############

package cspace::csIntersect3;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*PlanePolygon = *cspacec::csIntersect3_PlanePolygon;
*SegmentFrustum = *cspacec::csIntersect3_SegmentFrustum;
*SegmentTriangle = *cspacec::csIntersect3_SegmentTriangle;
*SegmentPolygon = *cspacec::csIntersect3_SegmentPolygon;
*SegmentPlanes = *cspacec::csIntersect3_SegmentPlanes;
*SegmentPlane = *cspacec::csIntersect3_SegmentPlane;
*ThreePlanes = *cspacec::csIntersect3_ThreePlanes;
*PlaneXPlane = *cspacec::csIntersect3_PlaneXPlane;
*PlaneYPlane = *cspacec::csIntersect3_PlaneYPlane;
*PlaneZPlane = *cspacec::csIntersect3_PlaneZPlane;
*PlaneAxisPlane = *cspacec::csIntersect3_PlaneAxisPlane;
*SegmentZ0Plane = *cspacec::csIntersect3_SegmentZ0Plane;
*SegmentXPlane = *cspacec::csIntersect3_SegmentXPlane;
*SegmentYPlane = *cspacec::csIntersect3_SegmentYPlane;
*SegmentZPlane = *cspacec::csIntersect3_SegmentZPlane;
*SegmentAxisPlane = *cspacec::csIntersect3_SegmentAxisPlane;
*SegmentXFrustum = *cspacec::csIntersect3_SegmentXFrustum;
*SegmentYFrustum = *cspacec::csIntersect3_SegmentYFrustum;
*BoxSegment = *cspacec::csIntersect3_BoxSegment;
*BoxFrustum = *cspacec::csIntersect3_BoxFrustum;
*BoxSphere = *cspacec::csIntersect3_BoxSphere;
*BoxPlane = *cspacec::csIntersect3_BoxPlane;
*BoxTriangle = *cspacec::csIntersect3_BoxTriangle;
*BoxBox = *cspacec::csIntersect3_BoxBox;
*FrustumFrustum = *cspacec::csIntersect3_FrustumFrustum;
*TriangleTriangle = *cspacec::csIntersect3_TriangleTriangle;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csIntersect3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csIntersect3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csGeomDebugHelper ##############

package cspace::csGeomDebugHelper;
@ISA = qw( cspace cspace::iDebugHelper );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csGeomDebugHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csGeomDebugHelper($self);
        delete $OWNER{$self};
    }
}

*swig_scfRefCount_get = *cspacec::csGeomDebugHelper_scfRefCount_get;
*swig_scfRefCount_set = *cspacec::csGeomDebugHelper_scfRefCount_set;
*swig_scfWeakRefOwners_get = *cspacec::csGeomDebugHelper_scfWeakRefOwners_get;
*swig_scfWeakRefOwners_set = *cspacec::csGeomDebugHelper_scfWeakRefOwners_set;
*scfRemoveRefOwners = *cspacec::csGeomDebugHelper_scfRemoveRefOwners;
*swig_scfParent_get = *cspacec::csGeomDebugHelper_scfParent_get;
*swig_scfParent_set = *cspacec::csGeomDebugHelper_scfParent_set;
*IncRef = *cspacec::csGeomDebugHelper_IncRef;
*DecRef = *cspacec::csGeomDebugHelper_DecRef;
*GetRefCount = *cspacec::csGeomDebugHelper_GetRefCount;
*AddRefOwner = *cspacec::csGeomDebugHelper_AddRefOwner;
*RemoveRefOwner = *cspacec::csGeomDebugHelper_RemoveRefOwner;
*QueryInterface = *cspacec::csGeomDebugHelper_QueryInterface;
*GetSupportedTests = *cspacec::csGeomDebugHelper_GetSupportedTests;
*UnitTest = *cspacec::csGeomDebugHelper_UnitTest;
*StateTest = *cspacec::csGeomDebugHelper_StateTest;
*Benchmark = *cspacec::csGeomDebugHelper_Benchmark;
*Dump = *cspacec::csGeomDebugHelper_Dump;
*DebugCommand = *cspacec::csGeomDebugHelper_DebugCommand;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPoly3D ##############

package cspace::csPoly3D;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPoly3D(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPoly3D($self);
        delete $OWNER{$self};
    }
}

*MakeEmpty = *cspacec::csPoly3D_MakeEmpty;
*GetVertexCount = *cspacec::csPoly3D_GetVertexCount;
*GetVertices = *cspacec::csPoly3D_GetVertices;
*GetVertex = *cspacec::csPoly3D_GetVertex;
*GetFirst = *cspacec::csPoly3D_GetFirst;
*GetLast = *cspacec::csPoly3D_GetLast;
*In = *cspacec::csPoly3D_In;
*MakeRoom = *cspacec::csPoly3D_MakeRoom;
*SetVertexCount = *cspacec::csPoly3D_SetVertexCount;
*AddVertex = *cspacec::csPoly3D_AddVertex;
*SetVertices = *cspacec::csPoly3D_SetVertices;
*ProjectXPlane = *cspacec::csPoly3D_ProjectXPlane;
*ProjectYPlane = *cspacec::csPoly3D_ProjectYPlane;
*ProjectZPlane = *cspacec::csPoly3D_ProjectZPlane;
*ProjectAxisPlane = *cspacec::csPoly3D_ProjectAxisPlane;
*Classify = *cspacec::csPoly3D_Classify;
*ClassifyX = *cspacec::csPoly3D_ClassifyX;
*ClassifyY = *cspacec::csPoly3D_ClassifyY;
*ClassifyZ = *cspacec::csPoly3D_ClassifyZ;
*ClassifyAxis = *cspacec::csPoly3D_ClassifyAxis;
*IsAxisAligned = *cspacec::csPoly3D_IsAxisAligned;
*CutToPlane = *cspacec::csPoly3D_CutToPlane;
*SplitWithPlane = *cspacec::csPoly3D_SplitWithPlane;
*SplitWithPlaneX = *cspacec::csPoly3D_SplitWithPlaneX;
*SplitWithPlaneY = *cspacec::csPoly3D_SplitWithPlaneY;
*SplitWithPlaneZ = *cspacec::csPoly3D_SplitWithPlaneZ;
*ComputeNormal = *cspacec::csPoly3D_ComputeNormal;
*ComputePlane = *cspacec::csPoly3D_ComputePlane;
*GetArea = *cspacec::csPoly3D_GetArea;
*GetCenter = *cspacec::csPoly3D_GetCenter;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csCompressVertex ##############

package cspace::csCompressVertex;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_orig_idx_get = *cspacec::csCompressVertex_orig_idx_get;
*swig_orig_idx_set = *cspacec::csCompressVertex_orig_idx_set;
*swig_x_get = *cspacec::csCompressVertex_x_get;
*swig_x_set = *cspacec::csCompressVertex_x_set;
*swig_y_get = *cspacec::csCompressVertex_y_get;
*swig_y_set = *cspacec::csCompressVertex_y_set;
*swig_z_get = *cspacec::csCompressVertex_z_get;
*swig_z_set = *cspacec::csCompressVertex_z_set;
*swig_new_idx_get = *cspacec::csCompressVertex_new_idx_get;
*swig_new_idx_set = *cspacec::csCompressVertex_new_idx_set;
*swig_used_get = *cspacec::csCompressVertex_used_get;
*swig_used_set = *cspacec::csCompressVertex_used_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csCompressVertex(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csCompressVertex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csVector3Array ##############

package cspace::csVector3Array;
@ISA = qw( cspace cspace::csPoly3D );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csVector3Array(@_);
    bless $self, $pkg if defined($self);
}

*AddVertexSmart = *cspacec::csVector3Array_AddVertexSmart;
*CompressVertices = *cspacec::csVector3Array_CompressVertices;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csVector3Array($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csTriangle ##############

package cspace::csTriangle;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_a_get = *cspacec::csTriangle_a_get;
*swig_a_set = *cspacec::csTriangle_a_set;
*swig_b_get = *cspacec::csTriangle_b_get;
*swig_b_set = *cspacec::csTriangle_b_set;
*swig_c_get = *cspacec::csTriangle_c_get;
*swig_c_set = *cspacec::csTriangle_c_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csTriangle(@_);
    bless $self, $pkg if defined($self);
}

*__copy__ = *cspacec::csTriangle___copy__;
*Set = *cspacec::csTriangle_Set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csTriangle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csRect ##############

package cspace::csRect;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_xmin_get = *cspacec::csRect_xmin_get;
*swig_xmin_set = *cspacec::csRect_xmin_set;
*swig_ymin_get = *cspacec::csRect_ymin_get;
*swig_ymin_set = *cspacec::csRect_ymin_set;
*swig_xmax_get = *cspacec::csRect_xmax_get;
*swig_xmax_set = *cspacec::csRect_xmax_set;
*swig_ymax_get = *cspacec::csRect_ymax_get;
*swig_ymax_set = *cspacec::csRect_ymax_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csRect(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csRect($self);
        delete $OWNER{$self};
    }
}

*Intersect = *cspacec::csRect_Intersect;
*Intersects = *cspacec::csRect_Intersects;
*Union = *cspacec::csRect_Union;
*Exclude = *cspacec::csRect_Exclude;
*Subtract = *cspacec::csRect_Subtract;
*IsEmpty = *cspacec::csRect_IsEmpty;
*MakeEmpty = *cspacec::csRect_MakeEmpty;
*Set = *cspacec::csRect_Set;
*SetPos = *cspacec::csRect_SetPos;
*SetSize = *cspacec::csRect_SetSize;
*Move = *cspacec::csRect_Move;
*Width = *cspacec::csRect_Width;
*Height = *cspacec::csRect_Height;
*Contains = *cspacec::csRect_Contains;
*ContainsRel = *cspacec::csRect_ContainsRel;
*Equal = *cspacec::csRect_Equal;
*Normalize = *cspacec::csRect_Normalize;
*Area = *cspacec::csRect_Area;
*AddAdjanced = *cspacec::csRect_AddAdjanced;
*__eq__ = *cspacec::csRect___eq__;
*__ne__ = *cspacec::csRect___ne__;
*Extend = *cspacec::csRect_Extend;
*Join = *cspacec::csRect_Join;
*Outset = *cspacec::csRect_Outset;
*Inset = *cspacec::csRect_Inset;
*ClipLineGeneral = *cspacec::csRect_ClipLineGeneral;
*ClipLine = *cspacec::csRect_ClipLine;
*ClipLineSafe = *cspacec::csRect_ClipLineSafe;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csRectRegion ##############

package cspace::csRectRegion;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csRectRegion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csRectRegion($self);
        delete $OWNER{$self};
    }
}

*Include = *cspacec::csRectRegion_Include;
*Exclude = *cspacec::csRectRegion_Exclude;
*ClipTo = *cspacec::csRectRegion_ClipTo;
*Count = *cspacec::csRectRegion_Count;
*RectAt = *cspacec::csRectRegion_RectAt;
*makeEmpty = *cspacec::csRectRegion_makeEmpty;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csQuaternion ##############

package cspace::csQuaternion;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*Init = *cspacec::csQuaternion_Init;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csQuaternion(@_);
    bless $self, $pkg if defined($self);
}

*__mult_ass__ = *cspacec::csQuaternion___mult_ass__;
*Conjugate = *cspacec::csQuaternion_Conjugate;
*Negate = *cspacec::csQuaternion_Negate;
*Invert = *cspacec::csQuaternion_Invert;
*GetAxisAngle = *cspacec::csQuaternion_GetAxisAngle;
*SetWithAxisAngle = *cspacec::csQuaternion_SetWithAxisAngle;
*PrepRotation = *cspacec::csQuaternion_PrepRotation;
*Rotate = *cspacec::csQuaternion_Rotate;
*Normalize = *cspacec::csQuaternion_Normalize;
*SetWithEuler = *cspacec::csQuaternion_SetWithEuler;
*GetEulerAngles = *cspacec::csQuaternion_GetEulerAngles;
*ToAxisAngle = *cspacec::csQuaternion_ToAxisAngle;
*Slerp = *cspacec::csQuaternion_Slerp;
*swig_r_get = *cspacec::csQuaternion_r_get;
*swig_r_set = *cspacec::csQuaternion_r_set;
*swig_x_get = *cspacec::csQuaternion_x_get;
*swig_x_set = *cspacec::csQuaternion_x_set;
*swig_y_get = *cspacec::csQuaternion_y_get;
*swig_y_set = *cspacec::csQuaternion_y_set;
*swig_z_get = *cspacec::csQuaternion_z_get;
*swig_z_set = *cspacec::csQuaternion_z_set;
*__add__ = *cspacec::csQuaternion___add__;
*__subtr__ = *cspacec::csQuaternion___subtr__;
*__mult__ = *cspacec::csQuaternion___mult__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csQuaternion($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csSpline ##############

package cspace::csSpline;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csSpline($self);
        delete $OWNER{$self};
    }
}

*GetDimensionCount = *cspacec::csSpline_GetDimensionCount;
*GetPointCount = *cspacec::csSpline_GetPointCount;
*InsertPoint = *cspacec::csSpline_InsertPoint;
*RemovePoint = *cspacec::csSpline_RemovePoint;
*SetTimeValues = *cspacec::csSpline_SetTimeValues;
*SetTimeValue = *cspacec::csSpline_SetTimeValue;
*GetTimeValues = *cspacec::csSpline_GetTimeValues;
*GetTimeValue = *cspacec::csSpline_GetTimeValue;
*SetDimensionValues = *cspacec::csSpline_SetDimensionValues;
*SetDimensionValue = *cspacec::csSpline_SetDimensionValue;
*GetDimensionValues = *cspacec::csSpline_GetDimensionValues;
*GetDimensionValue = *cspacec::csSpline_GetDimensionValue;
*SetIndexValues = *cspacec::csSpline_SetIndexValues;
*GetIndexValues = *cspacec::csSpline_GetIndexValues;
*Calculate = *cspacec::csSpline_Calculate;
*GetCurrentIndex = *cspacec::csSpline_GetCurrentIndex;
*GetInterpolatedDimension = *cspacec::csSpline_GetInterpolatedDimension;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csCubicSpline ##############

package cspace::csCubicSpline;
@ISA = qw( cspace cspace::csSpline );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csCubicSpline(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csCubicSpline($self);
        delete $OWNER{$self};
    }
}

*Calculate = *cspacec::csCubicSpline_Calculate;
*GetInterpolatedDimension = *cspacec::csCubicSpline_GetInterpolatedDimension;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csBSpline ##############

package cspace::csBSpline;
@ISA = qw( cspace cspace::csSpline );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csBSpline(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csBSpline($self);
        delete $OWNER{$self};
    }
}

*Calculate = *cspacec::csBSpline_Calculate;
*GetInterpolatedDimension = *cspacec::csBSpline_GetInterpolatedDimension;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csCatmullRomSpline ##############

package cspace::csCatmullRomSpline;
@ISA = qw( cspace cspace::csBSpline );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csCatmullRomSpline(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csCatmullRomSpline($self);
        delete $OWNER{$self};
    }
}

*Clone = *cspacec::csCatmullRomSpline_Clone;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPoint ##############

package cspace::csPoint;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *cspacec::csPoint_x_get;
*swig_x_set = *cspacec::csPoint_x_set;
*swig_y_get = *cspacec::csPoint_y_get;
*swig_y_set = *cspacec::csPoint_y_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPoint(@_);
    bless $self, $pkg if defined($self);
}

*Set = *cspacec::csPoint_Set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPoint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csBox2 ##############

package cspace::csBox2;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*MinX = *cspacec::csBox2_MinX;
*MinY = *cspacec::csBox2_MinY;
*MaxX = *cspacec::csBox2_MaxX;
*MaxY = *cspacec::csBox2_MaxY;
*Min = *cspacec::csBox2_Min;
*Max = *cspacec::csBox2_Max;
*GetCorner = *cspacec::csBox2_GetCorner;
*GetCenter = *cspacec::csBox2_GetCenter;
*SetCenter = *cspacec::csBox2_SetCenter;
*SetSize = *cspacec::csBox2_SetSize;
*GetEdgeInfo = *cspacec::csBox2_GetEdgeInfo;
*GetEdge = *cspacec::csBox2_GetEdge;
*Intersect = *cspacec::csBox2_Intersect;
*In = *cspacec::csBox2_In;
*Overlap = *cspacec::csBox2_Overlap;
*Contains = *cspacec::csBox2_Contains;
*Empty = *cspacec::csBox2_Empty;
*SquaredOriginDist = *cspacec::csBox2_SquaredOriginDist;
*SquaredOriginMaxDist = *cspacec::csBox2_SquaredOriginMaxDist;
*StartBoundingBox = *cspacec::csBox2_StartBoundingBox;
*AddBoundingVertex = *cspacec::csBox2_AddBoundingVertex;
*AddBoundingVertexSmart = *cspacec::csBox2_AddBoundingVertexSmart;
*AddBoundingVertexTest = *cspacec::csBox2_AddBoundingVertexTest;
*AddBoundingVertexSmartTest = *cspacec::csBox2_AddBoundingVertexSmartTest;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csBox2(@_);
    bless $self, $pkg if defined($self);
}

*Set = *cspacec::csBox2_Set;
*SetMin = *cspacec::csBox2_SetMin;
*SetMax = *cspacec::csBox2_SetMax;
*Description = *cspacec::csBox2_Description;
*__add_ass__ = *cspacec::csBox2___add_ass__;
*__mult_ass__ = *cspacec::csBox2___mult_ass__;
*TestIntersect = *cspacec::csBox2_TestIntersect;
*__mult__ = *cspacec::csBox2___mult__;
*__ne__ = *cspacec::csBox2___ne__;
*__gt__ = *cspacec::csBox2___gt__;
*__add__ = *cspacec::csBox2___add__;
*__lt__ = *cspacec::csBox2___lt__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csBox2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csBox3 ##############

package cspace::csBox3;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*MinX = *cspacec::csBox3_MinX;
*MinY = *cspacec::csBox3_MinY;
*MinZ = *cspacec::csBox3_MinZ;
*MaxX = *cspacec::csBox3_MaxX;
*MaxY = *cspacec::csBox3_MaxY;
*MaxZ = *cspacec::csBox3_MaxZ;
*Min = *cspacec::csBox3_Min;
*Max = *cspacec::csBox3_Max;
*GetCorner = *cspacec::csBox3_GetCorner;
*GetEdgeInfo = *cspacec::csBox3_GetEdgeInfo;
*GetFaceEdges = *cspacec::csBox3_GetFaceEdges;
*GetCenter = *cspacec::csBox3_GetCenter;
*SetCenter = *cspacec::csBox3_SetCenter;
*SetSize = *cspacec::csBox3_SetSize;
*GetSide = *cspacec::csBox3_GetSide;
*GetAxisPlane = *cspacec::csBox3_GetAxisPlane;
*GetVisibleSides = *cspacec::csBox3_GetVisibleSides;
*OtherSide = *cspacec::csBox3_OtherSide;
*GetEdge = *cspacec::csBox3_GetEdge;
*In = *cspacec::csBox3_In;
*Overlap = *cspacec::csBox3_Overlap;
*Contains = *cspacec::csBox3_Contains;
*Empty = *cspacec::csBox3_Empty;
*StartBoundingBox = *cspacec::csBox3_StartBoundingBox;
*AddBoundingVertex = *cspacec::csBox3_AddBoundingVertex;
*AddBoundingVertexSmart = *cspacec::csBox3_AddBoundingVertexSmart;
*AddBoundingVertexTest = *cspacec::csBox3_AddBoundingVertexTest;
*AddBoundingVertexSmartTest = *cspacec::csBox3_AddBoundingVertexSmartTest;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csBox3(@_);
    bless $self, $pkg if defined($self);
}

*Set = *cspacec::csBox3_Set;
*SetMin = *cspacec::csBox3_SetMin;
*SetMax = *cspacec::csBox3_SetMax;
*Description = *cspacec::csBox3_Description;
*Split = *cspacec::csBox3_Split;
*TestSplit = *cspacec::csBox3_TestSplit;
*AdjacentX = *cspacec::csBox3_AdjacentX;
*AdjacentY = *cspacec::csBox3_AdjacentY;
*AdjacentZ = *cspacec::csBox3_AdjacentZ;
*Adjacent = *cspacec::csBox3_Adjacent;
*CalculatePointSegment = *cspacec::csBox3_CalculatePointSegment;
*GetConvexOutline = *cspacec::csBox3_GetConvexOutline;
*Between = *cspacec::csBox3_Between;
*ManhattanDistance = *cspacec::csBox3_ManhattanDistance;
*SquaredOriginDist = *cspacec::csBox3_SquaredOriginDist;
*SquaredOriginMaxDist = *cspacec::csBox3_SquaredOriginMaxDist;
*ProjectBox = *cspacec::csBox3_ProjectBox;
*ProjectOutline = *cspacec::csBox3_ProjectOutline;
*ProjectBoxAndOutline = *cspacec::csBox3_ProjectBoxAndOutline;
*__add_ass__ = *cspacec::csBox3___add_ass__;
*__mult_ass__ = *cspacec::csBox3___mult_ass__;
*TestIntersect = *cspacec::csBox3_TestIntersect;
*__mult__ = *cspacec::csBox3___mult__;
*__ne__ = *cspacec::csBox3___ne__;
*__gt__ = *cspacec::csBox3___gt__;
*__add__ = *cspacec::csBox3___add__;
*__lt__ = *cspacec::csBox3___lt__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csBox3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csSegment2 ##############

package cspace::csSegment2;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csSegment2(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csSegment2($self);
        delete $OWNER{$self};
    }
}

*Set = *cspacec::csSegment2_Set;
*SetStart = *cspacec::csSegment2_SetStart;
*SetEnd = *cspacec::csSegment2_SetEnd;
*Start = *cspacec::csSegment2_Start;
*End = *cspacec::csSegment2_End;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csSegment3 ##############

package cspace::csSegment3;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csSegment3(@_);
    bless $self, $pkg if defined($self);
}

*Set = *cspacec::csSegment3_Set;
*SetStart = *cspacec::csSegment3_SetStart;
*SetEnd = *cspacec::csSegment3_SetEnd;
*Start = *cspacec::csSegment3_Start;
*End = *cspacec::csSegment3_End;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csSegment3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csRGBcolor ##############

package cspace::csRGBcolor;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_red_get = *cspacec::csRGBcolor_red_get;
*swig_red_set = *cspacec::csRGBcolor_red_set;
*swig_green_get = *cspacec::csRGBcolor_green_get;
*swig_green_set = *cspacec::csRGBcolor_green_set;
*swig_blue_get = *cspacec::csRGBcolor_blue_get;
*swig_blue_set = *cspacec::csRGBcolor_blue_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csRGBcolor(@_);
    bless $self, $pkg if defined($self);
}

*Set = *cspacec::csRGBcolor_Set;
*__eq__ = *cspacec::csRGBcolor___eq__;
*__ne__ = *cspacec::csRGBcolor___ne__;
*__add__ = *cspacec::csRGBcolor___add__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csRGBcolor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csRGBpixel ##############

package cspace::csRGBpixel;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_red_get = *cspacec::csRGBpixel_red_get;
*swig_red_set = *cspacec::csRGBpixel_red_set;
*swig_green_get = *cspacec::csRGBpixel_green_get;
*swig_green_set = *cspacec::csRGBpixel_green_set;
*swig_blue_get = *cspacec::csRGBpixel_blue_get;
*swig_blue_set = *cspacec::csRGBpixel_blue_set;
*swig_alpha_get = *cspacec::csRGBpixel_alpha_get;
*swig_alpha_set = *cspacec::csRGBpixel_alpha_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csRGBpixel(@_);
    bless $self, $pkg if defined($self);
}

*__eq__ = *cspacec::csRGBpixel___eq__;
*__ne__ = *cspacec::csRGBpixel___ne__;
*asRGBcolor = *cspacec::csRGBpixel_asRGBcolor;
*eq = *cspacec::csRGBpixel_eq;
*Intensity = *cspacec::csRGBpixel_Intensity;
*Luminance = *cspacec::csRGBpixel_Luminance;
*Set = *cspacec::csRGBpixel_Set;
*__add_ass__ = *cspacec::csRGBpixel___add_ass__;
*UnsafeAdd = *cspacec::csRGBpixel_UnsafeAdd;
*SafeAdd = *cspacec::csRGBpixel_SafeAdd;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csRGBpixel($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPluginRequest ##############

package cspace::csPluginRequest;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPluginRequest(@_);
    bless $self, $pkg if defined($self);
}

*__copy__ = *cspacec::csPluginRequest___copy__;
*__eq__ = *cspacec::csPluginRequest___eq__;
*__ne__ = *cspacec::csPluginRequest___ne__;
*GetClassName = *cspacec::csPluginRequest_GetClassName;
*GetInterfaceName = *cspacec::csPluginRequest_GetInterfaceName;
*GetInterfaceID = *cspacec::csPluginRequest_GetInterfaceID;
*GetInterfaceVersion = *cspacec::csPluginRequest_GetInterfaceVersion;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPluginRequest($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csInitializer ##############

package cspace::csInitializer;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*CreateEnvironment = *cspacec::csInitializer_CreateEnvironment;
*InitializeSCF = *cspacec::csInitializer_InitializeSCF;
*CreateObjectRegistry = *cspacec::csInitializer_CreateObjectRegistry;
*CreatePluginManager = *cspacec::csInitializer_CreatePluginManager;
*CreateEventQueue = *cspacec::csInitializer_CreateEventQueue;
*CreateVirtualClock = *cspacec::csInitializer_CreateVirtualClock;
*CreateCommandLineParser = *cspacec::csInitializer_CreateCommandLineParser;
*CreateVerbosityManager = *cspacec::csInitializer_CreateVerbosityManager;
*CreateConfigManager = *cspacec::csInitializer_CreateConfigManager;
*CreateInputDrivers = *cspacec::csInitializer_CreateInputDrivers;
*CreateStringSet = *cspacec::csInitializer_CreateStringSet;
*SetupConfigManager = *cspacec::csInitializer_SetupConfigManager;
*SetupVFS = *cspacec::csInitializer_SetupVFS;
*_RequestPlugins = *cspacec::csInitializer__RequestPlugins;
*OpenApplication = *cspacec::csInitializer_OpenApplication;
*CloseApplication = *cspacec::csInitializer_CloseApplication;
*_SetupEventHandler = *cspacec::csInitializer__SetupEventHandler;
*SetupEventHandler = *cspacec::csInitializer_SetupEventHandler;
*DestroyApplication = *cspacec::csInitializer_DestroyApplication;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csInitializer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csInitializer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPluginRequestArray ##############

package cspace::csPluginRequestArray;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPluginRequestArray($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPluginRequestArray(@_);
    bless $self, $pkg if defined($self);
}

*GetSize = *cspacec::csPluginRequestArray_GetSize;
*Length = *cspacec::csPluginRequestArray_Length;
*Get = *cspacec::csPluginRequestArray_Get;
*Push = *cspacec::csPluginRequestArray_Push;
*Pop = *cspacec::csPluginRequestArray_Pop;
*Top = *cspacec::csPluginRequestArray_Top;
*Insert = *cspacec::csPluginRequestArray_Insert;
*Contains = *cspacec::csPluginRequestArray_Contains;
*Truncate = *cspacec::csPluginRequestArray_Truncate;
*Empty = *cspacec::csPluginRequestArray_Empty;
*IsEmpty = *cspacec::csPluginRequestArray_IsEmpty;
*DeleteIndex = *cspacec::csPluginRequestArray_DeleteIndex;
*DeleteIndexFast = *cspacec::csPluginRequestArray_DeleteIndexFast;
*DeleteRange = *cspacec::csPluginRequestArray_DeleteRange;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsKey ##############

package cspace::iAwsKey;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Type = *cspacec::iAwsKey_Type;
*Name = *cspacec::iAwsKey_Name;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsKey($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iAwsKey_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsIntKey ##############

package cspace::iAwsIntKey;
@ISA = qw( cspace cspace::iAwsKey );
%OWNER = ();
%ITERATORS = ();
*Value = *cspacec::iAwsIntKey_Value;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsIntKey($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsFloatKey ##############

package cspace::iAwsFloatKey;
@ISA = qw( cspace cspace::iAwsKey );
%OWNER = ();
%ITERATORS = ();
*Value = *cspacec::iAwsFloatKey_Value;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsFloatKey($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsStringKey ##############

package cspace::iAwsStringKey;
@ISA = qw( cspace cspace::iAwsKey );
%OWNER = ();
%ITERATORS = ();
*Value = *cspacec::iAwsStringKey_Value;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsStringKey($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsRectKey ##############

package cspace::iAwsRectKey;
@ISA = qw( cspace cspace::iAwsKey );
%OWNER = ();
%ITERATORS = ();
*Value = *cspacec::iAwsRectKey_Value;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsRectKey($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsRGBKey ##############

package cspace::iAwsRGBKey;
@ISA = qw( cspace cspace::iAwsKey );
%OWNER = ();
%ITERATORS = ();
*Value = *cspacec::iAwsRGBKey_Value;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsRGBKey($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsPointKey ##############

package cspace::iAwsPointKey;
@ISA = qw( cspace cspace::iAwsKey );
%OWNER = ();
%ITERATORS = ();
*Value = *cspacec::iAwsPointKey_Value;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsPointKey($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsConnectionKey ##############

package cspace::iAwsConnectionKey;
@ISA = qw( cspace cspace::iAwsKey );
%OWNER = ();
%ITERATORS = ();
*Sink = *cspacec::iAwsConnectionKey_Sink;
*Trigger = *cspacec::iAwsConnectionKey_Trigger;
*Signal = *cspacec::iAwsConnectionKey_Signal;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsConnectionKey($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsKeyContainer ##############

package cspace::iAwsKeyContainer;
@ISA = qw( cspace cspace::iAwsKey );
%OWNER = ();
%ITERATORS = ();
*Find = *cspacec::iAwsKeyContainer_Find;
*Children = *cspacec::iAwsKeyContainer_Children;
*Add = *cspacec::iAwsKeyContainer_Add;
*GetAt = *cspacec::iAwsKeyContainer_GetAt;
*Length = *cspacec::iAwsKeyContainer_Length;
*Remove = *cspacec::iAwsKeyContainer_Remove;
*RemoveAll = *cspacec::iAwsKeyContainer_RemoveAll;
*Consume = *cspacec::iAwsKeyContainer_Consume;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsKeyContainer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsComponentNode ##############

package cspace::iAwsComponentNode;
@ISA = qw( cspace cspace::iAwsKeyContainer );
%OWNER = ();
%ITERATORS = ();
*ComponentTypeName = *cspacec::iAwsComponentNode_ComponentTypeName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsComponentNode($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAws ##############

package cspace::iAws;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetPrefMgr = *cspacec::iAws_GetPrefMgr;
*GetSinkMgr = *cspacec::iAws_GetSinkMgr;
*SetPrefMgr = *cspacec::iAws_SetPrefMgr;
*GetStringTable = *cspacec::iAws_GetStringTable;
*RegisterComponentFactory = *cspacec::iAws_RegisterComponentFactory;
*FindComponentFactory = *cspacec::iAws_FindComponentFactory;
*GetTopComponent = *cspacec::iAws_GetTopComponent;
*SetTopComponent = *cspacec::iAws_SetTopComponent;
*GetFocusedComponent = *cspacec::iAws_GetFocusedComponent;
*SetFocusedComponent = *cspacec::iAws_SetFocusedComponent;
*GetKeyboardFocusedComponent = *cspacec::iAws_GetKeyboardFocusedComponent;
*ComponentAt = *cspacec::iAws_ComponentAt;
*MouseInComponent = *cspacec::iAws_MouseInComponent;
*Print = *cspacec::iAws_Print;
*Redraw = *cspacec::iAws_Redraw;
*Mark = *cspacec::iAws_Mark;
*Unmark = *cspacec::iAws_Unmark;
*Erase = *cspacec::iAws_Erase;
*MaskEraser = *cspacec::iAws_MaskEraser;
*InvalidateUpdateStore = *cspacec::iAws_InvalidateUpdateStore;
*CaptureMouse = *cspacec::iAws_CaptureMouse;
*ReleaseMouse = *cspacec::iAws_ReleaseMouse;
*SetModal = *cspacec::iAws_SetModal;
*UnSetModal = *cspacec::iAws_UnSetModal;
*HandleEvent = *cspacec::iAws_HandleEvent;
*GetCanvas = *cspacec::iAws_GetCanvas;
*G2D = *cspacec::iAws_G2D;
*G3D = *cspacec::iAws_G3D;
*CreateWindowFrom = *cspacec::iAws_CreateWindowFrom;
*CreateEmbeddableComponent = *cspacec::iAws_CreateEmbeddableComponent;
*CreateParmList = *cspacec::iAws_CreateParmList;
*CreateTransition = *cspacec::iAws_CreateTransition;
*CreateTransitionEx = *cspacec::iAws_CreateTransitionEx;
*SetFlag = *cspacec::iAws_SetFlag;
*ClearFlag = *cspacec::iAws_ClearFlag;
*GetFlags = *cspacec::iAws_GetFlags;
*GetObjectRegistry = *cspacec::iAws_GetObjectRegistry;
*AllWindowsHidden = *cspacec::iAws_AllWindowsHidden;
*ComponentIsInTransition = *cspacec::iAws_ComponentIsInTransition;
*ComponentDestroyed = *cspacec::iAws_ComponentDestroyed;
*DeleteMarkedComponents = *cspacec::iAws_DeleteMarkedComponents;
*MarkToDeleteRecursively = *cspacec::iAws_MarkToDeleteRecursively;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAws($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iAws_scfGetVersion;
*SetupCanvas = *cspacec::iAws_SetupCanvas;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsPrefManager ##############

package cspace::iAwsPrefManager;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Setup = *cspacec::iAwsPrefManager_Setup;
*Load = *cspacec::iAwsPrefManager_Load;
*NameToId = *cspacec::iAwsPrefManager_NameToId;
*SelectDefaultSkin = *cspacec::iAwsPrefManager_SelectDefaultSkin;
*LookupIntKey = *cspacec::iAwsPrefManager_LookupIntKey;
*LookupStringKey = *cspacec::iAwsPrefManager_LookupStringKey;
*LookupRectKey = *cspacec::iAwsPrefManager_LookupRectKey;
*LookupRGBKey = *cspacec::iAwsPrefManager_LookupRGBKey;
*LookupPointKey = *cspacec::iAwsPrefManager_LookupPointKey;
*GetInt = *cspacec::iAwsPrefManager_GetInt;
*GetFloat = *cspacec::iAwsPrefManager_GetFloat;
*GetRect = *cspacec::iAwsPrefManager_GetRect;
*GetString = *cspacec::iAwsPrefManager_GetString;
*GetRGB = *cspacec::iAwsPrefManager_GetRGB;
*FindWindowDef = *cspacec::iAwsPrefManager_FindWindowDef;
*FindSkinDef = *cspacec::iAwsPrefManager_FindSkinDef;
*RemoveWindowDef = *cspacec::iAwsPrefManager_RemoveWindowDef;
*RemoveAllWindowDefs = *cspacec::iAwsPrefManager_RemoveAllWindowDefs;
*RemoveSkinDef = *cspacec::iAwsPrefManager_RemoveSkinDef;
*RemoveAllSkinDefs = *cspacec::iAwsPrefManager_RemoveAllSkinDefs;
*SetColor = *cspacec::iAwsPrefManager_SetColor;
*GetColor = *cspacec::iAwsPrefManager_GetColor;
*FindColor = *cspacec::iAwsPrefManager_FindColor;
*GetDefaultFont = *cspacec::iAwsPrefManager_GetDefaultFont;
*GetFont = *cspacec::iAwsPrefManager_GetFont;
*GetTexture = *cspacec::iAwsPrefManager_GetTexture;
*SetTextureManager = *cspacec::iAwsPrefManager_SetTextureManager;
*SetFontServer = *cspacec::iAwsPrefManager_SetFontServer;
*SetDefaultFont = *cspacec::iAwsPrefManager_SetDefaultFont;
*SetWindowMgr = *cspacec::iAwsPrefManager_SetWindowMgr;
*SetupPalette = *cspacec::iAwsPrefManager_SetupPalette;
*RegisterConstant = *cspacec::iAwsPrefManager_RegisterConstant;
*ConstantExists = *cspacec::iAwsPrefManager_ConstantExists;
*GetConstantValue = *cspacec::iAwsPrefManager_GetConstantValue;
*CreateKeyFactory = *cspacec::iAwsPrefManager_CreateKeyFactory;
*CreateConnectionNodeFactory = *cspacec::iAwsPrefManager_CreateConnectionNodeFactory;
*AddCustomStringProperty = *cspacec::iAwsPrefManager_AddCustomStringProperty;
*GetCustomStringProperties = *cspacec::iAwsPrefManager_GetCustomStringProperties;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsPrefManager($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsSinkManager ##############

package cspace::iAwsSinkManager;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Setup = *cspacec::iAwsSinkManager_Setup;
*RegisterSink = *cspacec::iAwsSinkManager_RegisterSink;
*RemoveSink = *cspacec::iAwsSinkManager_RemoveSink;
*FindSink = *cspacec::iAwsSinkManager_FindSink;
*CreateSink = *cspacec::iAwsSinkManager_CreateSink;
*CreateSlot = *cspacec::iAwsSinkManager_CreateSlot;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsSinkManager($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsSink ##############

package cspace::iAwsSink;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetTriggerID = *cspacec::iAwsSink_GetTriggerID;
*HandleTrigger = *cspacec::iAwsSink_HandleTrigger;
*RegisterTrigger = *cspacec::iAwsSink_RegisterTrigger;
*GetError = *cspacec::iAwsSink_GetError;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsSink($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsSource ##############

package cspace::iAwsSource;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetComponent = *cspacec::iAwsSource_GetComponent;
*RegisterSlot = *cspacec::iAwsSource_RegisterSlot;
*UnregisterSlot = *cspacec::iAwsSource_UnregisterSlot;
*Broadcast = *cspacec::iAwsSource_Broadcast;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsSlot ##############

package cspace::iAwsSlot;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Connect = *cspacec::iAwsSlot_Connect;
*Disconnect = *cspacec::iAwsSlot_Disconnect;
*Emit = *cspacec::iAwsSlot_Emit;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsSlot($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsLayoutManager ##############

package cspace::iAwsLayoutManager;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetOwner = *cspacec::iAwsLayoutManager_SetOwner;
*AddComponent = *cspacec::iAwsLayoutManager_AddComponent;
*RemoveComponent = *cspacec::iAwsLayoutManager_RemoveComponent;
*LayoutComponents = *cspacec::iAwsLayoutManager_LayoutComponents;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsLayoutManager($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsComponent ##############

package cspace::iAwsComponent;
@ISA = qw( cspace cspace::iAwsSource );
%OWNER = ();
%ITERATORS = ();
*Create = *cspacec::iAwsComponent_Create;
*Setup = *cspacec::iAwsComponent_Setup;
*HandleEvent = *cspacec::iAwsComponent_HandleEvent;
*GetProperty = *cspacec::iAwsComponent_GetProperty;
*SetProperty = *cspacec::iAwsComponent_SetProperty;
*Execute = *cspacec::iAwsComponent_Execute;
*Invalidate = *cspacec::iAwsComponent_Invalidate;
*Frame = *cspacec::iAwsComponent_Frame;
*ClientFrame = *cspacec::iAwsComponent_ClientFrame;
*Type = *cspacec::iAwsComponent_Type;
*SetFlag = *cspacec::iAwsComponent_SetFlag;
*ClearFlag = *cspacec::iAwsComponent_ClearFlag;
*Flags = *cspacec::iAwsComponent_Flags;
*WindowManager = *cspacec::iAwsComponent_WindowManager;
*Parent = *cspacec::iAwsComponent_Parent;
*Window = *cspacec::iAwsComponent_Window;
*Layout = *cspacec::iAwsComponent_Layout;
*SetParent = *cspacec::iAwsComponent_SetParent;
*SetLayout = *cspacec::iAwsComponent_SetLayout;
*AddToLayout = *cspacec::iAwsComponent_AddToLayout;
*getPreferredSize = *cspacec::iAwsComponent_getPreferredSize;
*setPreferredSize = *cspacec::iAwsComponent_setPreferredSize;
*clearPreferredSize = *cspacec::iAwsComponent_clearPreferredSize;
*getMinimumSize = *cspacec::iAwsComponent_getMinimumSize;
*getInsets = *cspacec::iAwsComponent_getInsets;
*Overlaps = *cspacec::iAwsComponent_Overlaps;
*isHidden = *cspacec::iAwsComponent_isHidden;
*SetFocusable = *cspacec::iAwsComponent_SetFocusable;
*Focusable = *cspacec::iAwsComponent_Focusable;
*isFocused = *cspacec::iAwsComponent_isFocused;
*IsMaximized = *cspacec::iAwsComponent_IsMaximized;
*Hide = *cspacec::iAwsComponent_Hide;
*Show = *cspacec::iAwsComponent_Show;
*SetFocus = *cspacec::iAwsComponent_SetFocus;
*UnsetFocus = *cspacec::iAwsComponent_UnsetFocus;
*Move = *cspacec::iAwsComponent_Move;
*MoveTo = *cspacec::iAwsComponent_MoveTo;
*Resize = *cspacec::iAwsComponent_Resize;
*ResizeTo = *cspacec::iAwsComponent_ResizeTo;
*Maximize = *cspacec::iAwsComponent_Maximize;
*UnMaximize = *cspacec::iAwsComponent_UnMaximize;
*LayoutChildren = *cspacec::iAwsComponent_LayoutChildren;
*isDeaf = *cspacec::iAwsComponent_isDeaf;
*SetDeaf = *cspacec::iAwsComponent_SetDeaf;
*GetID = *cspacec::iAwsComponent_GetID;
*SetID = *cspacec::iAwsComponent_SetID;
*FindChild = *cspacec::iAwsComponent_FindChild;
*DoFindChild = *cspacec::iAwsComponent_DoFindChild;
*ChildAt = *cspacec::iAwsComponent_ChildAt;
*AddChild = *cspacec::iAwsComponent_AddChild;
*RemoveChild = *cspacec::iAwsComponent_RemoveChild;
*GetChildCount = *cspacec::iAwsComponent_GetChildCount;
*GetTopChild = *cspacec::iAwsComponent_GetTopChild;
*ComponentAbove = *cspacec::iAwsComponent_ComponentAbove;
*ComponentBelow = *cspacec::iAwsComponent_ComponentBelow;
*SetComponentAbove = *cspacec::iAwsComponent_SetComponentAbove;
*SetComponentBelow = *cspacec::iAwsComponent_SetComponentBelow;
*AddToTabOrder = *cspacec::iAwsComponent_AddToTabOrder;
*TabNext = *cspacec::iAwsComponent_TabNext;
*TabPrev = *cspacec::iAwsComponent_TabPrev;
*GetTabLength = *cspacec::iAwsComponent_GetTabLength;
*GetTabComponent = *cspacec::iAwsComponent_GetTabComponent;
*GetFirstFocusableChild = *cspacec::iAwsComponent_GetFirstFocusableChild;
*Raise = *cspacec::iAwsComponent_Raise;
*Lower = *cspacec::iAwsComponent_Lower;
*HasChildren = *cspacec::iAwsComponent_HasChildren;
*SetRedrawTag = *cspacec::iAwsComponent_SetRedrawTag;
*RedrawTag = *cspacec::iAwsComponent_RedrawTag;
*OnDraw = *cspacec::iAwsComponent_OnDraw;
*OnMouseDown = *cspacec::iAwsComponent_OnMouseDown;
*OnMouseUp = *cspacec::iAwsComponent_OnMouseUp;
*OnMouseMove = *cspacec::iAwsComponent_OnMouseMove;
*OnMouseClick = *cspacec::iAwsComponent_OnMouseClick;
*OnMouseDoubleClick = *cspacec::iAwsComponent_OnMouseDoubleClick;
*OnMouseExit = *cspacec::iAwsComponent_OnMouseExit;
*OnMouseEnter = *cspacec::iAwsComponent_OnMouseEnter;
*OnKeyboard = *cspacec::iAwsComponent_OnKeyboard;
*OnLostFocus = *cspacec::iAwsComponent_OnLostFocus;
*OnGainFocus = *cspacec::iAwsComponent_OnGainFocus;
*OnFrame = *cspacec::iAwsComponent_OnFrame;
*OnAdded = *cspacec::iAwsComponent_OnAdded;
*OnResized = *cspacec::iAwsComponent_OnResized;
*OnChildMoved = *cspacec::iAwsComponent_OnChildMoved;
*OnRaise = *cspacec::iAwsComponent_OnRaise;
*OnLower = *cspacec::iAwsComponent_OnLower;
*OnChildHide = *cspacec::iAwsComponent_OnChildHide;
*OnChildShow = *cspacec::iAwsComponent_OnChildShow;
*OnSetFocus = *cspacec::iAwsComponent_OnSetFocus;
*OnUnsetFocus = *cspacec::iAwsComponent_OnUnsetFocus;
*Unlink = *cspacec::iAwsComponent_Unlink;
*LinkAbove = *cspacec::iAwsComponent_LinkAbove;
*LinkBelow = *cspacec::iAwsComponent_LinkBelow;
*SetTopChild = *cspacec::iAwsComponent_SetTopChild;
*MarkToDelete = *cspacec::iAwsComponent_MarkToDelete;
*GetMarkToDelete = *cspacec::iAwsComponent_GetMarkToDelete;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsComponent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsComponentFactory ##############

package cspace::iAwsComponentFactory;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Create = *cspacec::iAwsComponentFactory_Create;
*Register = *cspacec::iAwsComponentFactory_Register;
*RegisterConstant = *cspacec::iAwsComponentFactory_RegisterConstant;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsComponentFactory($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsKeyFactory ##############

package cspace::iAwsKeyFactory;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Initialize = *cspacec::iAwsKeyFactory_Initialize;
*AddToWindowList = *cspacec::iAwsKeyFactory_AddToWindowList;
*AddFactory = *cspacec::iAwsKeyFactory_AddFactory;
*AddIntKey = *cspacec::iAwsKeyFactory_AddIntKey;
*AddStringKey = *cspacec::iAwsKeyFactory_AddStringKey;
*AddRectKey = *cspacec::iAwsKeyFactory_AddRectKey;
*AddRGBKey = *cspacec::iAwsKeyFactory_AddRGBKey;
*AddPointKey = *cspacec::iAwsKeyFactory_AddPointKey;
*AddConnectionKey = *cspacec::iAwsKeyFactory_AddConnectionKey;
*AddConnectionNode = *cspacec::iAwsKeyFactory_AddConnectionNode;
*GetThisNode = *cspacec::iAwsKeyFactory_GetThisNode;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsKeyFactory($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAwsConnectionNodeFactory ##############

package cspace::iAwsConnectionNodeFactory;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Initialize = *cspacec::iAwsConnectionNodeFactory_Initialize;
*AddConnectionKey = *cspacec::iAwsConnectionNodeFactory_AddConnectionKey;
*GetThisNode = *cspacec::iAwsConnectionNodeFactory_GetThisNode;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAwsConnectionNodeFactory($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csVertexStatus ##############

package cspace::csVertexStatus;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_Type_get = *cspacec::csVertexStatus_Type_get;
*swig_Type_set = *cspacec::csVertexStatus_Type_set;
*swig_Vertex_get = *cspacec::csVertexStatus_Vertex_get;
*swig_Vertex_set = *cspacec::csVertexStatus_Vertex_set;
*swig_Pos_get = *cspacec::csVertexStatus_Pos_get;
*swig_Pos_set = *cspacec::csVertexStatus_Pos_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csVertexStatus(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csVertexStatus($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iClipper2D ##############

package cspace::iClipper2D;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Clip = *cspacec::iClipper2D_Clip;
*ClipInPlace = *cspacec::iClipper2D_ClipInPlace;
*ClassifyBox = *cspacec::iClipper2D_ClassifyBox;
*IsInside = *cspacec::iClipper2D_IsInside;
*GetVertexCount = *cspacec::iClipper2D_GetVertexCount;
*GetClipPoly = *cspacec::iClipper2D_GetClipPoly;
*clipperPoly = *cspacec::iClipper2D_clipperPoly;
*clipperBox = *cspacec::iClipper2D_clipperBox;
*GetClipperType = *cspacec::iClipper2D_GetClipperType;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iClipper2D($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iObjectModelListener ##############

package cspace::iObjectModelListener;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*ObjectModelChanged = *cspacec::iObjectModelListener_ObjectModelChanged;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iObjectModelListener($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iObjectModelListener_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iObjectModel ##############

package cspace::iObjectModel;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetShapeNumber = *cspacec::iObjectModel_GetShapeNumber;
*GetPolygonMeshBase = *cspacec::iObjectModel_GetPolygonMeshBase;
*GetPolygonMeshColldet = *cspacec::iObjectModel_GetPolygonMeshColldet;
*SetPolygonMeshColldet = *cspacec::iObjectModel_SetPolygonMeshColldet;
*GetPolygonMeshViscull = *cspacec::iObjectModel_GetPolygonMeshViscull;
*SetPolygonMeshViscull = *cspacec::iObjectModel_SetPolygonMeshViscull;
*GetPolygonMeshShadows = *cspacec::iObjectModel_GetPolygonMeshShadows;
*SetPolygonMeshShadows = *cspacec::iObjectModel_SetPolygonMeshShadows;
*CreateLowerDetailPolygonMesh = *cspacec::iObjectModel_CreateLowerDetailPolygonMesh;
*GetObjectBoundingBox = *cspacec::iObjectModel_GetObjectBoundingBox;
*SetObjectBoundingBox = *cspacec::iObjectModel_SetObjectBoundingBox;
*GetRadius = *cspacec::iObjectModel_GetRadius;
*AddListener = *cspacec::iObjectModel_AddListener;
*RemoveListener = *cspacec::iObjectModel_RemoveListener;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iObjectModel($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iObjectModel_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iPath ##############

package cspace::iPath;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Length = *cspacec::iPath_Length;
*CalculateAtTime = *cspacec::iPath_CalculateAtTime;
*GetCurrentIndex = *cspacec::iPath_GetCurrentIndex;
*SetPositionVectors = *cspacec::iPath_SetPositionVectors;
*SetUpVectors = *cspacec::iPath_SetUpVectors;
*SetForwardVectors = *cspacec::iPath_SetForwardVectors;
*SetPositionVector = *cspacec::iPath_SetPositionVector;
*SetUpVector = *cspacec::iPath_SetUpVector;
*SetForwardVector = *cspacec::iPath_SetForwardVector;
*GetPositionVector = *cspacec::iPath_GetPositionVector;
*GetUpVector = *cspacec::iPath_GetUpVector;
*GetForwardVector = *cspacec::iPath_GetForwardVector;
*GetTime = *cspacec::iPath_GetTime;
*SetTime = *cspacec::iPath_SetTime;
*GetInterpolatedPosition = *cspacec::iPath_GetInterpolatedPosition;
*GetInterpolatedUp = *cspacec::iPath_GetInterpolatedUp;
*GetInterpolatedForward = *cspacec::iPath_GetInterpolatedForward;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iPath($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iPath_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csMeshedPolygon ##############

package cspace::csMeshedPolygon;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_num_vertices_get = *cspacec::csMeshedPolygon_num_vertices_get;
*swig_num_vertices_set = *cspacec::csMeshedPolygon_num_vertices_set;
*swig_vertices_get = *cspacec::csMeshedPolygon_vertices_get;
*swig_vertices_set = *cspacec::csMeshedPolygon_vertices_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csMeshedPolygon(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csMeshedPolygon($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iPolygonMesh ##############

package cspace::iPolygonMesh;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetVertexCount = *cspacec::iPolygonMesh_GetVertexCount;
*GetVertices = *cspacec::iPolygonMesh_GetVertices;
*GetPolygonCount = *cspacec::iPolygonMesh_GetPolygonCount;
*GetPolygons = *cspacec::iPolygonMesh_GetPolygons;
*GetTriangleCount = *cspacec::iPolygonMesh_GetTriangleCount;
*GetTriangles = *cspacec::iPolygonMesh_GetTriangles;
*Lock = *cspacec::iPolygonMesh_Lock;
*Unlock = *cspacec::iPolygonMesh_Unlock;
*GetFlags = *cspacec::iPolygonMesh_GetFlags;
*GetChangeNumber = *cspacec::iPolygonMesh_GetChangeNumber;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iPolygonMesh($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iPolygonMesh_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPath ##############

package cspace::csPath;
@ISA = qw( cspace cspace::csCatmullRomSpline cspace::iPath );
%OWNER = ();
%ITERATORS = ();
*swig_scfRefCount_get = *cspacec::csPath_scfRefCount_get;
*swig_scfRefCount_set = *cspacec::csPath_scfRefCount_set;
*swig_scfWeakRefOwners_get = *cspacec::csPath_scfWeakRefOwners_get;
*swig_scfWeakRefOwners_set = *cspacec::csPath_scfWeakRefOwners_set;
*scfRemoveRefOwners = *cspacec::csPath_scfRemoveRefOwners;
*swig_scfParent_get = *cspacec::csPath_scfParent_get;
*swig_scfParent_set = *cspacec::csPath_scfParent_set;
*IncRef = *cspacec::csPath_IncRef;
*DecRef = *cspacec::csPath_DecRef;
*GetRefCount = *cspacec::csPath_GetRefCount;
*AddRefOwner = *cspacec::csPath_AddRefOwner;
*RemoveRefOwner = *cspacec::csPath_RemoveRefOwner;
*QueryInterface = *cspacec::csPath_QueryInterface;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPath(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPath($self);
        delete $OWNER{$self};
    }
}

*Length = *cspacec::csPath_Length;
*CalculateAtTime = *cspacec::csPath_CalculateAtTime;
*GetCurrentIndex = *cspacec::csPath_GetCurrentIndex;
*GetTime = *cspacec::csPath_GetTime;
*SetTime = *cspacec::csPath_SetTime;
*SetPositionVectors = *cspacec::csPath_SetPositionVectors;
*SetUpVectors = *cspacec::csPath_SetUpVectors;
*SetForwardVectors = *cspacec::csPath_SetForwardVectors;
*SetPositionVector = *cspacec::csPath_SetPositionVector;
*SetUpVector = *cspacec::csPath_SetUpVector;
*SetForwardVector = *cspacec::csPath_SetForwardVector;
*GetPositionVector = *cspacec::csPath_GetPositionVector;
*GetUpVector = *cspacec::csPath_GetUpVector;
*GetForwardVector = *cspacec::csPath_GetForwardVector;
*GetInterpolatedPosition = *cspacec::csPath_GetInterpolatedPosition;
*GetInterpolatedUp = *cspacec::csPath_GetInterpolatedUp;
*GetInterpolatedForward = *cspacec::csPath_GetInterpolatedForward;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPolygonMesh ##############

package cspace::csPolygonMesh;
@ISA = qw( cspace cspace::iPolygonMesh );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPolygonMesh(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPolygonMesh($self);
        delete $OWNER{$self};
    }
}

*SetVertices = *cspacec::csPolygonMesh_SetVertices;
*SetPolygons = *cspacec::csPolygonMesh_SetPolygons;
*SetPolygonIndices = *cspacec::csPolygonMesh_SetPolygonIndices;
*SetPolygonIndexCount = *cspacec::csPolygonMesh_SetPolygonIndexCount;
*GetPolygonIndices = *cspacec::csPolygonMesh_GetPolygonIndices;
*SetVertexCount = *cspacec::csPolygonMesh_SetVertexCount;
*SetPolygonCount = *cspacec::csPolygonMesh_SetPolygonCount;
*ShapeChanged = *cspacec::csPolygonMesh_ShapeChanged;
*swig_scfRefCount_get = *cspacec::csPolygonMesh_scfRefCount_get;
*swig_scfRefCount_set = *cspacec::csPolygonMesh_scfRefCount_set;
*swig_scfWeakRefOwners_get = *cspacec::csPolygonMesh_scfWeakRefOwners_get;
*swig_scfWeakRefOwners_set = *cspacec::csPolygonMesh_scfWeakRefOwners_set;
*scfRemoveRefOwners = *cspacec::csPolygonMesh_scfRemoveRefOwners;
*swig_scfParent_get = *cspacec::csPolygonMesh_scfParent_get;
*swig_scfParent_set = *cspacec::csPolygonMesh_scfParent_set;
*IncRef = *cspacec::csPolygonMesh_IncRef;
*DecRef = *cspacec::csPolygonMesh_DecRef;
*GetRefCount = *cspacec::csPolygonMesh_GetRefCount;
*AddRefOwner = *cspacec::csPolygonMesh_AddRefOwner;
*RemoveRefOwner = *cspacec::csPolygonMesh_RemoveRefOwner;
*QueryInterface = *cspacec::csPolygonMesh_QueryInterface;
*GetVertexCount = *cspacec::csPolygonMesh_GetVertexCount;
*GetVertices = *cspacec::csPolygonMesh_GetVertices;
*GetPolygonCount = *cspacec::csPolygonMesh_GetPolygonCount;
*GetPolygons = *cspacec::csPolygonMesh_GetPolygons;
*GetTriangleCount = *cspacec::csPolygonMesh_GetTriangleCount;
*GetTriangles = *cspacec::csPolygonMesh_GetTriangles;
*Lock = *cspacec::csPolygonMesh_Lock;
*Unlock = *cspacec::csPolygonMesh_Unlock;
*GetFlags = *cspacec::csPolygonMesh_GetFlags;
*GetChangeNumber = *cspacec::csPolygonMesh_GetChangeNumber;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPolygonMeshBox ##############

package cspace::csPolygonMeshBox;
@ISA = qw( cspace cspace::iPolygonMesh );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPolygonMeshBox(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPolygonMeshBox($self);
        delete $OWNER{$self};
    }
}

*SetBox = *cspacec::csPolygonMeshBox_SetBox;
*swig_scfRefCount_get = *cspacec::csPolygonMeshBox_scfRefCount_get;
*swig_scfRefCount_set = *cspacec::csPolygonMeshBox_scfRefCount_set;
*swig_scfWeakRefOwners_get = *cspacec::csPolygonMeshBox_scfWeakRefOwners_get;
*swig_scfWeakRefOwners_set = *cspacec::csPolygonMeshBox_scfWeakRefOwners_set;
*scfRemoveRefOwners = *cspacec::csPolygonMeshBox_scfRemoveRefOwners;
*swig_scfParent_get = *cspacec::csPolygonMeshBox_scfParent_get;
*swig_scfParent_set = *cspacec::csPolygonMeshBox_scfParent_set;
*IncRef = *cspacec::csPolygonMeshBox_IncRef;
*DecRef = *cspacec::csPolygonMeshBox_DecRef;
*GetRefCount = *cspacec::csPolygonMeshBox_GetRefCount;
*AddRefOwner = *cspacec::csPolygonMeshBox_AddRefOwner;
*RemoveRefOwner = *cspacec::csPolygonMeshBox_RemoveRefOwner;
*QueryInterface = *cspacec::csPolygonMeshBox_QueryInterface;
*GetVertexCount = *cspacec::csPolygonMeshBox_GetVertexCount;
*GetVertices = *cspacec::csPolygonMeshBox_GetVertices;
*GetPolygonCount = *cspacec::csPolygonMeshBox_GetPolygonCount;
*GetPolygons = *cspacec::csPolygonMeshBox_GetPolygons;
*GetTriangleCount = *cspacec::csPolygonMeshBox_GetTriangleCount;
*GetTriangles = *cspacec::csPolygonMeshBox_GetTriangles;
*Lock = *cspacec::csPolygonMeshBox_Lock;
*Unlock = *cspacec::csPolygonMeshBox_Unlock;
*GetFlags = *cspacec::csPolygonMeshBox_GetFlags;
*GetChangeNumber = *cspacec::csPolygonMeshBox_GetChangeNumber;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iFrustumViewUserdata ##############

package cspace::iFrustumViewUserdata;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iFrustumViewUserdata($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iFrustumViewUserdata_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csFrustumContext ##############

package cspace::csFrustumContext;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csFrustumContext(@_);
    bless $self, $pkg if defined($self);
}

*__copy__ = *cspacec::csFrustumContext___copy__;
*GetShadows = *cspacec::csFrustumContext_GetShadows;
*SetShadows = *cspacec::csFrustumContext_SetShadows;
*SetNewShadows = *cspacec::csFrustumContext_SetNewShadows;
*IsShared = *cspacec::csFrustumContext_IsShared;
*SetLightFrustum = *cspacec::csFrustumContext_SetLightFrustum;
*SetNewLightFrustum = *cspacec::csFrustumContext_SetNewLightFrustum;
*GetLightFrustum = *cspacec::csFrustumContext_GetLightFrustum;
*SetMirrored = *cspacec::csFrustumContext_SetMirrored;
*IsMirrored = *cspacec::csFrustumContext_IsMirrored;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csFrustumContext($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iFrustumView ##############

package cspace::iFrustumView;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetFrustumContext = *cspacec::iFrustumView_GetFrustumContext;
*CreateFrustumContext = *cspacec::iFrustumView_CreateFrustumContext;
*CopyFrustumContext = *cspacec::iFrustumView_CopyFrustumContext;
*SetFrustumContext = *cspacec::iFrustumView_SetFrustumContext;
*RestoreFrustumContext = *cspacec::iFrustumView_RestoreFrustumContext;
*SetObjectFunction = *cspacec::iFrustumView_SetObjectFunction;
*CallObjectFunction = *cspacec::iFrustumView_CallObjectFunction;
*GetRadius = *cspacec::iFrustumView_GetRadius;
*GetSquaredRadius = *cspacec::iFrustumView_GetSquaredRadius;
*ThingShadowsEnabled = *cspacec::iFrustumView_ThingShadowsEnabled;
*CheckShadowMask = *cspacec::iFrustumView_CheckShadowMask;
*CheckProcessMask = *cspacec::iFrustumView_CheckProcessMask;
*StartNewShadowBlock = *cspacec::iFrustumView_StartNewShadowBlock;
*SetUserdata = *cspacec::iFrustumView_SetUserdata;
*GetUserdata = *cspacec::iFrustumView_GetUserdata;
*CreateShadowBlock = *cspacec::iFrustumView_CreateShadowBlock;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iFrustumView($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iFrustumView_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iLightCallback ##############

package cspace::iLightCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*OnColorChange = *cspacec::iLightCallback_OnColorChange;
*OnPositionChange = *cspacec::iLightCallback_OnPositionChange;
*OnSectorChange = *cspacec::iLightCallback_OnSectorChange;
*OnRadiusChange = *cspacec::iLightCallback_OnRadiusChange;
*OnDestroy = *cspacec::iLightCallback_OnDestroy;
*OnAttenuationChange = *cspacec::iLightCallback_OnAttenuationChange;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iLightCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iLight ##############

package cspace::iLight;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetLightID = *cspacec::iLight_GetLightID;
*QueryObject = *cspacec::iLight_QueryObject;
*GetDynamicType = *cspacec::iLight_GetDynamicType;
*GetCenter = *cspacec::iLight_GetCenter;
*SetCenter = *cspacec::iLight_SetCenter;
*GetSector = *cspacec::iLight_GetSector;
*GetMovable = *cspacec::iLight_GetMovable;
*GetColor = *cspacec::iLight_GetColor;
*SetColor = *cspacec::iLight_SetColor;
*GetSpecularColor = *cspacec::iLight_GetSpecularColor;
*SetSpecularColor = *cspacec::iLight_SetSpecularColor;
*GetType = *cspacec::iLight_GetType;
*SetType = *cspacec::iLight_SetType;
*GetDirection = *cspacec::iLight_GetDirection;
*SetDirection = *cspacec::iLight_SetDirection;
*GetAttenuationMode = *cspacec::iLight_GetAttenuationMode;
*SetAttenuationMode = *cspacec::iLight_SetAttenuationMode;
*SetAttenuationConstants = *cspacec::iLight_SetAttenuationConstants;
*GetAttenuationConstants = *cspacec::iLight_GetAttenuationConstants;
*GetCutoffDistance = *cspacec::iLight_GetCutoffDistance;
*SetCutoffDistance = *cspacec::iLight_SetCutoffDistance;
*GetDirectionalCutoffRadius = *cspacec::iLight_GetDirectionalCutoffRadius;
*SetDirectionalCutoffRadius = *cspacec::iLight_SetDirectionalCutoffRadius;
*SetSpotLightFalloff = *cspacec::iLight_SetSpotLightFalloff;
*GetSpotLightFalloff = *cspacec::iLight_GetSpotLightFalloff;
*CreateCrossHalo = *cspacec::iLight_CreateCrossHalo;
*CreateNovaHalo = *cspacec::iLight_CreateNovaHalo;
*CreateFlareHalo = *cspacec::iLight_CreateFlareHalo;
*GetHalo = *cspacec::iLight_GetHalo;
*GetBrightnessAtDistance = *cspacec::iLight_GetBrightnessAtDistance;
*GetFlags = *cspacec::iLight_GetFlags;
*SetLightCallback = *cspacec::iLight_SetLightCallback;
*RemoveLightCallback = *cspacec::iLight_RemoveLightCallback;
*GetLightCallbackCount = *cspacec::iLight_GetLightCallbackCount;
*GetLightCallback = *cspacec::iLight_GetLightCallback;
*GetLightNumber = *cspacec::iLight_GetLightNumber;
*AddAffectedLightingInfo = *cspacec::iLight_AddAffectedLightingInfo;
*RemoveAffectedLightingInfo = *cspacec::iLight_RemoveAffectedLightingInfo;
*Setup = *cspacec::iLight_Setup;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iLight($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iLight_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iLightList ##############

package cspace::iLightList;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetCount = *cspacec::iLightList_GetCount;
*Get = *cspacec::iLightList_Get;
*Add = *cspacec::iLightList_Add;
*Remove = *cspacec::iLightList_Remove;
*RemoveAll = *cspacec::iLightList_RemoveAll;
*Find = *cspacec::iLightList_Find;
*FindByName = *cspacec::iLightList_FindByName;
*FindByID = *cspacec::iLightList_FindByID;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iLightList($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iLightList_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iLightingProcessData ##############

package cspace::iLightingProcessData;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*FinalizeLighting = *cspacec::iLightingProcessData_FinalizeLighting;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iLightingProcessData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iLightingProcessInfo ##############

package cspace::iLightingProcessInfo;
@ISA = qw( cspace cspace::iFrustumViewUserdata );
%OWNER = ();
%ITERATORS = ();
*GetLight = *cspacec::iLightingProcessInfo_GetLight;
*IsDynamic = *cspacec::iLightingProcessInfo_IsDynamic;
*SetColor = *cspacec::iLightingProcessInfo_SetColor;
*GetColor = *cspacec::iLightingProcessInfo_GetColor;
*AttachUserdata = *cspacec::iLightingProcessInfo_AttachUserdata;
*QueryUserdata = *cspacec::iLightingProcessInfo_QueryUserdata;
*FinalizeLighting = *cspacec::iLightingProcessInfo_FinalizeLighting;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iLightingProcessInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iLightIterator ##############

package cspace::iLightIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HasNext = *cspacec::iLightIterator_HasNext;
*Next = *cspacec::iLightIterator_Next;
*GetLastSector = *cspacec::iLightIterator_GetLastSector;
*Reset = *cspacec::iLightIterator_Reset;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iLightIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSectorCallback ##############

package cspace::iSectorCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Traverse = *cspacec::iSectorCallback_Traverse;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSectorCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSectorMeshCallback ##############

package cspace::iSectorMeshCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*NewMesh = *cspacec::iSectorMeshCallback_NewMesh;
*RemoveMesh = *cspacec::iSectorMeshCallback_RemoveMesh;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSectorMeshCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSector ##############

package cspace::iSector;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iSector_QueryObject;
*SetRenderLoop = *cspacec::iSector_SetRenderLoop;
*GetRenderLoop = *cspacec::iSector_GetRenderLoop;
*HasFog = *cspacec::iSector_HasFog;
*GetFog = *cspacec::iSector_GetFog;
*SetFog = *cspacec::iSector_SetFog;
*DisableFog = *cspacec::iSector_DisableFog;
*GetMeshes = *cspacec::iSector_GetMeshes;
*GetLights = *cspacec::iSector_GetLights;
*ShineLights = *cspacec::iSector_ShineLights;
*SetDynamicAmbientLight = *cspacec::iSector_SetDynamicAmbientLight;
*GetDynamicAmbientLight = *cspacec::iSector_GetDynamicAmbientLight;
*CalculateSectorBBox = *cspacec::iSector_CalculateSectorBBox;
*SetVisibilityCullerPlugin = *cspacec::iSector_SetVisibilityCullerPlugin;
*GetVisibilityCuller = *cspacec::iSector_GetVisibilityCuller;
*GetRecLevel = *cspacec::iSector_GetRecLevel;
*IncRecLevel = *cspacec::iSector_IncRecLevel;
*DecRecLevel = *cspacec::iSector_DecRecLevel;
*HitBeamPortals = *cspacec::iSector_HitBeamPortals;
*HitBeam = *cspacec::iSector_HitBeam;
*FollowSegment = *cspacec::iSector_FollowSegment;
*Draw = *cspacec::iSector_Draw;
*PrepareDraw = *cspacec::iSector_PrepareDraw;
*GetVisibleMeshes = *cspacec::iSector_GetVisibleMeshes;
*SetSectorCallback = *cspacec::iSector_SetSectorCallback;
*RemoveSectorCallback = *cspacec::iSector_RemoveSectorCallback;
*GetSectorCallbackCount = *cspacec::iSector_GetSectorCallbackCount;
*GetSectorCallback = *cspacec::iSector_GetSectorCallback;
*AddSectorMeshCallback = *cspacec::iSector_AddSectorMeshCallback;
*RemoveSectorMeshCallback = *cspacec::iSector_RemoveSectorMeshCallback;
*CheckFrustum = *cspacec::iSector_CheckFrustum;
*GetPortalMeshes = *cspacec::iSector_GetPortalMeshes;
*RegisterPortalMesh = *cspacec::iSector_RegisterPortalMesh;
*UnregisterPortalMesh = *cspacec::iSector_UnregisterPortalMesh;
*UnlinkObjects = *cspacec::iSector_UnlinkObjects;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSector($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSector_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSectorList ##############

package cspace::iSectorList;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetCount = *cspacec::iSectorList_GetCount;
*Get = *cspacec::iSectorList_Get;
*Add = *cspacec::iSectorList_Add;
*Remove = *cspacec::iSectorList_Remove;
*RemoveAll = *cspacec::iSectorList_RemoveAll;
*Find = *cspacec::iSectorList_Find;
*FindByName = *cspacec::iSectorList_FindByName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSectorList($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSectorList_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSectorIterator ##############

package cspace::iSectorIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HasNext = *cspacec::iSectorIterator_HasNext;
*Next = *cspacec::iSectorIterator_Next;
*GetLastPosition = *cspacec::iSectorIterator_GetLastPosition;
*Reset = *cspacec::iSectorIterator_Reset;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSectorIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEngineSectorCallback ##############

package cspace::iEngineSectorCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*NewSector = *cspacec::iEngineSectorCallback_NewSector;
*RemoveSector = *cspacec::iEngineSectorCallback_RemoveSector;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEngineSectorCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEngine ##############

package cspace::iEngine;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iEngine_QueryObject;
*Prepare = *cspacec::iEngine_Prepare;
*ForceRelight = *cspacec::iEngine_ForceRelight;
*RemoveLight = *cspacec::iEngine_RemoveLight;
*PrepareTextures = *cspacec::iEngine_PrepareTextures;
*PrepareMeshes = *cspacec::iEngine_PrepareMeshes;
*ShineLights = *cspacec::iEngine_ShineLights;
*GetTextureFormat = *cspacec::iEngine_GetTextureFormat;
*DeleteAll = *cspacec::iEngine_DeleteAll;
*RegisterRenderPriority = *cspacec::iEngine_RegisterRenderPriority;
*GetRenderPriority = *cspacec::iEngine_GetRenderPriority;
*GetRenderPrioritySorting = *cspacec::iEngine_GetRenderPrioritySorting;
*GetSkyRenderPriority = *cspacec::iEngine_GetSkyRenderPriority;
*GetPortalRenderPriority = *cspacec::iEngine_GetPortalRenderPriority;
*GetWallRenderPriority = *cspacec::iEngine_GetWallRenderPriority;
*GetObjectRenderPriority = *cspacec::iEngine_GetObjectRenderPriority;
*GetAlphaRenderPriority = *cspacec::iEngine_GetAlphaRenderPriority;
*ClearRenderPriorities = *cspacec::iEngine_ClearRenderPriorities;
*GetRenderPriorityCount = *cspacec::iEngine_GetRenderPriorityCount;
*GetRenderPriorityName = *cspacec::iEngine_GetRenderPriorityName;
*CreateBaseMaterial = *cspacec::iEngine_CreateBaseMaterial;
*CreateTexture = *cspacec::iEngine_CreateTexture;
*CreateBlackTexture = *cspacec::iEngine_CreateBlackTexture;
*CreateMaterial = *cspacec::iEngine_CreateMaterial;
*CreateSector = *cspacec::iEngine_CreateSector;
*AddEngineSectorCallback = *cspacec::iEngine_AddEngineSectorCallback;
*RemoveEngineSectorCallback = *cspacec::iEngine_RemoveEngineSectorCallback;
*CreateSectorWallsMesh = *cspacec::iEngine_CreateSectorWallsMesh;
*CreateThingMesh = *cspacec::iEngine_CreateThingMesh;
*GetSectors = *cspacec::iEngine_GetSectors;
*GetMeshFactories = *cspacec::iEngine_GetMeshFactories;
*GetMeshes = *cspacec::iEngine_GetMeshes;
*GetCollections = *cspacec::iEngine_GetCollections;
*GetCameraPositions = *cspacec::iEngine_GetCameraPositions;
*GetTextureList = *cspacec::iEngine_GetTextureList;
*GetMaterialList = *cspacec::iEngine_GetMaterialList;
*GetVariableList = *cspacec::iEngine_GetVariableList;
*AddMeshAndChildren = *cspacec::iEngine_AddMeshAndChildren;
*CreateRegion = *cspacec::iEngine_CreateRegion;
*GetRegions = *cspacec::iEngine_GetRegions;
*FindMaterial = *cspacec::iEngine_FindMaterial;
*FindTexture = *cspacec::iEngine_FindTexture;
*FindSector = *cspacec::iEngine_FindSector;
*FindMeshObject = *cspacec::iEngine_FindMeshObject;
*FindMeshFactory = *cspacec::iEngine_FindMeshFactory;
*FindCameraPosition = *cspacec::iEngine_FindCameraPosition;
*FindCollection = *cspacec::iEngine_FindCollection;
*SetLightingCacheMode = *cspacec::iEngine_SetLightingCacheMode;
*GetLightingCacheMode = *cspacec::iEngine_GetLightingCacheMode;
*SetClearZBuf = *cspacec::iEngine_SetClearZBuf;
*GetClearZBuf = *cspacec::iEngine_GetClearZBuf;
*GetDefaultClearZBuf = *cspacec::iEngine_GetDefaultClearZBuf;
*SetClearScreen = *cspacec::iEngine_SetClearScreen;
*GetClearScreen = *cspacec::iEngine_GetClearScreen;
*GetDefaultClearScreen = *cspacec::iEngine_GetDefaultClearScreen;
*SetMaxLightmapSize = *cspacec::iEngine_SetMaxLightmapSize;
*GetMaxLightmapSize = *cspacec::iEngine_GetMaxLightmapSize;
*GetDefaultMaxLightmapSize = *cspacec::iEngine_GetDefaultMaxLightmapSize;
*GetMaxLightmapAspectRatio = *cspacec::iEngine_GetMaxLightmapAspectRatio;
*ResetWorldSpecificSettings = *cspacec::iEngine_ResetWorldSpecificSettings;
*CreateCamera = *cspacec::iEngine_CreateCamera;
*CreateLight = *cspacec::iEngine_CreateLight;
*FindLight = *cspacec::iEngine_FindLight;
*FindLightID = *cspacec::iEngine_FindLightID;
*GetLightIterator = *cspacec::iEngine_GetLightIterator;
*GetBeginDrawFlags = *cspacec::iEngine_GetBeginDrawFlags;
*GetTopLevelClipper = *cspacec::iEngine_GetTopLevelClipper;
*CreateMeshFactory = *cspacec::iEngine_CreateMeshFactory;
*CreateLoaderContext = *cspacec::iEngine_CreateLoaderContext;
*LoadMeshFactory = *cspacec::iEngine_LoadMeshFactory;
*CreateMeshWrapper = *cspacec::iEngine_CreateMeshWrapper;
*LoadMeshWrapper = *cspacec::iEngine_LoadMeshWrapper;
*CreatePortalContainer = *cspacec::iEngine_CreatePortalContainer;
*CreatePortal = *cspacec::iEngine_CreatePortal;
*PrecacheDraw = *cspacec::iEngine_PrecacheDraw;
*Draw = *cspacec::iEngine_Draw;
*SetContext = *cspacec::iEngine_SetContext;
*GetContext = *cspacec::iEngine_GetContext;
*SetAmbientLight = *cspacec::iEngine_SetAmbientLight;
*GetAmbientLight = *cspacec::iEngine_GetAmbientLight;
*GetNearbyLights = *cspacec::iEngine_GetNearbyLights;
*GetNearbySectors = *cspacec::iEngine_GetNearbySectors;
*GetNearbyObjects = *cspacec::iEngine_GetNearbyObjects;
*GetNearbyMeshes = *cspacec::iEngine_GetNearbyMeshes;
*GetVisibleObjects = *cspacec::iEngine_GetVisibleObjects;
*GetVisibleMeshes = *cspacec::iEngine_GetVisibleMeshes;
*RemoveObject = *cspacec::iEngine_RemoveObject;
*SetCacheManager = *cspacec::iEngine_SetCacheManager;
*GetCacheManager = *cspacec::iEngine_GetCacheManager;
*GetDefaultAmbientLight = *cspacec::iEngine_GetDefaultAmbientLight;
*CreateFrustumView = *cspacec::iEngine_CreateFrustumView;
*CreateObjectWatcher = *cspacec::iEngine_CreateObjectWatcher;
*WantToDie = *cspacec::iEngine_WantToDie;
*GetRenderLoopManager = *cspacec::iEngine_GetRenderLoopManager;
*GetCurrentDefaultRenderloop = *cspacec::iEngine_GetCurrentDefaultRenderloop;
*SetCurrentDefaultRenderloop = *cspacec::iEngine_SetCurrentDefaultRenderloop;
*GetCurrentFrameNumber = *cspacec::iEngine_GetCurrentFrameNumber;
*SetSaveableFlag = *cspacec::iEngine_SetSaveableFlag;
*GetSaveableFlag = *cspacec::iEngine_GetSaveableFlag;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEngine($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iEngine_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iCameraSectorListener ##############

package cspace::iCameraSectorListener;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*NewSector = *cspacec::iCameraSectorListener_NewSector;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iCameraSectorListener($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iCamera ##############

package cspace::iCamera;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Clone = *cspacec::iCamera_Clone;
*GetFOV = *cspacec::iCamera_GetFOV;
*GetInvFOV = *cspacec::iCamera_GetInvFOV;
*GetFOVAngle = *cspacec::iCamera_GetFOVAngle;
*SetFOV = *cspacec::iCamera_SetFOV;
*SetFOVAngle = *cspacec::iCamera_SetFOVAngle;
*GetShiftX = *cspacec::iCamera_GetShiftX;
*GetShiftY = *cspacec::iCamera_GetShiftY;
*SetPerspectiveCenter = *cspacec::iCamera_SetPerspectiveCenter;
*GetTransform = *cspacec::iCamera_GetTransform;
*SetTransform = *cspacec::iCamera_SetTransform;
*MoveWorld = *cspacec::iCamera_MoveWorld;
*Move = *cspacec::iCamera_Move;
*MoveWorldUnrestricted = *cspacec::iCamera_MoveWorldUnrestricted;
*MoveUnrestricted = *cspacec::iCamera_MoveUnrestricted;
*GetSector = *cspacec::iCamera_GetSector;
*SetSector = *cspacec::iCamera_SetSector;
*Correct = *cspacec::iCamera_Correct;
*IsMirrored = *cspacec::iCamera_IsMirrored;
*SetMirrored = *cspacec::iCamera_SetMirrored;
*GetFarPlane = *cspacec::iCamera_GetFarPlane;
*SetFarPlane = *cspacec::iCamera_SetFarPlane;
*GetCameraNumber = *cspacec::iCamera_GetCameraNumber;
*Perspective = *cspacec::iCamera_Perspective;
*InvPerspective = *cspacec::iCamera_InvPerspective;
*OnlyPortals = *cspacec::iCamera_OnlyPortals;
*GetOnlyPortals = *cspacec::iCamera_GetOnlyPortals;
*AddCameraSectorListener = *cspacec::iCamera_AddCameraSectorListener;
*RemoveCameraSectorListener = *cspacec::iCamera_RemoveCameraSectorListener;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iCamera($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iCamera_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iCameraPosition ##############

package cspace::iCameraPosition;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iCameraPosition_QueryObject;
*Clone = *cspacec::iCameraPosition_Clone;
*GetSector = *cspacec::iCameraPosition_GetSector;
*SetSector = *cspacec::iCameraPosition_SetSector;
*GetPosition = *cspacec::iCameraPosition_GetPosition;
*SetPosition = *cspacec::iCameraPosition_SetPosition;
*GetUpwardVector = *cspacec::iCameraPosition_GetUpwardVector;
*SetUpwardVector = *cspacec::iCameraPosition_SetUpwardVector;
*GetForwardVector = *cspacec::iCameraPosition_GetForwardVector;
*SetForwardVector = *cspacec::iCameraPosition_SetForwardVector;
*Set = *cspacec::iCameraPosition_Set;
*Load = *cspacec::iCameraPosition_Load;
*SetFarPlane = *cspacec::iCameraPosition_SetFarPlane;
*ClearFarPlane = *cspacec::iCameraPosition_ClearFarPlane;
*GetFarPlane = *cspacec::iCameraPosition_GetFarPlane;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iCameraPosition($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iCameraPosition_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iCameraPositionList ##############

package cspace::iCameraPositionList;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*NewCameraPosition = *cspacec::iCameraPositionList_NewCameraPosition;
*GetCount = *cspacec::iCameraPositionList_GetCount;
*Get = *cspacec::iCameraPositionList_Get;
*Add = *cspacec::iCameraPositionList_Add;
*Remove = *cspacec::iCameraPositionList_Remove;
*RemoveAll = *cspacec::iCameraPositionList_RemoveAll;
*Find = *cspacec::iCameraPositionList_Find;
*FindByName = *cspacec::iCameraPositionList_FindByName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iCameraPositionList($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iTextureCallback ##############

package cspace::iTextureCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*UseTexture = *cspacec::iTextureCallback_UseTexture;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iTextureCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iTextureWrapper ##############

package cspace::iTextureWrapper;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iTextureWrapper_QueryObject;
*Clone = *cspacec::iTextureWrapper_Clone;
*SetImageFile = *cspacec::iTextureWrapper_SetImageFile;
*GetImageFile = *cspacec::iTextureWrapper_GetImageFile;
*SetTextureHandle = *cspacec::iTextureWrapper_SetTextureHandle;
*GetTextureHandle = *cspacec::iTextureWrapper_GetTextureHandle;
*SetKeyColor = *cspacec::iTextureWrapper_SetKeyColor;
*GetKeyColor = *cspacec::iTextureWrapper_GetKeyColor;
*SetFlags = *cspacec::iTextureWrapper_SetFlags;
*GetFlags = *cspacec::iTextureWrapper_GetFlags;
*Register = *cspacec::iTextureWrapper_Register;
*SetUseCallback = *cspacec::iTextureWrapper_SetUseCallback;
*GetUseCallback = *cspacec::iTextureWrapper_GetUseCallback;
*Visit = *cspacec::iTextureWrapper_Visit;
*IsVisitRequired = *cspacec::iTextureWrapper_IsVisitRequired;
*SetKeepImage = *cspacec::iTextureWrapper_SetKeepImage;
*KeepImage = *cspacec::iTextureWrapper_KeepImage;
*SetTextureClass = *cspacec::iTextureWrapper_SetTextureClass;
*GetTextureClass = *cspacec::iTextureWrapper_GetTextureClass;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iTextureWrapper($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iTextureWrapper_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iTextureList ##############

package cspace::iTextureList;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*NewTexture = *cspacec::iTextureList_NewTexture;
*GetCount = *cspacec::iTextureList_GetCount;
*Get = *cspacec::iTextureList_Get;
*Add = *cspacec::iTextureList_Add;
*Remove = *cspacec::iTextureList_Remove;
*RemoveAll = *cspacec::iTextureList_RemoveAll;
*Find = *cspacec::iTextureList_Find;
*FindByName = *cspacec::iTextureList_FindByName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iTextureList($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iTextureList_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMaterialWrapper ##############

package cspace::iMaterialWrapper;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iMaterialWrapper_QueryObject;
*Clone = *cspacec::iMaterialWrapper_Clone;
*SetMaterial = *cspacec::iMaterialWrapper_SetMaterial;
*GetMaterial = *cspacec::iMaterialWrapper_GetMaterial;
*Visit = *cspacec::iMaterialWrapper_Visit;
*IsVisitRequired = *cspacec::iMaterialWrapper_IsVisitRequired;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMaterialWrapper($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMaterialWrapper_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMaterialEngine ##############

package cspace::iMaterialEngine;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetTextureWrapper = *cspacec::iMaterialEngine_GetTextureWrapper;
*Visit = *cspacec::iMaterialEngine_Visit;
*IsVisitRequired = *cspacec::iMaterialEngine_IsVisitRequired;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMaterialEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMaterialList ##############

package cspace::iMaterialList;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*NewMaterial = *cspacec::iMaterialList_NewMaterial;
*GetCount = *cspacec::iMaterialList_GetCount;
*Get = *cspacec::iMaterialList_Get;
*Add = *cspacec::iMaterialList_Add;
*Remove = *cspacec::iMaterialList_Remove;
*RemoveAll = *cspacec::iMaterialList_RemoveAll;
*Find = *cspacec::iMaterialList_Find;
*FindByName = *cspacec::iMaterialList_FindByName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMaterialList($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMeshDrawCallback ##############

package cspace::iMeshDrawCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*BeforeDrawing = *cspacec::iMeshDrawCallback_BeforeDrawing;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMeshDrawCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMeshWrapper ##############

package cspace::iMeshWrapper;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iMeshWrapper_QueryObject;
*GetMeshObject = *cspacec::iMeshWrapper_GetMeshObject;
*SetMeshObject = *cspacec::iMeshWrapper_SetMeshObject;
*GetPortalContainer = *cspacec::iMeshWrapper_GetPortalContainer;
*GetLightingInfo = *cspacec::iMeshWrapper_GetLightingInfo;
*GetShadowReceiver = *cspacec::iMeshWrapper_GetShadowReceiver;
*GetShadowCaster = *cspacec::iMeshWrapper_GetShadowCaster;
*GetVisibilityNumber = *cspacec::iMeshWrapper_GetVisibilityNumber;
*GetFactory = *cspacec::iMeshWrapper_GetFactory;
*SetFactory = *cspacec::iMeshWrapper_SetFactory;
*SetLightingUpdate = *cspacec::iMeshWrapper_SetLightingUpdate;
*GetMovable = *cspacec::iMeshWrapper_GetMovable;
*PlaceMesh = *cspacec::iMeshWrapper_PlaceMesh;
*HitBeamBBox = *cspacec::iMeshWrapper_HitBeamBBox;
*HitBeamOutline = *cspacec::iMeshWrapper_HitBeamOutline;
*HitBeamObject = *cspacec::iMeshWrapper_HitBeamObject;
*HitBeam = *cspacec::iMeshWrapper_HitBeam;
*SetDrawCallback = *cspacec::iMeshWrapper_SetDrawCallback;
*RemoveDrawCallback = *cspacec::iMeshWrapper_RemoveDrawCallback;
*GetDrawCallbackCount = *cspacec::iMeshWrapper_GetDrawCallbackCount;
*GetDrawCallback = *cspacec::iMeshWrapper_GetDrawCallback;
*SetRenderPriority = *cspacec::iMeshWrapper_SetRenderPriority;
*GetRenderPriority = *cspacec::iMeshWrapper_GetRenderPriority;
*SetRenderPriorityRecursive = *cspacec::iMeshWrapper_SetRenderPriorityRecursive;
*GetFlags = *cspacec::iMeshWrapper_GetFlags;
*SetFlagsRecursive = *cspacec::iMeshWrapper_SetFlagsRecursive;
*SetZBufMode = *cspacec::iMeshWrapper_SetZBufMode;
*GetZBufMode = *cspacec::iMeshWrapper_GetZBufMode;
*SetZBufModeRecursive = *cspacec::iMeshWrapper_SetZBufModeRecursive;
*HardTransform = *cspacec::iMeshWrapper_HardTransform;
*GetWorldBoundingBox = *cspacec::iMeshWrapper_GetWorldBoundingBox;
*GetTransformedBoundingBox = *cspacec::iMeshWrapper_GetTransformedBoundingBox;
*GetScreenBoundingBox = *cspacec::iMeshWrapper_GetScreenBoundingBox;
*GetChildren = *cspacec::iMeshWrapper_GetChildren;
*GetParentContainer = *cspacec::iMeshWrapper_GetParentContainer;
*SetParentContainer = *cspacec::iMeshWrapper_SetParentContainer;
*GetRadius = *cspacec::iMeshWrapper_GetRadius;
*CreateStaticLOD = *cspacec::iMeshWrapper_CreateStaticLOD;
*DestroyStaticLOD = *cspacec::iMeshWrapper_DestroyStaticLOD;
*GetStaticLOD = *cspacec::iMeshWrapper_GetStaticLOD;
*AddMeshToStaticLOD = *cspacec::iMeshWrapper_AddMeshToStaticLOD;
*RemoveMeshFromStaticLOD = *cspacec::iMeshWrapper_RemoveMeshFromStaticLOD;
*DrawShadow = *cspacec::iMeshWrapper_DrawShadow;
*DrawLight = *cspacec::iMeshWrapper_DrawLight;
*CastHardwareShadow = *cspacec::iMeshWrapper_CastHardwareShadow;
*SetDrawAfterShadow = *cspacec::iMeshWrapper_SetDrawAfterShadow;
*GetDrawAfterShadow = *cspacec::iMeshWrapper_GetDrawAfterShadow;
*GetSVContext = *cspacec::iMeshWrapper_GetSVContext;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMeshWrapper($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMeshWrapper_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMeshFactoryWrapper ##############

package cspace::iMeshFactoryWrapper;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iMeshFactoryWrapper_QueryObject;
*GetMeshObjectFactory = *cspacec::iMeshFactoryWrapper_GetMeshObjectFactory;
*SetMeshObjectFactory = *cspacec::iMeshFactoryWrapper_SetMeshObjectFactory;
*HardTransform = *cspacec::iMeshFactoryWrapper_HardTransform;
*CreateMeshWrapper = *cspacec::iMeshFactoryWrapper_CreateMeshWrapper;
*GetParentContainer = *cspacec::iMeshFactoryWrapper_GetParentContainer;
*SetParentContainer = *cspacec::iMeshFactoryWrapper_SetParentContainer;
*GetChildren = *cspacec::iMeshFactoryWrapper_GetChildren;
*GetTransform = *cspacec::iMeshFactoryWrapper_GetTransform;
*SetTransform = *cspacec::iMeshFactoryWrapper_SetTransform;
*CreateStaticLOD = *cspacec::iMeshFactoryWrapper_CreateStaticLOD;
*DestroyStaticLOD = *cspacec::iMeshFactoryWrapper_DestroyStaticLOD;
*SetStaticLOD = *cspacec::iMeshFactoryWrapper_SetStaticLOD;
*GetStaticLOD = *cspacec::iMeshFactoryWrapper_GetStaticLOD;
*AddFactoryToStaticLOD = *cspacec::iMeshFactoryWrapper_AddFactoryToStaticLOD;
*RemoveFactoryFromStaticLOD = *cspacec::iMeshFactoryWrapper_RemoveFactoryFromStaticLOD;
*SetZBufMode = *cspacec::iMeshFactoryWrapper_SetZBufMode;
*GetZBufMode = *cspacec::iMeshFactoryWrapper_GetZBufMode;
*SetZBufModeRecursive = *cspacec::iMeshFactoryWrapper_SetZBufModeRecursive;
*SetRenderPriority = *cspacec::iMeshFactoryWrapper_SetRenderPriority;
*GetRenderPriority = *cspacec::iMeshFactoryWrapper_GetRenderPriority;
*SetRenderPriorityRecursive = *cspacec::iMeshFactoryWrapper_SetRenderPriorityRecursive;
*GetSVContext = *cspacec::iMeshFactoryWrapper_GetSVContext;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMeshFactoryWrapper($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMeshFactoryWrapper_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMeshList ##############

package cspace::iMeshList;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetCount = *cspacec::iMeshList_GetCount;
*Get = *cspacec::iMeshList_Get;
*Add = *cspacec::iMeshList_Add;
*Remove = *cspacec::iMeshList_Remove;
*RemoveAll = *cspacec::iMeshList_RemoveAll;
*Find = *cspacec::iMeshList_Find;
*FindByName = *cspacec::iMeshList_FindByName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMeshList($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMeshFactoryList ##############

package cspace::iMeshFactoryList;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetCount = *cspacec::iMeshFactoryList_GetCount;
*Get = *cspacec::iMeshFactoryList_Get;
*Add = *cspacec::iMeshFactoryList_Add;
*Remove = *cspacec::iMeshFactoryList_Remove;
*RemoveAll = *cspacec::iMeshFactoryList_RemoveAll;
*Find = *cspacec::iMeshFactoryList_Find;
*FindByName = *cspacec::iMeshFactoryList_FindByName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMeshFactoryList($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMeshWrapperIterator ##############

package cspace::iMeshWrapperIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Next = *cspacec::iMeshWrapperIterator_Next;
*Reset = *cspacec::iMeshWrapperIterator_Reset;
*HasNext = *cspacec::iMeshWrapperIterator_HasNext;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMeshWrapperIterator($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMeshWrapperIterator_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMovableListener ##############

package cspace::iMovableListener;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*MovableChanged = *cspacec::iMovableListener_MovableChanged;
*MovableDestroyed = *cspacec::iMovableListener_MovableDestroyed;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMovableListener($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMovableListener_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMovable ##############

package cspace::iMovable;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetParent = *cspacec::iMovable_GetParent;
*SetParent = *cspacec::iMovable_SetParent;
*SetSector = *cspacec::iMovable_SetSector;
*ClearSectors = *cspacec::iMovable_ClearSectors;
*GetSectors = *cspacec::iMovable_GetSectors;
*InSector = *cspacec::iMovable_InSector;
*SetPosition = *cspacec::iMovable_SetPosition;
*GetPosition = *cspacec::iMovable_GetPosition;
*GetFullPosition = *cspacec::iMovable_GetFullPosition;
*SetTransform = *cspacec::iMovable_SetTransform;
*GetTransform = *cspacec::iMovable_GetTransform;
*GetFullTransform = *cspacec::iMovable_GetFullTransform;
*MovePosition = *cspacec::iMovable_MovePosition;
*Transform = *cspacec::iMovable_Transform;
*AddListener = *cspacec::iMovable_AddListener;
*RemoveListener = *cspacec::iMovable_RemoveListener;
*UpdateMove = *cspacec::iMovable_UpdateMove;
*GetUpdateNumber = *cspacec::iMovable_GetUpdateNumber;
*IsTransformIdentity = *cspacec::iMovable_IsTransformIdentity;
*IsFullTransformIdentity = *cspacec::iMovable_IsFullTransformIdentity;
*TransformIdentity = *cspacec::iMovable_TransformIdentity;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMovable($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMovable_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iRegion ##############

package cspace::iRegion;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iRegion_QueryObject;
*Add = *cspacec::iRegion_Add;
*Remove = *cspacec::iRegion_Remove;
*Clear = *cspacec::iRegion_Clear;
*DeleteAll = *cspacec::iRegion_DeleteAll;
*PrepareTextures = *cspacec::iRegion_PrepareTextures;
*ShineLights = *cspacec::iRegion_ShineLights;
*Prepare = *cspacec::iRegion_Prepare;
*FindSector = *cspacec::iRegion_FindSector;
*FindMeshObject = *cspacec::iRegion_FindMeshObject;
*FindMeshFactory = *cspacec::iRegion_FindMeshFactory;
*FindTexture = *cspacec::iRegion_FindTexture;
*FindMaterial = *cspacec::iRegion_FindMaterial;
*FindCameraPosition = *cspacec::iRegion_FindCameraPosition;
*FindCollection = *cspacec::iRegion_FindCollection;
*IsInRegion = *cspacec::iRegion_IsInRegion;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iRegion($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iRegionList ##############

package cspace::iRegionList;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetCount = *cspacec::iRegionList_GetCount;
*Get = *cspacec::iRegionList_Get;
*Add = *cspacec::iRegionList_Add;
*Remove = *cspacec::iRegionList_Remove;
*RemoveAll = *cspacec::iRegionList_RemoveAll;
*Find = *cspacec::iRegionList_Find;
*FindByName = *cspacec::iRegionList_FindByName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iRegionList($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iVisibilityObjectIterator ##############

package cspace::iVisibilityObjectIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HasNext = *cspacec::iVisibilityObjectIterator_HasNext;
*Next = *cspacec::iVisibilityObjectIterator_Next;
*Reset = *cspacec::iVisibilityObjectIterator_Reset;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iVisibilityObjectIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iVisibilityCullerListener ##############

package cspace::iVisibilityCullerListener;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*ObjectVisible = *cspacec::iVisibilityCullerListener_ObjectVisible;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iVisibilityCullerListener($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iVisibilityCuller ##############

package cspace::iVisibilityCuller;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Setup = *cspacec::iVisibilityCuller_Setup;
*RegisterVisObject = *cspacec::iVisibilityCuller_RegisterVisObject;
*UnregisterVisObject = *cspacec::iVisibilityCuller_UnregisterVisObject;
*PrecacheCulling = *cspacec::iVisibilityCuller_PrecacheCulling;
*VisTest = *cspacec::iVisibilityCuller_VisTest;
*IntersectSegmentSloppy = *cspacec::iVisibilityCuller_IntersectSegmentSloppy;
*IntersectSegment = *cspacec::iVisibilityCuller_IntersectSegment;
*CastShadows = *cspacec::iVisibilityCuller_CastShadows;
*ParseCullerParameters = *cspacec::iVisibilityCuller_ParseCullerParameters;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iVisibilityCuller($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iVisibilityCuller_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iVisibilityObject ##############

package cspace::iVisibilityObject;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetMovable = *cspacec::iVisibilityObject_GetMovable;
*GetMeshWrapper = *cspacec::iVisibilityObject_GetMeshWrapper;
*SetVisibilityNumber = *cspacec::iVisibilityObject_SetVisibilityNumber;
*GetVisibilityNumber = *cspacec::iVisibilityObject_GetVisibilityNumber;
*GetObjectModel = *cspacec::iVisibilityObject_GetObjectModel;
*GetCullerFlags = *cspacec::iVisibilityObject_GetCullerFlags;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iVisibilityObject($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iPortalCallback ##############

package cspace::iPortalCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Traverse = *cspacec::iPortalCallback_Traverse;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iPortalCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iPortal ##############

package cspace::iPortal;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iPortal_QueryObject;
*SetName = *cspacec::iPortal_SetName;
*GetName = *cspacec::iPortal_GetName;
*GetSector = *cspacec::iPortal_GetSector;
*GetVertices = *cspacec::iPortal_GetVertices;
*GetWorldVertices = *cspacec::iPortal_GetWorldVertices;
*GetVertexIndices = *cspacec::iPortal_GetVertexIndices;
*GetVertexIndicesCount = *cspacec::iPortal_GetVertexIndicesCount;
*GetObjectPlane = *cspacec::iPortal_GetObjectPlane;
*GetWorldPlane = *cspacec::iPortal_GetWorldPlane;
*ComputeCameraPlane = *cspacec::iPortal_ComputeCameraPlane;
*PointOnPolygon = *cspacec::iPortal_PointOnPolygon;
*SetSector = *cspacec::iPortal_SetSector;
*GetFlags = *cspacec::iPortal_GetFlags;
*SetMaximumSectorVisit = *cspacec::iPortal_SetMaximumSectorVisit;
*GetMaximumSectorVisit = *cspacec::iPortal_GetMaximumSectorVisit;
*SetPortalCallback = *cspacec::iPortal_SetPortalCallback;
*RemovePortalCallback = *cspacec::iPortal_RemovePortalCallback;
*GetPortalCallbackCount = *cspacec::iPortal_GetPortalCallbackCount;
*GetPortalCallback = *cspacec::iPortal_GetPortalCallback;
*SetMissingSectorCallback = *cspacec::iPortal_SetMissingSectorCallback;
*RemoveMissingSectorCallback = *cspacec::iPortal_RemoveMissingSectorCallback;
*GetMissingSectorCallbackCount = *cspacec::iPortal_GetMissingSectorCallbackCount;
*GetMissingSectorCallback = *cspacec::iPortal_GetMissingSectorCallback;
*GetTextureFilter = *cspacec::iPortal_GetTextureFilter;
*SetFilter = *cspacec::iPortal_SetFilter;
*GetColorFilter = *cspacec::iPortal_GetColorFilter;
*SetWarp = *cspacec::iPortal_SetWarp;
*SetMirror = *cspacec::iPortal_SetMirror;
*GetWarp = *cspacec::iPortal_GetWarp;
*HardTransform = *cspacec::iPortal_HardTransform;
*ObjectToWorld = *cspacec::iPortal_ObjectToWorld;
*Warp = *cspacec::iPortal_Warp;
*WarpSpace = *cspacec::iPortal_WarpSpace;
*CompleteSector = *cspacec::iPortal_CompleteSector;
*CheckFrustum = *cspacec::iPortal_CheckFrustum;
*HitBeamPortals = *cspacec::iPortal_HitBeamPortals;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iPortal($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iPortal_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iPortalContainer ##############

package cspace::iPortalContainer;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetPortalCount = *cspacec::iPortalContainer_GetPortalCount;
*GetPortal = *cspacec::iPortalContainer_GetPortal;
*CreatePortal = *cspacec::iPortalContainer_CreatePortal;
*RemovePortal = *cspacec::iPortalContainer_RemovePortal;
*Draw = *cspacec::iPortalContainer_Draw;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iPortalContainer($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iPortalContainer_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iGeneralMeshCommonState ##############

package cspace::iGeneralMeshCommonState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetMaterialWrapper = *cspacec::iGeneralMeshCommonState_SetMaterialWrapper;
*GetMaterialWrapper = *cspacec::iGeneralMeshCommonState_GetMaterialWrapper;
*SetMixMode = *cspacec::iGeneralMeshCommonState_SetMixMode;
*GetMixMode = *cspacec::iGeneralMeshCommonState_GetMixMode;
*SetLighting = *cspacec::iGeneralMeshCommonState_SetLighting;
*IsLighting = *cspacec::iGeneralMeshCommonState_IsLighting;
*SetColor = *cspacec::iGeneralMeshCommonState_SetColor;
*GetColor = *cspacec::iGeneralMeshCommonState_GetColor;
*SetManualColors = *cspacec::iGeneralMeshCommonState_SetManualColors;
*IsManualColors = *cspacec::iGeneralMeshCommonState_IsManualColors;
*SetShadowCasting = *cspacec::iGeneralMeshCommonState_SetShadowCasting;
*IsShadowCasting = *cspacec::iGeneralMeshCommonState_IsShadowCasting;
*SetShadowReceiving = *cspacec::iGeneralMeshCommonState_SetShadowReceiving;
*IsShadowReceiving = *cspacec::iGeneralMeshCommonState_IsShadowReceiving;
*AddRenderBuffer = *cspacec::iGeneralMeshCommonState_AddRenderBuffer;
*RemoveRenderBuffer = *cspacec::iGeneralMeshCommonState_RemoveRenderBuffer;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iGeneralMeshCommonState($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iGeneralMeshState ##############

package cspace::iGeneralMeshState;
@ISA = qw( cspace cspace::iGeneralMeshCommonState );
%OWNER = ();
%ITERATORS = ();
*SetAnimationControl = *cspacec::iGeneralMeshState_SetAnimationControl;
*GetAnimationControl = *cspacec::iGeneralMeshState_GetAnimationControl;
*ClearSubMeshes = *cspacec::iGeneralMeshState_ClearSubMeshes;
*AddSubMesh = *cspacec::iGeneralMeshState_AddSubMesh;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iGeneralMeshState($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iGeneralMeshState_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iGeneralFactoryState ##############

package cspace::iGeneralFactoryState;
@ISA = qw( cspace cspace::iGeneralMeshCommonState );
%OWNER = ();
%ITERATORS = ();
*SetVertexCount = *cspacec::iGeneralFactoryState_SetVertexCount;
*GetVertexCount = *cspacec::iGeneralFactoryState_GetVertexCount;
*SetTriangleCount = *cspacec::iGeneralFactoryState_SetTriangleCount;
*GetTriangleCount = *cspacec::iGeneralFactoryState_GetTriangleCount;
*Invalidate = *cspacec::iGeneralFactoryState_Invalidate;
*CalculateNormals = *cspacec::iGeneralFactoryState_CalculateNormals;
*GenerateBox = *cspacec::iGeneralFactoryState_GenerateBox;
*SetBack2Front = *cspacec::iGeneralFactoryState_SetBack2Front;
*IsAutoNormals = *cspacec::iGeneralFactoryState_IsAutoNormals;
*IsBack2Front = *cspacec::iGeneralFactoryState_IsBack2Front;
*SetAnimationControlFactory = *cspacec::iGeneralFactoryState_SetAnimationControlFactory;
*GetAnimationControlFactory = *cspacec::iGeneralFactoryState_GetAnimationControlFactory;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iGeneralFactoryState($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iGeneralFactoryState_scfGetVersion;
*GetVertexByIndex = *cspacec::iGeneralFactoryState_GetVertexByIndex;
*GetTexelByIndex = *cspacec::iGeneralFactoryState_GetTexelByIndex;
*GetNormalByIndex = *cspacec::iGeneralFactoryState_GetNormalByIndex;
*GetTriangleByIndex = *cspacec::iGeneralFactoryState_GetTriangleByIndex;
*GetColorByIndex = *cspacec::iGeneralFactoryState_GetColorByIndex;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iGenMeshAnimationControl ##############

package cspace::iGenMeshAnimationControl;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*AnimatesVertices = *cspacec::iGenMeshAnimationControl_AnimatesVertices;
*AnimatesTexels = *cspacec::iGenMeshAnimationControl_AnimatesTexels;
*AnimatesNormals = *cspacec::iGenMeshAnimationControl_AnimatesNormals;
*AnimatesColors = *cspacec::iGenMeshAnimationControl_AnimatesColors;
*UpdateVertices = *cspacec::iGenMeshAnimationControl_UpdateVertices;
*UpdateTexels = *cspacec::iGenMeshAnimationControl_UpdateTexels;
*UpdateNormals = *cspacec::iGenMeshAnimationControl_UpdateNormals;
*UpdateColors = *cspacec::iGenMeshAnimationControl_UpdateColors;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iGenMeshAnimationControl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iGenMeshAnimationControlFactory ##############

package cspace::iGenMeshAnimationControlFactory;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*CreateAnimationControl = *cspacec::iGenMeshAnimationControlFactory_CreateAnimationControl;
*Load = *cspacec::iGenMeshAnimationControlFactory_Load;
*Save = *cspacec::iGenMeshAnimationControlFactory_Save;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iGenMeshAnimationControlFactory($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iGenMeshAnimationControlType ##############

package cspace::iGenMeshAnimationControlType;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*CreateAnimationControlFactory = *cspacec::iGenMeshAnimationControlType_CreateAnimationControlFactory;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iGenMeshAnimationControlType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csSprite2DVertex ##############

package cspace::csSprite2DVertex;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_pos_get = *cspacec::csSprite2DVertex_pos_get;
*swig_pos_set = *cspacec::csSprite2DVertex_pos_set;
*swig_color_init_get = *cspacec::csSprite2DVertex_color_init_get;
*swig_color_init_set = *cspacec::csSprite2DVertex_color_init_set;
*swig_color_get = *cspacec::csSprite2DVertex_color_get;
*swig_color_set = *cspacec::csSprite2DVertex_color_set;
*swig_u_get = *cspacec::csSprite2DVertex_u_get;
*swig_u_set = *cspacec::csSprite2DVertex_u_set;
*swig_v_get = *cspacec::csSprite2DVertex_v_get;
*swig_v_set = *cspacec::csSprite2DVertex_v_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csSprite2DVertex(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csSprite2DVertex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSprite2DUVAnimationFrame ##############

package cspace::iSprite2DUVAnimationFrame;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetName = *cspacec::iSprite2DUVAnimationFrame_SetName;
*GetName = *cspacec::iSprite2DUVAnimationFrame_GetName;
*GetUVCoo = *cspacec::iSprite2DUVAnimationFrame_GetUVCoo;
*GetUVCount = *cspacec::iSprite2DUVAnimationFrame_GetUVCount;
*SetUV = *cspacec::iSprite2DUVAnimationFrame_SetUV;
*SetFrameData = *cspacec::iSprite2DUVAnimationFrame_SetFrameData;
*RemoveUV = *cspacec::iSprite2DUVAnimationFrame_RemoveUV;
*GetDuration = *cspacec::iSprite2DUVAnimationFrame_GetDuration;
*SetDuration = *cspacec::iSprite2DUVAnimationFrame_SetDuration;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSprite2DUVAnimationFrame($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSprite2DUVAnimation ##############

package cspace::iSprite2DUVAnimation;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetName = *cspacec::iSprite2DUVAnimation_SetName;
*GetName = *cspacec::iSprite2DUVAnimation_GetName;
*GetFrameCount = *cspacec::iSprite2DUVAnimation_GetFrameCount;
*GetFrame = *cspacec::iSprite2DUVAnimation_GetFrame;
*CreateFrame = *cspacec::iSprite2DUVAnimation_CreateFrame;
*MoveFrame = *cspacec::iSprite2DUVAnimation_MoveFrame;
*RemoveFrame = *cspacec::iSprite2DUVAnimation_RemoveFrame;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSprite2DUVAnimation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSprite2DFactoryState ##############

package cspace::iSprite2DFactoryState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetMaterialWrapper = *cspacec::iSprite2DFactoryState_SetMaterialWrapper;
*GetMaterialWrapper = *cspacec::iSprite2DFactoryState_GetMaterialWrapper;
*SetMixMode = *cspacec::iSprite2DFactoryState_SetMixMode;
*GetMixMode = *cspacec::iSprite2DFactoryState_GetMixMode;
*SetLighting = *cspacec::iSprite2DFactoryState_SetLighting;
*HasLighting = *cspacec::iSprite2DFactoryState_HasLighting;
*GetUVAnimationCount = *cspacec::iSprite2DFactoryState_GetUVAnimationCount;
*CreateUVAnimation = *cspacec::iSprite2DFactoryState_CreateUVAnimation;
*RemoveUVAnimation = *cspacec::iSprite2DFactoryState_RemoveUVAnimation;
*GetUVAnimation = *cspacec::iSprite2DFactoryState_GetUVAnimation;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSprite2DFactoryState($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSprite2DState ##############

package cspace::iSprite2DState;
@ISA = qw( cspace cspace::iSprite2DFactoryState );
%OWNER = ();
%ITERATORS = ();
*CreateRegularVertices = *cspacec::iSprite2DState_CreateRegularVertices;
*SetUVAnimation = *cspacec::iSprite2DState_SetUVAnimation;
*GetUVAnimation = *cspacec::iSprite2DState_GetUVAnimation;
*StopUVAnimation = *cspacec::iSprite2DState_StopUVAnimation;
*PlayUVAnimation = *cspacec::iSprite2DState_PlayUVAnimation;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSprite2DState($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSprite2DState_scfGetVersion;
*GetVertexByIndex = *cspacec::iSprite2DState_GetVertexByIndex;
*GetVertexCount = *cspacec::iSprite2DState_GetVertexCount;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSpriteFrame ##############

package cspace::iSpriteFrame;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetName = *cspacec::iSpriteFrame_SetName;
*GetName = *cspacec::iSpriteFrame_GetName;
*GetAnmIndex = *cspacec::iSpriteFrame_GetAnmIndex;
*GetTexIndex = *cspacec::iSpriteFrame_GetTexIndex;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSpriteFrame($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSpriteAction ##############

package cspace::iSpriteAction;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetName = *cspacec::iSpriteAction_SetName;
*GetName = *cspacec::iSpriteAction_GetName;
*GetFrameCount = *cspacec::iSpriteAction_GetFrameCount;
*GetFrame = *cspacec::iSpriteAction_GetFrame;
*GetNextFrame = *cspacec::iSpriteAction_GetNextFrame;
*GetFrameDelay = *cspacec::iSpriteAction_GetFrameDelay;
*GetFrameDisplacement = *cspacec::iSpriteAction_GetFrameDisplacement;
*AddFrame = *cspacec::iSpriteAction_AddFrame;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSpriteAction($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSpriteSocket ##############

package cspace::iSpriteSocket;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetName = *cspacec::iSpriteSocket_SetName;
*GetName = *cspacec::iSpriteSocket_GetName;
*SetMeshWrapper = *cspacec::iSpriteSocket_SetMeshWrapper;
*GetMeshWrapper = *cspacec::iSpriteSocket_GetMeshWrapper;
*SetTriangleIndex = *cspacec::iSpriteSocket_SetTriangleIndex;
*GetTriangleIndex = *cspacec::iSpriteSocket_GetTriangleIndex;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSpriteSocket($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSprite3DFactoryState ##############

package cspace::iSprite3DFactoryState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetMaterialWrapper = *cspacec::iSprite3DFactoryState_SetMaterialWrapper;
*GetMaterialWrapper = *cspacec::iSprite3DFactoryState_GetMaterialWrapper;
*AddVertices = *cspacec::iSprite3DFactoryState_AddVertices;
*GetVertexCount = *cspacec::iSprite3DFactoryState_GetVertexCount;
*GetVertex = *cspacec::iSprite3DFactoryState_GetVertex;
*SetVertex = *cspacec::iSprite3DFactoryState_SetVertex;
*GetVertices = *cspacec::iSprite3DFactoryState_GetVertices;
*SetVertices = *cspacec::iSprite3DFactoryState_SetVertices;
*GetTexel = *cspacec::iSprite3DFactoryState_GetTexel;
*SetTexel = *cspacec::iSprite3DFactoryState_SetTexel;
*GetTexels = *cspacec::iSprite3DFactoryState_GetTexels;
*SetTexels = *cspacec::iSprite3DFactoryState_SetTexels;
*GetNormal = *cspacec::iSprite3DFactoryState_GetNormal;
*SetNormal = *cspacec::iSprite3DFactoryState_SetNormal;
*GetNormals = *cspacec::iSprite3DFactoryState_GetNormals;
*SetNormals = *cspacec::iSprite3DFactoryState_SetNormals;
*AddTriangle = *cspacec::iSprite3DFactoryState_AddTriangle;
*GetTriangle = *cspacec::iSprite3DFactoryState_GetTriangle;
*GetTriangles = *cspacec::iSprite3DFactoryState_GetTriangles;
*GetTriangleCount = *cspacec::iSprite3DFactoryState_GetTriangleCount;
*SetTriangleCount = *cspacec::iSprite3DFactoryState_SetTriangleCount;
*SetTriangles = *cspacec::iSprite3DFactoryState_SetTriangles;
*AddFrame = *cspacec::iSprite3DFactoryState_AddFrame;
*FindFrame = *cspacec::iSprite3DFactoryState_FindFrame;
*GetFrameCount = *cspacec::iSprite3DFactoryState_GetFrameCount;
*GetFrame = *cspacec::iSprite3DFactoryState_GetFrame;
*AddAction = *cspacec::iSprite3DFactoryState_AddAction;
*FindAction = *cspacec::iSprite3DFactoryState_FindAction;
*GetFirstAction = *cspacec::iSprite3DFactoryState_GetFirstAction;
*GetActionCount = *cspacec::iSprite3DFactoryState_GetActionCount;
*GetAction = *cspacec::iSprite3DFactoryState_GetAction;
*AddSocket = *cspacec::iSprite3DFactoryState_AddSocket;
*FindSocket = *cspacec::iSprite3DFactoryState_FindSocket;
*GetSocketCount = *cspacec::iSprite3DFactoryState_GetSocketCount;
*GetSocket = *cspacec::iSprite3DFactoryState_GetSocket;
*EnableTweening = *cspacec::iSprite3DFactoryState_EnableTweening;
*IsTweeningEnabled = *cspacec::iSprite3DFactoryState_IsTweeningEnabled;
*SetLightingQuality = *cspacec::iSprite3DFactoryState_SetLightingQuality;
*GetLightingQuality = *cspacec::iSprite3DFactoryState_GetLightingQuality;
*SetLightingQualityConfig = *cspacec::iSprite3DFactoryState_SetLightingQualityConfig;
*GetLightingQualityConfig = *cspacec::iSprite3DFactoryState_GetLightingQualityConfig;
*SetLodLevelConfig = *cspacec::iSprite3DFactoryState_SetLodLevelConfig;
*GetLodLevelConfig = *cspacec::iSprite3DFactoryState_GetLodLevelConfig;
*MergeNormals = *cspacec::iSprite3DFactoryState_MergeNormals;
*SetMixMode = *cspacec::iSprite3DFactoryState_SetMixMode;
*GetMixMode = *cspacec::iSprite3DFactoryState_GetMixMode;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSprite3DFactoryState($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSprite3DState ##############

package cspace::iSprite3DState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetMaterialWrapper = *cspacec::iSprite3DState_SetMaterialWrapper;
*GetMaterialWrapper = *cspacec::iSprite3DState_GetMaterialWrapper;
*SetMixMode = *cspacec::iSprite3DState_SetMixMode;
*GetMixMode = *cspacec::iSprite3DState_GetMixMode;
*SetLighting = *cspacec::iSprite3DState_SetLighting;
*IsLighting = *cspacec::iSprite3DState_IsLighting;
*SetFrame = *cspacec::iSprite3DState_SetFrame;
*GetCurFrame = *cspacec::iSprite3DState_GetCurFrame;
*GetFrameCount = *cspacec::iSprite3DState_GetFrameCount;
*SetAction = *cspacec::iSprite3DState_SetAction;
*SetReverseAction = *cspacec::iSprite3DState_SetReverseAction;
*SetSingleStepAction = *cspacec::iSprite3DState_SetSingleStepAction;
*SetOverrideAction = *cspacec::iSprite3DState_SetOverrideAction;
*PropagateAction = *cspacec::iSprite3DState_PropagateAction;
*GetCurAction = *cspacec::iSprite3DState_GetCurAction;
*GetReverseAction = *cspacec::iSprite3DState_GetReverseAction;
*EnableTweening = *cspacec::iSprite3DState_EnableTweening;
*IsTweeningEnabled = *cspacec::iSprite3DState_IsTweeningEnabled;
*UnsetTexture = *cspacec::iSprite3DState_UnsetTexture;
*GetLightingQuality = *cspacec::iSprite3DState_GetLightingQuality;
*SetLocalLightingQuality = *cspacec::iSprite3DState_SetLocalLightingQuality;
*SetLightingQualityConfig = *cspacec::iSprite3DState_SetLightingQualityConfig;
*GetLightingQualityConfig = *cspacec::iSprite3DState_GetLightingQualityConfig;
*SetLodLevelConfig = *cspacec::iSprite3DState_SetLodLevelConfig;
*GetLodLevelConfig = *cspacec::iSprite3DState_GetLodLevelConfig;
*IsLodEnabled = *cspacec::iSprite3DState_IsLodEnabled;
*SetBaseColor = *cspacec::iSprite3DState_SetBaseColor;
*GetBaseColor = *cspacec::iSprite3DState_GetBaseColor;
*FindSocket = *cspacec::iSprite3DState_FindSocket;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSprite3DState($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSprite3DState_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSpriteCal3DSocket ##############

package cspace::iSpriteCal3DSocket;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetName = *cspacec::iSpriteCal3DSocket_SetName;
*GetName = *cspacec::iSpriteCal3DSocket_GetName;
*SetMeshWrapper = *cspacec::iSpriteCal3DSocket_SetMeshWrapper;
*GetMeshWrapper = *cspacec::iSpriteCal3DSocket_GetMeshWrapper;
*SetTriangleIndex = *cspacec::iSpriteCal3DSocket_SetTriangleIndex;
*GetTriangleIndex = *cspacec::iSpriteCal3DSocket_GetTriangleIndex;
*SetSubmeshIndex = *cspacec::iSpriteCal3DSocket_SetSubmeshIndex;
*GetSubmeshIndex = *cspacec::iSpriteCal3DSocket_GetSubmeshIndex;
*SetMeshIndex = *cspacec::iSpriteCal3DSocket_SetMeshIndex;
*GetMeshIndex = *cspacec::iSpriteCal3DSocket_GetMeshIndex;
*SetTransform = *cspacec::iSpriteCal3DSocket_SetTransform;
*GetTransform = *cspacec::iSpriteCal3DSocket_GetTransform;
*GetSecondaryCount = *cspacec::iSpriteCal3DSocket_GetSecondaryCount;
*GetSecondaryMesh = *cspacec::iSpriteCal3DSocket_GetSecondaryMesh;
*GetSecondaryTransform = *cspacec::iSpriteCal3DSocket_GetSecondaryTransform;
*SetSecondaryTransform = *cspacec::iSpriteCal3DSocket_SetSecondaryTransform;
*AttachSecondary = *cspacec::iSpriteCal3DSocket_AttachSecondary;
*DetachSecondary = *cspacec::iSpriteCal3DSocket_DetachSecondary;
*FindSecondary = *cspacec::iSpriteCal3DSocket_FindSecondary;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSpriteCal3DSocket($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSpriteCal3DFactoryState ##############

package cspace::iSpriteCal3DFactoryState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Create = *cspacec::iSpriteCal3DFactoryState_Create;
*ReportLastError = *cspacec::iSpriteCal3DFactoryState_ReportLastError;
*SetLoadFlags = *cspacec::iSpriteCal3DFactoryState_SetLoadFlags;
*SetBasePath = *cspacec::iSpriteCal3DFactoryState_SetBasePath;
*LoadCoreSkeleton = *cspacec::iSpriteCal3DFactoryState_LoadCoreSkeleton;
*RescaleFactory = *cspacec::iSpriteCal3DFactoryState_RescaleFactory;
*LoadCoreAnimation = *cspacec::iSpriteCal3DFactoryState_LoadCoreAnimation;
*LoadCoreMesh = *cspacec::iSpriteCal3DFactoryState_LoadCoreMesh;
*LoadCoreMorphTarget = *cspacec::iSpriteCal3DFactoryState_LoadCoreMorphTarget;
*AddMorphAnimation = *cspacec::iSpriteCal3DFactoryState_AddMorphAnimation;
*AddMorphTarget = *cspacec::iSpriteCal3DFactoryState_AddMorphTarget;
*AddCoreMaterial = *cspacec::iSpriteCal3DFactoryState_AddCoreMaterial;
*CalculateAllBoneBoundingBoxes = *cspacec::iSpriteCal3DFactoryState_CalculateAllBoneBoundingBoxes;
*BindMaterials = *cspacec::iSpriteCal3DFactoryState_BindMaterials;
*GetMeshCount = *cspacec::iSpriteCal3DFactoryState_GetMeshCount;
*GetMorphAnimationCount = *cspacec::iSpriteCal3DFactoryState_GetMorphAnimationCount;
*GetMorphTargetCount = *cspacec::iSpriteCal3DFactoryState_GetMorphTargetCount;
*GetMeshName = *cspacec::iSpriteCal3DFactoryState_GetMeshName;
*FindMeshName = *cspacec::iSpriteCal3DFactoryState_FindMeshName;
*GetDefaultMaterial = *cspacec::iSpriteCal3DFactoryState_GetDefaultMaterial;
*GetMorphAnimationName = *cspacec::iSpriteCal3DFactoryState_GetMorphAnimationName;
*FindMorphAnimationName = *cspacec::iSpriteCal3DFactoryState_FindMorphAnimationName;
*IsMeshDefault = *cspacec::iSpriteCal3DFactoryState_IsMeshDefault;
*AddSocket = *cspacec::iSpriteCal3DFactoryState_AddSocket;
*FindSocket = *cspacec::iSpriteCal3DFactoryState_FindSocket;
*GetSocketCount = *cspacec::iSpriteCal3DFactoryState_GetSocketCount;
*GetSocket = *cspacec::iSpriteCal3DFactoryState_GetSocket;
*GetCal3DCoreModel = *cspacec::iSpriteCal3DFactoryState_GetCal3DCoreModel;
*RegisterAnimCallback = *cspacec::iSpriteCal3DFactoryState_RegisterAnimCallback;
*RemoveAnimCallback = *cspacec::iSpriteCal3DFactoryState_RemoveAnimCallback;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSpriteCal3DFactoryState($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAnimTimeUpdateHandler ##############

package cspace::iAnimTimeUpdateHandler;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*UpdatePosition = *cspacec::iAnimTimeUpdateHandler_UpdatePosition;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAnimTimeUpdateHandler($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSpriteCal3DState ##############

package cspace::iSpriteCal3DState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*C3D_ANIM_TYPE_NONE = *cspacec::iSpriteCal3DState_C3D_ANIM_TYPE_NONE;
*C3D_ANIM_TYPE_IDLE = *cspacec::iSpriteCal3DState_C3D_ANIM_TYPE_IDLE;
*C3D_ANIM_TYPE_TRAVEL = *cspacec::iSpriteCal3DState_C3D_ANIM_TYPE_TRAVEL;
*C3D_ANIM_TYPE_CYCLE = *cspacec::iSpriteCal3DState_C3D_ANIM_TYPE_CYCLE;
*C3D_ANIM_TYPE_STYLE_CYCLE = *cspacec::iSpriteCal3DState_C3D_ANIM_TYPE_STYLE_CYCLE;
*C3D_ANIM_TYPE_ACTION = *cspacec::iSpriteCal3DState_C3D_ANIM_TYPE_ACTION;
*GetAnimCount = *cspacec::iSpriteCal3DState_GetAnimCount;
*GetAnimName = *cspacec::iSpriteCal3DState_GetAnimName;
*GetAnimType = *cspacec::iSpriteCal3DState_GetAnimType;
*FindAnim = *cspacec::iSpriteCal3DState_FindAnim;
*ClearAllAnims = *cspacec::iSpriteCal3DState_ClearAllAnims;
*SetAnimCycle = *cspacec::iSpriteCal3DState_SetAnimCycle;
*AddAnimCycle = *cspacec::iSpriteCal3DState_AddAnimCycle;
*ClearAnimCycle = *cspacec::iSpriteCal3DState_ClearAnimCycle;
*GetActiveAnimCount = *cspacec::iSpriteCal3DState_GetActiveAnimCount;
*GetActiveAnims = *cspacec::iSpriteCal3DState_GetActiveAnims;
*SetActiveAnims = *cspacec::iSpriteCal3DState_SetActiveAnims;
*SetAnimAction = *cspacec::iSpriteCal3DState_SetAnimAction;
*SetVelocity = *cspacec::iSpriteCal3DState_SetVelocity;
*SetDefaultIdleAnim = *cspacec::iSpriteCal3DState_SetDefaultIdleAnim;
*SetLOD = *cspacec::iSpriteCal3DState_SetLOD;
*AttachCoreMesh = *cspacec::iSpriteCal3DState_AttachCoreMesh;
*DetachCoreMesh = *cspacec::iSpriteCal3DState_DetachCoreMesh;
*BlendMorphTarget = *cspacec::iSpriteCal3DState_BlendMorphTarget;
*ClearMorphTarget = *cspacec::iSpriteCal3DState_ClearMorphTarget;
*FindSocket = *cspacec::iSpriteCal3DState_FindSocket;
*SetMaterial = *cspacec::iSpriteCal3DState_SetMaterial;
*SetTimeFactor = *cspacec::iSpriteCal3DState_SetTimeFactor;
*GetTimeFactor = *cspacec::iSpriteCal3DState_GetTimeFactor;
*GetAnimationTime = *cspacec::iSpriteCal3DState_GetAnimationTime;
*GetAnimationDuration = *cspacec::iSpriteCal3DState_GetAnimationDuration;
*SetAnimationTime = *cspacec::iSpriteCal3DState_SetAnimationTime;
*GetCal3DModel = *cspacec::iSpriteCal3DState_GetCal3DModel;
*SetUserData = *cspacec::iSpriteCal3DState_SetUserData;
*SetAnimTimeUpdateHandler = *cspacec::iSpriteCal3DState_SetAnimTimeUpdateHandler;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSpriteCal3DState($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSpriteCal3DState_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csModelConverterFormat ##############

package cspace::csModelConverterFormat;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_Name_get = *cspacec::csModelConverterFormat_Name_get;
*swig_Name_set = *cspacec::csModelConverterFormat_Name_set;
*swig_CanLoad_get = *cspacec::csModelConverterFormat_CanLoad_get;
*swig_CanLoad_set = *cspacec::csModelConverterFormat_CanLoad_set;
*swig_CanSave_get = *cspacec::csModelConverterFormat_CanSave_get;
*swig_CanSave_set = *cspacec::csModelConverterFormat_CanSave_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csModelConverterFormat(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csModelConverterFormat($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iModelConverter ##############

package cspace::iModelConverter;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetFormatCount = *cspacec::iModelConverter_GetFormatCount;
*GetFormat = *cspacec::iModelConverter_GetFormat;
*Load = *cspacec::iModelConverter_Load;
*Save = *cspacec::iModelConverter_Save;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iModelConverter($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iModelConverter_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMeshObjectDrawCallback ##############

package cspace::iMeshObjectDrawCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*BeforeDrawing = *cspacec::iMeshObjectDrawCallback_BeforeDrawing;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMeshObjectDrawCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMeshObject ##############

package cspace::iMeshObject;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetFactory = *cspacec::iMeshObject_GetFactory;
*GetFlags = *cspacec::iMeshObject_GetFlags;
*Clone = *cspacec::iMeshObject_Clone;
*GetRenderMeshes = *cspacec::iMeshObject_GetRenderMeshes;
*SetVisibleCallback = *cspacec::iMeshObject_SetVisibleCallback;
*GetVisibleCallback = *cspacec::iMeshObject_GetVisibleCallback;
*NextFrame = *cspacec::iMeshObject_NextFrame;
*HardTransform = *cspacec::iMeshObject_HardTransform;
*SupportsHardTransform = *cspacec::iMeshObject_SupportsHardTransform;
*HitBeamOutline = *cspacec::iMeshObject_HitBeamOutline;
*HitBeamObject = *cspacec::iMeshObject_HitBeamObject;
*SetLogicalParent = *cspacec::iMeshObject_SetLogicalParent;
*GetLogicalParent = *cspacec::iMeshObject_GetLogicalParent;
*GetObjectModel = *cspacec::iMeshObject_GetObjectModel;
*SetColor = *cspacec::iMeshObject_SetColor;
*GetColor = *cspacec::iMeshObject_GetColor;
*SetMaterialWrapper = *cspacec::iMeshObject_SetMaterialWrapper;
*GetMaterialWrapper = *cspacec::iMeshObject_GetMaterialWrapper;
*InvalidateMaterialHandles = *cspacec::iMeshObject_InvalidateMaterialHandles;
*PositionChild = *cspacec::iMeshObject_PositionChild;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMeshObject($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMeshObject_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMeshObjectFactory ##############

package cspace::iMeshObjectFactory;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetFlags = *cspacec::iMeshObjectFactory_GetFlags;
*NewInstance = *cspacec::iMeshObjectFactory_NewInstance;
*Clone = *cspacec::iMeshObjectFactory_Clone;
*HardTransform = *cspacec::iMeshObjectFactory_HardTransform;
*SupportsHardTransform = *cspacec::iMeshObjectFactory_SupportsHardTransform;
*SetLogicalParent = *cspacec::iMeshObjectFactory_SetLogicalParent;
*GetLogicalParent = *cspacec::iMeshObjectFactory_GetLogicalParent;
*GetMeshObjectType = *cspacec::iMeshObjectFactory_GetMeshObjectType;
*GetObjectModel = *cspacec::iMeshObjectFactory_GetObjectModel;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMeshObjectFactory($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMeshObjectFactory_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMeshObjectType ##############

package cspace::iMeshObjectType;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*NewFactory = *cspacec::iMeshObjectType_NewFactory;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMeshObjectType($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMeshObjectType_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iBallState ##############

package cspace::iBallState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetRadius = *cspacec::iBallState_SetRadius;
*GetRadius = *cspacec::iBallState_GetRadius;
*SetShift = *cspacec::iBallState_SetShift;
*GetShift = *cspacec::iBallState_GetShift;
*SetRimVertices = *cspacec::iBallState_SetRimVertices;
*GetRimVertices = *cspacec::iBallState_GetRimVertices;
*SetMaterialWrapper = *cspacec::iBallState_SetMaterialWrapper;
*GetMaterialWrapper = *cspacec::iBallState_GetMaterialWrapper;
*SetMixMode = *cspacec::iBallState_SetMixMode;
*GetMixMode = *cspacec::iBallState_GetMixMode;
*SetReversed = *cspacec::iBallState_SetReversed;
*IsReversed = *cspacec::iBallState_IsReversed;
*SetTopOnly = *cspacec::iBallState_SetTopOnly;
*IsTopOnly = *cspacec::iBallState_IsTopOnly;
*SetLighting = *cspacec::iBallState_SetLighting;
*IsLighting = *cspacec::iBallState_IsLighting;
*SetColor = *cspacec::iBallState_SetColor;
*GetColor = *cspacec::iBallState_GetColor;
*SetCylindricalMapping = *cspacec::iBallState_SetCylindricalMapping;
*IsCylindricalMapping = *cspacec::iBallState_IsCylindricalMapping;
*ApplyVertGradient = *cspacec::iBallState_ApplyVertGradient;
*ApplyLightSpot = *cspacec::iBallState_ApplyLightSpot;
*PaintSky = *cspacec::iBallState_PaintSky;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iBallState($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iBallState_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPolygonRange ##############

package cspace::csPolygonRange;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_start_get = *cspacec::csPolygonRange_start_get;
*swig_start_set = *cspacec::csPolygonRange_start_set;
*swig_end_get = *cspacec::csPolygonRange_end_get;
*swig_end_set = *cspacec::csPolygonRange_end_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPolygonRange(@_);
    bless $self, $pkg if defined($self);
}

*Set = *cspacec::csPolygonRange_Set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPolygonRange($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iPolygonHandle ##############

package cspace::iPolygonHandle;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetThingFactoryState = *cspacec::iPolygonHandle_GetThingFactoryState;
*GetMeshObjectFactory = *cspacec::iPolygonHandle_GetMeshObjectFactory;
*GetThingState = *cspacec::iPolygonHandle_GetThingState;
*GetMeshObject = *cspacec::iPolygonHandle_GetMeshObject;
*GetIndex = *cspacec::iPolygonHandle_GetIndex;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iPolygonHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iThingFactoryState ##############

package cspace::iThingFactoryState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*CompressVertices = *cspacec::iThingFactoryState_CompressVertices;
*GetPolygonCount = *cspacec::iThingFactoryState_GetPolygonCount;
*RemovePolygon = *cspacec::iThingFactoryState_RemovePolygon;
*RemovePolygons = *cspacec::iThingFactoryState_RemovePolygons;
*FindPolygonByName = *cspacec::iThingFactoryState_FindPolygonByName;
*AddEmptyPolygon = *cspacec::iThingFactoryState_AddEmptyPolygon;
*AddTriangle = *cspacec::iThingFactoryState_AddTriangle;
*AddQuad = *cspacec::iThingFactoryState_AddQuad;
*AddPolygon = *cspacec::iThingFactoryState_AddPolygon;
*AddOutsideBox = *cspacec::iThingFactoryState_AddOutsideBox;
*AddInsideBox = *cspacec::iThingFactoryState_AddInsideBox;
*SetPolygonName = *cspacec::iThingFactoryState_SetPolygonName;
*GetPolygonName = *cspacec::iThingFactoryState_GetPolygonName;
*CreatePolygonHandle = *cspacec::iThingFactoryState_CreatePolygonHandle;
*SetPolygonMaterial = *cspacec::iThingFactoryState_SetPolygonMaterial;
*GetPolygonMaterial = *cspacec::iThingFactoryState_GetPolygonMaterial;
*AddPolygonVertex = *cspacec::iThingFactoryState_AddPolygonVertex;
*SetPolygonVertexIndices = *cspacec::iThingFactoryState_SetPolygonVertexIndices;
*GetPolygonVertexCount = *cspacec::iThingFactoryState_GetPolygonVertexCount;
*GetPolygonVertex = *cspacec::iThingFactoryState_GetPolygonVertex;
*GetPolygonVertexIndices = *cspacec::iThingFactoryState_GetPolygonVertexIndices;
*SetPolygonTextureMapping = *cspacec::iThingFactoryState_SetPolygonTextureMapping;
*GetPolygonTextureMapping = *cspacec::iThingFactoryState_GetPolygonTextureMapping;
*SetPolygonTextureMappingEnabled = *cspacec::iThingFactoryState_SetPolygonTextureMappingEnabled;
*IsPolygonTextureMappingEnabled = *cspacec::iThingFactoryState_IsPolygonTextureMappingEnabled;
*SetPolygonFlags = *cspacec::iThingFactoryState_SetPolygonFlags;
*ResetPolygonFlags = *cspacec::iThingFactoryState_ResetPolygonFlags;
*GetPolygonFlags = *cspacec::iThingFactoryState_GetPolygonFlags;
*GetPolygonObjectPlane = *cspacec::iThingFactoryState_GetPolygonObjectPlane;
*IsPolygonTransparent = *cspacec::iThingFactoryState_IsPolygonTransparent;
*PointOnPolygon = *cspacec::iThingFactoryState_PointOnPolygon;
*GetVertexCount = *cspacec::iThingFactoryState_GetVertexCount;
*GetVertex = *cspacec::iThingFactoryState_GetVertex;
*GetVertices = *cspacec::iThingFactoryState_GetVertices;
*CreateVertex = *cspacec::iThingFactoryState_CreateVertex;
*SetVertex = *cspacec::iThingFactoryState_SetVertex;
*DeleteVertex = *cspacec::iThingFactoryState_DeleteVertex;
*DeleteVertices = *cspacec::iThingFactoryState_DeleteVertices;
*SetSmoothingFlag = *cspacec::iThingFactoryState_SetSmoothingFlag;
*GetSmoothingFlag = *cspacec::iThingFactoryState_GetSmoothingFlag;
*GetNormals = *cspacec::iThingFactoryState_GetNormals;
*GetCosinusFactor = *cspacec::iThingFactoryState_GetCosinusFactor;
*SetCosinusFactor = *cspacec::iThingFactoryState_SetCosinusFactor;
*AddPolygonRenderBuffer = *cspacec::iThingFactoryState_AddPolygonRenderBuffer;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iThingFactoryState($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iThingState ##############

package cspace::iThingState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetFactory = *cspacec::iThingState_GetFactory;
*GetVertexW = *cspacec::iThingState_GetVertexW;
*GetVerticesW = *cspacec::iThingState_GetVerticesW;
*GetMovingOption = *cspacec::iThingState_GetMovingOption;
*SetMovingOption = *cspacec::iThingState_SetMovingOption;
*Prepare = *cspacec::iThingState_Prepare;
*Unprepare = *cspacec::iThingState_Unprepare;
*ReplaceMaterial = *cspacec::iThingState_ReplaceMaterial;
*ClearReplacedMaterials = *cspacec::iThingState_ClearReplacedMaterials;
*SetMixMode = *cspacec::iThingState_SetMixMode;
*GetMixMode = *cspacec::iThingState_GetMixMode;
*CreatePolygonHandle = *cspacec::iThingState_CreatePolygonHandle;
*GetPolygonWorldPlane = *cspacec::iThingState_GetPolygonWorldPlane;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iThingState($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iThingState_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iThingEnvironment ##############

package cspace::iThingEnvironment;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Clear = *cspacec::iThingEnvironment_Clear;
*GetLightmapCellSize = *cspacec::iThingEnvironment_GetLightmapCellSize;
*SetLightmapCellSize = *cspacec::iThingEnvironment_SetLightmapCellSize;
*GetDefaultLightmapCellSize = *cspacec::iThingEnvironment_GetDefaultLightmapCellSize;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iThingEnvironment($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iTerrainObjectState ##############

package cspace::iTerrainObjectState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetMaterialPalette = *cspacec::iTerrainObjectState_SetMaterialPalette;
*GetMaterialPalette = *cspacec::iTerrainObjectState_GetMaterialPalette;
*SetMaterialMap = *cspacec::iTerrainObjectState_SetMaterialMap;
*SetLODValue = *cspacec::iTerrainObjectState_SetLODValue;
*GetLODValue = *cspacec::iTerrainObjectState_GetLODValue;
*SaveState = *cspacec::iTerrainObjectState_SaveState;
*RestoreState = *cspacec::iTerrainObjectState_RestoreState;
*CollisionDetect = *cspacec::iTerrainObjectState_CollisionDetect;
*SetStaticLighting = *cspacec::iTerrainObjectState_SetStaticLighting;
*GetStaticLighting = *cspacec::iTerrainObjectState_GetStaticLighting;
*SetCastShadows = *cspacec::iTerrainObjectState_SetCastShadows;
*GetCastShadows = *cspacec::iTerrainObjectState_GetCastShadows;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iTerrainObjectState($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iTerrainObjectState_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iTerrainFactoryState ##############

package cspace::iTerrainFactoryState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetTerraFormer = *cspacec::iTerrainFactoryState_SetTerraFormer;
*GetTerraFormer = *cspacec::iTerrainFactoryState_GetTerraFormer;
*SetSamplerRegion = *cspacec::iTerrainFactoryState_SetSamplerRegion;
*GetSamplerRegion = *cspacec::iTerrainFactoryState_GetSamplerRegion;
*SaveState = *cspacec::iTerrainFactoryState_SaveState;
*RestoreState = *cspacec::iTerrainFactoryState_RestoreState;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iTerrainFactoryState($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iTerrainFactoryState_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iLoaderStatus ##############

package cspace::iLoaderStatus;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*IsReady = *cspacec::iLoaderStatus_IsReady;
*IsError = *cspacec::iLoaderStatus_IsError;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iLoaderStatus($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iLoader ##############

package cspace::iLoader;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*LoadImage = *cspacec::iLoader_LoadImage;
*LoadTexture = *cspacec::iLoader_LoadTexture;
*LoadSoundData = *cspacec::iLoader_LoadSoundData;
*LoadSound = *cspacec::iLoader_LoadSound;
*ThreadedLoadMapFile = *cspacec::iLoader_ThreadedLoadMapFile;
*LoadMapFile = *cspacec::iLoader_LoadMapFile;
*LoadLibraryFile = *cspacec::iLoader_LoadLibraryFile;
*LoadMeshObjectFactory = *cspacec::iLoader_LoadMeshObjectFactory;
*LoadMeshObject = *cspacec::iLoader_LoadMeshObject;
*Load = *cspacec::iLoader_Load;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iLoader($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iLoader_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iLoaderPlugin ##############

package cspace::iLoaderPlugin;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Parse = *cspacec::iLoaderPlugin_Parse;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iLoaderPlugin($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iLoaderPlugin_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iBinaryLoaderPlugin ##############

package cspace::iBinaryLoaderPlugin;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Parse = *cspacec::iBinaryLoaderPlugin_Parse;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iBinaryLoaderPlugin($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iBinaryLoaderPlugin_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSaver ##############

package cspace::iSaver;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SaveMapFile = *cspacec::iSaver_SaveMapFile;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSaver($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSoundHandle ##############

package cspace::iSoundHandle;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*IsStatic = *cspacec::iSoundHandle_IsStatic;
*Play = *cspacec::iSoundHandle_Play;
*CreateSource = *cspacec::iSoundHandle_CreateSource;
*StartStream = *cspacec::iSoundHandle_StartStream;
*StopStream = *cspacec::iSoundHandle_StopStream;
*ResetStream = *cspacec::iSoundHandle_ResetStream;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSoundHandle($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSoundHandle_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSoundLoader ##############

package cspace::iSoundLoader;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*LoadSound = *cspacec::iSoundLoader_LoadSound;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSoundLoader($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSoundLoader_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSoundRender ##############

package cspace::iSoundRender;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetVolume = *cspacec::iSoundRender_SetVolume;
*GetVolume = *cspacec::iSoundRender_GetVolume;
*RegisterSound = *cspacec::iSoundRender_RegisterSound;
*UnregisterSound = *cspacec::iSoundRender_UnregisterSound;
*GetListener = *cspacec::iSoundRender_GetListener;
*MixingFunction = *cspacec::iSoundRender_MixingFunction;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSoundRender($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSoundRender_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSoundWrapper ##############

package cspace::iSoundWrapper;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetSound = *cspacec::iSoundWrapper_GetSound;
*QueryObject = *cspacec::iSoundWrapper_QueryObject;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSoundWrapper($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSoundWrapper_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSoundDriver ##############

package cspace::iSoundDriver;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Open = *cspacec::iSoundDriver_Open;
*Close = *cspacec::iSoundDriver_Close;
*LockMemory = *cspacec::iSoundDriver_LockMemory;
*UnlockMemory = *cspacec::iSoundDriver_UnlockMemory;
*IsBackground = *cspacec::iSoundDriver_IsBackground;
*Is16Bits = *cspacec::iSoundDriver_Is16Bits;
*IsStereo = *cspacec::iSoundDriver_IsStereo;
*GetFrequency = *cspacec::iSoundDriver_GetFrequency;
*IsHandleVoidSound = *cspacec::iSoundDriver_IsHandleVoidSound;
*ThreadAware = *cspacec::iSoundDriver_ThreadAware;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSoundDriver($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSoundDriver_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSoundSource ##############

package cspace::iSoundSource;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Play = *cspacec::iSoundSource_Play;
*Stop = *cspacec::iSoundSource_Stop;
*SetVolume = *cspacec::iSoundSource_SetVolume;
*GetVolume = *cspacec::iSoundSource_GetVolume;
*SetFrequencyFactor = *cspacec::iSoundSource_SetFrequencyFactor;
*GetFrequencyFactor = *cspacec::iSoundSource_GetFrequencyFactor;
*GetMode3D = *cspacec::iSoundSource_GetMode3D;
*SetMode3D = *cspacec::iSoundSource_SetMode3D;
*SetPosition = *cspacec::iSoundSource_SetPosition;
*GetPosition = *cspacec::iSoundSource_GetPosition;
*SetVelocity = *cspacec::iSoundSource_SetVelocity;
*GetVelocity = *cspacec::iSoundSource_GetVelocity;
*SetMinimumDistance = *cspacec::iSoundSource_SetMinimumDistance;
*SetMaximumDistance = *cspacec::iSoundSource_SetMaximumDistance;
*GetMinimumDistance = *cspacec::iSoundSource_GetMinimumDistance;
*GetMaximumDistance = *cspacec::iSoundSource_GetMaximumDistance;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSoundSource($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSoundSource_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iComponent ##############

package cspace::iComponent;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Initialize = *cspacec::iComponent_Initialize;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iComponent($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iComponent_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iCacheManager ##############

package cspace::iCacheManager;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetCurrentType = *cspacec::iCacheManager_SetCurrentType;
*GetCurrentType = *cspacec::iCacheManager_GetCurrentType;
*SetCurrentScope = *cspacec::iCacheManager_SetCurrentScope;
*GetCurrentScope = *cspacec::iCacheManager_GetCurrentScope;
*CacheData = *cspacec::iCacheManager_CacheData;
*ReadCache = *cspacec::iCacheManager_ReadCache;
*ClearCache = *cspacec::iCacheManager_ClearCache;
*Flush = *cspacec::iCacheManager_Flush;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iCacheManager($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iCacheManager_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csFileTime ##############

package cspace::csFileTime;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_sec_get = *cspacec::csFileTime_sec_get;
*swig_sec_set = *cspacec::csFileTime_sec_set;
*swig_min_get = *cspacec::csFileTime_min_get;
*swig_min_set = *cspacec::csFileTime_min_set;
*swig_hour_get = *cspacec::csFileTime_hour_get;
*swig_hour_set = *cspacec::csFileTime_hour_set;
*swig_day_get = *cspacec::csFileTime_day_get;
*swig_day_set = *cspacec::csFileTime_day_set;
*swig_mon_get = *cspacec::csFileTime_mon_get;
*swig_mon_set = *cspacec::csFileTime_mon_set;
*swig_year_get = *cspacec::csFileTime_year_get;
*swig_year_set = *cspacec::csFileTime_year_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csFileTime(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csFileTime($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iFile ##############

package cspace::iFile;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetName = *cspacec::iFile_GetName;
*GetSize = *cspacec::iFile_GetSize;
*GetStatus = *cspacec::iFile_GetStatus;
*Read = *cspacec::iFile_Read;
*Write = *cspacec::iFile_Write;
*Flush = *cspacec::iFile_Flush;
*AtEOF = *cspacec::iFile_AtEOF;
*GetPos = *cspacec::iFile_GetPos;
*SetPos = *cspacec::iFile_SetPos;
*GetAllData = *cspacec::iFile_GetAllData;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iFile($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iFile_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iVFS ##############

package cspace::iVFS;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*ChDir = *cspacec::iVFS_ChDir;
*GetCwd = *cspacec::iVFS_GetCwd;
*PushDir = *cspacec::iVFS_PushDir;
*PopDir = *cspacec::iVFS_PopDir;
*ExpandPath = *cspacec::iVFS_ExpandPath;
*Exists = *cspacec::iVFS_Exists;
*FindFiles = *cspacec::iVFS_FindFiles;
*Open = *cspacec::iVFS_Open;
*ReadFile = *cspacec::iVFS_ReadFile;
*WriteFile = *cspacec::iVFS_WriteFile;
*DeleteFile = *cspacec::iVFS_DeleteFile;
*Sync = *cspacec::iVFS_Sync;
*Mount = *cspacec::iVFS_Mount;
*Unmount = *cspacec::iVFS_Unmount;
*MountRoot = *cspacec::iVFS_MountRoot;
*SaveMounts = *cspacec::iVFS_SaveMounts;
*LoadMountsFromFile = *cspacec::iVFS_LoadMountsFromFile;
*ChDirAuto = *cspacec::iVFS_ChDirAuto;
*GetFileTime = *cspacec::iVFS_GetFileTime;
*SetFileTime = *cspacec::iVFS_SetFileTime;
*GetFileSize = *cspacec::iVFS_GetFileSize;
*GetRealPath = *cspacec::iVFS_GetRealPath;
*GetMounts = *cspacec::iVFS_GetMounts;
*GetRealMountPaths = *cspacec::iVFS_GetRealMountPaths;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iVFS($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iVFS_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iObject ##############

package cspace::iObject;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetName = *cspacec::iObject_SetName;
*GetName = *cspacec::iObject_GetName;
*GetID = *cspacec::iObject_GetID;
*SetObjectParent = *cspacec::iObject_SetObjectParent;
*GetObjectParent = *cspacec::iObject_GetObjectParent;
*ObjAdd = *cspacec::iObject_ObjAdd;
*ObjRemove = *cspacec::iObject_ObjRemove;
*ObjRemoveAll = *cspacec::iObject_ObjRemoveAll;
*ObjAddChildren = *cspacec::iObject_ObjAddChildren;
*GetChild = *cspacec::iObject_GetChild;
*GetIterator = *cspacec::iObject_GetIterator;
*ObjReleaseOld = *cspacec::iObject_ObjReleaseOld;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iObject($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iObject_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iObjectIterator ##############

package cspace::iObjectIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Next = *cspacec::iObjectIterator_Next;
*Reset = *cspacec::iObjectIterator_Reset;
*GetParentObj = *cspacec::iObjectIterator_GetParentObj;
*HasNext = *cspacec::iObjectIterator_HasNext;
*FindName = *cspacec::iObjectIterator_FindName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iObjectIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iStringSet ##############

package cspace::iStringSet;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Request = *cspacec::iStringSet_Request;
*Contains = *cspacec::iStringSet_Contains;
*Delete = *cspacec::iStringSet_Delete;
*Empty = *cspacec::iStringSet_Empty;
*Clear = *cspacec::iStringSet_Clear;
*GetSize = *cspacec::iStringSet_GetSize;
*IsEmpty = *cspacec::iStringSet_IsEmpty;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iStringSet($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iStringSet_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iObjectRegistry ##############

package cspace::iObjectRegistry;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Clear = *cspacec::iObjectRegistry_Clear;
*Register = *cspacec::iObjectRegistry_Register;
*Unregister = *cspacec::iObjectRegistry_Unregister;
*Get = *cspacec::iObjectRegistry_Get;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iObjectRegistry($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iObjectRegistry_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iObjectRegistryIterator ##############

package cspace::iObjectRegistryIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Reset = *cspacec::iObjectRegistryIterator_Reset;
*GetCurrentTag = *cspacec::iObjectRegistryIterator_GetCurrentTag;
*HasNext = *cspacec::iObjectRegistryIterator_HasNext;
*Next = *cspacec::iObjectRegistryIterator_Next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iObjectRegistryIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iVirtualClock ##############

package cspace::iVirtualClock;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Advance = *cspacec::iVirtualClock_Advance;
*Suspend = *cspacec::iVirtualClock_Suspend;
*Resume = *cspacec::iVirtualClock_Resume;
*GetElapsedTicks = *cspacec::iVirtualClock_GetElapsedTicks;
*GetCurrentTicks = *cspacec::iVirtualClock_GetCurrentTicks;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iVirtualClock($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iVirtualClock_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEventAttributeIterator ##############

package cspace::iEventAttributeIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HasNext = *cspacec::iEventAttributeIterator_HasNext;
*Next = *cspacec::iEventAttributeIterator_Next;
*Reset = *cspacec::iEventAttributeIterator_Reset;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEventAttributeIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csKeyEventData ##############

package cspace::csKeyEventData;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_eventType_get = *cspacec::csKeyEventData_eventType_get;
*swig_eventType_set = *cspacec::csKeyEventData_eventType_set;
*swig_codeRaw_get = *cspacec::csKeyEventData_codeRaw_get;
*swig_codeRaw_set = *cspacec::csKeyEventData_codeRaw_set;
*swig_codeCooked_get = *cspacec::csKeyEventData_codeCooked_get;
*swig_codeCooked_set = *cspacec::csKeyEventData_codeCooked_set;
*swig_modifiers_get = *cspacec::csKeyEventData_modifiers_get;
*swig_modifiers_set = *cspacec::csKeyEventData_modifiers_set;
*swig_autoRepeat_get = *cspacec::csKeyEventData_autoRepeat_get;
*swig_autoRepeat_set = *cspacec::csKeyEventData_autoRepeat_set;
*swig_charType_get = *cspacec::csKeyEventData_charType_get;
*swig_charType_set = *cspacec::csKeyEventData_charType_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csKeyEventData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csKeyEventData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csEventMouseData ##############

package cspace::csEventMouseData;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *cspacec::csEventMouseData_x_get;
*swig_x_set = *cspacec::csEventMouseData_x_set;
*swig_y_get = *cspacec::csEventMouseData_y_get;
*swig_y_set = *cspacec::csEventMouseData_y_set;
*swig_Button_get = *cspacec::csEventMouseData_Button_get;
*swig_Button_set = *cspacec::csEventMouseData_Button_set;
*swig_Modifiers_get = *cspacec::csEventMouseData_Modifiers_get;
*swig_Modifiers_set = *cspacec::csEventMouseData_Modifiers_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csEventMouseData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csEventMouseData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csEventJoystickData ##############

package cspace::csEventJoystickData;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_number_get = *cspacec::csEventJoystickData_number_get;
*swig_number_set = *cspacec::csEventJoystickData_number_set;
*swig_x_get = *cspacec::csEventJoystickData_x_get;
*swig_x_set = *cspacec::csEventJoystickData_x_set;
*swig_y_get = *cspacec::csEventJoystickData_y_get;
*swig_y_set = *cspacec::csEventJoystickData_y_set;
*swig_Button_get = *cspacec::csEventJoystickData_Button_get;
*swig_Button_set = *cspacec::csEventJoystickData_Button_set;
*swig_Modifiers_get = *cspacec::csEventJoystickData_Modifiers_get;
*swig_Modifiers_set = *cspacec::csEventJoystickData_Modifiers_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csEventJoystickData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csEventJoystickData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csEventCommandData ##############

package cspace::csEventCommandData;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_Code_get = *cspacec::csEventCommandData_Code_get;
*swig_Code_set = *cspacec::csEventCommandData_Code_set;
*swig_Info_get = *cspacec::csEventCommandData_Info_get;
*swig_Info_set = *cspacec::csEventCommandData_Info_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csEventCommandData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csEventCommandData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEvent ##############

package cspace::iEvent;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*swig_Type_get = *cspacec::iEvent_Type_get;
*swig_Type_set = *cspacec::iEvent_Type_set;
*swig_Category_get = *cspacec::iEvent_Category_get;
*swig_Category_set = *cspacec::iEvent_Category_set;
*swig_SubCategory_get = *cspacec::iEvent_SubCategory_get;
*swig_SubCategory_set = *cspacec::iEvent_SubCategory_set;
*swig_Flags_get = *cspacec::iEvent_Flags_get;
*swig_Flags_set = *cspacec::iEvent_Flags_set;
*swig_Time_get = *cspacec::iEvent_Time_get;
*swig_Time_set = *cspacec::iEvent_Time_set;
*AddInt8 = *cspacec::iEvent_AddInt8;
*AddUInt8 = *cspacec::iEvent_AddUInt8;
*AddInt16 = *cspacec::iEvent_AddInt16;
*AddUInt16 = *cspacec::iEvent_AddUInt16;
*AddInt32 = *cspacec::iEvent_AddInt32;
*AddUInt32 = *cspacec::iEvent_AddUInt32;
*AddFloat = *cspacec::iEvent_AddFloat;
*AddDouble = *cspacec::iEvent_AddDouble;
*AddBool = *cspacec::iEvent_AddBool;
*Add = *cspacec::iEvent_Add;
*RetrieveInt8 = *cspacec::iEvent_RetrieveInt8;
*RetrieveUInt8 = *cspacec::iEvent_RetrieveUInt8;
*RetrieveInt16 = *cspacec::iEvent_RetrieveInt16;
*RetrieveUInt16 = *cspacec::iEvent_RetrieveUInt16;
*RetrieveUInt32 = *cspacec::iEvent_RetrieveUInt32;
*RetrieveFloat = *cspacec::iEvent_RetrieveFloat;
*RetrieveDouble = *cspacec::iEvent_RetrieveDouble;
*RetrieveBool = *cspacec::iEvent_RetrieveBool;
*Retrieve = *cspacec::iEvent_Retrieve;
*AttributeExists = *cspacec::iEvent_AttributeExists;
*GetAttributeType = *cspacec::iEvent_GetAttributeType;
*Remove = *cspacec::iEvent_Remove;
*RemoveAll = *cspacec::iEvent_RemoveAll;
*GetAttributeIterator = *cspacec::iEvent_GetAttributeIterator;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEvent($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iEvent_scfGetVersion;
*swig_Mouse_get = *cspacec::iEvent_Mouse_get;
*swig_Mouse_set = *cspacec::iEvent_Mouse_set;
*swig_Joystick_get = *cspacec::iEvent_Joystick_get;
*swig_Joystick_set = *cspacec::iEvent_Joystick_set;
*swig_Command_get = *cspacec::iEvent_Command_get;
*swig_Command_set = *cspacec::iEvent_Command_set;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEventPlug ##############

package cspace::iEventPlug;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetPotentiallyConflictingEvents = *cspacec::iEventPlug_GetPotentiallyConflictingEvents;
*QueryEventPriority = *cspacec::iEventPlug_QueryEventPriority;
*EnableEvents = *cspacec::iEventPlug_EnableEvents;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEventPlug($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEventOutlet ##############

package cspace::iEventOutlet;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*CreateEvent = *cspacec::iEventOutlet_CreateEvent;
*Post = *cspacec::iEventOutlet_Post;
*Key = *cspacec::iEventOutlet_Key;
*Mouse = *cspacec::iEventOutlet_Mouse;
*Joystick = *cspacec::iEventOutlet_Joystick;
*Broadcast = *cspacec::iEventOutlet_Broadcast;
*ImmediateBroadcast = *cspacec::iEventOutlet_ImmediateBroadcast;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEventOutlet($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEventCord ##############

package cspace::iEventCord;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Insert = *cspacec::iEventCord_Insert;
*Remove = *cspacec::iEventCord_Remove;
*GetPass = *cspacec::iEventCord_GetPass;
*SetPass = *cspacec::iEventCord_SetPass;
*GetCategory = *cspacec::iEventCord_GetCategory;
*GetSubcategory = *cspacec::iEventCord_GetSubcategory;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEventCord($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csKeyEventHelper ##############

package cspace::csKeyEventHelper;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*GetRawCode = *cspacec::csKeyEventHelper_GetRawCode;
*GetCookedCode = *cspacec::csKeyEventHelper_GetCookedCode;
*GetEventType = *cspacec::csKeyEventHelper_GetEventType;
*GetAutoRepeat = *cspacec::csKeyEventHelper_GetAutoRepeat;
*GetCharacterType = *cspacec::csKeyEventHelper_GetCharacterType;
*GetEventData = *cspacec::csKeyEventHelper_GetEventData;
*GetModifiersBits = *cspacec::csKeyEventHelper_GetModifiersBits;
*GetModifiers = *cspacec::csKeyEventHelper_GetModifiers;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csKeyEventHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csKeyEventHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csKeyModifiers ##############

package cspace::csKeyModifiers;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_modifiers_get = *cspacec::csKeyModifiers_modifiers_get;
*swig_modifiers_set = *cspacec::csKeyModifiers_modifiers_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csKeyModifiers(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csKeyModifiers($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEventQueue ##############

package cspace::iEventQueue;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Process = *cspacec::iEventQueue_Process;
*Dispatch = *cspacec::iEventQueue_Dispatch;
*RegisterListener = *cspacec::iEventQueue_RegisterListener;
*RemoveListener = *cspacec::iEventQueue_RemoveListener;
*ChangeListenerTrigger = *cspacec::iEventQueue_ChangeListenerTrigger;
*CreateEventOutlet = *cspacec::iEventQueue_CreateEventOutlet;
*GetEventOutlet = *cspacec::iEventQueue_GetEventOutlet;
*GetEventCord = *cspacec::iEventQueue_GetEventCord;
*CreateEvent = *cspacec::iEventQueue_CreateEvent;
*Post = *cspacec::iEventQueue_Post;
*Get = *cspacec::iEventQueue_Get;
*Clear = *cspacec::iEventQueue_Clear;
*IsEmpty = *cspacec::iEventQueue_IsEmpty;
*RemoveAllListeners = *cspacec::iEventQueue_RemoveAllListeners;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEventQueue($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iEventQueue_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEventHandler ##############

package cspace::iEventHandler;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HandleEvent = *cspacec::iEventHandler_HandleEvent;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEventHandler($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iEventHandler_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iPluginIterator ##############

package cspace::iPluginIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HasNext = *cspacec::iPluginIterator_HasNext;
*Next = *cspacec::iPluginIterator_Next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iPluginIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iPluginManager ##############

package cspace::iPluginManager;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*LoadPlugin = *cspacec::iPluginManager_LoadPlugin;
*QueryPlugin = *cspacec::iPluginManager_QueryPlugin;
*UnloadPlugin = *cspacec::iPluginManager_UnloadPlugin;
*RegisterPlugin = *cspacec::iPluginManager_RegisterPlugin;
*GetPlugins = *cspacec::iPluginManager_GetPlugins;
*Clear = *cspacec::iPluginManager_Clear;
*QueryOptions = *cspacec::iPluginManager_QueryOptions;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iPluginManager($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iPluginManager_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iKeyComposer ##############

package cspace::iKeyComposer;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HandleKey = *cspacec::iKeyComposer_HandleKey;
*ResetState = *cspacec::iKeyComposer_ResetState;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iKeyComposer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iKeyboardDriver ##############

package cspace::iKeyboardDriver;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Reset = *cspacec::iKeyboardDriver_Reset;
*DoKey = *cspacec::iKeyboardDriver_DoKey;
*GetModifierState = *cspacec::iKeyboardDriver_GetModifierState;
*CreateKeyComposer = *cspacec::iKeyboardDriver_CreateKeyComposer;
*SynthesizeCooked = *cspacec::iKeyboardDriver_SynthesizeCooked;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iKeyboardDriver($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iKeyboardDriver_scfGetVersion;
*GetKeyState = *cspacec::iKeyboardDriver_GetKeyState;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMouseDriver ##############

package cspace::iMouseDriver;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetDoubleClickTime = *cspacec::iMouseDriver_SetDoubleClickTime;
*Reset = *cspacec::iMouseDriver_Reset;
*GetLastX = *cspacec::iMouseDriver_GetLastX;
*GetLastY = *cspacec::iMouseDriver_GetLastY;
*GetLastButton = *cspacec::iMouseDriver_GetLastButton;
*DoButton = *cspacec::iMouseDriver_DoButton;
*DoMotion = *cspacec::iMouseDriver_DoMotion;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMouseDriver($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMouseDriver_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iJoystickDriver ##############

package cspace::iJoystickDriver;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Reset = *cspacec::iJoystickDriver_Reset;
*GetLastX = *cspacec::iJoystickDriver_GetLastX;
*GetLastY = *cspacec::iJoystickDriver_GetLastY;
*GetLastButton = *cspacec::iJoystickDriver_GetLastButton;
*DoButton = *cspacec::iJoystickDriver_DoButton;
*DoMotion = *cspacec::iJoystickDriver_DoMotion;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iJoystickDriver($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iConfigFile ##############

package cspace::iConfigFile;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetFileName = *cspacec::iConfigFile_GetFileName;
*GetVFS = *cspacec::iConfigFile_GetVFS;
*SetFileName = *cspacec::iConfigFile_SetFileName;
*Load = *cspacec::iConfigFile_Load;
*Save = *cspacec::iConfigFile_Save;
*Clear = *cspacec::iConfigFile_Clear;
*Enumerate = *cspacec::iConfigFile_Enumerate;
*KeyExists = *cspacec::iConfigFile_KeyExists;
*SubsectionExists = *cspacec::iConfigFile_SubsectionExists;
*GetInt = *cspacec::iConfigFile_GetInt;
*GetFloat = *cspacec::iConfigFile_GetFloat;
*GetStr = *cspacec::iConfigFile_GetStr;
*GetBool = *cspacec::iConfigFile_GetBool;
*GetComment = *cspacec::iConfigFile_GetComment;
*SetStr = *cspacec::iConfigFile_SetStr;
*SetInt = *cspacec::iConfigFile_SetInt;
*SetFloat = *cspacec::iConfigFile_SetFloat;
*SetBool = *cspacec::iConfigFile_SetBool;
*SetComment = *cspacec::iConfigFile_SetComment;
*DeleteKey = *cspacec::iConfigFile_DeleteKey;
*GetEOFComment = *cspacec::iConfigFile_GetEOFComment;
*SetEOFComment = *cspacec::iConfigFile_SetEOFComment;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iConfigFile($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iConfigFile_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iConfigIterator ##############

package cspace::iConfigIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetConfigFile = *cspacec::iConfigIterator_GetConfigFile;
*GetSubsection = *cspacec::iConfigIterator_GetSubsection;
*Rewind = *cspacec::iConfigIterator_Rewind;
*Next = *cspacec::iConfigIterator_Next;
*GetKey = *cspacec::iConfigIterator_GetKey;
*GetInt = *cspacec::iConfigIterator_GetInt;
*GetFloat = *cspacec::iConfigIterator_GetFloat;
*GetStr = *cspacec::iConfigIterator_GetStr;
*GetBool = *cspacec::iConfigIterator_GetBool;
*GetComment = *cspacec::iConfigIterator_GetComment;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iConfigIterator($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iConfigIterator_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iConfigManager ##############

package cspace::iConfigManager;
@ISA = qw( cspace cspace::iConfigFile );
%OWNER = ();
%ITERATORS = ();
*PriorityMin = *cspacec::iConfigManager_PriorityMin;
*PriorityVeryLow = *cspacec::iConfigManager_PriorityVeryLow;
*PriorityLow = *cspacec::iConfigManager_PriorityLow;
*PriorityMedium = *cspacec::iConfigManager_PriorityMedium;
*PriorityHigh = *cspacec::iConfigManager_PriorityHigh;
*PriorityVeryHigh = *cspacec::iConfigManager_PriorityVeryHigh;
*PriorityMax = *cspacec::iConfigManager_PriorityMax;
*ConfigPriorityPlugin = *cspacec::iConfigManager_ConfigPriorityPlugin;
*ConfigPriorityApplication = *cspacec::iConfigManager_ConfigPriorityApplication;
*ConfigPriorityUserGlobal = *cspacec::iConfigManager_ConfigPriorityUserGlobal;
*ConfigPriorityUserApp = *cspacec::iConfigManager_ConfigPriorityUserApp;
*ConfigPriorityCmdLine = *cspacec::iConfigManager_ConfigPriorityCmdLine;
*AddDomain = *cspacec::iConfigManager_AddDomain;
*RemoveDomain = *cspacec::iConfigManager_RemoveDomain;
*LookupDomain = *cspacec::iConfigManager_LookupDomain;
*SetDomainPriority = *cspacec::iConfigManager_SetDomainPriority;
*GetDomainPriority = *cspacec::iConfigManager_GetDomainPriority;
*SetDynamicDomain = *cspacec::iConfigManager_SetDynamicDomain;
*GetDynamicDomain = *cspacec::iConfigManager_GetDynamicDomain;
*SetDynamicDomainPriority = *cspacec::iConfigManager_SetDynamicDomainPriority;
*GetDynamicDomainPriority = *cspacec::iConfigManager_GetDynamicDomainPriority;
*FlushRemoved = *cspacec::iConfigManager_FlushRemoved;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iConfigManager($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iConfigManager_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iStringArray ##############

package cspace::iStringArray;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetSize = *cspacec::iStringArray_GetSize;
*Length = *cspacec::iStringArray_Length;
*Push = *cspacec::iStringArray_Push;
*Pop = *cspacec::iStringArray_Pop;
*Get = *cspacec::iStringArray_Get;
*Find = *cspacec::iStringArray_Find;
*FindCaseInsensitive = *cspacec::iStringArray_FindCaseInsensitive;
*FindSortedKey = *cspacec::iStringArray_FindSortedKey;
*Contains = *cspacec::iStringArray_Contains;
*Sort = *cspacec::iStringArray_Sort;
*DeleteIndex = *cspacec::iStringArray_DeleteIndex;
*Insert = *cspacec::iStringArray_Insert;
*Empty = *cspacec::iStringArray_Empty;
*DeleteAll = *cspacec::iStringArray_DeleteAll;
*IsEmpty = *cspacec::iStringArray_IsEmpty;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iStringArray($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iStringArray_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDocumentAttributeIterator ##############

package cspace::iDocumentAttributeIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HasNext = *cspacec::iDocumentAttributeIterator_HasNext;
*Next = *cspacec::iDocumentAttributeIterator_Next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDocumentAttributeIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDocumentAttribute ##############

package cspace::iDocumentAttribute;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetName = *cspacec::iDocumentAttribute_GetName;
*GetValue = *cspacec::iDocumentAttribute_GetValue;
*GetValueAsInt = *cspacec::iDocumentAttribute_GetValueAsInt;
*GetValueAsFloat = *cspacec::iDocumentAttribute_GetValueAsFloat;
*GetValueAsBool = *cspacec::iDocumentAttribute_GetValueAsBool;
*SetName = *cspacec::iDocumentAttribute_SetName;
*SetValue = *cspacec::iDocumentAttribute_SetValue;
*SetValueAsInt = *cspacec::iDocumentAttribute_SetValueAsInt;
*SetValueAsFloat = *cspacec::iDocumentAttribute_SetValueAsFloat;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDocumentAttribute($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDocumentNodeIterator ##############

package cspace::iDocumentNodeIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HasNext = *cspacec::iDocumentNodeIterator_HasNext;
*Next = *cspacec::iDocumentNodeIterator_Next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDocumentNodeIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDocumentNode ##############

package cspace::iDocumentNode;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetType = *cspacec::iDocumentNode_GetType;
*Equals = *cspacec::iDocumentNode_Equals;
*GetValue = *cspacec::iDocumentNode_GetValue;
*SetValue = *cspacec::iDocumentNode_SetValue;
*SetValueAsInt = *cspacec::iDocumentNode_SetValueAsInt;
*SetValueAsFloat = *cspacec::iDocumentNode_SetValueAsFloat;
*GetParent = *cspacec::iDocumentNode_GetParent;
*GetNodes = *cspacec::iDocumentNode_GetNodes;
*GetNode = *cspacec::iDocumentNode_GetNode;
*RemoveNode = *cspacec::iDocumentNode_RemoveNode;
*RemoveNodes = *cspacec::iDocumentNode_RemoveNodes;
*CreateNodeBefore = *cspacec::iDocumentNode_CreateNodeBefore;
*GetContentsValue = *cspacec::iDocumentNode_GetContentsValue;
*GetContentsValueAsInt = *cspacec::iDocumentNode_GetContentsValueAsInt;
*GetContentsValueAsFloat = *cspacec::iDocumentNode_GetContentsValueAsFloat;
*GetAttributes = *cspacec::iDocumentNode_GetAttributes;
*GetAttribute = *cspacec::iDocumentNode_GetAttribute;
*GetAttributeValue = *cspacec::iDocumentNode_GetAttributeValue;
*GetAttributeValueAsInt = *cspacec::iDocumentNode_GetAttributeValueAsInt;
*GetAttributeValueAsFloat = *cspacec::iDocumentNode_GetAttributeValueAsFloat;
*GetAttributeValueAsBool = *cspacec::iDocumentNode_GetAttributeValueAsBool;
*RemoveAttribute = *cspacec::iDocumentNode_RemoveAttribute;
*RemoveAttributes = *cspacec::iDocumentNode_RemoveAttributes;
*SetAttribute = *cspacec::iDocumentNode_SetAttribute;
*SetAttributeAsInt = *cspacec::iDocumentNode_SetAttributeAsInt;
*SetAttributeAsFloat = *cspacec::iDocumentNode_SetAttributeAsFloat;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDocumentNode($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDocument ##############

package cspace::iDocument;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Clear = *cspacec::iDocument_Clear;
*CreateRoot = *cspacec::iDocument_CreateRoot;
*GetRoot = *cspacec::iDocument_GetRoot;
*Parse = *cspacec::iDocument_Parse;
*Write = *cspacec::iDocument_Write;
*Changeable = *cspacec::iDocument_Changeable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDocument($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iDocument_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDocumentSystem ##############

package cspace::iDocumentSystem;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*CreateDocument = *cspacec::iDocumentSystem_CreateDocument;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDocumentSystem($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iDocumentSystem_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csTinyDocumentSystem ##############

package cspace::csTinyDocumentSystem;
@ISA = qw( cspace cspace::iDocumentSystem );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csTinyDocumentSystem(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csTinyDocumentSystem($self);
        delete $OWNER{$self};
    }
}

*swig_scfRefCount_get = *cspacec::csTinyDocumentSystem_scfRefCount_get;
*swig_scfRefCount_set = *cspacec::csTinyDocumentSystem_scfRefCount_set;
*swig_scfWeakRefOwners_get = *cspacec::csTinyDocumentSystem_scfWeakRefOwners_get;
*swig_scfWeakRefOwners_set = *cspacec::csTinyDocumentSystem_scfWeakRefOwners_set;
*scfRemoveRefOwners = *cspacec::csTinyDocumentSystem_scfRemoveRefOwners;
*swig_scfParent_get = *cspacec::csTinyDocumentSystem_scfParent_get;
*swig_scfParent_set = *cspacec::csTinyDocumentSystem_scfParent_set;
*IncRef = *cspacec::csTinyDocumentSystem_IncRef;
*DecRef = *cspacec::csTinyDocumentSystem_DecRef;
*GetRefCount = *cspacec::csTinyDocumentSystem_GetRefCount;
*AddRefOwner = *cspacec::csTinyDocumentSystem_AddRefOwner;
*RemoveRefOwner = *cspacec::csTinyDocumentSystem_RemoveRefOwner;
*QueryInterface = *cspacec::csTinyDocumentSystem_QueryInterface;
*CreateDocument = *cspacec::csTinyDocumentSystem_CreateDocument;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDataBuffer ##############

package cspace::iDataBuffer;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetSize = *cspacec::iDataBuffer_GetSize;
*GetData = *cspacec::iDataBuffer_GetData;
*__ref__ = *cspacec::iDataBuffer___ref__;
*GetUint8 = *cspacec::iDataBuffer_GetUint8;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDataBuffer($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iDataBuffer_scfGetVersion;
*__string__ = *cspacec::iDataBuffer___string__;
*__sv__ = *cspacec::iDataBuffer___sv__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPixelCoord ##############

package cspace::csPixelCoord;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *cspacec::csPixelCoord_x_get;
*swig_x_set = *cspacec::csPixelCoord_x_set;
*swig_y_get = *cspacec::csPixelCoord_y_get;
*swig_y_set = *cspacec::csPixelCoord_y_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPixelCoord(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPixelCoord($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPixelFormat ##############

package cspace::csPixelFormat;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_RedMask_get = *cspacec::csPixelFormat_RedMask_get;
*swig_RedMask_set = *cspacec::csPixelFormat_RedMask_set;
*swig_GreenMask_get = *cspacec::csPixelFormat_GreenMask_get;
*swig_GreenMask_set = *cspacec::csPixelFormat_GreenMask_set;
*swig_BlueMask_get = *cspacec::csPixelFormat_BlueMask_get;
*swig_BlueMask_set = *cspacec::csPixelFormat_BlueMask_set;
*swig_AlphaMask_get = *cspacec::csPixelFormat_AlphaMask_get;
*swig_AlphaMask_set = *cspacec::csPixelFormat_AlphaMask_set;
*swig_RedShift_get = *cspacec::csPixelFormat_RedShift_get;
*swig_RedShift_set = *cspacec::csPixelFormat_RedShift_set;
*swig_GreenShift_get = *cspacec::csPixelFormat_GreenShift_get;
*swig_GreenShift_set = *cspacec::csPixelFormat_GreenShift_set;
*swig_BlueShift_get = *cspacec::csPixelFormat_BlueShift_get;
*swig_BlueShift_set = *cspacec::csPixelFormat_BlueShift_set;
*swig_AlphaShift_get = *cspacec::csPixelFormat_AlphaShift_get;
*swig_AlphaShift_set = *cspacec::csPixelFormat_AlphaShift_set;
*swig_RedBits_get = *cspacec::csPixelFormat_RedBits_get;
*swig_RedBits_set = *cspacec::csPixelFormat_RedBits_set;
*swig_GreenBits_get = *cspacec::csPixelFormat_GreenBits_get;
*swig_GreenBits_set = *cspacec::csPixelFormat_GreenBits_set;
*swig_BlueBits_get = *cspacec::csPixelFormat_BlueBits_get;
*swig_BlueBits_set = *cspacec::csPixelFormat_BlueBits_set;
*swig_AlphaBits_get = *cspacec::csPixelFormat_AlphaBits_get;
*swig_AlphaBits_set = *cspacec::csPixelFormat_AlphaBits_set;
*swig_PalEntries_get = *cspacec::csPixelFormat_PalEntries_get;
*swig_PalEntries_set = *cspacec::csPixelFormat_PalEntries_set;
*swig_PixelBytes_get = *cspacec::csPixelFormat_PixelBytes_get;
*swig_PixelBytes_set = *cspacec::csPixelFormat_PixelBytes_set;
*complete = *cspacec::csPixelFormat_complete;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPixelFormat(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPixelFormat($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csImageArea ##############

package cspace::csImageArea;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *cspacec::csImageArea_x_get;
*swig_x_set = *cspacec::csImageArea_x_set;
*swig_y_get = *cspacec::csImageArea_y_get;
*swig_y_set = *cspacec::csImageArea_y_set;
*swig_w_get = *cspacec::csImageArea_w_get;
*swig_w_set = *cspacec::csImageArea_w_set;
*swig_h_get = *cspacec::csImageArea_h_get;
*swig_h_set = *cspacec::csImageArea_h_set;
*swig_data_get = *cspacec::csImageArea_data_get;
*swig_data_set = *cspacec::csImageArea_data_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csImageArea(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csImageArea($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iOffscreenCanvasCallback ##############

package cspace::iOffscreenCanvasCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*FinishDraw = *cspacec::iOffscreenCanvasCallback_FinishDraw;
*SetRGB = *cspacec::iOffscreenCanvasCallback_SetRGB;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iOffscreenCanvasCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iGraphics2D ##############

package cspace::iGraphics2D;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Open = *cspacec::iGraphics2D_Open;
*Close = *cspacec::iGraphics2D_Close;
*GetWidth = *cspacec::iGraphics2D_GetWidth;
*GetHeight = *cspacec::iGraphics2D_GetHeight;
*GetPage = *cspacec::iGraphics2D_GetPage;
*DoubleBuffer = *cspacec::iGraphics2D_DoubleBuffer;
*GetDoubleBufferState = *cspacec::iGraphics2D_GetDoubleBufferState;
*GetPixelFormat = *cspacec::iGraphics2D_GetPixelFormat;
*GetPixelBytes = *cspacec::iGraphics2D_GetPixelBytes;
*GetPalEntryCount = *cspacec::iGraphics2D_GetPalEntryCount;
*GetPalette = *cspacec::iGraphics2D_GetPalette;
*SetRGB = *cspacec::iGraphics2D_SetRGB;
*FindRGB = *cspacec::iGraphics2D_FindRGB;
*GetRGB = *cspacec::iGraphics2D_GetRGB;
*GetRGBA = *cspacec::iGraphics2D_GetRGBA;
*SetClipRect = *cspacec::iGraphics2D_SetClipRect;
*GetClipRect = *cspacec::iGraphics2D_GetClipRect;
*BeginDraw = *cspacec::iGraphics2D_BeginDraw;
*FinishDraw = *cspacec::iGraphics2D_FinishDraw;
*Print = *cspacec::iGraphics2D_Print;
*Clear = *cspacec::iGraphics2D_Clear;
*ClearAll = *cspacec::iGraphics2D_ClearAll;
*DrawLine = *cspacec::iGraphics2D_DrawLine;
*DrawBox = *cspacec::iGraphics2D_DrawBox;
*ClipLine = *cspacec::iGraphics2D_ClipLine;
*DrawPixel = *cspacec::iGraphics2D_DrawPixel;
*DrawPixels = *cspacec::iGraphics2D_DrawPixels;
*Blit = *cspacec::iGraphics2D_Blit;
*GetPixelAt = *cspacec::iGraphics2D_GetPixelAt;
*GetPixel = *cspacec::iGraphics2D_GetPixel;
*SaveArea = *cspacec::iGraphics2D_SaveArea;
*RestoreArea = *cspacec::iGraphics2D_RestoreArea;
*FreeArea = *cspacec::iGraphics2D_FreeArea;
*Write = *cspacec::iGraphics2D_Write;
*WriteBaseline = *cspacec::iGraphics2D_WriteBaseline;
*AllowResize = *cspacec::iGraphics2D_AllowResize;
*Resize = *cspacec::iGraphics2D_Resize;
*GetFontServer = *cspacec::iGraphics2D_GetFontServer;
*PerformExtension = *cspacec::iGraphics2D_PerformExtension;
*ScreenShot = *cspacec::iGraphics2D_ScreenShot;
*GetNativeWindow = *cspacec::iGraphics2D_GetNativeWindow;
*GetFullScreen = *cspacec::iGraphics2D_GetFullScreen;
*SetFullScreen = *cspacec::iGraphics2D_SetFullScreen;
*SetMousePosition = *cspacec::iGraphics2D_SetMousePosition;
*SetMouseCursor = *cspacec::iGraphics2D_SetMouseCursor;
*SetGamma = *cspacec::iGraphics2D_SetGamma;
*GetGamma = *cspacec::iGraphics2D_GetGamma;
*CreateOffscreenCanvas = *cspacec::iGraphics2D_CreateOffscreenCanvas;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iGraphics2D($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iGraphics2D_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csFog ##############

package cspace::csFog;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_enabled_get = *cspacec::csFog_enabled_get;
*swig_enabled_set = *cspacec::csFog_enabled_set;
*swig_density_get = *cspacec::csFog_density_get;
*swig_density_set = *cspacec::csFog_density_set;
*swig_red_get = *cspacec::csFog_red_get;
*swig_red_set = *cspacec::csFog_red_set;
*swig_green_get = *cspacec::csFog_green_get;
*swig_green_set = *cspacec::csFog_green_set;
*swig_blue_get = *cspacec::csFog_blue_get;
*swig_blue_set = *cspacec::csFog_blue_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csFog(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csFog($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csAlphaMode ##############

package cspace::csAlphaMode;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*alphaNone = *cspacec::csAlphaMode_alphaNone;
*alphaBinary = *cspacec::csAlphaMode_alphaBinary;
*alphaSmooth = *cspacec::csAlphaMode_alphaSmooth;
*swig_autoAlphaMode_get = *cspacec::csAlphaMode_autoAlphaMode_get;
*swig_autoAlphaMode_set = *cspacec::csAlphaMode_autoAlphaMode_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csAlphaMode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csAlphaMode($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csGraphics3DCaps ##############

package cspace::csGraphics3DCaps;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_CanClip_get = *cspacec::csGraphics3DCaps_CanClip_get;
*swig_CanClip_set = *cspacec::csGraphics3DCaps_CanClip_set;
*swig_minTexHeight_get = *cspacec::csGraphics3DCaps_minTexHeight_get;
*swig_minTexHeight_set = *cspacec::csGraphics3DCaps_minTexHeight_set;
*swig_minTexWidth_get = *cspacec::csGraphics3DCaps_minTexWidth_get;
*swig_minTexWidth_set = *cspacec::csGraphics3DCaps_minTexWidth_set;
*swig_maxTexHeight_get = *cspacec::csGraphics3DCaps_maxTexHeight_get;
*swig_maxTexHeight_set = *cspacec::csGraphics3DCaps_maxTexHeight_set;
*swig_maxTexWidth_get = *cspacec::csGraphics3DCaps_maxTexWidth_get;
*swig_maxTexWidth_set = *cspacec::csGraphics3DCaps_maxTexWidth_set;
*swig_fog_get = *cspacec::csGraphics3DCaps_fog_get;
*swig_fog_set = *cspacec::csGraphics3DCaps_fog_set;
*swig_NeedsPO2Maps_get = *cspacec::csGraphics3DCaps_NeedsPO2Maps_get;
*swig_NeedsPO2Maps_set = *cspacec::csGraphics3DCaps_NeedsPO2Maps_set;
*swig_MaxAspectRatio_get = *cspacec::csGraphics3DCaps_MaxAspectRatio_get;
*swig_MaxAspectRatio_set = *cspacec::csGraphics3DCaps_MaxAspectRatio_set;
*swig_SupportsPointSprites_get = *cspacec::csGraphics3DCaps_SupportsPointSprites_get;
*swig_SupportsPointSprites_set = *cspacec::csGraphics3DCaps_SupportsPointSprites_set;
*swig_DestinationAlpha_get = *cspacec::csGraphics3DCaps_DestinationAlpha_get;
*swig_DestinationAlpha_set = *cspacec::csGraphics3DCaps_DestinationAlpha_set;
*swig_StencilShadows_get = *cspacec::csGraphics3DCaps_StencilShadows_get;
*swig_StencilShadows_set = *cspacec::csGraphics3DCaps_StencilShadows_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csGraphics3DCaps(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csGraphics3DCaps($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csSimpleRenderMesh ##############

package cspace::csSimpleRenderMesh;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_meshtype_get = *cspacec::csSimpleRenderMesh_meshtype_get;
*swig_meshtype_set = *cspacec::csSimpleRenderMesh_meshtype_set;
*swig_indexCount_get = *cspacec::csSimpleRenderMesh_indexCount_get;
*swig_indexCount_set = *cspacec::csSimpleRenderMesh_indexCount_set;
*swig_indices_get = *cspacec::csSimpleRenderMesh_indices_get;
*swig_indices_set = *cspacec::csSimpleRenderMesh_indices_set;
*swig_vertexCount_get = *cspacec::csSimpleRenderMesh_vertexCount_get;
*swig_vertexCount_set = *cspacec::csSimpleRenderMesh_vertexCount_set;
*swig_vertices_get = *cspacec::csSimpleRenderMesh_vertices_get;
*swig_vertices_set = *cspacec::csSimpleRenderMesh_vertices_set;
*swig_texcoords_get = *cspacec::csSimpleRenderMesh_texcoords_get;
*swig_texcoords_set = *cspacec::csSimpleRenderMesh_texcoords_set;
*swig_colors_get = *cspacec::csSimpleRenderMesh_colors_get;
*swig_colors_set = *cspacec::csSimpleRenderMesh_colors_set;
*swig_texture_get = *cspacec::csSimpleRenderMesh_texture_get;
*swig_texture_set = *cspacec::csSimpleRenderMesh_texture_set;
*swig_shader_get = *cspacec::csSimpleRenderMesh_shader_get;
*swig_shader_set = *cspacec::csSimpleRenderMesh_shader_set;
*swig_dynDomain_get = *cspacec::csSimpleRenderMesh_dynDomain_get;
*swig_dynDomain_set = *cspacec::csSimpleRenderMesh_dynDomain_set;
*swig_alphaType_get = *cspacec::csSimpleRenderMesh_alphaType_get;
*swig_alphaType_set = *cspacec::csSimpleRenderMesh_alphaType_set;
*swig_z_buf_mode_get = *cspacec::csSimpleRenderMesh_z_buf_mode_get;
*swig_z_buf_mode_set = *cspacec::csSimpleRenderMesh_z_buf_mode_set;
*swig_mixmode_get = *cspacec::csSimpleRenderMesh_mixmode_get;
*swig_mixmode_set = *cspacec::csSimpleRenderMesh_mixmode_set;
*swig_object2world_get = *cspacec::csSimpleRenderMesh_object2world_get;
*swig_object2world_set = *cspacec::csSimpleRenderMesh_object2world_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csSimpleRenderMesh(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csSimpleRenderMesh($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iGraphics3D ##############

package cspace::iGraphics3D;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Open = *cspacec::iGraphics3D_Open;
*Close = *cspacec::iGraphics3D_Close;
*GetDriver2D = *cspacec::iGraphics3D_GetDriver2D;
*GetTextureManager = *cspacec::iGraphics3D_GetTextureManager;
*SetDimensions = *cspacec::iGraphics3D_SetDimensions;
*GetWidth = *cspacec::iGraphics3D_GetWidth;
*GetHeight = *cspacec::iGraphics3D_GetHeight;
*GetCaps = *cspacec::iGraphics3D_GetCaps;
*SetPerspectiveCenter = *cspacec::iGraphics3D_SetPerspectiveCenter;
*GetPerspectiveCenter = *cspacec::iGraphics3D_GetPerspectiveCenter;
*SetPerspectiveAspect = *cspacec::iGraphics3D_SetPerspectiveAspect;
*GetPerspectiveAspect = *cspacec::iGraphics3D_GetPerspectiveAspect;
*SetRenderTarget = *cspacec::iGraphics3D_SetRenderTarget;
*GetRenderTarget = *cspacec::iGraphics3D_GetRenderTarget;
*BeginDraw = *cspacec::iGraphics3D_BeginDraw;
*FinishDraw = *cspacec::iGraphics3D_FinishDraw;
*Print = *cspacec::iGraphics3D_Print;
*DrawMesh = *cspacec::iGraphics3D_DrawMesh;
*DrawSimpleMesh = *cspacec::iGraphics3D_DrawSimpleMesh;
*DrawPixmap = *cspacec::iGraphics3D_DrawPixmap;
*DrawLine = *cspacec::iGraphics3D_DrawLine;
*ActivateBuffers = *cspacec::iGraphics3D_ActivateBuffers;
*DeactivateBuffers = *cspacec::iGraphics3D_DeactivateBuffers;
*SetTextureState = *cspacec::iGraphics3D_SetTextureState;
*SetClipper = *cspacec::iGraphics3D_SetClipper;
*GetClipper = *cspacec::iGraphics3D_GetClipper;
*GetClipType = *cspacec::iGraphics3D_GetClipType;
*SetNearPlane = *cspacec::iGraphics3D_SetNearPlane;
*ResetNearPlane = *cspacec::iGraphics3D_ResetNearPlane;
*GetNearPlane = *cspacec::iGraphics3D_GetNearPlane;
*HasNearPlane = *cspacec::iGraphics3D_HasNearPlane;
*SetRenderState = *cspacec::iGraphics3D_SetRenderState;
*GetRenderState = *cspacec::iGraphics3D_GetRenderState;
*SetOption = *cspacec::iGraphics3D_SetOption;
*SetWriteMask = *cspacec::iGraphics3D_SetWriteMask;
*GetWriteMask = *cspacec::iGraphics3D_GetWriteMask;
*SetZMode = *cspacec::iGraphics3D_SetZMode;
*GetZMode = *cspacec::iGraphics3D_GetZMode;
*EnableZOffset = *cspacec::iGraphics3D_EnableZOffset;
*DisableZOffset = *cspacec::iGraphics3D_DisableZOffset;
*SetShadowState = *cspacec::iGraphics3D_SetShadowState;
*GetZBuffValue = *cspacec::iGraphics3D_GetZBuffValue;
*OpenPortal = *cspacec::iGraphics3D_OpenPortal;
*ClosePortal = *cspacec::iGraphics3D_ClosePortal;
*CreateHalo = *cspacec::iGraphics3D_CreateHalo;
*RemoveFromCache = *cspacec::iGraphics3D_RemoveFromCache;
*CreatePolygonRenderer = *cspacec::iGraphics3D_CreatePolygonRenderer;
*SetWorldToCamera = *cspacec::iGraphics3D_SetWorldToCamera;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iGraphics3D($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iGraphics3D_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iNativeWindowManager ##############

package cspace::iNativeWindowManager;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Alert = *cspacec::iNativeWindowManager_Alert;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iNativeWindowManager($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iNativeWindow ##############

package cspace::iNativeWindow;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetTitle = *cspacec::iNativeWindow_SetTitle;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iNativeWindow($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iFontDeleteNotify ##############

package cspace::iFontDeleteNotify;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*BeforeDelete = *cspacec::iFontDeleteNotify_BeforeDelete;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iFontDeleteNotify($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csBitmapMetrics ##############

package cspace::csBitmapMetrics;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_width_get = *cspacec::csBitmapMetrics_width_get;
*swig_width_set = *cspacec::csBitmapMetrics_width_set;
*swig_height_get = *cspacec::csBitmapMetrics_height_get;
*swig_height_set = *cspacec::csBitmapMetrics_height_set;
*swig_left_get = *cspacec::csBitmapMetrics_left_get;
*swig_left_set = *cspacec::csBitmapMetrics_left_set;
*swig_top_get = *cspacec::csBitmapMetrics_top_get;
*swig_top_set = *cspacec::csBitmapMetrics_top_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csBitmapMetrics(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csBitmapMetrics($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csGlyphMetrics ##############

package cspace::csGlyphMetrics;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_advance_get = *cspacec::csGlyphMetrics_advance_get;
*swig_advance_set = *cspacec::csGlyphMetrics_advance_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csGlyphMetrics(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csGlyphMetrics($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iFont ##############

package cspace::iFont;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*AddDeleteCallback = *cspacec::iFont_AddDeleteCallback;
*RemoveDeleteCallback = *cspacec::iFont_RemoveDeleteCallback;
*GetSize = *cspacec::iFont_GetSize;
*GetMaxSize = *cspacec::iFont_GetMaxSize;
*GetGlyphMetrics = *cspacec::iFont_GetGlyphMetrics;
*GetGlyphBitmap = *cspacec::iFont_GetGlyphBitmap;
*GetGlyphAlphaBitmap = *cspacec::iFont_GetGlyphAlphaBitmap;
*GetDimensions = *cspacec::iFont_GetDimensions;
*GetLength = *cspacec::iFont_GetLength;
*GetDescent = *cspacec::iFont_GetDescent;
*GetAscent = *cspacec::iFont_GetAscent;
*HasGlyph = *cspacec::iFont_HasGlyph;
*GetTextHeight = *cspacec::iFont_GetTextHeight;
*GetUnderlinePosition = *cspacec::iFont_GetUnderlinePosition;
*GetUnderlineThickness = *cspacec::iFont_GetUnderlineThickness;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iFont($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iFont_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iFontServer ##############

package cspace::iFontServer;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*LoadFont = *cspacec::iFontServer_LoadFont;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iFontServer($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iFontServer_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iHalo ##############

package cspace::iHalo;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetWidth = *cspacec::iHalo_GetWidth;
*GetHeight = *cspacec::iHalo_GetHeight;
*SetColor = *cspacec::iHalo_SetColor;
*GetColor = *cspacec::iHalo_GetColor;
*Draw = *cspacec::iHalo_Draw;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iHalo($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iHalo_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iShaderVariableContext ##############

package cspace::iShaderVariableContext;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*AddVariable = *cspacec::iShaderVariableContext_AddVariable;
*GetVariable = *cspacec::iShaderVariableContext_GetVariable;
*GetVariableAdd = *cspacec::iShaderVariableContext_GetVariableAdd;
*GetShaderVariables = *cspacec::iShaderVariableContext_GetShaderVariables;
*PushVariables = *cspacec::iShaderVariableContext_PushVariables;
*PopVariables = *cspacec::iShaderVariableContext_PopVariables;
*IsEmpty = *cspacec::iShaderVariableContext_IsEmpty;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iShaderVariableContext($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iShaderVariableContext_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iShaderManager ##############

package cspace::iShaderManager;
@ISA = qw( cspace cspace::iShaderVariableContext );
%OWNER = ();
%ITERATORS = ();
*RegisterShader = *cspacec::iShaderManager_RegisterShader;
*UnregisterShader = *cspacec::iShaderManager_UnregisterShader;
*GetShader = *cspacec::iShaderManager_GetShader;
*GetShaders = *cspacec::iShaderManager_GetShaders;
*RegisterCompiler = *cspacec::iShaderManager_RegisterCompiler;
*GetCompiler = *cspacec::iShaderManager_GetCompiler;
*GetShaderVariableStack = *cspacec::iShaderManager_GetShaderVariableStack;
*SetTagOptions = *cspacec::iShaderManager_SetTagOptions;
*GetTagOptions = *cspacec::iShaderManager_GetTagOptions;
*GetTags = *cspacec::iShaderManager_GetTags;
*SetActiveLights = *cspacec::iShaderManager_SetActiveLights;
*GetActiveLights = *cspacec::iShaderManager_GetActiveLights;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iShaderManager($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iShaderManager_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iShaderRenderInterface ##############

package cspace::iShaderRenderInterface;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetPrivateObject = *cspacec::iShaderRenderInterface_GetPrivateObject;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iShaderRenderInterface($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csShaderMetadata ##############

package cspace::csShaderMetadata;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_description_get = *cspacec::csShaderMetadata_description_get;
*swig_description_set = *cspacec::csShaderMetadata_description_set;
*swig_numberOfLights_get = *cspacec::csShaderMetadata_numberOfLights_get;
*swig_numberOfLights_set = *cspacec::csShaderMetadata_numberOfLights_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csShaderMetadata(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csShaderMetadata($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iShader ##############

package cspace::iShader;
@ISA = qw( cspace cspace::iShaderVariableContext );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iShader_QueryObject;
*GetFileName = *cspacec::iShader_GetFileName;
*SetFileName = *cspacec::iShader_SetFileName;
*GetTicket = *cspacec::iShader_GetTicket;
*GetNumberOfPasses = *cspacec::iShader_GetNumberOfPasses;
*ActivatePass = *cspacec::iShader_ActivatePass;
*SetupPass = *cspacec::iShader_SetupPass;
*TeardownPass = *cspacec::iShader_TeardownPass;
*DeactivatePass = *cspacec::iShader_DeactivatePass;
*GetMetadata = *cspacec::iShader_GetMetadata;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iShader($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iShaderPriorityList ##############

package cspace::iShaderPriorityList;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetCount = *cspacec::iShaderPriorityList_GetCount;
*GetPriority = *cspacec::iShaderPriorityList_GetPriority;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iShaderPriorityList($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iShaderCompiler ##############

package cspace::iShaderCompiler;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetName = *cspacec::iShaderCompiler_GetName;
*CompileShader = *cspacec::iShaderCompiler_CompileShader;
*ValidateTemplate = *cspacec::iShaderCompiler_ValidateTemplate;
*IsTemplateToCompiler = *cspacec::iShaderCompiler_IsTemplateToCompiler;
*GetPriorities = *cspacec::iShaderCompiler_GetPriorities;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iShaderCompiler($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iTextureHandle ##############

package cspace::iTextureHandle;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetFlags = *cspacec::iTextureHandle_GetFlags;
*SetKeyColor = *cspacec::iTextureHandle_SetKeyColor;
*GetKeyColorStatus = *cspacec::iTextureHandle_GetKeyColorStatus;
*GetKeyColor = *cspacec::iTextureHandle_GetKeyColor;
*CS_TEX_IMG_1D = *cspacec::iTextureHandle_CS_TEX_IMG_1D;
*CS_TEX_IMG_2D = *cspacec::iTextureHandle_CS_TEX_IMG_2D;
*CS_TEX_IMG_3D = *cspacec::iTextureHandle_CS_TEX_IMG_3D;
*CS_TEX_IMG_CUBEMAP = *cspacec::iTextureHandle_CS_TEX_IMG_CUBEMAP;
*CS_TEXTURE_CUBE_POS_X = *cspacec::iTextureHandle_CS_TEXTURE_CUBE_POS_X;
*CS_TEXTURE_CUBE_NEG_X = *cspacec::iTextureHandle_CS_TEXTURE_CUBE_NEG_X;
*CS_TEXTURE_CUBE_POS_Y = *cspacec::iTextureHandle_CS_TEXTURE_CUBE_POS_Y;
*CS_TEXTURE_CUBE_NEG_Y = *cspacec::iTextureHandle_CS_TEXTURE_CUBE_NEG_Y;
*CS_TEXTURE_CUBE_POS_Z = *cspacec::iTextureHandle_CS_TEXTURE_CUBE_POS_Z;
*CS_TEXTURE_CUBE_NEG_Z = *cspacec::iTextureHandle_CS_TEXTURE_CUBE_NEG_Z;
*GetRendererDimensions = *cspacec::iTextureHandle_GetRendererDimensions;
*GetOriginalDimensions = *cspacec::iTextureHandle_GetOriginalDimensions;
*GetTextureTarget = *cspacec::iTextureHandle_GetTextureTarget;
*Blit = *cspacec::iTextureHandle_Blit;
*GetImageName = *cspacec::iTextureHandle_GetImageName;
*GetCacheData = *cspacec::iTextureHandle_GetCacheData;
*SetCacheData = *cspacec::iTextureHandle_SetCacheData;
*GetPrivateObject = *cspacec::iTextureHandle_GetPrivateObject;
*GetAlphaMap = *cspacec::iTextureHandle_GetAlphaMap;
*GetAlphaType = *cspacec::iTextureHandle_GetAlphaType;
*Precache = *cspacec::iTextureHandle_Precache;
*SetTextureClass = *cspacec::iTextureHandle_SetTextureClass;
*GetTextureClass = *cspacec::iTextureHandle_GetTextureClass;
*SetAlphaType = *cspacec::iTextureHandle_SetAlphaType;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iTextureHandle($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iTextureHandle_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iRendererLightmap ##############

package cspace::iRendererLightmap;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetSLMCoords = *cspacec::iRendererLightmap_GetSLMCoords;
*SetData = *cspacec::iRendererLightmap_SetData;
*SetLightCellSize = *cspacec::iRendererLightmap_SetLightCellSize;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iRendererLightmap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSuperLightmap ##############

package cspace::iSuperLightmap;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*RegisterLightmap = *cspacec::iSuperLightmap_RegisterLightmap;
*Dump = *cspacec::iSuperLightmap_Dump;
*GetTexture = *cspacec::iSuperLightmap_GetTexture;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSuperLightmap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iTextureManager ##############

package cspace::iTextureManager;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*RegisterTexture = *cspacec::iTextureManager_RegisterTexture;
*GetTextureFormat = *cspacec::iTextureManager_GetTextureFormat;
*CreateSuperLightmap = *cspacec::iTextureManager_CreateSuperLightmap;
*GetMaxTextureSize = *cspacec::iTextureManager_GetMaxTextureSize;
*GetLightmapRendererCoords = *cspacec::iTextureManager_GetLightmapRendererCoords;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iTextureManager($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iTextureManager_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iMaterial ##############

package cspace::iMaterial;
@ISA = qw( cspace cspace::iShaderVariableContext );
%OWNER = ();
%ITERATORS = ();
*SetShader = *cspacec::iMaterial_SetShader;
*GetShader = *cspacec::iMaterial_GetShader;
*GetShaders = *cspacec::iMaterial_GetShaders;
*GetTexture = *cspacec::iMaterial_GetTexture;
*GetFlatColor = *cspacec::iMaterial_GetFlatColor;
*SetFlatColor = *cspacec::iMaterial_SetFlatColor;
*GetReflection = *cspacec::iMaterial_GetReflection;
*SetReflection = *cspacec::iMaterial_SetReflection;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iMaterial($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iMaterial_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csStreamDescription ##############

package cspace::csStreamDescription;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *cspacec::csStreamDescription_type_get;
*swig_type_set = *cspacec::csStreamDescription_type_set;
*swig_codec_get = *cspacec::csStreamDescription_codec_get;
*swig_codec_set = *cspacec::csStreamDescription_codec_set;
*swig_name_get = *cspacec::csStreamDescription_name_get;
*swig_name_set = *cspacec::csStreamDescription_name_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csStreamDescription(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csStreamDescription($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csVideoStreamDescription ##############

package cspace::csVideoStreamDescription;
@ISA = qw( cspace cspace::csStreamDescription );
%OWNER = ();
%ITERATORS = ();
*swig_colordepth_get = *cspacec::csVideoStreamDescription_colordepth_get;
*swig_colordepth_set = *cspacec::csVideoStreamDescription_colordepth_set;
*swig_framecount_get = *cspacec::csVideoStreamDescription_framecount_get;
*swig_framecount_set = *cspacec::csVideoStreamDescription_framecount_set;
*swig_width_get = *cspacec::csVideoStreamDescription_width_get;
*swig_width_set = *cspacec::csVideoStreamDescription_width_set;
*swig_height_get = *cspacec::csVideoStreamDescription_height_get;
*swig_height_set = *cspacec::csVideoStreamDescription_height_set;
*swig_framerate_get = *cspacec::csVideoStreamDescription_framerate_get;
*swig_framerate_set = *cspacec::csVideoStreamDescription_framerate_set;
*swig_duration_get = *cspacec::csVideoStreamDescription_duration_get;
*swig_duration_set = *cspacec::csVideoStreamDescription_duration_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csVideoStreamDescription(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csVideoStreamDescription($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csAudioStreamDescription ##############

package cspace::csAudioStreamDescription;
@ISA = qw( cspace cspace::csStreamDescription );
%OWNER = ();
%ITERATORS = ();
*swig_formattag_get = *cspacec::csAudioStreamDescription_formattag_get;
*swig_formattag_set = *cspacec::csAudioStreamDescription_formattag_set;
*swig_channels_get = *cspacec::csAudioStreamDescription_channels_get;
*swig_channels_set = *cspacec::csAudioStreamDescription_channels_set;
*swig_samplespersecond_get = *cspacec::csAudioStreamDescription_samplespersecond_get;
*swig_samplespersecond_set = *cspacec::csAudioStreamDescription_samplespersecond_set;
*swig_bitspersample_get = *cspacec::csAudioStreamDescription_bitspersample_get;
*swig_bitspersample_set = *cspacec::csAudioStreamDescription_bitspersample_set;
*swig_duration_get = *cspacec::csAudioStreamDescription_duration_get;
*swig_duration_set = *cspacec::csAudioStreamDescription_duration_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csAudioStreamDescription(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csAudioStreamDescription($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iStreamIterator ##############

package cspace::iStreamIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HasNext = *cspacec::iStreamIterator_HasNext;
*Next = *cspacec::iStreamIterator_Next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iStreamIterator($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iStreamIterator_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iStreamFormat ##############

package cspace::iStreamFormat;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetCaps = *cspacec::iStreamFormat_GetCaps;
*GetStreamIterator = *cspacec::iStreamFormat_GetStreamIterator;
*Select = *cspacec::iStreamFormat_Select;
*NextFrame = *cspacec::iStreamFormat_NextFrame;
*Load = *cspacec::iStreamFormat_Load;
*Unload = *cspacec::iStreamFormat_Unload;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iStreamFormat($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iStreamFormat_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iStream ##############

package cspace::iStream;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetStreamDescription = *cspacec::iStream_GetStreamDescription;
*GotoFrame = *cspacec::iStream_GotoFrame;
*GotoTime = *cspacec::iStream_GotoTime;
*SetPlayMethod = *cspacec::iStream_SetPlayMethod;
*NextFrame = *cspacec::iStream_NextFrame;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iStream($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iStream_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iVideoStream ##############

package cspace::iVideoStream;
@ISA = qw( cspace cspace::iStream );
%OWNER = ();
%ITERATORS = ();
*GetStreamDescription = *cspacec::iVideoStream_GetStreamDescription;
*SetRect = *cspacec::iVideoStream_SetRect;
*SetFXMode = *cspacec::iVideoStream_SetFXMode;
*NextFrameGetTexture = *cspacec::iVideoStream_NextFrameGetTexture;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iVideoStream($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iVideoStream_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iAudioStream ##############

package cspace::iAudioStream;
@ISA = qw( cspace cspace::iStream );
%OWNER = ();
%ITERATORS = ();
*GetStreamDescription = *cspacec::iAudioStream_GetStreamDescription;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iAudioStream($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iAudioStream_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csCodecDescription ##############

package cspace::csCodecDescription;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_codec_get = *cspacec::csCodecDescription_codec_get;
*swig_codec_set = *cspacec::csCodecDescription_codec_set;
*swig_bEncode_get = *cspacec::csCodecDescription_bEncode_get;
*swig_bEncode_set = *cspacec::csCodecDescription_bEncode_set;
*swig_bDecode_get = *cspacec::csCodecDescription_bDecode_get;
*swig_bDecode_set = *cspacec::csCodecDescription_bDecode_set;
*swig_decodeoutput_get = *cspacec::csCodecDescription_decodeoutput_get;
*swig_decodeoutput_set = *cspacec::csCodecDescription_decodeoutput_set;
*swig_encodeinput_get = *cspacec::csCodecDescription_encodeinput_get;
*swig_encodeinput_set = *cspacec::csCodecDescription_encodeinput_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csCodecDescription(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csCodecDescription($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iImage ##############

package cspace::iImage;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetImageData = *cspacec::iImage_GetImageData;
*GetWidth = *cspacec::iImage_GetWidth;
*GetHeight = *cspacec::iImage_GetHeight;
*GetDepth = *cspacec::iImage_GetDepth;
*SetName = *cspacec::iImage_SetName;
*GetName = *cspacec::iImage_GetName;
*GetFormat = *cspacec::iImage_GetFormat;
*GetPalette = *cspacec::iImage_GetPalette;
*GetAlpha = *cspacec::iImage_GetAlpha;
*HasKeyColor = *cspacec::iImage_HasKeyColor;
*HasKeycolor = *cspacec::iImage_HasKeycolor;
*GetKeyColor = *cspacec::iImage_GetKeyColor;
*GetKeycolor = *cspacec::iImage_GetKeycolor;
*HasMipmaps = *cspacec::iImage_HasMipmaps;
*GetMipmap = *cspacec::iImage_GetMipmap;
*GetRawFormat = *cspacec::iImage_GetRawFormat;
*GetRawData = *cspacec::iImage_GetRawData;
*GetImageType = *cspacec::iImage_GetImageType;
*HasSubImages = *cspacec::iImage_HasSubImages;
*GetSubImage = *cspacec::iImage_GetSubImage;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iImage($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iImage_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csImageIOFileFormatDescription ##############

package cspace::csImageIOFileFormatDescription;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_mime_get = *cspacec::csImageIOFileFormatDescription_mime_get;
*swig_mime_set = *cspacec::csImageIOFileFormatDescription_mime_set;
*swig_subtype_get = *cspacec::csImageIOFileFormatDescription_subtype_get;
*swig_subtype_set = *cspacec::csImageIOFileFormatDescription_subtype_set;
*swig_cap_get = *cspacec::csImageIOFileFormatDescription_cap_get;
*swig_cap_set = *cspacec::csImageIOFileFormatDescription_cap_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csImageIOFileFormatDescription(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csImageIOFileFormatDescription($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iImageIO ##############

package cspace::iImageIO;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetDescription = *cspacec::iImageIO_GetDescription;
*Load = *cspacec::iImageIO_Load;
*SetDithering = *cspacec::iImageIO_SetDithering;
*Save = *cspacec::iImageIO_Save;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iImageIO($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iImageIO_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iReporterListener ##############

package cspace::iReporterListener;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Report = *cspacec::iReporterListener_Report;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iReporterListener($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iReporterListener_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iReporterIterator ##############

package cspace::iReporterIterator;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*HasNext = *cspacec::iReporterIterator_HasNext;
*Next = *cspacec::iReporterIterator_Next;
*GetMessageSeverity = *cspacec::iReporterIterator_GetMessageSeverity;
*GetMessageId = *cspacec::iReporterIterator_GetMessageId;
*GetMessageDescription = *cspacec::iReporterIterator_GetMessageDescription;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iReporterIterator($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iReporterIterator_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iReporter ##############

package cspace::iReporter;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Report = *cspacec::iReporter_Report;
*Clear = *cspacec::iReporter_Clear;
*GetMessageIterator = *cspacec::iReporter_GetMessageIterator;
*AddReporterListener = *cspacec::iReporter_AddReporterListener;
*RemoveReporterListener = *cspacec::iReporter_RemoveReporterListener;
*FindReporterListener = *cspacec::iReporter_FindReporterListener;
*ReportError = *cspacec::iReporter_ReportError;
*ReportWarning = *cspacec::iReporter_ReportWarning;
*ReportNotify = *cspacec::iReporter_ReportNotify;
*ReportBug = *cspacec::iReporter_ReportBug;
*ReportDebug = *cspacec::iReporter_ReportDebug;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iReporter($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iReporter_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csReporterHelper ##############

package cspace::csReporterHelper;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*Report = *cspacec::csReporterHelper_Report;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csReporterHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csReporterHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iConsoleWatcher ##############

package cspace::iConsoleWatcher;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*ConsoleVisibilityChanged = *cspacec::iConsoleWatcher_ConsoleVisibilityChanged;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iConsoleWatcher($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iConsoleOutput ##############

package cspace::iConsoleOutput;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*PutText = *cspacec::iConsoleOutput_PutText;
*GetLine = *cspacec::iConsoleOutput_GetLine;
*Draw2D = *cspacec::iConsoleOutput_Draw2D;
*Draw3D = *cspacec::iConsoleOutput_Draw3D;
*Clear = *cspacec::iConsoleOutput_Clear;
*SetBufferSize = *cspacec::iConsoleOutput_SetBufferSize;
*GetTransparency = *cspacec::iConsoleOutput_GetTransparency;
*SetTransparency = *cspacec::iConsoleOutput_SetTransparency;
*GetFont = *cspacec::iConsoleOutput_GetFont;
*SetFont = *cspacec::iConsoleOutput_SetFont;
*GetTopLine = *cspacec::iConsoleOutput_GetTopLine;
*ScrollTo = *cspacec::iConsoleOutput_ScrollTo;
*GetCursorStyle = *cspacec::iConsoleOutput_GetCursorStyle;
*SetCursorStyle = *cspacec::iConsoleOutput_SetCursorStyle;
*SetVisible = *cspacec::iConsoleOutput_SetVisible;
*GetVisible = *cspacec::iConsoleOutput_GetVisible;
*AutoUpdate = *cspacec::iConsoleOutput_AutoUpdate;
*SetCursorPos = *cspacec::iConsoleOutput_SetCursorPos;
*GetMaxLineWidth = *cspacec::iConsoleOutput_GetMaxLineWidth;
*RegisterWatcher = *cspacec::iConsoleOutput_RegisterWatcher;
*PerformExtension = *cspacec::iConsoleOutput_PerformExtension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iConsoleOutput($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iStandardReporterListener ##############

package cspace::iStandardReporterListener;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetOutputConsole = *cspacec::iStandardReporterListener_SetOutputConsole;
*SetNativeWindowManager = *cspacec::iStandardReporterListener_SetNativeWindowManager;
*SetReporter = *cspacec::iStandardReporterListener_SetReporter;
*SetDebugFile = *cspacec::iStandardReporterListener_SetDebugFile;
*SetDefaults = *cspacec::iStandardReporterListener_SetDefaults;
*SetMessageDestination = *cspacec::iStandardReporterListener_SetMessageDestination;
*RemoveMessages = *cspacec::iStandardReporterListener_RemoveMessages;
*ShowMessageID = *cspacec::iStandardReporterListener_ShowMessageID;
*GetDebugFile = *cspacec::iStandardReporterListener_GetDebugFile;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iStandardReporterListener($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iStandardReporterListener_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iView ##############

package cspace::iView;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetEngine = *cspacec::iView_GetEngine;
*SetEngine = *cspacec::iView_SetEngine;
*GetCamera = *cspacec::iView_GetCamera;
*SetCamera = *cspacec::iView_SetCamera;
*GetContext = *cspacec::iView_GetContext;
*SetContext = *cspacec::iView_SetContext;
*SetRectangle = *cspacec::iView_SetRectangle;
*ClearView = *cspacec::iView_ClearView;
*AddViewVertex = *cspacec::iView_AddViewVertex;
*RestrictClipperToScreen = *cspacec::iView_RestrictClipperToScreen;
*UpdateClipper = *cspacec::iView_UpdateClipper;
*GetClipper = *cspacec::iView_GetClipper;
*Draw = *cspacec::iView_Draw;
*SetAutoResize = *cspacec::iView_SetAutoResize;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iView($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iView_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csCollisionPair ##############

package cspace::csCollisionPair;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_a1_get = *cspacec::csCollisionPair_a1_get;
*swig_a1_set = *cspacec::csCollisionPair_a1_set;
*swig_b1_get = *cspacec::csCollisionPair_b1_get;
*swig_b1_set = *cspacec::csCollisionPair_b1_set;
*swig_c1_get = *cspacec::csCollisionPair_c1_get;
*swig_c1_set = *cspacec::csCollisionPair_c1_set;
*swig_a2_get = *cspacec::csCollisionPair_a2_get;
*swig_a2_set = *cspacec::csCollisionPair_a2_set;
*swig_b2_get = *cspacec::csCollisionPair_b2_get;
*swig_b2_set = *cspacec::csCollisionPair_b2_set;
*swig_c2_get = *cspacec::csCollisionPair_c2_get;
*swig_c2_set = *cspacec::csCollisionPair_c2_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csCollisionPair(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csCollisionPair($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csIntersectingTriangle ##############

package cspace::csIntersectingTriangle;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*swig_a_get = *cspacec::csIntersectingTriangle_a_get;
*swig_a_set = *cspacec::csIntersectingTriangle_a_set;
*swig_b_get = *cspacec::csIntersectingTriangle_b_get;
*swig_b_set = *cspacec::csIntersectingTriangle_b_set;
*swig_c_get = *cspacec::csIntersectingTriangle_c_get;
*swig_c_set = *cspacec::csIntersectingTriangle_c_set;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csIntersectingTriangle(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csIntersectingTriangle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iCollider ##############

package cspace::iCollider;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iCollider($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iCollider_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iCollideSystem ##############

package cspace::iCollideSystem;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*CreateCollider = *cspacec::iCollideSystem_CreateCollider;
*Collide = *cspacec::iCollideSystem_Collide;
*GetCollisionPairs = *cspacec::iCollideSystem_GetCollisionPairs;
*GetCollisionPairCount = *cspacec::iCollideSystem_GetCollisionPairCount;
*ResetCollisionPairs = *cspacec::iCollideSystem_ResetCollisionPairs;
*CollideRay = *cspacec::iCollideSystem_CollideRay;
*GetIntersectingTriangles = *cspacec::iCollideSystem_GetIntersectingTriangles;
*SetOneHitOnly = *cspacec::iCollideSystem_SetOneHitOnly;
*GetOneHitOnly = *cspacec::iCollideSystem_GetOneHitOnly;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iCollideSystem($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iCollideSystem_scfGetVersion;
*GetCollisionPairByIndex = *cspacec::iCollideSystem_GetCollisionPairByIndex;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDynamics ##############

package cspace::iDynamics;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*CreateSystem = *cspacec::iDynamics_CreateSystem;
*RemoveSystem = *cspacec::iDynamics_RemoveSystem;
*FindSystem = *cspacec::iDynamics_FindSystem;
*Step = *cspacec::iDynamics_Step;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDynamics($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iDynamics_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDynamicSystem ##############

package cspace::iDynamicSystem;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iDynamicSystem_QueryObject;
*SetGravity = *cspacec::iDynamicSystem_SetGravity;
*GetGravity = *cspacec::iDynamicSystem_GetGravity;
*SetLinearDampener = *cspacec::iDynamicSystem_SetLinearDampener;
*GetLinearDampener = *cspacec::iDynamicSystem_GetLinearDampener;
*SetRollingDampener = *cspacec::iDynamicSystem_SetRollingDampener;
*GetRollingDampener = *cspacec::iDynamicSystem_GetRollingDampener;
*EnableAutoDisable = *cspacec::iDynamicSystem_EnableAutoDisable;
*AutoDisableEnabled = *cspacec::iDynamicSystem_AutoDisableEnabled;
*SetAutoDisableParams = *cspacec::iDynamicSystem_SetAutoDisableParams;
*Step = *cspacec::iDynamicSystem_Step;
*CreateBody = *cspacec::iDynamicSystem_CreateBody;
*RemoveBody = *cspacec::iDynamicSystem_RemoveBody;
*FindBody = *cspacec::iDynamicSystem_FindBody;
*CreateGroup = *cspacec::iDynamicSystem_CreateGroup;
*RemoveGroup = *cspacec::iDynamicSystem_RemoveGroup;
*CreateJoint = *cspacec::iDynamicSystem_CreateJoint;
*RemoveJoint = *cspacec::iDynamicSystem_RemoveJoint;
*GetDefaultMoveCallback = *cspacec::iDynamicSystem_GetDefaultMoveCallback;
*AttachColliderMesh = *cspacec::iDynamicSystem_AttachColliderMesh;
*AttachColliderCylinder = *cspacec::iDynamicSystem_AttachColliderCylinder;
*AttachColliderBox = *cspacec::iDynamicSystem_AttachColliderBox;
*AttachColliderSphere = *cspacec::iDynamicSystem_AttachColliderSphere;
*AttachColliderPlane = *cspacec::iDynamicSystem_AttachColliderPlane;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDynamicSystem($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iDynamicSystem_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDynamicsMoveCallback ##############

package cspace::iDynamicsMoveCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Execute = *cspacec::iDynamicsMoveCallback_Execute;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDynamicsMoveCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iDynamicsCollisionCallback ##############

package cspace::iDynamicsCollisionCallback;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Execute = *cspacec::iDynamicsCollisionCallback_Execute;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iDynamicsCollisionCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iBodyGroup ##############

package cspace::iBodyGroup;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*AddBody = *cspacec::iBodyGroup_AddBody;
*RemoveBody = *cspacec::iBodyGroup_RemoveBody;
*BodyInGroup = *cspacec::iBodyGroup_BodyInGroup;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iBodyGroup($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iBodyGroup_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iRigidBody ##############

package cspace::iRigidBody;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iRigidBody_QueryObject;
*MakeStatic = *cspacec::iRigidBody_MakeStatic;
*MakeDynamic = *cspacec::iRigidBody_MakeDynamic;
*IsStatic = *cspacec::iRigidBody_IsStatic;
*Disable = *cspacec::iRigidBody_Disable;
*Enable = *cspacec::iRigidBody_Enable;
*IsEnabled = *cspacec::iRigidBody_IsEnabled;
*GetGroup = *cspacec::iRigidBody_GetGroup;
*AttachColliderMesh = *cspacec::iRigidBody_AttachColliderMesh;
*AttachColliderCylinder = *cspacec::iRigidBody_AttachColliderCylinder;
*AttachColliderBox = *cspacec::iRigidBody_AttachColliderBox;
*AttachColliderSphere = *cspacec::iRigidBody_AttachColliderSphere;
*AttachColliderPlane = *cspacec::iRigidBody_AttachColliderPlane;
*SetPosition = *cspacec::iRigidBody_SetPosition;
*GetPosition = *cspacec::iRigidBody_GetPosition;
*SetOrientation = *cspacec::iRigidBody_SetOrientation;
*GetOrientation = *cspacec::iRigidBody_GetOrientation;
*SetTransform = *cspacec::iRigidBody_SetTransform;
*GetTransform = *cspacec::iRigidBody_GetTransform;
*SetLinearVelocity = *cspacec::iRigidBody_SetLinearVelocity;
*GetLinearVelocity = *cspacec::iRigidBody_GetLinearVelocity;
*SetAngularVelocity = *cspacec::iRigidBody_SetAngularVelocity;
*GetAngularVelocity = *cspacec::iRigidBody_GetAngularVelocity;
*SetProperties = *cspacec::iRigidBody_SetProperties;
*GetProperties = *cspacec::iRigidBody_GetProperties;
*GetMass = *cspacec::iRigidBody_GetMass;
*GetCenter = *cspacec::iRigidBody_GetCenter;
*GetInertia = *cspacec::iRigidBody_GetInertia;
*AdjustTotalMass = *cspacec::iRigidBody_AdjustTotalMass;
*AddForce = *cspacec::iRigidBody_AddForce;
*AddTorque = *cspacec::iRigidBody_AddTorque;
*AddRelForce = *cspacec::iRigidBody_AddRelForce;
*AddRelTorque = *cspacec::iRigidBody_AddRelTorque;
*AddForceAtPos = *cspacec::iRigidBody_AddForceAtPos;
*AddForceAtRelPos = *cspacec::iRigidBody_AddForceAtRelPos;
*AddRelForceAtPos = *cspacec::iRigidBody_AddRelForceAtPos;
*AddRelForceAtRelPos = *cspacec::iRigidBody_AddRelForceAtRelPos;
*GetForce = *cspacec::iRigidBody_GetForce;
*GetTorque = *cspacec::iRigidBody_GetTorque;
*AttachMesh = *cspacec::iRigidBody_AttachMesh;
*GetAttachedMesh = *cspacec::iRigidBody_GetAttachedMesh;
*SetMoveCallback = *cspacec::iRigidBody_SetMoveCallback;
*SetCollisionCallback = *cspacec::iRigidBody_SetCollisionCallback;
*Collision = *cspacec::iRigidBody_Collision;
*Update = *cspacec::iRigidBody_Update;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iRigidBody($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iJoint ##############

package cspace::iJoint;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Attach = *cspacec::iJoint_Attach;
*GetAttachedBody = *cspacec::iJoint_GetAttachedBody;
*SetTransform = *cspacec::iJoint_SetTransform;
*GetTransform = *cspacec::iJoint_GetTransform;
*SetTransConstraints = *cspacec::iJoint_SetTransConstraints;
*IsXTransConstrained = *cspacec::iJoint_IsXTransConstrained;
*IsYTransConstrained = *cspacec::iJoint_IsYTransConstrained;
*IsZTransConstrained = *cspacec::iJoint_IsZTransConstrained;
*SetMinimumDistance = *cspacec::iJoint_SetMinimumDistance;
*GetMinimumDistance = *cspacec::iJoint_GetMinimumDistance;
*SetMaximumDistance = *cspacec::iJoint_SetMaximumDistance;
*GetMaximumDistance = *cspacec::iJoint_GetMaximumDistance;
*SetRotConstraints = *cspacec::iJoint_SetRotConstraints;
*IsXRotConstrained = *cspacec::iJoint_IsXRotConstrained;
*IsYRotConstrained = *cspacec::iJoint_IsYRotConstrained;
*IsZRotConstrained = *cspacec::iJoint_IsZRotConstrained;
*SetMinimumAngle = *cspacec::iJoint_SetMinimumAngle;
*GetMinimumAngle = *cspacec::iJoint_GetMinimumAngle;
*SetMaximumAngle = *cspacec::iJoint_SetMaximumAngle;
*GetMaximumAngle = *cspacec::iJoint_GetMaximumAngle;
*SetBounce = *cspacec::iJoint_SetBounce;
*GetBounce = *cspacec::iJoint_GetBounce;
*SetDesiredVelocity = *cspacec::iJoint_SetDesiredVelocity;
*GetDesiredVelocity = *cspacec::iJoint_GetDesiredVelocity;
*SetMaxForce = *cspacec::iJoint_SetMaxForce;
*GetMaxForce = *cspacec::iJoint_GetMaxForce;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iJoint($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iJoint_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iParameterESM ##############

package cspace::iParameterESM;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetValue = *cspacec::iParameterESM_GetValue;
*IsConstant = *cspacec::iParameterESM_IsConstant;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iParameterESM($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEngineSequenceParameters ##############

package cspace::iEngineSequenceParameters;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetParameterCount = *cspacec::iEngineSequenceParameters_GetParameterCount;
*GetParameter = *cspacec::iEngineSequenceParameters_GetParameter;
*GetParameterIdx = *cspacec::iEngineSequenceParameters_GetParameterIdx;
*GetParameterName = *cspacec::iEngineSequenceParameters_GetParameterName;
*AddParameter = *cspacec::iEngineSequenceParameters_AddParameter;
*SetParameter = *cspacec::iEngineSequenceParameters_SetParameter;
*CreateParameterESM = *cspacec::iEngineSequenceParameters_CreateParameterESM;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEngineSequenceParameters($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSequenceWrapper ##############

package cspace::iSequenceWrapper;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iSequenceWrapper_QueryObject;
*GetSequence = *cspacec::iSequenceWrapper_GetSequence;
*CreateBaseParameterBlock = *cspacec::iSequenceWrapper_CreateBaseParameterBlock;
*GetBaseParameterBlock = *cspacec::iSequenceWrapper_GetBaseParameterBlock;
*CreateParameterBlock = *cspacec::iSequenceWrapper_CreateParameterBlock;
*AddOperationSetVariable = *cspacec::iSequenceWrapper_AddOperationSetVariable;
*AddOperationSetMaterial = *cspacec::iSequenceWrapper_AddOperationSetMaterial;
*AddOperationSetPolygonMaterial = *cspacec::iSequenceWrapper_AddOperationSetPolygonMaterial;
*AddOperationSetLight = *cspacec::iSequenceWrapper_AddOperationSetLight;
*AddOperationFadeLight = *cspacec::iSequenceWrapper_AddOperationFadeLight;
*AddOperationSetAmbient = *cspacec::iSequenceWrapper_AddOperationSetAmbient;
*AddOperationFadeAmbient = *cspacec::iSequenceWrapper_AddOperationFadeAmbient;
*AddOperationRandomDelay = *cspacec::iSequenceWrapper_AddOperationRandomDelay;
*AddOperationSetMeshColor = *cspacec::iSequenceWrapper_AddOperationSetMeshColor;
*AddOperationFadeMeshColor = *cspacec::iSequenceWrapper_AddOperationFadeMeshColor;
*AddOperationSetFog = *cspacec::iSequenceWrapper_AddOperationSetFog;
*AddOperationFadeFog = *cspacec::iSequenceWrapper_AddOperationFadeFog;
*AddOperationRotateDuration = *cspacec::iSequenceWrapper_AddOperationRotateDuration;
*AddOperationMoveDuration = *cspacec::iSequenceWrapper_AddOperationMoveDuration;
*AddOperationTriggerState = *cspacec::iSequenceWrapper_AddOperationTriggerState;
*AddOperationCheckTrigger = *cspacec::iSequenceWrapper_AddOperationCheckTrigger;
*AddOperationTestTrigger = *cspacec::iSequenceWrapper_AddOperationTestTrigger;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSequenceWrapper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSequenceTrigger ##############

package cspace::iSequenceTrigger;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*QueryObject = *cspacec::iSequenceTrigger_QueryObject;
*AddConditionInSector = *cspacec::iSequenceTrigger_AddConditionInSector;
*AddConditionSectorVisible = *cspacec::iSequenceTrigger_AddConditionSectorVisible;
*AddConditionMeshClick = *cspacec::iSequenceTrigger_AddConditionMeshClick;
*AddConditionLightChange = *cspacec::iSequenceTrigger_AddConditionLightChange;
*AddConditionManual = *cspacec::iSequenceTrigger_AddConditionManual;
*SetEnabled = *cspacec::iSequenceTrigger_SetEnabled;
*IsEnabled = *cspacec::iSequenceTrigger_IsEnabled;
*ClearConditions = *cspacec::iSequenceTrigger_ClearConditions;
*Trigger = *cspacec::iSequenceTrigger_Trigger;
*SetParameters = *cspacec::iSequenceTrigger_SetParameters;
*GetParameters = *cspacec::iSequenceTrigger_GetParameters;
*FireSequence = *cspacec::iSequenceTrigger_FireSequence;
*GetFiredSequence = *cspacec::iSequenceTrigger_GetFiredSequence;
*TestConditions = *cspacec::iSequenceTrigger_TestConditions;
*CheckState = *cspacec::iSequenceTrigger_CheckState;
*ForceFire = *cspacec::iSequenceTrigger_ForceFire;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSequenceTrigger($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSequenceTimedOperation ##############

package cspace::iSequenceTimedOperation;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Do = *cspacec::iSequenceTimedOperation_Do;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSequenceTimedOperation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iEngineSequenceManager ##############

package cspace::iEngineSequenceManager;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetSequenceManager = *cspacec::iEngineSequenceManager_GetSequenceManager;
*SetCamera = *cspacec::iEngineSequenceManager_SetCamera;
*GetCamera = *cspacec::iEngineSequenceManager_GetCamera;
*CreateParameterESM = *cspacec::iEngineSequenceManager_CreateParameterESM;
*CreateTrigger = *cspacec::iEngineSequenceManager_CreateTrigger;
*RemoveTrigger = *cspacec::iEngineSequenceManager_RemoveTrigger;
*RemoveTriggers = *cspacec::iEngineSequenceManager_RemoveTriggers;
*GetTriggerCount = *cspacec::iEngineSequenceManager_GetTriggerCount;
*GetTrigger = *cspacec::iEngineSequenceManager_GetTrigger;
*FindTriggerByName = *cspacec::iEngineSequenceManager_FindTriggerByName;
*FireTriggerByName = *cspacec::iEngineSequenceManager_FireTriggerByName;
*CreateSequence = *cspacec::iEngineSequenceManager_CreateSequence;
*RemoveSequence = *cspacec::iEngineSequenceManager_RemoveSequence;
*RemoveSequences = *cspacec::iEngineSequenceManager_RemoveSequences;
*GetSequenceCount = *cspacec::iEngineSequenceManager_GetSequenceCount;
*GetSequence = *cspacec::iEngineSequenceManager_GetSequence;
*FindSequenceByName = *cspacec::iEngineSequenceManager_FindSequenceByName;
*RunSequenceByName = *cspacec::iEngineSequenceManager_RunSequenceByName;
*FireTimedOperation = *cspacec::iEngineSequenceManager_FireTimedOperation;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iEngineSequenceManager($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iScriptObject ##############

package cspace::iScriptObject;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*IsType = *cspacec::iScriptObject_IsType;
*GetPointer = *cspacec::iScriptObject_GetPointer;
*SetPointer = *cspacec::iScriptObject_SetPointer;
*IntCall = *cspacec::iScriptObject_IntCall;
*FloatCall = *cspacec::iScriptObject_FloatCall;
*DoubleCall = *cspacec::iScriptObject_DoubleCall;
*Call = *cspacec::iScriptObject_Call;
*ObjectCall = *cspacec::iScriptObject_ObjectCall;
*SetInt = *cspacec::iScriptObject_SetInt;
*SetFloat = *cspacec::iScriptObject_SetFloat;
*SetDouble = *cspacec::iScriptObject_SetDouble;
*SetString = *cspacec::iScriptObject_SetString;
*Set = *cspacec::iScriptObject_Set;
*SetTruth = *cspacec::iScriptObject_SetTruth;
*Get = *cspacec::iScriptObject_Get;
*GetTruth = *cspacec::iScriptObject_GetTruth;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iScriptObject($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iScriptObject_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iScript ##############

package cspace::iScript;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*Initialize = *cspacec::iScript_Initialize;
*RunText = *cspacec::iScript_RunText;
*LoadModule = *cspacec::iScript_LoadModule;
*IntCall = *cspacec::iScript_IntCall;
*FloatCall = *cspacec::iScript_FloatCall;
*DoubleCall = *cspacec::iScript_DoubleCall;
*Call = *cspacec::iScript_Call;
*ObjectCall = *cspacec::iScript_ObjectCall;
*NewObject = *cspacec::iScript_NewObject;
*StoreInt = *cspacec::iScript_StoreInt;
*StoreFloat = *cspacec::iScript_StoreFloat;
*StoreDouble = *cspacec::iScript_StoreDouble;
*StoreString = *cspacec::iScript_StoreString;
*Store = *cspacec::iScript_Store;
*SetTruth = *cspacec::iScript_SetTruth;
*Retrieve = *cspacec::iScript_Retrieve;
*GetTruth = *cspacec::iScript_GetTruth;
*Remove = *cspacec::iScript_Remove;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iScript($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iScript_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iSimpleFormerState ##############

package cspace::iSimpleFormerState;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SetHeightmap = *cspacec::iSimpleFormerState_SetHeightmap;
*SetScale = *cspacec::iSimpleFormerState_SetScale;
*SetOffset = *cspacec::iSimpleFormerState_SetOffset;
*SetIntegerMap = *cspacec::iSimpleFormerState_SetIntegerMap;
*SetFloatMap = *cspacec::iSimpleFormerState_SetFloatMap;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iSimpleFormerState($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iSimpleFormerState_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iTerraFormer ##############

package cspace::iTerraFormer;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*GetSampler = *cspacec::iTerraFormer_GetSampler;
*SampleFloat = *cspacec::iTerraFormer_SampleFloat;
*SampleVector2 = *cspacec::iTerraFormer_SampleVector2;
*SampleVector3 = *cspacec::iTerraFormer_SampleVector3;
*SampleInteger = *cspacec::iTerraFormer_SampleInteger;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iTerraFormer($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iTerraFormer_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::iTerraSampler ##############

package cspace::iTerraSampler;
@ISA = qw( cspace cspace::iBase );
%OWNER = ();
%ITERATORS = ();
*SampleFloat = *cspacec::iTerraSampler_SampleFloat;
*SampleVector2 = *cspacec::iTerraSampler_SampleVector2;
*SampleVector3 = *cspacec::iTerraSampler_SampleVector3;
*SampleInteger = *cspacec::iTerraSampler_SampleInteger;
*GetMaterialPalette = *cspacec::iTerraSampler_GetMaterialPalette;
*GetRegion = *cspacec::iTerraSampler_GetRegion;
*GetResolution = *cspacec::iTerraSampler_GetResolution;
*GetVersion = *cspacec::iTerraSampler_GetVersion;
*Cleanup = *cspacec::iTerraSampler_Cleanup;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_iTerraSampler($self);
        delete $OWNER{$self};
    }
}

*scfGetVersion = *cspacec::iTerraSampler_scfGetVersion;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csObject ##############

package cspace::csObject;
@ISA = qw( cspace cspace::iObject );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csObject(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csObject($self);
        delete $OWNER{$self};
    }
}

*SetName = *cspacec::csObject_SetName;
*GetName = *cspacec::csObject_GetName;
*GetID = *cspacec::csObject_GetID;
*SetObjectParent = *cspacec::csObject_SetObjectParent;
*GetObjectParent = *cspacec::csObject_GetObjectParent;
*ObjAdd = *cspacec::csObject_ObjAdd;
*ObjRemove = *cspacec::csObject_ObjRemove;
*ObjRemoveAll = *cspacec::csObject_ObjRemoveAll;
*ObjAddChildren = *cspacec::csObject_ObjAddChildren;
*GetChild = *cspacec::csObject_GetChild;
*GetIterator = *cspacec::csObject_GetIterator;
*swig_scfRefCount_get = *cspacec::csObject_scfRefCount_get;
*swig_scfRefCount_set = *cspacec::csObject_scfRefCount_set;
*swig_scfWeakRefOwners_get = *cspacec::csObject_scfWeakRefOwners_get;
*swig_scfWeakRefOwners_set = *cspacec::csObject_scfWeakRefOwners_set;
*scfRemoveRefOwners = *cspacec::csObject_scfRemoveRefOwners;
*swig_scfParent_get = *cspacec::csObject_scfParent_get;
*swig_scfParent_set = *cspacec::csObject_scfParent_set;
*IncRef = *cspacec::csObject_IncRef;
*DecRef = *cspacec::csObject_DecRef;
*GetRefCount = *cspacec::csObject_GetRefCount;
*AddRefOwner = *cspacec::csObject_AddRefOwner;
*RemoveRefOwner = *cspacec::csObject_RemoveRefOwner;
*QueryInterface = *cspacec::csObject_QueryInterface;
*ObjReleaseOld = *cspacec::csObject_ObjReleaseOld;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csView ##############

package cspace::csView;
@ISA = qw( cspace cspace::iView );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csView(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csView($self);
        delete $OWNER{$self};
    }
}

*GetEngine = *cspacec::csView_GetEngine;
*SetEngine = *cspacec::csView_SetEngine;
*GetCamera = *cspacec::csView_GetCamera;
*SetCamera = *cspacec::csView_SetCamera;
*GetContext = *cspacec::csView_GetContext;
*SetContext = *cspacec::csView_SetContext;
*SetRectangle = *cspacec::csView_SetRectangle;
*ClearView = *cspacec::csView_ClearView;
*AddViewVertex = *cspacec::csView_AddViewVertex;
*RestrictClipperToScreen = *cspacec::csView_RestrictClipperToScreen;
*SetAutoResize = *cspacec::csView_SetAutoResize;
*UpdateClipper = *cspacec::csView_UpdateClipper;
*GetClipper = *cspacec::csView_GetClipper;
*Draw = *cspacec::csView_Draw;
*swig_scfRefCount_get = *cspacec::csView_scfRefCount_get;
*swig_scfRefCount_set = *cspacec::csView_scfRefCount_set;
*swig_scfWeakRefOwners_get = *cspacec::csView_scfWeakRefOwners_get;
*swig_scfWeakRefOwners_set = *cspacec::csView_scfWeakRefOwners_set;
*scfRemoveRefOwners = *cspacec::csView_scfRemoveRefOwners;
*swig_scfParent_get = *cspacec::csView_scfParent_get;
*swig_scfParent_set = *cspacec::csView_scfParent_set;
*IncRef = *cspacec::csView_IncRef;
*DecRef = *cspacec::csView_DecRef;
*GetRefCount = *cspacec::csView_GetRefCount;
*AddRefOwner = *cspacec::csView_AddRefOwner;
*RemoveRefOwner = *cspacec::csView_RemoveRefOwner;
*QueryInterface = *cspacec::csView_QueryInterface;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csColliderWrapper ##############

package cspace::csColliderWrapper;
@ISA = qw( cspace cspace::csObject );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csColliderWrapper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csColliderWrapper($self);
        delete $OWNER{$self};
    }
}

*GetCollider = *cspacec::csColliderWrapper_GetCollider;
*GetCollideSystem = *cspacec::csColliderWrapper_GetCollideSystem;
*Collide = *cspacec::csColliderWrapper_Collide;
*GetColliderWrapper = *cspacec::csColliderWrapper_GetColliderWrapper;
*IncRef = *cspacec::csColliderWrapper_IncRef;
*DecRef = *cspacec::csColliderWrapper_DecRef;
*GetRefCount = *cspacec::csColliderWrapper_GetRefCount;
*AddRefOwner = *cspacec::csColliderWrapper_AddRefOwner;
*RemoveRefOwner = *cspacec::csColliderWrapper_RemoveRefOwner;
*QueryInterface = *cspacec::csColliderWrapper_QueryInterface;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csColliderHelper ##############

package cspace::csColliderHelper;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
*InitializeCollisionWrapper = *cspacec::csColliderHelper_InitializeCollisionWrapper;
*InitializeCollisionWrappers = *cspacec::csColliderHelper_InitializeCollisionWrappers;
*CollideArray = *cspacec::csColliderHelper_CollideArray;
*CollidePath = *cspacec::csColliderHelper_CollidePath;
*TraceBeam = *cspacec::csColliderHelper_TraceBeam;
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csColliderHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csColliderHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : cspace::csPixmap ##############

package cspace::csPixmap;
@ISA = qw( cspace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = cspacec::new_csPixmap(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        cspacec::delete_csPixmap($self);
        delete $OWNER{$self};
    }
}

*SetTextureHandle = *cspacec::csPixmap_SetTextureHandle;
*SetTextureRectangle = *cspacec::csPixmap_SetTextureRectangle;
*DrawScaled = *cspacec::csPixmap_DrawScaled;
*DrawTiled = *cspacec::csPixmap_DrawTiled;
*Width = *cspacec::csPixmap_Width;
*Height = *cspacec::csPixmap_Height;
*Advance = *cspacec::csPixmap_Advance;
*GetTextureHandle = *cspacec::csPixmap_GetTextureHandle;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- CONSTANT STUBS -------

package cspace;

sub CS_WCHAR_T_SIZE () { $cspacec::CS_WCHAR_T_SIZE }
sub CS_VOIDED_PTR () { $cspacec::CS_VOIDED_PTR }
sub SCF_STATIC_CLASS_CONTEXT () { $cspacec::SCF_STATIC_CLASS_CONTEXT }
sub SCF_VERBOSE_NONE () { $cspacec::SCF_VERBOSE_NONE }
sub SCF_VERBOSE_PLUGIN_SCAN () { $cspacec::SCF_VERBOSE_PLUGIN_SCAN }
sub SCF_VERBOSE_PLUGIN_LOAD () { $cspacec::SCF_VERBOSE_PLUGIN_LOAD }
sub SCF_VERBOSE_PLUGIN_REGISTER () { $cspacec::SCF_VERBOSE_PLUGIN_REGISTER }
sub SCF_VERBOSE_CLASS_REGISTER () { $cspacec::SCF_VERBOSE_CLASS_REGISTER }
sub SCF_VERBOSE_ALL () { $cspacec::SCF_VERBOSE_ALL }
sub CS_DBGHELP_UNITTEST () { $cspacec::CS_DBGHELP_UNITTEST }
sub CS_DBGHELP_BENCHMARK () { $cspacec::CS_DBGHELP_BENCHMARK }
sub CS_DBGHELP_TXTDUMP () { $cspacec::CS_DBGHELP_TXTDUMP }
sub CS_DBGHELP_GFXDUMP () { $cspacec::CS_DBGHELP_GFXDUMP }
sub CS_DBGHELP_STATETEST () { $cspacec::CS_DBGHELP_STATETEST }
sub CS_AXIS_NONE () { $cspacec::CS_AXIS_NONE }
sub CS_AXIS_X () { $cspacec::CS_AXIS_X }
sub CS_AXIS_Y () { $cspacec::CS_AXIS_Y }
sub CS_AXIS_Z () { $cspacec::CS_AXIS_Z }
sub CS_POLY_IN () { $cspacec::CS_POLY_IN }
sub CS_POLY_ON () { $cspacec::CS_POLY_ON }
sub CS_POLY_OUT () { $cspacec::CS_POLY_OUT }
sub CS_POL_SAME_PLANE () { $cspacec::CS_POL_SAME_PLANE }
sub CS_POL_FRONT () { $cspacec::CS_POL_FRONT }
sub CS_POL_BACK () { $cspacec::CS_POL_BACK }
sub CS_POL_SPLIT_NEEDED () { $cspacec::CS_POL_SPLIT_NEEDED }
sub CS_BOUNDINGBOX_MAXVALUE () { $cspacec::CS_BOUNDINGBOX_MAXVALUE }
sub CS_BOX_CORNER_xy () { $cspacec::CS_BOX_CORNER_xy }
sub CS_BOX_CORNER_xY () { $cspacec::CS_BOX_CORNER_xY }
sub CS_BOX_CORNER_Xy () { $cspacec::CS_BOX_CORNER_Xy }
sub CS_BOX_CORNER_XY () { $cspacec::CS_BOX_CORNER_XY }
sub CS_BOX_CENTER2 () { $cspacec::CS_BOX_CENTER2 }
sub CS_BOX_EDGE_xy_Xy () { $cspacec::CS_BOX_EDGE_xy_Xy }
sub CS_BOX_EDGE_Xy_xy () { $cspacec::CS_BOX_EDGE_Xy_xy }
sub CS_BOX_EDGE_Xy_XY () { $cspacec::CS_BOX_EDGE_Xy_XY }
sub CS_BOX_EDGE_XY_Xy () { $cspacec::CS_BOX_EDGE_XY_Xy }
sub CS_BOX_EDGE_XY_xY () { $cspacec::CS_BOX_EDGE_XY_xY }
sub CS_BOX_EDGE_xY_XY () { $cspacec::CS_BOX_EDGE_xY_XY }
sub CS_BOX_EDGE_xY_xy () { $cspacec::CS_BOX_EDGE_xY_xy }
sub CS_BOX_EDGE_xy_xY () { $cspacec::CS_BOX_EDGE_xy_xY }
sub CS_BOX_CORNER_xyz () { $cspacec::CS_BOX_CORNER_xyz }
sub CS_BOX_CORNER_xyZ () { $cspacec::CS_BOX_CORNER_xyZ }
sub CS_BOX_CORNER_xYz () { $cspacec::CS_BOX_CORNER_xYz }
sub CS_BOX_CORNER_xYZ () { $cspacec::CS_BOX_CORNER_xYZ }
sub CS_BOX_CORNER_Xyz () { $cspacec::CS_BOX_CORNER_Xyz }
sub CS_BOX_CORNER_XyZ () { $cspacec::CS_BOX_CORNER_XyZ }
sub CS_BOX_CORNER_XYz () { $cspacec::CS_BOX_CORNER_XYz }
sub CS_BOX_CORNER_XYZ () { $cspacec::CS_BOX_CORNER_XYZ }
sub CS_BOX_CENTER3 () { $cspacec::CS_BOX_CENTER3 }
sub CS_BOX_SIDE_x () { $cspacec::CS_BOX_SIDE_x }
sub CS_BOX_SIDE_X () { $cspacec::CS_BOX_SIDE_X }
sub CS_BOX_SIDE_y () { $cspacec::CS_BOX_SIDE_y }
sub CS_BOX_SIDE_Y () { $cspacec::CS_BOX_SIDE_Y }
sub CS_BOX_SIDE_z () { $cspacec::CS_BOX_SIDE_z }
sub CS_BOX_SIDE_Z () { $cspacec::CS_BOX_SIDE_Z }
sub CS_BOX_INSIDE () { $cspacec::CS_BOX_INSIDE }
sub CS_BOX_EDGE_Xyz_xyz () { $cspacec::CS_BOX_EDGE_Xyz_xyz }
sub CS_BOX_EDGE_xyz_Xyz () { $cspacec::CS_BOX_EDGE_xyz_Xyz }
sub CS_BOX_EDGE_xyz_xYz () { $cspacec::CS_BOX_EDGE_xyz_xYz }
sub CS_BOX_EDGE_xYz_xyz () { $cspacec::CS_BOX_EDGE_xYz_xyz }
sub CS_BOX_EDGE_xYz_XYz () { $cspacec::CS_BOX_EDGE_xYz_XYz }
sub CS_BOX_EDGE_XYz_xYz () { $cspacec::CS_BOX_EDGE_XYz_xYz }
sub CS_BOX_EDGE_XYz_Xyz () { $cspacec::CS_BOX_EDGE_XYz_Xyz }
sub CS_BOX_EDGE_Xyz_XYz () { $cspacec::CS_BOX_EDGE_Xyz_XYz }
sub CS_BOX_EDGE_Xyz_XyZ () { $cspacec::CS_BOX_EDGE_Xyz_XyZ }
sub CS_BOX_EDGE_XyZ_Xyz () { $cspacec::CS_BOX_EDGE_XyZ_Xyz }
sub CS_BOX_EDGE_XyZ_XYZ () { $cspacec::CS_BOX_EDGE_XyZ_XYZ }
sub CS_BOX_EDGE_XYZ_XyZ () { $cspacec::CS_BOX_EDGE_XYZ_XyZ }
sub CS_BOX_EDGE_XYZ_XYz () { $cspacec::CS_BOX_EDGE_XYZ_XYz }
sub CS_BOX_EDGE_XYz_XYZ () { $cspacec::CS_BOX_EDGE_XYz_XYZ }
sub CS_BOX_EDGE_XYZ_xYZ () { $cspacec::CS_BOX_EDGE_XYZ_xYZ }
sub CS_BOX_EDGE_xYZ_XYZ () { $cspacec::CS_BOX_EDGE_xYZ_XYZ }
sub CS_BOX_EDGE_xYZ_xYz () { $cspacec::CS_BOX_EDGE_xYZ_xYz }
sub CS_BOX_EDGE_xYz_xYZ () { $cspacec::CS_BOX_EDGE_xYz_xYZ }
sub CS_BOX_EDGE_xYZ_xyZ () { $cspacec::CS_BOX_EDGE_xYZ_xyZ }
sub CS_BOX_EDGE_xyZ_xYZ () { $cspacec::CS_BOX_EDGE_xyZ_xYZ }
sub CS_BOX_EDGE_xyZ_xyz () { $cspacec::CS_BOX_EDGE_xyZ_xyz }
sub CS_BOX_EDGE_xyz_xyZ () { $cspacec::CS_BOX_EDGE_xyz_xyZ }
sub CS_BOX_EDGE_xyZ_XyZ () { $cspacec::CS_BOX_EDGE_xyZ_XyZ }
sub CS_BOX_EDGE_XyZ_xyZ () { $cspacec::CS_BOX_EDGE_XyZ_xyZ }
sub R_COEF () { $cspacec::R_COEF }
sub G_COEF () { $cspacec::G_COEF }
sub B_COEF () { $cspacec::B_COEF }
sub R_COEF_SQ () { $cspacec::R_COEF_SQ }
sub G_COEF_SQ () { $cspacec::G_COEF_SQ }
sub B_COEF_SQ () { $cspacec::B_COEF_SQ }
sub MAX_OUTPUT_VERTICES () { $cspacec::MAX_OUTPUT_VERTICES }
sub CS_CLIP_OUTSIDE () { $cspacec::CS_CLIP_OUTSIDE }
sub CS_CLIP_INSIDE () { $cspacec::CS_CLIP_INSIDE }
sub CS_CLIP_CLIPPED () { $cspacec::CS_CLIP_CLIPPED }
sub CS_VERTEX_ORIGINAL () { $cspacec::CS_VERTEX_ORIGINAL }
sub CS_VERTEX_ONEDGE () { $cspacec::CS_VERTEX_ONEDGE }
sub CS_VERTEX_INSIDE () { $cspacec::CS_VERTEX_INSIDE }
sub CS_POLYMESH_CLOSED () { $cspacec::CS_POLYMESH_CLOSED }
sub CS_POLYMESH_NOTCLOSED () { $cspacec::CS_POLYMESH_NOTCLOSED }
sub CS_POLYMESH_CONVEX () { $cspacec::CS_POLYMESH_CONVEX }
sub CS_POLYMESH_NOTCONVEX () { $cspacec::CS_POLYMESH_NOTCONVEX }
sub CS_POLYMESH_DEFORMABLE () { $cspacec::CS_POLYMESH_DEFORMABLE }
sub CS_POLYMESH_TRIANGLEMESH () { $cspacec::CS_POLYMESH_TRIANGLEMESH }
sub CS_LIGHT_THINGSHADOWS () { $cspacec::CS_LIGHT_THINGSHADOWS }
sub CS_LIGHT_ACTIVEHALO () { $cspacec::CS_LIGHT_ACTIVEHALO }
sub CS_LIGHT_DYNAMICTYPE_STATIC () { $cspacec::CS_LIGHT_DYNAMICTYPE_STATIC }
sub CS_LIGHT_DYNAMICTYPE_PSEUDO () { $cspacec::CS_LIGHT_DYNAMICTYPE_PSEUDO }
sub CS_LIGHT_DYNAMICTYPE_DYNAMIC () { $cspacec::CS_LIGHT_DYNAMICTYPE_DYNAMIC }
sub CS_DEFAULT_LIGHT_LEVEL () { $cspacec::CS_DEFAULT_LIGHT_LEVEL }
sub CS_NORMAL_LIGHT_LEVEL () { $cspacec::CS_NORMAL_LIGHT_LEVEL }
sub CS_ATTN_NONE () { $cspacec::CS_ATTN_NONE }
sub CS_ATTN_LINEAR () { $cspacec::CS_ATTN_LINEAR }
sub CS_ATTN_INVERSE () { $cspacec::CS_ATTN_INVERSE }
sub CS_ATTN_REALISTIC () { $cspacec::CS_ATTN_REALISTIC }
sub CS_ATTN_CLQ () { $cspacec::CS_ATTN_CLQ }
sub CS_LIGHT_POINTLIGHT () { $cspacec::CS_LIGHT_POINTLIGHT }
sub CS_LIGHT_DIRECTIONAL () { $cspacec::CS_LIGHT_DIRECTIONAL }
sub CS_LIGHT_SPOTLIGHT () { $cspacec::CS_LIGHT_SPOTLIGHT }
sub CS_ENGINE_CACHE_READ () { $cspacec::CS_ENGINE_CACHE_READ }
sub CS_ENGINE_CACHE_WRITE () { $cspacec::CS_ENGINE_CACHE_WRITE }
sub CS_ENGINE_CACHE_NOUPDATE () { $cspacec::CS_ENGINE_CACHE_NOUPDATE }
sub CS_RENDPRI_NONE () { $cspacec::CS_RENDPRI_NONE }
sub CS_RENDPRI_BACK2FRONT () { $cspacec::CS_RENDPRI_BACK2FRONT }
sub CS_RENDPRI_FRONT2BACK () { $cspacec::CS_RENDPRI_FRONT2BACK }
sub CS_ENTITY_DETAIL () { $cspacec::CS_ENTITY_DETAIL }
sub CS_ENTITY_CAMERA () { $cspacec::CS_ENTITY_CAMERA }
sub CS_ENTITY_INVISIBLEMESH () { $cspacec::CS_ENTITY_INVISIBLEMESH }
sub CS_ENTITY_NOSHADOWS () { $cspacec::CS_ENTITY_NOSHADOWS }
sub CS_ENTITY_NOLIGHTING () { $cspacec::CS_ENTITY_NOLIGHTING }
sub CS_ENTITY_NOHITBEAM () { $cspacec::CS_ENTITY_NOHITBEAM }
sub CS_LIGHTINGUPDATE_SORTRELEVANCE () { $cspacec::CS_LIGHTINGUPDATE_SORTRELEVANCE }
sub CS_LIGHTINGUPDATE_ALWAYSUPDATE () { $cspacec::CS_LIGHTINGUPDATE_ALWAYSUPDATE }
sub CS_CULLER_HINT_GOODOCCLUDER () { $cspacec::CS_CULLER_HINT_GOODOCCLUDER }
sub CS_CULLER_HINT_BADOCCLUDER () { $cspacec::CS_CULLER_HINT_BADOCCLUDER }
sub CS_PORTAL_CLIPDEST () { $cspacec::CS_PORTAL_CLIPDEST }
sub CS_PORTAL_CLIPSTRADDLING () { $cspacec::CS_PORTAL_CLIPSTRADDLING }
sub CS_PORTAL_ZFILL () { $cspacec::CS_PORTAL_ZFILL }
sub CS_PORTAL_WARP () { $cspacec::CS_PORTAL_WARP }
sub CS_PORTAL_MIRROR () { $cspacec::CS_PORTAL_MIRROR }
sub CS_PORTAL_STATICDEST () { $cspacec::CS_PORTAL_STATICDEST }
sub CS_PORTAL_FLOAT () { $cspacec::CS_PORTAL_FLOAT }
sub CS_PORTAL_COLLDET () { $cspacec::CS_PORTAL_COLLDET }
sub CS_PORTAL_VISCULL () { $cspacec::CS_PORTAL_VISCULL }
sub CS_SPR_LIGHTING_HQ () { $cspacec::CS_SPR_LIGHTING_HQ }
sub CS_SPR_LIGHTING_LQ () { $cspacec::CS_SPR_LIGHTING_LQ }
sub CS_SPR_LIGHTING_FAST () { $cspacec::CS_SPR_LIGHTING_FAST }
sub CS_SPR_LIGHTING_RANDOM () { $cspacec::CS_SPR_LIGHTING_RANDOM }
sub CS_SPR_LIGHT_GLOBAL () { $cspacec::CS_SPR_LIGHT_GLOBAL }
sub CS_SPR_LIGHT_TEMPLATE () { $cspacec::CS_SPR_LIGHT_TEMPLATE }
sub CS_SPR_LIGHT_LOCAL () { $cspacec::CS_SPR_LIGHT_LOCAL }
sub CS_SPR_LOD_GLOBAL () { $cspacec::CS_SPR_LOD_GLOBAL }
sub CS_SPR_LOD_TEMPLATE () { $cspacec::CS_SPR_LOD_TEMPLATE }
sub CS_SPR_LOD_LOCAL () { $cspacec::CS_SPR_LOD_LOCAL }
sub CS_MESH_STATICPOS () { $cspacec::CS_MESH_STATICPOS }
sub CS_MESH_STATICSHAPE () { $cspacec::CS_MESH_STATICSHAPE }
sub CS_FACTORY_STATICSHAPE () { $cspacec::CS_FACTORY_STATICSHAPE }
sub CS_POLY_LIGHTING () { $cspacec::CS_POLY_LIGHTING }
sub CS_POLY_COLLDET () { $cspacec::CS_POLY_COLLDET }
sub CS_POLY_VISCULL () { $cspacec::CS_POLY_VISCULL }
sub CS_POLYINDEX_LAST () { $cspacec::CS_POLYINDEX_LAST }
sub CS_THING_NOCOMPRESS () { $cspacec::CS_THING_NOCOMPRESS }
sub CS_THING_MOVE_NEVER () { $cspacec::CS_THING_MOVE_NEVER }
sub CS_THING_MOVE_OCCASIONAL () { $cspacec::CS_THING_MOVE_OCCASIONAL }
sub SOUND_RESTART () { $cspacec::SOUND_RESTART }
sub SOUND_LOOP () { $cspacec::SOUND_LOOP }
sub SOUND3D_DISABLE () { $cspacec::SOUND3D_DISABLE }
sub SOUND3D_RELATIVE () { $cspacec::SOUND3D_RELATIVE }
sub SOUND3D_ABSOLUTE () { $cspacec::SOUND3D_ABSOLUTE }
sub SOUND_DISTANCE_INFINITE () { $cspacec::SOUND_DISTANCE_INFINITE }
sub VFS_PATH_DIVIDER () { $cspacec::VFS_PATH_DIVIDER }
sub VFS_PATH_SEPARATOR () { $cspacec::VFS_PATH_SEPARATOR }
sub VFS_MAX_PATH_LEN () { $cspacec::VFS_MAX_PATH_LEN }
sub VFS_FILE_MODE () { $cspacec::VFS_FILE_MODE }
sub VFS_FILE_READ () { $cspacec::VFS_FILE_READ }
sub VFS_FILE_WRITE () { $cspacec::VFS_FILE_WRITE }
sub VFS_FILE_APPEND () { $cspacec::VFS_FILE_APPEND }
sub VFS_FILE_UNCOMPRESSED () { $cspacec::VFS_FILE_UNCOMPRESSED }
sub VFS_STATUS_OK () { $cspacec::VFS_STATUS_OK }
sub VFS_STATUS_OTHER () { $cspacec::VFS_STATUS_OTHER }
sub VFS_STATUS_NOSPACE () { $cspacec::VFS_STATUS_NOSPACE }
sub VFS_STATUS_RESOURCES () { $cspacec::VFS_STATUS_RESOURCES }
sub VFS_STATUS_ACCESSDENIED () { $cspacec::VFS_STATUS_ACCESSDENIED }
sub VFS_STATUS_IOERROR () { $cspacec::VFS_STATUS_IOERROR }
sub csmbLeft () { $cspacec::csmbLeft }
sub csmbRight () { $cspacec::csmbRight }
sub csmbMiddle () { $cspacec::csmbMiddle }
sub csmbWheelUp () { $cspacec::csmbWheelUp }
sub csmbWheelDown () { $cspacec::csmbWheelDown }
sub csmbExtra1 () { $cspacec::csmbExtra1 }
sub csmbExtra2 () { $cspacec::csmbExtra2 }
sub csEventErrNone () { $cspacec::csEventErrNone }
sub csEventErrLossy () { $cspacec::csEventErrLossy }
sub csEventErrNotFound () { $cspacec::csEventErrNotFound }
sub csEventErrMismatchInt () { $cspacec::csEventErrMismatchInt }
sub csEventErrMismatchUInt () { $cspacec::csEventErrMismatchUInt }
sub csEventErrMismatchFloat () { $cspacec::csEventErrMismatchFloat }
sub csEventErrMismatchBuffer () { $cspacec::csEventErrMismatchBuffer }
sub csEventErrMismatchEvent () { $cspacec::csEventErrMismatchEvent }
sub csEventErrMismatchIBase () { $cspacec::csEventErrMismatchIBase }
sub csEventErrUhOhUnknown () { $cspacec::csEventErrUhOhUnknown }
sub csEventAttrUnknown () { $cspacec::csEventAttrUnknown }
sub csEventAttrInt () { $cspacec::csEventAttrInt }
sub csEventAttrUInt () { $cspacec::csEventAttrUInt }
sub csEventAttrFloat () { $cspacec::csEventAttrFloat }
sub csEventAttrDatabuffer () { $cspacec::csEventAttrDatabuffer }
sub csEventAttrEvent () { $cspacec::csEventAttrEvent }
sub csEventAttriBase () { $cspacec::csEventAttriBase }
sub csevNothing () { $cspacec::csevNothing }
sub csevKeyboard () { $cspacec::csevKeyboard }
sub csevMouseMove () { $cspacec::csevMouseMove }
sub csevMouseDown () { $cspacec::csevMouseDown }
sub csevMouseUp () { $cspacec::csevMouseUp }
sub csevMouseClick () { $cspacec::csevMouseClick }
sub csevMouseDoubleClick () { $cspacec::csevMouseDoubleClick }
sub csevJoystickMove () { $cspacec::csevJoystickMove }
sub csevJoystickDown () { $cspacec::csevJoystickDown }
sub csevJoystickUp () { $cspacec::csevJoystickUp }
sub csevCommand () { $cspacec::csevCommand }
sub csevBroadcast () { $cspacec::csevBroadcast }
sub csevMouseEnter () { $cspacec::csevMouseEnter }
sub csevMouseExit () { $cspacec::csevMouseExit }
sub csevLostFocus () { $cspacec::csevLostFocus }
sub csevGainFocus () { $cspacec::csevGainFocus }
sub csevGroupOff () { $cspacec::csevGroupOff }
sub csevFrameStart () { $cspacec::csevFrameStart }
sub csKeyEventTypeUp () { $cspacec::csKeyEventTypeUp }
sub csKeyEventTypeDown () { $cspacec::csKeyEventTypeDown }
sub CSEF_BROADCAST () { $cspacec::CSEF_BROADCAST }
sub csKeyModifierTypeShift () { $cspacec::csKeyModifierTypeShift }
sub csKeyModifierTypeCtrl () { $cspacec::csKeyModifierTypeCtrl }
sub csKeyModifierTypeAlt () { $cspacec::csKeyModifierTypeAlt }
sub csKeyModifierTypeCapsLock () { $cspacec::csKeyModifierTypeCapsLock }
sub csKeyModifierTypeNumLock () { $cspacec::csKeyModifierTypeNumLock }
sub csKeyModifierTypeScrollLock () { $cspacec::csKeyModifierTypeScrollLock }
sub csKeyModifierTypeLast () { $cspacec::csKeyModifierTypeLast }
sub csKeyModifierNumLeft () { $cspacec::csKeyModifierNumLeft }
sub csKeyModifierNumRight () { $cspacec::csKeyModifierNumRight }
sub csKeyModifierNumAny () { $cspacec::csKeyModifierNumAny }
sub CSKEY_ESC () { $cspacec::CSKEY_ESC }
sub CSKEY_ENTER () { $cspacec::CSKEY_ENTER }
sub CSKEY_TAB () { $cspacec::CSKEY_TAB }
sub CSKEY_BACKSPACE () { $cspacec::CSKEY_BACKSPACE }
sub CSKEY_SPACE () { $cspacec::CSKEY_SPACE }
sub CSKEY_SPECIAL_FIRST () { $cspacec::CSKEY_SPECIAL_FIRST }
sub CSKEY_SPECIAL_LAST () { $cspacec::CSKEY_SPECIAL_LAST }
sub CSKEY_UP () { $cspacec::CSKEY_UP }
sub CSKEY_DOWN () { $cspacec::CSKEY_DOWN }
sub CSKEY_LEFT () { $cspacec::CSKEY_LEFT }
sub CSKEY_RIGHT () { $cspacec::CSKEY_RIGHT }
sub CSKEY_PGUP () { $cspacec::CSKEY_PGUP }
sub CSKEY_PGDN () { $cspacec::CSKEY_PGDN }
sub CSKEY_HOME () { $cspacec::CSKEY_HOME }
sub CSKEY_END () { $cspacec::CSKEY_END }
sub CSKEY_INS () { $cspacec::CSKEY_INS }
sub CSKEY_DEL () { $cspacec::CSKEY_DEL }
sub CSKEY_CONTEXT () { $cspacec::CSKEY_CONTEXT }
sub CSKEY_PRINTSCREEN () { $cspacec::CSKEY_PRINTSCREEN }
sub CSKEY_PAUSE () { $cspacec::CSKEY_PAUSE }
sub CSKEY_F1 () { $cspacec::CSKEY_F1 }
sub CSKEY_F2 () { $cspacec::CSKEY_F2 }
sub CSKEY_F3 () { $cspacec::CSKEY_F3 }
sub CSKEY_F4 () { $cspacec::CSKEY_F4 }
sub CSKEY_F5 () { $cspacec::CSKEY_F5 }
sub CSKEY_F6 () { $cspacec::CSKEY_F6 }
sub CSKEY_F7 () { $cspacec::CSKEY_F7 }
sub CSKEY_F8 () { $cspacec::CSKEY_F8 }
sub CSKEY_F9 () { $cspacec::CSKEY_F9 }
sub CSKEY_F10 () { $cspacec::CSKEY_F10 }
sub CSKEY_F11 () { $cspacec::CSKEY_F11 }
sub CSKEY_F12 () { $cspacec::CSKEY_F12 }
sub CSKEY_MODIFIER_FIRST () { $cspacec::CSKEY_MODIFIER_FIRST }
sub CSKEY_MODIFIER_LAST () { $cspacec::CSKEY_MODIFIER_LAST }
sub CSKEY_MODIFIERTYPE_SHIFT () { $cspacec::CSKEY_MODIFIERTYPE_SHIFT }
sub CSKEY_PAD_FLAG () { $cspacec::CSKEY_PAD_FLAG }
sub csKeyCharTypeNormal () { $cspacec::csKeyCharTypeNormal }
sub csKeyCharTypeDead () { $cspacec::csKeyCharTypeDead }
sub CSEVTYPE_Keyboard () { $cspacec::CSEVTYPE_Keyboard }
sub CSEVTYPE_Mouse () { $cspacec::CSEVTYPE_Mouse }
sub CSEVTYPE_Joystick () { $cspacec::CSEVTYPE_Joystick }
sub cscmdNothing () { $cspacec::cscmdNothing }
sub cscmdQuit () { $cspacec::cscmdQuit }
sub cscmdFocusChanged () { $cspacec::cscmdFocusChanged }
sub cscmdSystemOpen () { $cspacec::cscmdSystemOpen }
sub cscmdSystemClose () { $cspacec::cscmdSystemClose }
sub cscmdContextResize () { $cspacec::cscmdContextResize }
sub cscmdContextClose () { $cspacec::cscmdContextClose }
sub cscmdCommandLineHelp () { $cspacec::cscmdCommandLineHelp }
sub cscmdPreProcess () { $cspacec::cscmdPreProcess }
sub cscmdProcess () { $cspacec::cscmdProcess }
sub cscmdPostProcess () { $cspacec::cscmdPostProcess }
sub cscmdFinalProcess () { $cspacec::cscmdFinalProcess }
sub cscmdCanvasHidden () { $cspacec::cscmdCanvasHidden }
sub cscmdCanvasExposed () { $cspacec::cscmdCanvasExposed }
sub CS_MAX_MOUSE_BUTTONS () { $cspacec::CS_MAX_MOUSE_BUTTONS }
sub CS_MAX_JOYSTICK_COUNT () { $cspacec::CS_MAX_JOYSTICK_COUNT }
sub CS_MAX_JOYSTICK_BUTTONS () { $cspacec::CS_MAX_JOYSTICK_BUTTONS }
sub csComposeNoChar () { $cspacec::csComposeNoChar }
sub csComposeNormalChar () { $cspacec::csComposeNormalChar }
sub csComposeComposedChar () { $cspacec::csComposeComposedChar }
sub csComposeUncomposeable () { $cspacec::csComposeUncomposeable }
sub CS_NODE_DOCUMENT () { $cspacec::CS_NODE_DOCUMENT }
sub CS_NODE_ELEMENT () { $cspacec::CS_NODE_ELEMENT }
sub CS_NODE_COMMENT () { $cspacec::CS_NODE_COMMENT }
sub CS_NODE_UNKNOWN () { $cspacec::CS_NODE_UNKNOWN }
sub CS_NODE_TEXT () { $cspacec::CS_NODE_TEXT }
sub CS_NODE_DECLARATION () { $cspacec::CS_NODE_DECLARATION }
sub CS_CHANGEABLE_NEVER () { $cspacec::CS_CHANGEABLE_NEVER }
sub CS_CHANGEABLE_NEWROOT () { $cspacec::CS_CHANGEABLE_NEWROOT }
sub CS_CHANGEABLE_YES () { $cspacec::CS_CHANGEABLE_YES }
sub CS_WRITE_BASELINE () { $cspacec::CS_WRITE_BASELINE }
sub CS_WRITE_NOANTIALIAS () { $cspacec::CS_WRITE_NOANTIALIAS }
sub CSDRAW_2DGRAPHICS () { $cspacec::CSDRAW_2DGRAPHICS }
sub CSDRAW_3DGRAPHICS () { $cspacec::CSDRAW_3DGRAPHICS }
sub CSDRAW_CLEARZBUFFER () { $cspacec::CSDRAW_CLEARZBUFFER }
sub CSDRAW_CLEARSCREEN () { $cspacec::CSDRAW_CLEARSCREEN }
sub CS_CLIPPER_NONE () { $cspacec::CS_CLIPPER_NONE }
sub CS_CLIPPER_OPTIONAL () { $cspacec::CS_CLIPPER_OPTIONAL }
sub CS_CLIPPER_TOPLEVEL () { $cspacec::CS_CLIPPER_TOPLEVEL }
sub CS_CLIPPER_REQUIRED () { $cspacec::CS_CLIPPER_REQUIRED }
sub CS_CLIP_NOT () { $cspacec::CS_CLIP_NOT }
sub CS_CLIP_NEEDED () { $cspacec::CS_CLIP_NEEDED }
sub CS_ZBUF_NONE () { $cspacec::CS_ZBUF_NONE }
sub CS_ZBUF_FILL () { $cspacec::CS_ZBUF_FILL }
sub CS_ZBUF_TEST () { $cspacec::CS_ZBUF_TEST }
sub CS_ZBUF_USE () { $cspacec::CS_ZBUF_USE }
sub CS_ZBUF_FILLONLY () { $cspacec::CS_ZBUF_FILLONLY }
sub CS_ZBUF_EQUAL () { $cspacec::CS_ZBUF_EQUAL }
sub CS_ZBUF_INVERT () { $cspacec::CS_ZBUF_INVERT }
sub CS_ZBUF_MESH () { $cspacec::CS_ZBUF_MESH }
sub CS_ZBUF_MESH2 () { $cspacec::CS_ZBUF_MESH2 }
sub CS_VATTRIB_SPECIFIC_FIRST () { $cspacec::CS_VATTRIB_SPECIFIC_FIRST }
sub CS_VATTRIB_SPECIFIC_LAST () { $cspacec::CS_VATTRIB_SPECIFIC_LAST }
sub CS_VATTRIB_GENERIC_FIRST () { $cspacec::CS_VATTRIB_GENERIC_FIRST }
sub CS_VATTRIB_GENERIC_LAST () { $cspacec::CS_VATTRIB_GENERIC_LAST }
sub CS_VATTRIB_POSITION () { $cspacec::CS_VATTRIB_POSITION }
sub CS_VATTRIB_WEIGHT () { $cspacec::CS_VATTRIB_WEIGHT }
sub CS_VATTRIB_NORMAL () { $cspacec::CS_VATTRIB_NORMAL }
sub CS_VATTRIB_COLOR () { $cspacec::CS_VATTRIB_COLOR }
sub CS_VATTRIB_PRIMARY_COLOR () { $cspacec::CS_VATTRIB_PRIMARY_COLOR }
sub CS_VATTRIB_SECONDARY_COLOR () { $cspacec::CS_VATTRIB_SECONDARY_COLOR }
sub CS_VATTRIB_FOGCOORD () { $cspacec::CS_VATTRIB_FOGCOORD }
sub CS_VATTRIB_TEXCOORD () { $cspacec::CS_VATTRIB_TEXCOORD }
sub CS_VATTRIB_TEXCOORD0 () { $cspacec::CS_VATTRIB_TEXCOORD0 }
sub CS_VATTRIB_TEXCOORD1 () { $cspacec::CS_VATTRIB_TEXCOORD1 }
sub CS_VATTRIB_TEXCOORD2 () { $cspacec::CS_VATTRIB_TEXCOORD2 }
sub CS_VATTRIB_TEXCOORD3 () { $cspacec::CS_VATTRIB_TEXCOORD3 }
sub CS_VATTRIB_TEXCOORD4 () { $cspacec::CS_VATTRIB_TEXCOORD4 }
sub CS_VATTRIB_TEXCOORD5 () { $cspacec::CS_VATTRIB_TEXCOORD5 }
sub CS_VATTRIB_TEXCOORD6 () { $cspacec::CS_VATTRIB_TEXCOORD6 }
sub CS_VATTRIB_TEXCOORD7 () { $cspacec::CS_VATTRIB_TEXCOORD7 }
sub CS_VATTRIB_0 () { $cspacec::CS_VATTRIB_0 }
sub CS_VATTRIB_1 () { $cspacec::CS_VATTRIB_1 }
sub CS_VATTRIB_2 () { $cspacec::CS_VATTRIB_2 }
sub CS_VATTRIB_3 () { $cspacec::CS_VATTRIB_3 }
sub CS_VATTRIB_4 () { $cspacec::CS_VATTRIB_4 }
sub CS_VATTRIB_5 () { $cspacec::CS_VATTRIB_5 }
sub CS_VATTRIB_6 () { $cspacec::CS_VATTRIB_6 }
sub CS_VATTRIB_7 () { $cspacec::CS_VATTRIB_7 }
sub CS_VATTRIB_8 () { $cspacec::CS_VATTRIB_8 }
sub CS_VATTRIB_9 () { $cspacec::CS_VATTRIB_9 }
sub CS_VATTRIB_10 () { $cspacec::CS_VATTRIB_10 }
sub CS_VATTRIB_11 () { $cspacec::CS_VATTRIB_11 }
sub CS_VATTRIB_12 () { $cspacec::CS_VATTRIB_12 }
sub CS_VATTRIB_13 () { $cspacec::CS_VATTRIB_13 }
sub CS_VATTRIB_14 () { $cspacec::CS_VATTRIB_14 }
sub CS_VATTRIB_15 () { $cspacec::CS_VATTRIB_15 }
sub G3DFOGMETHOD_NONE () { $cspacec::G3DFOGMETHOD_NONE }
sub G3DFOGMETHOD_ZBUFFER () { $cspacec::G3DFOGMETHOD_ZBUFFER }
sub G3DFOGMETHOD_VERTEX () { $cspacec::G3DFOGMETHOD_VERTEX }
sub CS_FX_MASK_MIXMODE () { $cspacec::CS_FX_MASK_MIXMODE }
sub CS_FX_COPY () { $cspacec::CS_FX_COPY }
sub CS_FX_MULTIPLY () { $cspacec::CS_FX_MULTIPLY }
sub CS_FX_MULTIPLY2 () { $cspacec::CS_FX_MULTIPLY2 }
sub CS_FX_ADD () { $cspacec::CS_FX_ADD }
sub CS_FX_ALPHA () { $cspacec::CS_FX_ALPHA }
sub CS_FX_TRANSPARENT () { $cspacec::CS_FX_TRANSPARENT }
sub CS_FX_DESTALPHAADD () { $cspacec::CS_FX_DESTALPHAADD }
sub CS_FX_SRCALPHAADD () { $cspacec::CS_FX_SRCALPHAADD }
sub CS_FX_PREMULTALPHA () { $cspacec::CS_FX_PREMULTALPHA }
sub CS_FX_MESH () { $cspacec::CS_FX_MESH }
sub CS_FX_KEYCOLOR () { $cspacec::CS_FX_KEYCOLOR }
sub CS_FX_FLAT () { $cspacec::CS_FX_FLAT }
sub CS_FX_TILING () { $cspacec::CS_FX_TILING }
sub CS_FX_MASK_ALPHA () { $cspacec::CS_FX_MASK_ALPHA }
sub CS_LIGHTPARAM_POSITION () { $cspacec::CS_LIGHTPARAM_POSITION }
sub CS_LIGHTPARAM_DIFFUSE () { $cspacec::CS_LIGHTPARAM_DIFFUSE }
sub CS_LIGHTPARAM_SPECULAR () { $cspacec::CS_LIGHTPARAM_SPECULAR }
sub CS_LIGHTPARAM_ATTENUATION () { $cspacec::CS_LIGHTPARAM_ATTENUATION }
sub CS_SHADOW_VOLUME_BEGIN () { $cspacec::CS_SHADOW_VOLUME_BEGIN }
sub CS_SHADOW_VOLUME_PASS1 () { $cspacec::CS_SHADOW_VOLUME_PASS1 }
sub CS_SHADOW_VOLUME_PASS2 () { $cspacec::CS_SHADOW_VOLUME_PASS2 }
sub CS_SHADOW_VOLUME_FAIL1 () { $cspacec::CS_SHADOW_VOLUME_FAIL1 }
sub CS_SHADOW_VOLUME_FAIL2 () { $cspacec::CS_SHADOW_VOLUME_FAIL2 }
sub CS_SHADOW_VOLUME_USE () { $cspacec::CS_SHADOW_VOLUME_USE }
sub CS_SHADOW_VOLUME_FINISH () { $cspacec::CS_SHADOW_VOLUME_FINISH }
sub G3DRENDERSTATE_ZBUFFERMODE () { $cspacec::G3DRENDERSTATE_ZBUFFERMODE }
sub G3DRENDERSTATE_DITHERENABLE () { $cspacec::G3DRENDERSTATE_DITHERENABLE }
sub G3DRENDERSTATE_BILINEARMAPPINGENABLE () { $cspacec::G3DRENDERSTATE_BILINEARMAPPINGENABLE }
sub G3DRENDERSTATE_TRILINEARMAPPINGENABLE () { $cspacec::G3DRENDERSTATE_TRILINEARMAPPINGENABLE }
sub G3DRENDERSTATE_TRANSPARENCYENABLE () { $cspacec::G3DRENDERSTATE_TRANSPARENCYENABLE }
sub G3DRENDERSTATE_MIPMAPENABLE () { $cspacec::G3DRENDERSTATE_MIPMAPENABLE }
sub G3DRENDERSTATE_TEXTUREMAPPINGENABLE () { $cspacec::G3DRENDERSTATE_TEXTUREMAPPINGENABLE }
sub G3DRENDERSTATE_LIGHTINGENABLE () { $cspacec::G3DRENDERSTATE_LIGHTINGENABLE }
sub G3DRENDERSTATE_INTERLACINGENABLE () { $cspacec::G3DRENDERSTATE_INTERLACINGENABLE }
sub G3DRENDERSTATE_MMXENABLE () { $cspacec::G3DRENDERSTATE_MMXENABLE }
sub G3DRENDERSTATE_INTERPOLATIONSTEP () { $cspacec::G3DRENDERSTATE_INTERPOLATIONSTEP }
sub G3DRENDERSTATE_MAXPOLYGONSTODRAW () { $cspacec::G3DRENDERSTATE_MAXPOLYGONSTODRAW }
sub G3DRENDERSTATE_GOURAUDENABLE () { $cspacec::G3DRENDERSTATE_GOURAUDENABLE }
sub G3DRENDERSTATE_EDGES () { $cspacec::G3DRENDERSTATE_EDGES }
sub CS_MESHTYPE_TRIANGLES () { $cspacec::CS_MESHTYPE_TRIANGLES }
sub CS_MESHTYPE_QUADS () { $cspacec::CS_MESHTYPE_QUADS }
sub CS_MESHTYPE_TRIANGLESTRIP () { $cspacec::CS_MESHTYPE_TRIANGLESTRIP }
sub CS_MESHTYPE_TRIANGLEFAN () { $cspacec::CS_MESHTYPE_TRIANGLEFAN }
sub CS_MESHTYPE_POINTS () { $cspacec::CS_MESHTYPE_POINTS }
sub CS_MESHTYPE_POINT_SPRITES () { $cspacec::CS_MESHTYPE_POINT_SPRITES }
sub CS_MESHTYPE_LINES () { $cspacec::CS_MESHTYPE_LINES }
sub CS_MESHTYPE_LINESTRIP () { $cspacec::CS_MESHTYPE_LINESTRIP }
sub CS_MESHTYPE_POLYGON () { $cspacec::CS_MESHTYPE_POLYGON }
sub csSimpleMeshScreenspace () { $cspacec::csSimpleMeshScreenspace }
sub csmcNone () { $cspacec::csmcNone }
sub csmcArrow () { $cspacec::csmcArrow }
sub csmcLens () { $cspacec::csmcLens }
sub csmcCross () { $cspacec::csmcCross }
sub csmcPen () { $cspacec::csmcPen }
sub csmcMove () { $cspacec::csmcMove }
sub csmcSizeNWSE () { $cspacec::csmcSizeNWSE }
sub csmcSizeNESW () { $cspacec::csmcSizeNESW }
sub csmcSizeNS () { $cspacec::csmcSizeNS }
sub csmcSizeEW () { $cspacec::csmcSizeEW }
sub csmcStop () { $cspacec::csmcStop }
sub csmcWait () { $cspacec::csmcWait }
sub CS_ALERT_ERROR () { $cspacec::CS_ALERT_ERROR }
sub CS_ALERT_WARNING () { $cspacec::CS_ALERT_WARNING }
sub CS_ALERT_NOTE () { $cspacec::CS_ALERT_NOTE }
sub CSFONT_LARGE () { $cspacec::CSFONT_LARGE }
sub CSFONT_ITALIC () { $cspacec::CSFONT_ITALIC }
sub CSFONT_COURIER () { $cspacec::CSFONT_COURIER }
sub CSFONT_SMALL () { $cspacec::CSFONT_SMALL }
sub CS_FONT_DEFAULT_GLYPH () { $cspacec::CS_FONT_DEFAULT_GLYPH }
sub TagNeutral () { $cspacec::TagNeutral }
sub TagForbidden () { $cspacec::TagForbidden }
sub TagRequired () { $cspacec::TagRequired }
sub CS_TEXTURE_2D () { $cspacec::CS_TEXTURE_2D }
sub CS_TEXTURE_3D () { $cspacec::CS_TEXTURE_3D }
sub CS_TEXTURE_DITHER () { $cspacec::CS_TEXTURE_DITHER }
sub CS_TEXTURE_NOMIPMAPS () { $cspacec::CS_TEXTURE_NOMIPMAPS }
sub CS_TEXTURE_CLAMP () { $cspacec::CS_TEXTURE_CLAMP }
sub CS_TEXTURE_NOFILTER () { $cspacec::CS_TEXTURE_NOFILTER }
sub CS_DEFMAT_DIFFUSE () { $cspacec::CS_DEFMAT_DIFFUSE }
sub CS_DEFMAT_AMBIENT () { $cspacec::CS_DEFMAT_AMBIENT }
sub CS_DEFMAT_REFLECTION () { $cspacec::CS_DEFMAT_REFLECTION }
sub CS_MATERIAL_VARNAME_DIFFUSE () { $cspacec::CS_MATERIAL_VARNAME_DIFFUSE }
sub CS_MATERIAL_VARNAME_AMBIENT () { $cspacec::CS_MATERIAL_VARNAME_AMBIENT }
sub CS_MATERIAL_VARNAME_REFLECTION () { $cspacec::CS_MATERIAL_VARNAME_REFLECTION }
sub CS_MATERIAL_VARNAME_FLATCOLOR () { $cspacec::CS_MATERIAL_VARNAME_FLATCOLOR }
sub CS_MATERIAL_TEXTURE_DIFFUSE () { $cspacec::CS_MATERIAL_TEXTURE_DIFFUSE }
sub CS_POS_BY_FRAME () { $cspacec::CS_POS_BY_FRAME }
sub CS_POS_BY_TIME () { $cspacec::CS_POS_BY_TIME }
sub CS_DECODE_SPAN () { $cspacec::CS_DECODE_SPAN }
sub CS_DYNAMIC_FRAMESIZE () { $cspacec::CS_DYNAMIC_FRAMESIZE }
sub CS_STREAMTYPE_AUDIO () { $cspacec::CS_STREAMTYPE_AUDIO }
sub CS_STREAMTYPE_VIDEO () { $cspacec::CS_STREAMTYPE_VIDEO }
sub CS_STREAMTYPE_MIDI () { $cspacec::CS_STREAMTYPE_MIDI }
sub CS_STREAMTYPE_TEXT () { $cspacec::CS_STREAMTYPE_TEXT }
sub CS_CODECFORMAT_RGB_CHANNEL () { $cspacec::CS_CODECFORMAT_RGB_CHANNEL }
sub CS_CODECFORMAT_RGBA_CHANNEL () { $cspacec::CS_CODECFORMAT_RGBA_CHANNEL }
sub CS_CODECFORMAT_YUV_CHANNEL () { $cspacec::CS_CODECFORMAT_YUV_CHANNEL }
sub CS_CODECFORMAT_RGB_INTERLEAVED () { $cspacec::CS_CODECFORMAT_RGB_INTERLEAVED }
sub CS_CODECFORMAT_RGBA_INTERLEAVED () { $cspacec::CS_CODECFORMAT_RGBA_INTERLEAVED }
sub CS_CODECFORMAT_YUV_INTERLEAVED () { $cspacec::CS_CODECFORMAT_YUV_INTERLEAVED }
sub CS_IMGFMT_MASK () { $cspacec::CS_IMGFMT_MASK }
sub CS_IMGFMT_NONE () { $cspacec::CS_IMGFMT_NONE }
sub CS_IMGFMT_TRUECOLOR () { $cspacec::CS_IMGFMT_TRUECOLOR }
sub CS_IMGFMT_PALETTED8 () { $cspacec::CS_IMGFMT_PALETTED8 }
sub CS_IMGFMT_ANY () { $cspacec::CS_IMGFMT_ANY }
sub CS_IMGFMT_ALPHA () { $cspacec::CS_IMGFMT_ALPHA }
sub CS_IMGFMT_INVALID () { $cspacec::CS_IMGFMT_INVALID }
sub csimg2D () { $cspacec::csimg2D }
sub csimg3D () { $cspacec::csimg3D }
sub csimgCube () { $cspacec::csimgCube }
sub CS_IMAGEIO_LOAD () { $cspacec::CS_IMAGEIO_LOAD }
sub CS_IMAGEIO_SAVE () { $cspacec::CS_IMAGEIO_SAVE }
sub CS_REPORTER_SEVERITY_BUG () { $cspacec::CS_REPORTER_SEVERITY_BUG }
sub CS_REPORTER_SEVERITY_ERROR () { $cspacec::CS_REPORTER_SEVERITY_ERROR }
sub CS_REPORTER_SEVERITY_WARNING () { $cspacec::CS_REPORTER_SEVERITY_WARNING }
sub CS_REPORTER_SEVERITY_NOTIFY () { $cspacec::CS_REPORTER_SEVERITY_NOTIFY }
sub CS_REPORTER_SEVERITY_DEBUG () { $cspacec::CS_REPORTER_SEVERITY_DEBUG }
sub csConPageUp () { $cspacec::csConPageUp }
sub csConPageDown () { $cspacec::csConPageDown }
sub csConVeryTop () { $cspacec::csConVeryTop }
sub csConVeryBottom () { $cspacec::csConVeryBottom }
sub csConNoCursor () { $cspacec::csConNoCursor }
sub csConNormalCursor () { $cspacec::csConNormalCursor }
sub csConInsertCursor () { $cspacec::csConInsertCursor }
sub CS_SEQUENCE_LIGHTCHANGE_NONE () { $cspacec::CS_SEQUENCE_LIGHTCHANGE_NONE }
sub CS_SEQUENCE_LIGHTCHANGE_LESS () { $cspacec::CS_SEQUENCE_LIGHTCHANGE_LESS }
sub CS_SEQUENCE_LIGHTCHANGE_GREATER () { $cspacec::CS_SEQUENCE_LIGHTCHANGE_GREATER }
sub PIXMAP_TOP () { $cspacec::PIXMAP_TOP }
sub PIXMAP_LEFT () { $cspacec::PIXMAP_LEFT }
sub PIXMAP_CENTER () { $cspacec::PIXMAP_CENTER }
sub PIXMAP_BOTTOM () { $cspacec::PIXMAP_BOTTOM }
sub PIXMAP_RIGHT () { $cspacec::PIXMAP_RIGHT }

# ------- VARIABLE STUBS --------

package cspace;

*csArrayItemNotFound = *cspacec::csArrayItemNotFound;

my %__iSCF_SCF_hash;
tie %__iSCF_SCF_hash,"cspace::iSCF", $cspacec::iSCF_SCF;
$iSCF_SCF= \%__iSCF_SCF_hash;
bless $iSCF_SCF, cspace::iSCF;
*FRAGMENT_BUFFER_SIZE = *cspacec::FRAGMENT_BUFFER_SIZE;
*aws_debug = *cspacec::aws_debug;
*AWSF_AlwaysEraseWindows = *cspacec::AWSF_AlwaysEraseWindows;
*AWSF_AlwaysRedrawWindows = *cspacec::AWSF_AlwaysRedrawWindows;
*AWSF_RaiseOnMouseOver = *cspacec::AWSF_RaiseOnMouseOver;
*AWSF_KeyboardControl = *cspacec::AWSF_KeyboardControl;
*csInvalidStringID = *cspacec::csInvalidStringID;
1;
