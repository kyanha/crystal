@c -*-texinfo-*-
@node XML File Format, Old Map File Format, csParser, csParser
@subsection Format of Map File (@sc{xml})
@cindex Format of Map File
@cindex Map File Format
@cindex @sc{xml}

This section describes the the Crystal Space map, which uses @sc{xml}, and is a
companion to the @sc{xml} schema file residing at:

@noindent
@file{CS/scripts/xml/cs_world.xsd}

This document is not yet complete but it should give you sufficient information
to get started.  For the format of the mesh object loaders you should look at
the appropriate mesh object documentation (@pxref{MeshObject}).  There is also
a @sc{howto} on loading a map file (@pxref{HOWTO Level Loading}) and a
@sc{howto} with a simple map example (@pxref{HOWTO Simple Map Example}).

The Crystal Space engine, itself, does not care about the external format of
world data, nor does it care about how that information was obtained.  It is
possible to create additional map loaders as plug-in modules which understand
world data stored in other formats, such as binary.  A map loading plug-in
module could even load maps over the network from a map file server, or
generate worlds randomly based upon some set of input properties.  There are
many possibilities.

The map file syntax described in this section, however, is that which is
understood by the standard map file loader which accompanies Crystal Space.
It deals strictly with plain-text @sc{xml}-format files.

@menu
* XML Init Section:: Initalization Section
* XML World Element Section:: World Element Section
* XML World Definition Section:: World Definition Section
* XML Action Section:: Action Section
@end menu

@subsubheading Basic Structure

The basic structure of a map file for Crystal Space is as follows:

@example
<world>
  initialization part:
    one texture specification section.
    one material specification section.
    one shader section.
    one sounds section.
    one variable section.
    one render priority section.
    one plugin section.
    one settings section.
    zero or more start locations.
    zero or more library specifications.
    zero or more keys.
  world elements:
    zero or more add-ons.
    zero or more mesh factories.
  world definition:
    zero or more sectors.
    zero or more collections.
  action section:
    one sequence section.
    one trigger section.
</world>
@end example

The structure above divides the world into roughly four sections.  This is only
a logical division for explanatory purposes; in reality there are no such
divisions.

The initialization part contains everything that is related to
setting up the map except for geometry-related data. The textures,
materials, and other required parts are defined there.

The world elements section defines objects (mesh factories) and optional
additional features (add-on's) which will be used throughout the
actual world definition. Thus, geometry-templates are defined here, though
instantiated later.

In the world definition section the actual geometry is defined. At the
highest level you have sectors. In every sector the actual objects reside
(see later for more information about this).

Finally there is the action section. In this section sequences and
triggers are used to define interactions and other special actions on
objects and other objects in the world.

@node XML Init Section, XML World Element Section, XML File Format, XML File Format
@subsubsection Initalization Section

This section describes the initialization section.

@subsubheading Texture Specification Section
@cindex textures Specification (Map File)

Here is an example texture specification section:

@example
<textures>
  <texture name="wood">
    <file>/mygamedata/wood.png</file>
  </texture>
  <texture name="transp">
    <file>/mygamedata/stripes.png</file>
    <transparent red="1" green="0" blue="0"/>
  </texture>
  <proctex name="plasma">
    <type>plasma</type>
  </proctex>
</textures>
@end example

In this example we define three textures. The first one is called
@samp{wood} and will be loaded from the @sc{vfs} file
@file{/mygamedata/wood.png}. @xref{VFS}.

The second texture, @samp{transp}, is loaded from
@file{/mygamedata/stripes.png}. The red color will be made fully
transparent. If you want to use an alpha channel then this is supported
too. In that case simply load a @sc{png} image that has an alpha channel (or
any other type of image that supports an alpha channel).

The third texture is a procedural texture. There are four types of
procedural textures predefined in Crystal Space: @samp{fire}, @samp{water},
@samp{dots}, and @samp{plasma}.

@subsubheading Material Specification Section
@cindex materials (Map File)

Materials are very important in Crystal Space. Almost all objects will
use materials to define the surface characteristics of their geometry.
A material itself is usually made from one or more textures.

Here is an example material section. It uses the textures defined
in the previous section:

@example
<materials>
  <material name="table_material">
    <texture>wood</texture>
  </material>
  <material name="fence_material">
    <texture>transp</texture>
  </material>
  <material name="plasma_wood">
    <texture>wood</texture>
    <shader type="standard">std_lighting_detail_alpha</shader>
    <shadervar name="tex detail" type="texture">plasma</shadervar>
    <shadervar name="detail texture scale"
               type="vector2">10,10</shadervar>
    <shadervar name="detail texture color"
               type="vector4">1,1,1,0.25</shadervar>
  </material>
</materials>
@end example

When defining materials you usually use a name that indicates the use of that
material.  That way you can easily replace how the material looks like (by
swapping textures) without having to change the material name itself.

In the example above we first define a @samp{table_material} which uses only
the @samp{wood} texture.  The second material is @samp{fence_material} which
uses the semi-transparent @samp{transp} texture.

The last material is interesting. The base of the material is the
@samp{wood} texture. On top of that there is an additional texture layer
that uses the @samp{plasma} texture. The layer is scaled 10 times in both
@emph{u} and @emph{v} direction and it is added to the original texture
(i.e. the colors are added).

@subsubheading Shader Section
@cindex shaders (Map File)

With shaders you can describe more advanced texture and material
effects. The documentation for this section is not up-to-date
since the entire shader system is still work in progress.

@subsubheading Sounds Section
@cindex sounds (Map File)

@@@@@@Todo.

@subsubheading Variable Section
@cindex variables (Map File)

@@@@@@Todo.

@subsubheading Render Priority Section
@cindex render priorities (Map File)

Render priorities are important for deciding when to render objects.
When placing objects in a sector you place them in some render priority
queue (@pxref{HOWTO Render Priorities}).

Here is an example render priority section. It is also the default
render priority section. i.e. if you don't specify render priorities you
will get at least @samp{sky}, @samp{wall}, @samp{object}, and @samp{alpha}:

@example
<renderpriorities>
    <priority name="sky">
        <level>1</level>
        <sort>NONE</sort>
    </priority>
    <priority name="wall">
        <level>2</level>
        <sort>NONE</sort>
    </priority>
    <priority name="object">
        <level>3</level>
        <sort>NONE</sort>
    </priority>
    <priority name="alpha">
        <level>4</level>
        <sort>BACK2FRONT</sort>
    </priority>
</renderpriorities>
@end example

@subsubheading Plugin Section
@cindex plugin section (Map File)

The plugin section is purely for convenience later. Normally when creating
mesh objects you have to specify the @sc{scf} class name of the loader
which will parse the @sc{xml} data for that mesh object. This is a long
name. The plugin section allows you to define shorter names for those
plugins. Here is an example where names are defined for the thing,
spr3d, and spr3dfact plugins:

@example
<plugins>
    <plugin name="thing">
        crystalspace.mesh.loader.thing
    </plugin>
    <plugin name="spr3dFact">
        crystalspace.mesh.loader.factory.sprite.3d
    </plugin>
    <plugin name="spr3d">
        crystalspace.mesh.loader.sprite.3d
    </plugin>
</plugins>
@end example

@subsubheading Settings Section
@cindex settings (Map File)

In the settings section there are a few configuration options that you can
specify. Here is a complete settings example:

@example
<settings>
  <clearzbuf />
  <clearscreen />
  <lightmapcellsize>16</lightmapcellsize>
  <maxlightmapsize horizontal="256" vertical="256" />
  <ambient red=".1" green=".1" blue=".1" />
  <fastmesh>300</fastmesh>
</settings>
@end example

By default Crystal Space does not clear the z-buffer not the screen every
frame. For the z-buffer it depends on objects to fill the z-buffer. In a
typical Crystal Space world every sector would have an outer hull (either
a skybox or else the walls of the room) which would use @samp{zfill} mode
so that the z-buffer is updated but not read. Objects in the room can then
use @samp{zuse}. If you don't want this (i.e. you want to use @samp{zuse}
for all objects) then you can use @samp{clearzbuf}. Similar for
@samp{clearscreen}.

The lightmap cellsize defines how many texels (pixels on a texture) there
are in every lumel (lightmap value). For example, if the lightmap cellsize
is 16 (default) then for every 16x16 texels there will be one lumel.

The maximum lightmap size is usually 256x256. You can change this value
here but this usually doesn't make much sense.

In addition to the lighting information given by all lights in the system,
every object will also get ambient lighting. Ambient lighting is global to
the engine (at least static ambient lighting). You can set the ambient
for a level in the settings block. Default ambient is 0.078 for all color
components.

With @samp{fastmesh} you can control at which point Crystal Space will use
@samp{CS_THING_FASTMESH} for a thing. This is a faster routine (in principle)
but at this moment it only seems to pay off for objects with a high
number of polygons. The default is 500.

@subsubheading Start Location Section
@cindex start location (Map File)

A map file can contain zero or more start locations for the camera. How
these start locations are interpreted is up to the application. Typically
there is one start location that has no name and which is considered the
default. But you can have multiple start locations and refer to them by
name in your application. Here is an example:

@example
<start>
    <sector>room</sector>
    <position x="0" y="0" z="0" />
</start>
<start name="alternate">
    <sector>other_room</sector>
    <position x="0" y="0" z="0" />
    <up x="0" y="-1" z="0" />
    <forward x="0" y="0" z="-1" />
    <farplane a="0" b="0" c="1" d="100" />
</start>
@end example

If there is no start location then by convention many applications assume
that the default start is in sector called @samp{room} at location
@samp{0,0,0}.

The first example above is easy. It just defines the same starting location
as specifying nothing would have done.

The second example is more complicated. It defines a start location called
@samp{alternate}. The up-vector is specified as @samp{0,-1,0} which is just
the reverse of the default @samp{0,1,0}. This means that the camera will
be upside down. The forward vector is @samp{0,0,-1} which means that
the camera will be looking to the negative z axis. By default the camera
looks in the positive z direction.

The last @samp{farplane} option is interesting. It indicates that all
geometry beyond @samp{z=100} will be clipped away. You can use this if
you want to speed up rendering and you know that objects further away than
the specified distance are not interesting or you use fog that would have
made them invisible anyway. Note that fog alone doesn't do that. By default
there is no farplane. If you use the farplane option it is usually recommended
to let the engine clear the z-buffer every frame (see the @samp{settings}
section above) because you can no longer depend on geometry to do it for you
if it is culled away.

@subsubheading Library Specification Section
@cindex libraries (Map File)

It is possible to define libraries that contain objects like mesh factories,
textures, materials, and so on and then include those libraries in your
map files. Creating a library file is very easy. It is basically the same
as creating a map file but instead of @code{<world>} you would use
@code{<library>}. To use a library you can simply put the following in
your map file:

@example
<library>/mygamedata/library</library>
@end example

@subsubheading Keys
@cindex keys (Map File)

Crystal Space has a system with which you can attach user data to almost
all Crystal Space objects. This user data has a name and several values (string
based) and in code you can query for those name/value pairs. Crystal Space
itself doesn't use this. It only stores the information.

When you specify name/value pairs in the world section itself you are
essentially adding information to the engine class. Here is an example:

@example
<key name="spawn_monster" type="ghost" location="mainhall"
  pos="10,1,12" />
<key name="spawn_monster" type="goblin" location="corridor"
  pos="15,3,10" />
@end example

@node XML World Element Section, XML World Definition Section, XML Init Section, XML File Format
@subsubsection World Element Section

This section describes the world element section.

@subsubheading Addon Section
@cindex addons (Map File)
@cindex @code{iLoaderPlugin}

Addons are loader plugins that can be used to extend the loading
capabilities. Like keys, addons can also be loaded from almost any
Crystal Space object. The difference is that the loaded information
is not automatically attached to the object. Instead the object in which
the addon is called is given as a @emph{context} to the addon loader
so that it can choose to do with it whatever it wants. For example, you
could make an addon plugin for your own game that sets up a physics
object for a mesh object. To do that you would have to create a plugin
that implements the @samp{iLoaderPlugin} interface. In the plugin
implementation you can examine the context and based on that create some
information that you can attach to that context (if it is a mesh object
for example). The addon plugin will also get an @sc{xml} node that it
can parse for additional parameters.

Crystal Space itself currently defines two addon loaders itself. The
first one is useful for defining bezier templates that you can later use
in a bezier curve. The second one is useful for creating named texture
planes that can be used to define texture mapping for a number of polygons
that are all on the same plane. Here is an example of both:

@example
<addon>
    <plugin>crystalspace.mesh.loader.thing.bezier</plugin>
    <params>
        <name>b1</name>
        <material>mosaic</material>
        <v>0</v>
        <v>1</v>
        <v>2</v>
        <v>8</v>
        <v>9</v>
        <v>10</v>
        <v>16</v>
        <v>17</v>
        <v>18</v>
    </params>
</addon>

<addon>
    <plugin>crystalspace.mesh.loader.thing.plane</plugin>
    <params>
        <name>floor_plane</name>
        <orig x="-20" y="-1" z="20" />
        <first x="-19" y="-1" z="20" />
        <firstlen>5</firstlen>
        <second x="-20" y="-1" z="19" />
        <secondlen>5</secondlen>
    </params>
</addon>
@end example

I will only explain the second example here as bezier curves are likely
to change in the not-too-distant future. Important in both examples is
that the part inside the @samp{params} block is parsed by the addon itself.
It is also possible to specify the parameters of a plugin in another
@sc{xml} file in which case you can use @samp{paramsfile}.

The plane addon that is used above defines a horizontal texture plane at
location @emph{y} equal to @samp{-1}. The dimension of the texture on
that plane will be 5x5 units. This means that in the space of a 5x5 unit
block the texture will be shown exactly one time. If the polygons are bigger
then that then tiling will be used. When you define @samp{thing} mesh objects
you can use this plane if the polygon happens to be at @emph{y} equal to
@samp{-1}.

@subsubheading Mesh Factory Section
@cindex mesh factories (Map File)

In a map file you can define zero or more mesh factories. A mesh factory
itself is not an object that you can see. It only defines a blue-print
for creating mesh objects later. How a mesh factory and mesh object
interact depends on the specific type of mesh object. For some types
factories are required but for others you can just define the object
directly as a mesh object (@pxref{MeshObject}).

Here is an example mesh factory:

@example
<meshfact name="square">
    <plugin>crystalspace.mesh.loader.factory.genmesh</plugin>
    <params>
        <numvt>4</numvt>
        <numtri>4</numtri>
        <v x="-2" y="0" z="-2" u="0" v="0" />
        <v x="2" y="0" z="-2" u="1" v="0" />
        <v x="2" y="0" z="2" u="1" v="1" />
        <v x="-2" y="0" z="2" u="0" v="1" />
        <t v1="3" v2="0" v3="1" />
        <t v1="1" v2="2" v3="3" />
        <t v1="1" v2="0" v3="3" />
        <t v1="3" v2="2" v3="1" />
        <autonormals />
    </params>
</meshfact>
@end example

In the example above we use the @samp{genmesh} factory loader plugin.
Everything inside the @samp{params} block is specific to that loader. If
you use other loaders you will need other stuff in there.
It is also possible to specify the parameters of a plugin in another
@sc{xml} file in which case you can use @samp{paramsfile}. The use
of @samp{paramsfile} is required if the other file is binary or not
@sc{xml}.

The example above defines a factory called @samp{square}. When you later
define mesh objects you can create them from that factory. In case of
@samp{genmesh} which is used here you must use factories.

Mesh factories can contain keys and addons.

@node XML World Definition Section, XML Action Section, XML World Element Section, XML File Format
@subsubsection World Definition Section

This section describes the world definition section.

@subsubheading Sector Section
@cindex sectors (Map File)

A map file usually contains at least one sector. A sector is an infinite
area of space which you can populate with mesh objects and lights. Using
portals you can connect different sectors.

Note that while a sector is in fact infinite, in practice it is usually
bounded by some geometry. For an outside level there is usually
a sky box or sky dome which marks the outermost geometry. In case of indoor
type levels there are usually sector walls.

Here is an example sector:

@example
<sector name="room">
  <meshobj name="walls">
    <plugin>crystalspace.mesh.loader.thing</plugin>
    <zfill />
    <params>
      <v x="-10" y="-1" z="10"/> <v x="10" y="-1" z="10"/>
      <v x="-10" y="-1" z="-10"/> <v x="10" y="-1" z="-10"/>
      <v x="-10" y="4" z="10"/> <v x="10" y="4" z="10"/>
      <v x="-10" y="4" z="-10"/> <v x="10" y="4" z="-10"/>
      <material>wood</material>
      <texlen>4</texlen>
      <p name="up">
        <v>6</v> <v>7</v> <v>5</v> <v>4</v>
      </p>
      <p name="down">
        <v>3</v> <v>2</v> <v>0</v> <v>1</v>
      </p>
      <p name="back">
        <v>7</v> <v>6</v> <v>2</v> <v>3</v>
      </p>
      <p name="front">
        <v>4</v> <v>5</v> <v>1</v> <v>0</v>
      </p>
      <p name="left">
        <v>6</v> <v>4</v> <v>0</v> <v>2</v>
      </p>
      <p name="right">
        <v>5</v> <v>7</v> <v>3</v> <v>1</v>
      </p>
    </params>
  </meshobj>
  <light>
    <center x="0" y="3" z="0"/>
    <radius>40</radius>
    <color red="1" green="1" blue="1"/>
  </light>
</sector>
@end example

In the above example we create a sector called @samp{room} which contains
one mesh object (the outer walls of the sector) and one light. Any type
of mesh object can be placed in a sector. In this example we use the
@samp{thing} mesh object.

There are some other things you can specify in a sector. By default a
sector will use the @samp{frustvis} visibility culler. This visibility culler
will only do frustum culling. For small sectors (i.e. a small number of
objects) this is usually sufficient. If you have a large sector with lots
of objects then you should probably use @samp{dynavis} instead. Like this:

@example
<cullerp>crystalspace.culling.dynavis</cullerp>
@end example

In addition to using @samp{meshobj} for specifying mesh objects in a sector
there are also some other techniques that you can use.

@itemize
@item
@samp{meshref}: with @samp{meshref} you can directly create a mesh object
from a factory. This sounds similar to @samp{meshobj} but the main difference
is that you can create hierarchical mesh objects from hierarchical mesh
factories with this. The disadvantage is that it is not possible to supply
mesh object specific parameters to the created mesh objects (i.e. you cannot
supply a @samp{params} or @samp{paramsfile} with @samp{meshref}).

@item
@samp{meshlib:} normally a library contains mesh factories. But it is possible
to define mesh objects in libraries too. These mesh objects will be placed
in the engine but not in any sector. To actually link such an object to
a sector you have to use @samp{meshlib} then. It is possible to supply
additional parameters using @samp{params} or @samp{paramsfile} with
@samp{meshlib}. These will be used in addition to the parameters already
supplied to the mesh object as defined in the library. Note that once you
added an object to a sector using @samp{meshlib} you cannot add it to other
sectors. This technique is not an alternative for using mesh factories.
@end itemize

A sector can also contain fog like this:

@example
<fog red=".5" green=".5" blue=".5" density=".01" />
@end example

Finally a sector can contain nodes. A node represents something that has
a position. In addition a node can contain keys and addons. Crystal Space
itself doesn't use nodes but an application using Crystal Space can use
them for whatever purpose it needs. Here is an example:

@example
<node name="monster">
    <position x="10" y="3" z="12" />
    <key name="spawn" value="100" />
</node>
@end example

Sectors can contain keys and addons.

@subsubheading Region Specification
@cindex regions (Map File)

With regions it is possible to group related objects (like textures,
materials, mesh objects, mesh factories, sectors, sequences, triggers,
shared variables, @dots{}).
Regions are not a geometrical concept. It is possible to define a region which
contains all wall geometry and a region which contains all moving geometry.
Usually though, regions represent some area in the world. You can use
regions to dynamically load/unload parts of the world. This is useful
if you have really big worlds that don't fit in memory at once.

@subsubheading Collection Specification
@cindex collections (Map File)

A collection is similar to a region in some respects but the purpose
is different. Basically a collection is a collection of some other
objects which you want to tie together for some reason (other than
dynamic loading). For example, using them in a scripting setup.

Here is an example collection:

@example
<collection name="carCol">
    <meshobj>car</meshobj>
    <meshobj>tire1</meshobj>
    <meshobj>tire2</meshobj>
    <meshobj>tire3</meshobj>
    <meshobj>tire4</meshobj>
    <light>lightname</light>
</collection>
@end example

Collections can also contain keys.

@node XML Action Section, , XML World Definition Section, XML File Format
@subsubsection Action Section

This section describes the action section.

@subsubheading Sequences and Triggers
@cindex sequences (Map File)
@cindex triggers (Map File)

With the sequences and triggers section you can define actions and
interactions on objects in your map file. These sections are used to drive
the engine sequence manager (@pxref{Sequence Manager}).
