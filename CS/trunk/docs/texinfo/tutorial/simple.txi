@c -*-texinfo-*-
@node Tutorial Simple, Tutorial Simple 2, Tutorial Introduction, Tutorials
@section Simple Tutorial 1
@cindex Tutorial, Simple
@cindex Simple Tutorial

This tutorial provides a step-by-step explanation on how you can use Crystal
Space from within your application.  This tutorial is mainly based on the
@file{simple} application which you can compile and run to see what it does
(type @samp{make tutsimp1} if you use commandline based compilation).

When you downloaded the Crystal Space package it contains a @samp{CS/include}
directory. This directory contains all header files you need to be able to
use the Crystal Space components and libraries in your own applications. On
one hand, the include directory contains @sc{scf} interface definitions.
These pure interface file names start with the letter @samp{i} (as in
@file{iengine/engine.h}).  On the other hand we also have plain C++ include
files for interfacing with the libraries of Crystal Space.
When you install Crystal Space on your development system (for instance,
by invoking @samp{make install}), these headers are placed in a location where
they can be easily accessed when writing new programs based on Crystal Space.
On Unix systems, for instance, these files usually end up in
@file{/usr/local/crystal/include}.

Crystal Space also has a reference manual and @sc{api} documentation.
The manual is included in @sc{html} form Crystal Space itself and is also
available online.  The @sc{api} documentation can be generated locally or
viewed online.  @xref{Where to Get}.

Before reading this tutorial you should read the Tutorial Introduction first
(@pxref{Tutorial Introduction}).

@menu
* Simple Header File::
* Simple Event Handling:: Event Handling
* Simple World:: Creating a ``World''
* Simple Camera:: The Camera
* Simple Locomotion:: Locomotion (Moving Around)
@end menu

@node Simple Header File, Simple Event Handling, Tutorial Simple, Tutorial Simple
@subsection Simple Header File
@cindex Tutorial Simple Header File
@cindex Simple Header File, Tutorial

It is good practice to always put defines and declares in header
files as opposed to source files. In some cases it is even needed. Here
we will show the header file for a simple Crystal Space application.
Although this is not strictly required, we use a class to encapsulate
the application logic. Our @file{simple.h} header looks as follows:

@example
#ifndef __SIMPLE_H__
#define __SIMPLE_H__

#include <stdarg.h>

struct iEngine;
struct iLoader;
struct iGraphics3D;
struct iKeyboardDriver;
struct iSector;
struct iView;
struct iVirtualClock;
struct iObjectRegistry;
struct iEvent;

class Simple
@{
private:
  iObjectRegistry* object_reg;
  iEngine* engine;
  iLoader* loader;
  iGraphics3D* g3d;
  iKeyboardDriver* kbd;
  iVirtualClock* vc;
 
public:
  Simple ();
  ~Simple ();

  bool Initialize (int argc, const char* const argv[]);
  void Start ();
@};

#endif // __SIMPLE1_H__
@end example

In the @code{Simple} class we keep a number of references to important
objects that we are going to need a lot. That way we don't have to get
them every time when we need them. Other than that we have a constructor
which will do the initialization of these variables, a destructor which
will clean up the application, an initialization function which will
be responsible for the full set up of Crystal Space and our application,
and finally a @code{Start()} function to start the event handler.

In the source file @file{simple.cpp} we place the following:

@example
#include "cssysdef.h"
#include "cssys/sysfunc.h"
#include "iutil/vfs.h"
#include "csutil/cscolor.h"
#include "cstool/csview.h"
#include "cstool/initapp.h"
#include "simple.h"
#include "iutil/eventq.h"
#include "iutil/event.h"
#include "iutil/objreg.h"
#include "iutil/csinput.h"
#include "iutil/virtclk.h"
#include "iengine/sector.h"
#include "iengine/engine.h"
#include "iengine/camera.h"
#include "iengine/light.h"
#include "iengine/statlght.h"
#include "iengine/texture.h"
#include "iengine/mesh.h"
#include "iengine/movable.h"
#include "iengine/material.h"
#include "imesh/thing/polygon.h"
#include "imesh/thing/thing.h"
#include "imesh/object.h"
#include "ivideo/graph3d.h"
#include "ivideo/graph2d.h"
#include "ivideo/txtmgr.h"
#include "ivideo/texture.h"
#include "ivideo/material.h"
#include "ivideo/fontserv.h"
#include "igraphic/imageio.h"
#include "imap/parser.h"
#include "ivaria/reporter.h"
#include "ivaria/stdrep.h"
#include "csutil/cmdhelp.h"

CS_IMPLEMENT_APPLICATION

// The global pointer to simple
Simple *simple;

Simple::Simple ()
@{
  engine = NULL;
  loader = NULL;
  g3d = NULL;
  kbd = NULL;
  vc = NULL;
@}

Simple::~Simple ()
@{
  if (vc) vc->DecRef ();
  if (engine) engine->DecRef ();
  if (loader) loader->DecRef();
  if (g3d) g3d->DecRef ();
  if (kbd) kbd->DecRef ();
  csInitializer::DestroyApplication (object_reg);
@}

bool Simple::Initialize (int argc, const char* const argv[])
@{
  object_reg = csInitializer::CreateEnvironment ();
  if (!object_reg) return false;

  csInitializer::SetupCommandLineParser (object_reg, argc, argv);
  if (!csInitializer::RequestPlugins (object_reg,
  	CS_REQUEST_VFS,
	CS_REQUEST_SOFTWARE3D,
	CS_REQUEST_ENGINE,
	CS_REQUEST_FONTSERVER,
	CS_REQUEST_IMAGELOADER,
	CS_REQUEST_LEVELLOADER,
	CS_REQUEST_REPORTER,
	CS_REQUEST_REPORTERLISTENER,
	CS_REQUEST_END))
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
	"Can't initialize plugins!");
    return false;
  @}

  // Check for commandline help.
  if (csCommandLineHelper::CheckHelp (object_reg))
  @{
    csCommandLineHelper::Help (object_reg);
    return false;
  @}

  // The virtual clock.
  vc = CS_QUERY_REGISTRY (object_reg, iVirtualClock);
  if (!vc)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
	"Can't find the virtual clock!");
    return false;
  @}

  // Find the pointer to engine plugin
  engine = CS_QUERY_REGISTRY (object_reg, iEngine);
  if (!engine)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
	"No iEngine plugin!");
    return false;
  @}

  loader = CS_QUERY_REGISTRY (object_reg, iLoader);
  if (!loader)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
    	"No iLoader plugin!");
    return false;
  @}

  g3d = CS_QUERY_REGISTRY (object_reg, iGraphics3D);
  if (!g3d)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
    	"No iGraphics3D plugin!");
    return false;
  @}

  kbd = CS_QUERY_REGISTRY (object_reg, iKeyboardDriver);
  if (!kbd)
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
    	"No iKeyboardDriver plugin!");
    return false;
  @}

  // Open the main system. This will open all the previously
  // loaded plug-ins.
  if (!csInitializer::OpenApplication (object_reg))
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
    	"Error opening system!");
    return false;
  @}

  csReport (object_reg, CS_REPORTER_SEVERITY_NOTIFY,
    	"crystalspace.application.simple",
	"Simple Crystal Space Application version 0.1.");

  return true;
@}

void Simple::Start ()
@{
  csDefaultRunLoop (object_reg);
@}

/*---------------*
 * Main function
 *---------------*/
int main (int argc, char* argv[])
@{
  simple = new Simple ();

  if (simple->Initialize (argc, argv))
    simple->Start ();

  delete simple;
  return 0;
@}
@end example

This is almost the simplest possible application and it is absolutely useless.
Also don't run it on an operating system where you can't kill a running
application because there is no way to stop the application once it has
started running.

Even though this application is useless it already has a lot of features
that are going to be very useful later. Here is a short summary of all
the things and features it already has:

@itemize
@item
It will open a window.
@item
You can control the size of the window and the video driver used
for that window with commandline options (@code{-video} and @code{-mode}
commandline options).
@item
It will give commandline help when you use the @code{-help} commandline
option.
@item
It has the following plugins initialized and ready to use: engine, 3D
renderer, canvas, reporter, reporter listener, font server, image loader,
level loader, and VFS.
@end itemize

Before we start making this application more useful lets have a look at what
actually happens here.

Before doing anything at all, after including the necessary header files, we
first need to use a few macros.  The CS_IMPLEMENT_APPLICATION macro is
essential for every application using CS.  It makes sure that the @code{main()}
routine is correctly linked and called on every platform.

The main routine first creates an instance of our
@samp{Simple} class. We put this instance into a global variable to make
access to it easier. The next step is initialization. The first thing the
@code{Initialize()} function does is to create the environment with
@code{csInitializer::CreateEnvironment()}. This will initialize @sc{scf},
create the object registry, and then create a number of other useful
entities (plugin manager, event queue, ...).

Note the usage of the @code{csReport()} function. This is a conveniance
function to send a message (usually an error or notification) to the
reporter plugin. It works a lot like @code{printf} except that you
additionally need to give the severity level and an identifier which can give
someone listening to the reporter an idea of the origin of the message.

Then we call @code{csInitializer::SetupCommandLineParser()} to setup
the commandline parser. This will allow the rest of the initialization
pass to actually read the commandline.

@code{csInitializer::RequestPlugins()} will use the config file (which
we are not using in this tutorial), the commandline and the requested
plugins to find out which plugins to load. The commandline has highest
priority, followed by the config file and lastly the requested plugins.

The @code{csCommandLineHelper::CheckHelp()} function will check if the
@code{-help} commandline option is given and if so show the help for
all loaded plugins (every plugin that is loaded in memory is capable of
extending the commandline options).

After that we will query the object registry to find out all the common
objects that we're going to need later and store a reference in our
main class. At destruction time we must then release these references
with @code{DecRef()}.

Finally, when all is done the window is opened with a call to the function
@code{csInitializer::OpenApplication()}.  This sends the @code{cscmdSystemOpen}
message to all components that are listening to the event queue.  One of the
plugins that does this is the 3D renderer which will then open its window (or
enable graphics on a non-windowing operating system).

This concludes the initialization pass.

In @code{Simple::Start()} we will start the default main loop by
calling @code{csDefaultRunLoop()}. This function will only return when
the application exits (which this example cannot yet do). Basically
this function will start the loop to handle events.

@node Simple Event Handling, Simple World, Simple Header File, Tutorial Simple
@subsection Event Handling
@cindex Event Handling, Simple Tutorial
@cindex Simple Tutorial Event Handling

To make the testing somewhat easier we will add a way to terminate the
application by responding to the @key{ESC} key.  Add the following private
methods to our class in @file{simple.h}:

@example
  static bool SimpleEventHandler (iEvent& ev);
  bool HandleEvent (iEvent& ev);
@end example

The static function @code{SimpleEventHandler()} will be registered to
the event queue. It has to be a static function because the event queue
expects to call a normal C-style function (alternatively you could also
implement this by making a subclass of @code{iEventHandler} but this is
more complicated and not really required).

@code{HandleEvent()} is the real event handler. @code{SimpleEventHandler()}
only serves as a stub function to call @code{HandleEvent()}.

Then add the following code before @code{Simple::Initialize()}:

@example
bool Simple::HandleEvent (iEvent& ev)
@{
  if (ev.Type == csevKeyDown && ev.Key.Code == CSKEY_ESC)
  @{
    iEventQueue* q = CS_QUERY_REGISTRY (object_reg, iEventQueue);
    if (q)
    @{
      q->GetEventOutlet()->Broadcast (cscmdQuit);
      q->DecRef ();
    @}
    return true;
  @}
  return false;
@}

bool Simple::SimpleEventHandler (iEvent& ev)
@{
  return simple->HandleEvent (ev);
@}
@end example

@code{HandleEvent()} checks if the @key{ESC} key has been pressed. If so it
will use the object registry to find the global event queue object. Using
@code{Broadcast} it will then broadcast the @code{cscmdQuit} message
to all interested parties. This will cause the application to quit by ending
the default run loop.

We also need to initialize this event handler function. To do that add
the following after the call to @code{csInitializer::RequestPlugins()}:

@example
  if (!csInitializer::SetupEventHandler(
    object_reg, SimpleEventHandler))
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
	"Can't initialize event handler!");
    return false;
  @}
@end example

@node Simple World, Simple Camera, Simple Event Handling, Tutorial Simple
@subsection Creating a ``World''
@cindex Tutorial, Creating a ``World''
@cindex World, Creating, Simple Tutorial
@cindex iMaterialWrapper
@cindex iSector
@cindex iThingState
@cindex iPolygon3D
@cindex iLight
@cindex iLightList
@cindex iStatLight
@cindex iMeshWrapper

Now we have a very exciting application which opens a black window and waits
for the @key{ESC} key to quit.  We assume this is the application you always
wanted to have?  No?  Ok then, let's create some 3D stuff.

We'll add a texture manager, a room (technically called a @dfn{sector}) and
some lights.  First, add a pointer to our main sector to the @code{Simple}
class header file:

@example
@dots{}
struct iSector;
@dots{}
class Simple
@{
private:
  @dots{}
  iSector* room;
  @dots{}
@end example

Now add these chunks of code (texture manager, room, lights) to
@file{simple.cpp}:

@example
bool Simple::Initialize (int argc, const char* const argv[])
@{
  @dots{}
  if (!csInitializer::OpenApplication (object_reg))
  @{
    @dots{}
  @}

  // Setup the texture manager
  iTextureManager* txtmgr = g3d->GetTextureManager ();
  txtmgr->SetVerbose (true);

  // Initialize the texture manager
  txtmgr->ResetPalette ();
  @dots{}
  // First disable the lighting cache. Our app is simple enough
  // not to need this.
  engine->SetLightingCacheMode (0);

  if (!loader->LoadTexture ("stone", "/lib/std/stone4.gif"))
  @{
    csReport (object_reg, CS_REPORTER_SEVERITY_ERROR,
    	"crystalspace.application.simple",
    	"Error loading 'stone4' texture!");
    return false;
  @}
  iMaterialWrapper* tm =
    engine->GetMaterialList ()->FindByName ("stone");

  room = engine->CreateSector ("room");
  iMeshWrapper* walls =
    engine->CreateSectorWallsMesh (room, "walls");
  iThingState* walls_state =
    SCF_QUERY_INTERFACE (walls->GetMeshObject (), iThingState);
  iPolygon3D* p;
  p = walls_state->CreatePolygon ();
  p->SetMaterial (tm);
  p->CreateVertex (csVector3 (-5, 0, 5));
  p->CreateVertex (csVector3 (5, 0, 5));
  p->CreateVertex (csVector3 (5, 0, -5));
  p->CreateVertex (csVector3 (-5, 0, -5));
  p->SetTextureSpace (p->GetVertex (0), p->GetVertex (1), 3);

  p = walls_state->CreatePolygon ();
  p->SetMaterial (tm);
  p->CreateVertex (csVector3 (-5, 20, -5));
  p->CreateVertex (csVector3 (5, 20, -5));
  p->CreateVertex (csVector3 (5, 20, 5));
  p->CreateVertex (csVector3 (-5, 20, 5));
  p->SetTextureSpace (p->GetVertex (0), p->GetVertex (1), 3);

  p = walls_state->CreatePolygon ();
  p->SetMaterial (tm);
  p->CreateVertex (csVector3 (-5, 20, 5));
  p->CreateVertex (csVector3 (5, 20, 5));
  p->CreateVertex (csVector3 (5, 0, 5));
  p->CreateVertex (csVector3 (-5, 0, 5));
  p->SetTextureSpace (p->GetVertex (0), p->GetVertex (1), 3);

  p = walls_state->CreatePolygon ();
  p->SetMaterial (tm);
  p->CreateVertex (csVector3 (5, 20, 5));
  p->CreateVertex (csVector3 (5, 20, -5));
  p->CreateVertex (csVector3 (5, 0, -5));
  p->CreateVertex (csVector3 (5, 0, 5));
  p->SetTextureSpace (p->GetVertex (0), p->GetVertex (1), 3);

  p = walls_state->CreatePolygon ();
  p->SetMaterial (tm);
  p->CreateVertex (csVector3 (-5, 20, -5));
  p->CreateVertex (csVector3 (-5, 20, 5));
  p->CreateVertex (csVector3 (-5, 0, 5));
  p->CreateVertex (csVector3 (-5, 0, -5));
  p->SetTextureSpace (p->GetVertex (0), p->GetVertex (1), 3);

  p = walls_state->CreatePolygon ();
  p->SetMaterial (tm);
  p->CreateVertex (csVector3 (5, 20, -5));
  p->CreateVertex (csVector3 (-5, 20, -5));
  p->CreateVertex (csVector3 (-5, 0, -5));
  p->CreateVertex (csVector3 (5, 0, -5));
  p->SetTextureSpace (p->GetVertex (0), p->GetVertex (1), 3);

  walls_state->DecRef ();
  walls->DecRef ();

  iStatLight* light;
  iLightList* ll = room->GetLights ();

  light = engine->CreateLight (NULL, csVector3 (-3, 5, 0), 10,
  	csColor (1, 0, 0), false);
  ll->Add (light->QueryLight ());
  light->DecRef ();

  light = engine->CreateLight (NULL, csVector3 (3, 5,  0), 10,
  	csColor (0, 0, 1), false);
  ll->Add (light->QueryLight ());
  light->DecRef ();

  light = engine->CreateLight (NULL, csVector3 (0, 5, -3), 10,
  	csColor (0, 1, 0), false);
  ll->Add (light->QueryLight ());
  light->DecRef ();

  engine->Prepare ();

  iTextureManager* txtmgr = g3d->GetTextureManager ();
  txtmgr->SetPalette ();
  return true;
@}
@end example

This extra code first loads a texture with @code{LoadTexture()}.
The first parameter is the name of the texture as it will be known in the
engine; and the third is the
actual filename on the @sc{vfs} volume (@pxref{VFS}).  Note, if you don't have
the @file{stone4.gif} texture you can use another one.  The only requirement
is that it must have sizes which are a power of 2 (e.g. 64x64) (note that
CS will scale them automatically if this requirement isn't met but this can
reduce quality). This functions
returns a @samp{iTextureWrapper} which we don't use.  Instead we use
the @samp{iMaterialWrapper} which is created automatically by
@code{LoadTexture()}.

Then we create our room with @code{CreateSector()}.  This room will initially
be empty.  A room in Crystal Space is represented by @samp{iSector} which is
basically a container which can hold geometrical objects. Objects
in Crystal Space are represented by @sc{mesh objects} (@pxref{MeshObject}).
There are several types of mesh objects in Crystal Space. Every type of
mesh object represents some different way to represent geometry. In this
tutorial we are only going to use the 'thing' mesh object type. This mesh
object type is very useful for walls of indoor type levels or buildings.

Now we want create the six walls of our room. First we make our thing mesh
object. Because this is a very common case there is a conveniance function
in the engine (called @code{CreateSectorWallsMesh()}) which will create a
thing mesh and add it to the given sector. The only thing that has to be
done after this is add polygons to that mesh. To do this we first query
the interface called @code{iThingState} from the thing mesh object.
We use the macro @code{SCF_QUERY_INTERFACE} which is part of @sc{scf}
(@pxref{SCF}). This will see if the mesh object (which is wrapped by
the mesh wrapper) actually implements @code{iThingState} (which should
be the case here) and if so it will return a pointer to the implementation
of @code{iThingState}. All mesh objects implement some kind of state
interface which is used to set up or query the state of that mesh object.
Note that all interfaces which you query using @code{SCF_QUERY_INTERFACE}
should be released when you no longer need them (by calling @code{DecRef()}).

The returned thing state we can now use to create polygons by calling
@code{CreatePolygon()} for every wall. This will return a pointer to a
polygon (@code{iPolygon3D}). On this we can set various parameters like
the material. Then we add four vertices (note that in Crystal Space
a polygon is visible if vertices are oriented clock-wise). The location
given to @code{CreateVertex()} is in object space (in contrast with
world space and camera space).
To define how the texture is mapped on the polygon we use
@code{SetTextureSpace()}.  There are several versions of this function.  The
one we use in this tutorial is one of the simplest but it offers the least
control.  In this particular case we take the first two vertices of the
polygon and use that for the u-axis of the texture.  The v-axis will be
calculated perpendicular to the u-axis.  The parameter 3 indicates that the
texture will be scaled so that one texture tile is exactly 3x3 world units in
size.

Finally we create some lights in our room to make sure that we actually are
able to see the walls.  The interface @samp{iStatLight} represents a static
light which can not move and change intensity.  We create three such lights
and add them to the room with @code{AddLight()}. Note that the list of lights
in a sector is presented by an object implementing @code{iLightList}. To
get this list you call @code{iSector::GetLights()}. Also note that this light
list works with lights of type @code{iLight}. @code{iLight} is the base
interface for all lights in Crystal Space. To get the @code{iLight} from an
instance of @code{iStatLight} you can do @code{iStatLight::QueryLight()}.

When creating a light we use several parameters.
First we have the name of the light. This is not used
often and mostly you can set this to @code{NULL}. The second parameter is
the location of the light in the world. Then follows a radius. The light will
not affect polygons which are outside the sphere described by the center of
the light and the radius.  The next parameter is the color of the light in
@sc{rgb} format (@code{<1,1,1>} means white and @code{<0,0,0>} means black).
The last parameter indicates whether or not we want to have a pseudo-dynamic
light.  A pseudo-dynamic light still cannot move but it can change intensity.
There are some performance costs associated with pseudo-dynamic lights so
it is not enabled by default.

The call to @code{Prepare()} prepares the engine for rendering your scene.  It
will prepare all textures and create all lightmaps if needed.  Only after this
call can you start rendering your world, because lightmaps may have to be
converted to a format more suitable for the chosen 3D renderer.

The last code we added allocates the palette with the texture manager.
Note that is needed even if you are running on a true-color display which
has no palette.  That's because the code does some other things beside
setting up a palette.

Ok, now we have created our room and properly initialized it.  If you would
compile and run this application you would still see a black screen.  Why?
Because we have not created a camera through which you can see.

@node Simple Camera, Simple Locomotion, Simple World, Tutorial Simple
@subsection The Camera
@cindex Tutorial, Camera
@cindex Camera, Tutorial
@cindex iView
@cindex iCamera

In Crystal Space there is an interface called @code{iView} which
encapsulates both @samp{iCamera} and @code{iClipper2D} instances.
In principle you can use those classes directly but using @code{iView} is
easier.  Now edit @file{simple.h} to make use of @code{iView}:

@example
@dots{}
struct iView;
@dots{}

class Simple
@{
private:
  @dots{}
  iView* view;
  @dots{}
  void SetupFrame ();
  void FinishFrame ();
  @dots{}
@end example

Then edit @file{simple.cpp} and make the following changes to the constructor
and destructor of @samp{Simple}:

@example
Simple::Simple ()
@{
  view = NULL;
  @dots{}
@}

Simple::~Simple ()
@{
  if (view) view->DecRef ();
  @dots{}
@}
@end example

At the end of our @code{Initialize()} function (before
@code{txtmgr->SetPalette()} we add the following:

@example
bool Simple::Initialize (int argc, const char* const argv[])
@{
  @dots{}
  view = new csView (engine, g3d);
  view->GetCamera ()->SetSector (room);
  view->GetCamera ()->GetTransform ().SetOrigin (csVector3 (0, 5, -3));
  iGraphics2D* g2d = g3d->GetDriver2D ();
  view->SetRectangle (0, 0, g2d->GetWidth (), g2d->GetHeight ());

  txtmgr->SetPalette ();
  return true;
@}
@end example

So first we create a view for our world and 3D graphics renderer.  The view
has a current sector which is passed to the camera and is set by
@code{SetSector()}.  The camera also has a position in that sector which you
can set by first getting the camera with @code{GetCamera()} and then setting
the position (which is a @samp{csVector3}) with @code{SetPosition()}.  The
view also holds a clipping region which corresponds to the area on the window
that is going to be used for drawing the world.  Crystal Space supports convex
polygons to be used as viewing areas, but in case we use a simple rectangle
which has almost the size of the window.  We set this viewing rectangle with
@code{SetRectangle()}.

Now, this still isn't enough.  We have a camera but the camera is not used.
We still have to write code that actually draws the screen. We will do this
in the functions @code{SetupFrame()} and @code{FinishFrame()}. Note that
Crystal Space is event driver so the actual drawing needs to be triggered
by the event handler. Add the following code somewhere in the source file:

@example
void Simple::SetupFrame ()
@{
  // Tell 3D driver we're going to display 3D things.
  if (!g3d->BeginDraw(
    engine->GetBeginDrawFlags() | CSDRAW_3DGRAPHICS))
    return;

  // Tell the camera to render into the frame buffer.
  view->Draw ();
@}

void Simple::FinishFrame ()
@{
  g3d->FinishDraw ();
  g3d->Print (NULL);
@}
@end example

Modify the event handler like this:

@example
bool Simple::HandleEvent (iEvent& ev)
@{
  if (ev.Type == csevBroadcast && ev.Command.Code == cscmdProcess)
  @{
    simple->SetupFrame ();
    return true;
  @}
  else if (ev.Type == csevBroadcast &&
    ev.Command.Code == cscmdFinalProcess)
  @{
    simple->FinishFrame ();
    return true;
  @}
  else if (ev.Type == csevKeyDown && ev.Key.Code == CSKEY_ESC)
  @dots{}
@end example

Drawing the screen is split in two parts. First there is the part that
is done in @code{SetupFrame()}. Here we will actually fill the display.
In this case we let the engine do most of that work by calling
@code{view->Draw()}. But in principle you can do any kind of drawing here.

In @code{SetupFrame()} we first have to indicate to the 3D rasterizer that
we want to start drawing 3D graphics.  This call makes sure that the
needed buffers are set up and
performs all necessary initialization. The engine often needs extra settings
for this as well so you @emph{must} call @code{engine->GetBeginDrawFlags()} to
get these flags and or them with the ones that you want.

The second part is in @code{FinishFrame()} where we actually dump the
frame to the screen. The reason this is split is that other components
(plugins) in Crystal Space may choose to listen to events to draw additional
things on top of the 3D view rendered in @code{SetupFrame()}. When a frame
needs to be rendered the Crystal Space framework will send four messages:

@itemize
@item
@code{cscmdPreProcess} is sent first. This allows plugins to preprocess
things before drawing can happen.
@item
@code{cscmdProcess} follows. In this pass the application will render.
@item
@code{cscmdPostProcess} is after that. This is the pass that can be used
by external components to render on top of the view rendered by the
application.
@item
@code{cscmdFinalProcess} is last. In this pass the application will display
the frame on screen.
@end itemize

Compile and run this example.  For the first time you should see something.  A
solid wall.  Congratulations, you have created your first almost useful
Crystal Space application.

@node Simple Locomotion, , Simple Camera, Tutorial Simple
@subsection Locomotion (Moving Around)
@cindex Tutorial Simple Locomotion
@cindex Locomotion, Tutorial
@cindex Movement, Tutorial

Staring at that solid wall gets a bit boring after some time.  The problem is
that we can't move the camera to change our view point.  Let's add some code
to do exactly this.  Edit @file{simple.cpp} again and change
@file{SetupFrame()} as follows:

@example
void Simple::SetupFrame ()
@{
  // First get elapsed time from the virtual clock.
  csTicks elapsed_time = vc->GetElapsedTicks ();
  
  // Now rotate the camera according to keyboard state
  float speed = (elapsed_time / 1000.0) * (0.03 * 20);

  iCamera* c = view->GetCamera();
  if (kbd->GetKeyState (CSKEY_RIGHT))
    c->GetTransform ().RotateThis (CS_VEC_ROT_RIGHT, speed);
  if (kbd->GetKeyState (CSKEY_LEFT))
    c->GetTransform ().RotateThis (CS_VEC_ROT_LEFT, speed);
  if (kbd->GetKeyState (CSKEY_PGUP))
    c->GetTransform ().RotateThis (CS_VEC_TILT_UP, speed);
  if (kbd->GetKeyState (CSKEY_PGDN))
    c->GetTransform ().RotateThis (CS_VEC_TILT_DOWN, speed);
  if (kbd->GetKeyState (CSKEY_UP))
    c->Move (CS_VEC_FORWARD * 4 * speed);
  if (kbd->GetKeyState (CSKEY_DOWN))
    c->Move (CS_VEC_BACKWARD * 4 * speed);
  @dots{}
@}
@end example

That's all!  With this simple change you can rotate the camera with the left
and right arrow keys and move forward and backward with the up and down arrow
keys.  Try it out to see the effect.  To rotate the camera we use
@code{RotateThis()} which expects a vector to rotate along and an angle given in
radians (the speed parameter).  There are a number of predefined vectors which
you can use.  A couple of them are used in this example.

That's it for now.  In this tutorial you learned how to setup the Crystal
Space system for use, how to create a simple room with some lights, event
handling, and how to handle some basic camera operations.

You can now go on to the next tutorial (@pxref{Tutorial Simple 2})) to learn
how to add a 3D sprite to this application.

