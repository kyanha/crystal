@c -*-texinfo-*-
@node Tutorial Introduction, Tutorial Simple, Tutorials, Tutorials
@section Developing a Crystal Space Application

Crystal Space is a package of components and libraries which can all be useful
for creating computer games.  Although some of the packages are intended more
for 3D gaming this is not as such a restriction of the package.  Components as
the sound driver function just as well in a 2D gaming environment and the
networking component can even be used in a text oriented environment.  This
highlights one of the important characteristics of Crystal Space: the
components and libraries are more or less independent of each other.  If you
don't want networking, then just don't use the networking drivers.  If you
don't want scripting then don't include that.  All packages are designed to be
functional on their own or with a minimal number of other packages.  There are
some dependencies of course.  For example, the 3D Engine requires a 3D
Rasterizer to display its output.  On the other hand, you could very well use
the 3D Rasterizer without the 3D Engine.

Although there is a high level of independence, there is also a high level of
integration.  The components and libraries were also designed to be used
together and as such offer a flexible scheme of integration.

If you are interested in developing a program using Crystal Space, then it is
important to understand that Crystal Space is not a single monolithic library,
but instead consists of several @dfn{libraries} and @dfn{plug-in modules}.
This manual uses the term @dfn{module} for both libraries and plug-ins when
the distinction between the two is not important.

A plug-in module is similar to a library, but has some advantages over a
library.  All plug-ins can be accessed in a common fashion.  They have a
@emph{very} clear interface, and they can provide this interface even if they
are extracted to a DLL.  So they are the better solution as long as speed is
not the dictator of all decisions as in the math library (access to plug-in
functions uses virtual methods).  The main difference between the interface of
a library and a plug-in is that a library may use @sc{scf} and C++ classes;
plug-ins may only use @sc{scf}.

@itemize @bullet
@item
What is @sc{scf}?

The main @sc{scf} object is the @emph{Interface}.  An interface is the
solution to strictly decouple the public methods of an object from their
implementation.  You only get a pointer to an abstract class with only virtual
methods, called the interface, so your program doesn't know about the actual
object behind the pointer.  This object is called an @emph{Implementation} of
the interface.  You as the user of Crystal Space will call functions that
create the actual object, but only return the interface.  After that you can
use the interface like a C++ object.  When you don't need it anymore, don't
@samp{delete} it, but call @code{DecRef()}.  When you pass a pointer to the
interface to anywhere, call @code{AddRef()} from there, and @code{DecRef()}
when you don't need the interface there anymore.

As the user you'll only have to include a header that defines the interface,
but not the implementation.  Despite the obvious advantage of having a very
clear structure in your code, there is the advantage that linking the
interface to the implementation can be done at run-time, but more about this
later.

@item
What are the characteristics of a library?

A library is just a normal C++ library as you know them.  A library can
optionally provide @sc{scf} interfaces.  In the case of a library this is just
a way to define a clear structure.  But as their main interface, libraries
provide C++ classes.

@item
What are the characteristics of a plug-in?

A plug-in, on the other hand, will only provide @sc{scf} interfaces, no normal
C++ classes.  This is part of the definition of a plug-in.  A plug-in can be
organized as static library or @sc{dll}; this only makes a small difference in
how you use it in your program.  As the user of Crystal Space, you have to do
the following steps to use a plug-in:

@itemize @minus
@item
First, do all these steps for the dependencies (other plug-ins) that this
plug-in relies on.

@item
Register the library that contains the plug-in.

@item
Load the plug-in.  This will also initialize the plug-in.  It will fail if you
forgot any dependencies.

@item
Query the plug-in interface.  This is an @sc{scf} interface, so you now have
access to the functions of the plug-in.
@end itemize

@item
How can I register the plug-in library?

This depends on whether you have a static library or @sc{dll}.  For a static
library, put this line at topl evel into one of your C++ files and link to the
static library.

@example
REGISTER_STATIC_LIBRARY(@var{name})
@end example

For a @sc{dll}, use @samp{scfreg} at your command line:

@example
scfreg @var{name}.dll    # @r{For Windows or @sc{dos}}
scfreg lib@var{name}.so  # @r{For most Unix platforms}
@end example

@samp{@var{name}} is the name of the library, which is chosen by its author.
The filename of the @sc{dll} is then @file{name.dll} or @file{name.so}.  Note
that it is possible that several plug-ins are stored in the same library.  In
this case you must @emph{register} the library only once, but you must
``load'' all plug-ins (see next section).

@item
How can I load the plug-in?

You must tell the system driver that you want to use this plugin.  There are
two ways how to do this.  The first way is to add the following line in the
@code{[PlugIns]} section in your config file: @samp{@var{anything} =
@var{pluginsymbol}}.

@samp{@var{anything}} can be ``anything'' but you may not use the same
@samp{@var{anything}} twice.  It has no special meaning.
@samp{@var{pluginsymbol}} is the symbol the author has chosen for the plug-in,
for example @samp{crystalspace.graphics3d.software}.  It is a synonym for the
implementation of the main plug-in interface.

The other way is to call
@code{@var{YourSysDriver}->RequestPlugin("@var{pluginsymbol}")} before calling
@code{Initialize()}.

@item
How can I query the plug-in interface?

You can use @code{QUERY_INTERFACE(@var{YourSysDriver},@var{iSomething})} to
get a pointer to the global instance of the plug-in (as a pointer to its
interface, of course).  Returns @samp{NULL} on failure.

@item
Conclusion

To sum it up, @sc{scf} is mainly used to provide common interfaces for
@sc{dll}s, but it can also be used by statically linked libraries.  If you
want to know how to write a plug-in yourself, you should read the @sc{scf}
documentation.  @xref{SCF}.
@end itemize

For further information about modules and plug-in drivers, see the sections on
project anatomy (@pxref{Anatomy}) and plug-in modules (@pxref{Plug-In
Drivers}).

Now that you have learned some basics about the Crystal Space environment, you
can try writing your first program.
