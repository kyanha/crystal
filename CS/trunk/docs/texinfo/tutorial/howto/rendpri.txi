@c -*-texinfo-*-
@node HOWTO Render Priorities, HOWTO CS Project, HOWTO Pixmaps, HOWTO
@subsection Render Priorities and Objects in Sectors
@cindex @code{iMeshWrapper}
@cindex mesh objects
@cindex render priorities
@cindex z-buffer mode
@cindex @code{csSector}
@cindex @code{iSector}
@cindex @code{iMovable}

Since 0.19 there are some extra concepts that can be used for organizing
how objects in a sector have to be rendered. In this section the basic
rendering algorithm is explained. This is a more theoretical explanation.
Later some examples are given of some commonly used configurations.

@subsubheading Meshes and Sectors

One of the most fundamental concepts in Crystal Space is a sector (class
@code{csSector} or interface @code{iSector}). A sector is basically empty
space which needs to be filled with geometry. In Crystal Space 0.18 or
older a sector could also contain geometry (i.e. the sector walls) but
since 0.19 this is no longer possible (nor needed).

To put geometry in a sector you use one or more mesh objects
(@pxref{MeshObject}).  Note that a mesh object can also be in several sectors
at once.  This happens when some object is busy traversing some portal from one
sector to another.  The list of sectors that a mesh object is in and also the
position (i.e. transform) is kept by an instance of @code{iMovable}
(@pxref{HOWTO Mesh Movement}).

@subsubheading Render Priorities

The engine supports the notion of render priorities. There is usually
a limited set of render priority slots available. By default these are:

@enumerate
@item
@samp{sky}
@item
@samp{wall}
@item
@samp{object}
@item
@samp{alpha}
@end enumerate

But you can setup your own render priorities. Objects which are in a lower
render priority (i.e. @samp{sky} is lower than @samp{wall}) will be rendered
before objects with a higher priority. So using the render priority system
you can choose in which order to render objects.

To set up render priorities from within a map file you can use the
following construct:

@example
RENDERPRIORITIES (
  PRIORITY 'sky' (1,NONE)
  PRIORITY 'wall' (2,NONE)
  PRIORITY 'object' (3,NONE)
  PRIORITY 'alpha' (4,BACK2FRONT)
)
@end example

This example sets up the render priorities like they are by default.
The first number for every render priority is the priority itself. This
should be a low number to avoid having a render priority table that grows
too big (every sector will have such a table). The second parameter is
a keyword that indicates the order in which objects of that priority
will be rendered. By default this is @samp{NONE} which means no special
sorting will happen. At this moment no other options are implemented
but in the future you will be able to choose from:

@itemize
@item
@samp{NONE}: no sorting
@item
@samp{BACK2FRONT}: back to front (as seen from camera)
@item
@samp{FRONT2BACK}: front to back
@item
@samp{MATERIAL}: sort on material (for more efficient rendering)
@end itemize

For the @samp{alpha} render priority (which is usually used by transparent
objects) you should use @samp{BACK2FRONT}.

To set up render priorities from within your application you can use
the following:

@example
  engine->RegisterRenderPriority ("wall", 2);
@end example

This will setup a render priority named @samp{wall} with numeric value 2.
If there is already a render priority with that name then the render priority
will be replaced. The engine will keep track of the render priorities named
@samp{wall}, @samp{sky}, @samp{object}, and @samp{alpha}.

To set the render priority for an object you can use the following
in a map file:

@example
  MESHOBJ 'myObject' (
    PLUGIN ('...')
    PARAMS (...)
    PRIORITY ('object')
  )
@end example

To set the render priority from within the code you can do:

@example
  iMeshWrapper* mesh;
  mesh->SetRenderPriority (engine->GetRenderPriority ("object"));
@end example

By default objects will be put in the @samp{object} render queue.

@subsubheading Z-Buffer Render Mode

In addition to render priorities you can also choose how the object
will be renderer with regards to the Z-buffer. There are four possibilities:

@itemize
@item
@samp{ZUSE}: use the Z-buffer to see where the object has to be rendered and
also update the Z-buffer wherever the object is actually rendered.
@item
@samp{ZFILL}: only update the Z-buffer where the object is rendered but don't
check against the existing Z-buffer contents.
@item
@samp{ZTEST}: use the Z-buffer to see where the object has to be rendered
but don't update the Z-buffer.
@item
@samp{ZNONE}: don't update or read the Z-buffer when rendering this object.
@end itemize

To set the Z-buffer mode from a map file you can do the following:

@example
  MESHOBJ 'myObject' (
    PLUGIN ('...')
    PARAMS (...)
    PRIORITY ('object')
    ZUSE ()
  )
@end example

To set the Z-buffer mode from the code you can use the following example:

@example
  iMeshWrapper* mesh;
  mesh->SetZBufMode (CS_ZBUF_USE);
@end example

@samp{ZUSE} is the default Z-buffer mode for objects created from within
an application.

By using the z-buffer mode in combination with the render priorities we
now have a very powerful system to control object rendering in a sector.
In the following sections we will show some popular examples. But first
we show in a table what the common usage is of the render priorities in
combination with the Z-buffer modes:

@itemize
@item
@samp{sky}: This render priority is used for rendering the object that
represents the sky. This can be a skybox, or a skydome, or something else.
Usually these objects have @samp{ZNONE} or @samp{ZFILL} render mode. If
you want to use @samp{ZNONE} you have to make sure that the Z-buffer
is cleared every frame.
@item
@samp{wall}: Sector walls are put in this queue. They are usually rendered
using @samp{ZFILL}.
@item
@samp{object}: After sector walls the normal objects are rendered. Usually
these have @samp{ZUSE} Z-buffer mode.
@item
@samp{alpha}: Transparent objects need to be rendered after all other
objects (and in back to front render mode as seen from the camera). The
best Z-buffer mode for these kinds of objects is @samp{ZTEST}.
@end itemize

@subsubheading Multiple Layers of Sky

The @samp{sky} render priority queue is really only suitable for one sky layer
(i.e. one skybox or one skydome). But it is possible to have two or more
layers by using multiple sky priority queues (i.e. @samp{sky1} and
@samp{sky2}). In the first sky queue you put an object with @samp{ZFILL}
or @samp{ZNONE} Z-buffer mode. In the second sky queue you put a
semi-transparent object using @samp{ZNONE} mode (there is no need to either
check or update the Z-buffer for the second object).

Note that sky objects are usually created with the @samp{CAMERA} keyword
(in map file) or the @code{CS_ENTITY_CAMERA} flag (in
@code{iMeshWrapper::GetFlags()}). The camera keyword makes sure that the
camera will always be in the center of that object. So you can move forever
in some direction without ever reaching the bounds of the sky.

@subsubheading Include Files

The include files useful for this section are:

@example
  #include "iengine/mesh.h"
  #include "iengine/sector.h"
  #include "iengine/engine.h"
  #include "ivideo/graph3d.h"
@end example

