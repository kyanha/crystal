@c -*-texinfo-*-
@node HOWTO Create Your Own Plugin, HOWTO Simple Map Example, HOWTO Setting the CRYSTAL environment variable, HOWTO
@subsection Create Your Own Plugin

Making a plugin in Crystal Space is not very hard but nevertheless
there are still a few issues that are often forgotten. Here in this
article we show you how you can write a simple plugin and use
it in your application.

@subsubheading Defining your Plugin @sc{api}

The first thing that you need to do when making a plugin is to define the
@sc{api} for it.  The @sc{api} is what your application is going to use to talk
to the plugin.  It is the interface to the plugin so it is very important to
get this right.  In the Crystal Space framework the Shared Class Facility
(@pxref{SCF}) is used to define the @sc{api}.  With this facility you create an
abstract interface containing only the methods from the @sc{api}.  An abstract
class in C++ means that all methods are pure virtual.  This means that no
implementation is given; only method declarations.  The implementation will
come later in the code of the plugin.

This concept is completely analogous to the Java interface mechanism.  The
advantage of using this paradigm is that you have a clear separation between
the @sc{api} and the implementation.  This allows one to easily replace an
implementation of some @sc{api} or even provide multiple implementations (for
example, the software and OpenGL renderers are two implementations of the same
3D rendering @sc{api}).

Here is the @sc{api} definition for our sample plugin:

@example
#ifndef __GAME_MYAPI_H__
#define __GAME_MYAPI_H__

#include "csutil/scf.h"

class csVector3;

SCF_VERSION (iMyApi, 0, 0, 1);

/**
 * This is the API for our plugin. It is recommended
 * that you use better comments than this one in a
 * real situation.
 */
struct iMyApi : public iBase
@{
/// Do something.
virtual void DoSomething (int param, const csVector3& v) = 0;
/// Get something.
virtual int GetSomething () const = 0;
@};

#endif // __GAME_MYAPI_H__
@end example

The above text should be put in a header file. Let's put it in
@file{myapi.h}.

First we include @file{csutil/scf.h}. This is a Crystal Space header
for @sc{scf} which we need to get the definition of @samp{iBase} and the
definition of the @code{SCF_VERSION()} macro.

Then we declare @samp{csVector3} as a class. We do this so that we
can later use @samp{csVector3} as a parameter in one of the @sc{api} methods.
We do not need the complete definition of @samp{csVector3} since we
are going to define the method so that it passes the vector by
reference.

After this we use the @code{SCF_VERSION()} macro to define the version
of this interface. This versioning can be used to query for
specific versions of an interface. This can be useful later when you
want to extend the @sc{api} without breaking existing apps. The version
has three parts: major, minor, and micro.

Finally we define the @sc{api} by making a structure that inherits from
@samp{iBase}.  We use @samp{struct} instead of @samp{class} simply because, for
structures, the default visibility is @samp{public} instead of @samp{private}
as for classes.  This is just a convenience.  There is no other difference
between a @samp{struct} or a @samp{class} in C++.

The name @samp{iMyApi} is not random.  Crystal Space uses this naming
convention (starting a name with @samp{i}) for @sc{scf} interfaces so that it
is easy to see that they refer to @sc{scf} interfaces.

We inherit from @samp{iBase} because it is the basis of all @sc{scf}
interfaces.  All @sc{scf} interfaces must inherit from @samp{iBase} either
directly or indirectly.  This will ensure that we have reference counting (more
on that later) and also takes care of the other internal @sc{scf} issues.

In that structure we define two methods: @code{DoSomething()} and
@code{GetSomething()}. Note that every method is defined as follows:

@example
virtual @dots{} = 0;
@end example

The @samp{= 0} means that we will not give an implementation here. The
implementation will be provided by the plugin (see later).

Note that it is good practice to use @samp{const} wherever applicable.  In the
declaration of @code{GetSomething()} we added @samp{const} at the end to
indicate that this method will not change the object.  This is useful for two
reasons:

@enumerate
@item 
It serves as documentation for the @sc{api} user.
@item 
A good compiler might be able to do some optimizations if it knows that the
method will not modify the object.
@end enumerate

@subsubheading Creating the Plugin Implementation (header)

After you defined the @sc{api} for your plugin it is now time to actually
make the plugin implementation. First you define a header called
@file{myplug.h} with the following contents:

@example
#ifndef __GAME_MYPLUG_H__
#define __GAME_MYPLUG_H__

#include "iutil/comp.h"
#include "csgeom/vector3.h"
#include "myapi.h"

struct iObjectRegistry;

/**
* This is the implementation for our API and
* also the implementation of the plugin.
*/
class MyPlugin : public iMyApi
@{
private:
  iObjectRegistry* object_reg;
  csVector3 store_v;

public:
  SCF_DECLARE_IBASE;

  MyPlugin (iBase* parent);
  virtual ~MyPlugin ();
  bool Initialize (iObjectRegistry* iobject_reg);

  virtual void DoSomething (int param, const csVector3& v);
  virtual int GetSomething () const;

  struct Component : public iComponent
  @{
    SCF_DECLARE_EMBEDDED_IBASE (MyPlugin);
    virtual bool Initialize (iObjectRegistry* object_reg)
      @{ return scfParent->Initialize (object_reg); @}
  @} scfiComponent;
@};

#endif // __GAME_MYPLUG_H__
@end example

This requires a little explanation.  The Crystal Space plugin framework
requires that every @dfn{named} @sc{scf} class which will be requested by name
from a plugin module via the Crystal Space @dfn{plugin manager/loader} must
implement the @samp{iComponent} interface.  This interface has a single method,
@code{Initialize()}, with which the class will be initialized after it is
instantiated.  This gives the instance a chance to perform various
initialization operations and it also provides the instance with a pointer to
the global object registry.

But, our plugin also needs to implement its own native @samp{iMyApi} interface.
So here is a situation where the same class needs to implement two interfaces
at the same time.  There are basically two ways to do this: multiple
inheritance, or via use of an embedded @sc{scf} class.  We use the second case
here since it tends to be more portable and works better with older compilers
which have trouble supporting multiple inheritance.

In the example above the class @samp{MyPlugin} inherits from
@samp{iMyApi}. The methods from @samp{iMyApi} are implemented directly in
@samp{MyPlugin}. To do that the method declarations from @samp{iMyApi} are
copied to @samp{MyPlugin} except that the @samp{= 0} is removed. To indicate
that this class represents an implementation of an @sc{scf} interface
we additionally need the @code{SCF_DECLARE_IBASE()} macro. This macro
will take care of declaring the @code{DecRef()} and @code{IncRef()} functions
to take care of reference counting. In addition the macro also
declares @code{QueryInterface()} so that it is possible to request
other interfaces (like @samp{iComponent)} from this class. You don't need
to worry much about this.

Note that @samp{MyPlugin} needs a constructor that accepts an @samp{iBase*}
parameter. Otherwise @sc{scf} will not be able to intantiate this class.

To implement @samp{iComponent} we add an inner class called @samp{Component}.
This new class will inherit directly from @samp{iComponent} which allows
@samp{MyPlugin} to implement @samp{iComponent} indirectly.  Since this is an
embedded interface we now need the @code{SCF_DECLARE_EMBEDDED_IBASE()} macro.
This macro takes care of the fact that this interface actually belongs to the
parent class (which is given as a parameter).  One thing it does is declare a
variable of type @samp{MyPlugin} which is called @samp{scfParent}.  Through
that variable the method implementations of the embedded interface can access
the main class.  After declaring the class @samp{Component} we immediately
create an instance of this called @samp{scfiComponent}.  You can call it
whatever you like.  This name is just a convention in Crystal Space.

Sometimes embedded classes are also made friend of the main
class so that they can access the private information. In this case
this is not needed. The only thing that @samp{Component} has is an
@code{Initialize()} method which immediately transfers control to
the parent's @code{Initialize()} method.

@subsubheading Creating the Plugin Implementation (source)

Now we create the main source file containing the implementation
of our plugin. Let's call this @file{myplug.cpp}:

@example
#include "cssysdef.h"
#include "myplug.h"
#include "iutil/objreg.h"
#include "iutil/plugin.h"

CS_IMPLEMENT_PLUGIN

SCF_IMPLEMENT_IBASE (MyPlugin)
  SCF_IMPLEMENTS_INTERFACE (iMyApi)
  SCF_IMPLEMENTS_EMBEDDED_INTERFACE (iComponent)
SCF_IMPLEMENT_IBASE_END

SCF_IMPLEMENT_EMBEDDED_IBASE (MyPlugin::Component)
  SCF_IMPLEMENTS_INTERFACE (iComponent)
SCF_IMPLEMENT_EMBEDDED_IBASE_END

SCF_IMPLEMENT_FACTORY (MyPlugin)

MyPlugin::MyPlugin (iBase* parent)
@{
  SCF_CONSTRUCT_IBASE (parent);
  SCF_CONSTRUCT_EMBEDDED_IBASE (scfiComponent);
  object_reg = 0;
@}

MyPlugin::~MyPlugin ()
@{
  SCF_DESTRUCT_EMBEDDED_IBASE (scfiComponent);
  SCF_DESTRUCT_IBASE ();
@}

bool MyPlugin::Initialize (iObjectRegistry* iobject_reg)
@{
  object_reg = iobject_reg;
  return true;
@}

void MyPlugin::DoSomething (int param, const csVector3& v)
@{
  // Just some behavior.
  if (param == 1)
    store_v = v;
  else
    store_v = -v;
@}

int MyPlugin::GetSomething () const
@{
  return (int)store_v.x + (int)store_v.y + (int)store_v.z;
@}

@end example

The first macro is @code{CS_IMPLEMENT_PLUGIN()}. This indicates to the
@sc{Crystal Space} framework that this module will end up as a plugin
(as opposed to an application or library). On some platforms this
actually makes a difference; on others it does not.  For best portability,
you should use this macro in exactly one C++ file within each plugin
module.

The first @code{SCF_IMPLEMENT_IBASE()} describes what interfaces the class
@samp{MyPlugin} implements.  This section says that @samp{MyPlugin} implements
@samp{iMyApi} directly and @samp{iComponent} through embedding.

The second @code{SCF_IMPLEMENT_EMBEDDED_IBASE()} lists the interfaces
implemented by the class @samp{MyPlugin::Component} (the embedded class).
@samp{MyPlugin::Component} only implements @samp{iComponent}.

It is important to correctly use the above macros.  These macros will ensure
that the implementation for @code{IncRef()}, @code{DecRef()}, and
@code{QueryInterface()} are provided by your custom class.

The @code{SCF_IMPLEMENT_FACTORY()} says that C++ class @samp{MyPlugin}
represents an @sc{scf} factory which allows @sc{scf} to instantiate objects of
this class.  In addition to some other administrative tasks, this macro defines
a function capable of instantiating an object of class @samp{MyPlugin}.  Note
that one plugin module can in fact define several distinct @sc{scf} classes.
In that case you need multiple @code{SCF_IMPLEMENT_FACTORY()} lines; one for
each @sc{scf} class.

@code{SCF_IMPLEMENT_@dots{}()} and @code{SCF_IMPLEMENT_FACTORY()}) are general
@sc{scf} macros.  As such they are not specifically related to plugin modules;
but rather help to define @sc{scf} classes.

In the constructor of @samp{MyPlugin} you must call
@code{SCF_CONSTRUCT_IBASE()} for the main interface and
@code{SCF_CONSTRUCT_EMBEDDED_IBASE()} for each embedded interface.  These
macros will ensure that the object is initialized correctly (i.e. reference
count set to 1 and so on).  Likewise, in the destructor, you must call the
corresponding @code{SCF_DESTRUCT_IBASE()} and
@code{SCF_DESTRUCT_EMBEDDED_IBASE()} macros.

The rest of the plugin is very straightforward. It is important
to realize that you should do most initialization of the plugin
in the @code{Initialize()} function and not in the constructor. The reason
for this is that at construction time you cannot depend on the entire
Crystal Space framework being ready. Also when @code{Initialize()} is
called you get a pointer to the object registry which is essential
for locating other modules and plugins loaded by the Crystal Space
framework.

This should conclude the implementation of the plugin.

@subsubheading Telling @sc{scf} About Your Plugin

@sc{scf} discovers plugins automatically and dynamically.  It determines which
plugin modules implement which @sc{scf} classes by consulting meta-information
associated with each plugin.  The meta-information file for your plugin must
have the same basename as your built plugin module, but with extension
@file{.csplugin}.  For instance, if the example plugin is built with the name
@file{myplugin.dll} (Windows) or @file{myplugin.so} (Unix), then the associated
meta-information file should be named @file{myplugin.csplugin}.  The
meta-information file is a structured @sc{xml}-format document, and can contain
any information relevant to the plugin module.  @sc{scf} expects to find a node
named @samp{scf}, which contains @sc{scf}-related information about the plugin
module.

The @file{myplugin.csplugin} meta-information file for our example plugin module
might look like this:

@example
<?xml version="1.0"?>
<!-- myplugin.csplugin -->
<plugin>
  <scf>
    <classes>
      <class>
        <name>crystalspace.mygame.myplugin</name>
        <implementation>MyPlugin</implementation>
        <description>My Special Game Plugin</description>
        <requires>
          <class>crystalspace.graphics3d.</class>
        </requires>
      </class>
    </classes>
  </scf>
</plugin>
@end example

@noindent
Each @sc{scf} class exported by the plugin should be presented in a
@code{<class>} node within the @code{<classes>} group.  Each class has a
@code{<name>}, which is the @sc{scf} name of the class; an
@code{<implementation>}, which is the name of the C++ class implementing the
@sc{scf} class; a @code{<description>}; and optionally a @code{<requires>}
node, which lists the other @sc{scf} classes upon which this class depends.
Any number of classes may appear in the @code{<requires>} group.  If your
plugin depends only upon a certain type of class, rather than a specific
@sc{scf} class, then you list only the prefix portion of the desired class
type, as shown in this example (where we desire any 3D renderer).

@subsubheading Compiling the Plugin

Depending on the compiler that you use I refer you to the
@sc{howto}'s on the subject of compiling an external application. There
is a template makefile provided which also works for plugins. That's
by far the easiest way to get this compiled.

@subsubheading Loading the Plugin in your Application

First include the header defining the @sc{api} of the plugin:

@example
#include "myapi.h"
@end example

Do @emph{not} include the @file{myplug.h} header file! This is implementation
specific and you should not use the implementation of the plugin
directly. Doing this invalidates the entire reason to use plugins
in the first place.

To load the plugin there are a few possibilities. First you
can load the plugin manually using @code{CS_LOAD_PLUGIN()} like this:

@example
csRef<iPluginManager> plugin_mgr = 
  CS_QUERY_REGISTRY (object_reg, iPluginManager);
csRef<iMyApi> myapi = CS_LOAD_PLUGIN (plugin_mgr,
  "crystalspace.mygame.myplugin", iMyApi);        
@end example

This will query the plugin manager from the object registry.
This is the module that is responsible for loading and unloading
plugins.

Then it will use the plugin manager to load your plugin. Note that
this can fail. You should always check the returned value to see if
it is different from @samp{0}.

Another way to load the plugin is through @code{RequestPlugins()} which
is called at initialization time:

@example
if (!csInitializer::RequestPlugins (object_reg,
     CS_REQUEST_VFS,
     CS_REQUEST_SOFTWARE3D,
     CS_REQUEST_ENGINE,
     @dots{}
     CS_REQUEST_PLUGIN("crystalspace.mygame.myplugin", iMyApi),
     CS_REQUEST_END))
@{
  @dots{}
@}
@dots{}

csRef<iMyApi> myapi = CS_QUERY_REGISTRY (object_reg, iMyApi);
@end example

This way has several advantages.  First it makes sure that the user can
override your plugin at the command line or in the configuration file (if you
have one for your game).  In cases where there are multiple possible
implementations for the same @sc{api} this can be important.  It is by doing
this that it is possible to switch between software and OpenGL renderers with
the command line or via configuration file.

Secondly it registers the plugin with the object registry so that
it is easier to find your module later. This way other plugins
can find your plugin by doing a query on the object registry.

@subsubheading Using the Plugin in Your Application

After loading the plugin you can use the plugin by just
calling the methods defined in the @sc{api}:

@example
myapi->DoSomething (1, csVector3 (2, 3, 4));
printf ("%d\n", myapi->GetSomething ());
@end example

This should print out 9.
