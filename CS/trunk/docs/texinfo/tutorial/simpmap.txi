@c -*-texinfo-*-
@node Tutorial Simple Map, map2cs Tutorial, Tutorial Simple 2, Tutorials
@section Simple Tutorial 3: Map Loading
@cindex Tutorial, Simple
@cindex Simple Tutorial

This tutorial continues on tutorial one. Here we will learn how to
load a level from a map file instead of creating the geometry
programmatically.

@menu
* Simple Base Code:: Minimal Base Code
* Simple Loading The Map:: Loading The Map
* Simple Locating the Camera:: Locating the Camera
@end menu

@node Simple Base Code, Simple Loading The Map, Tutorial Simple Map, Tutorial Simple Map
@subsection Minimal Base Code

To start, we first take the code of tutorial one
and remove the code that creates geometry and initializes
the default camera position. In addition we add a new @code{LoadMap()}
function. This results in the following for @file{simpmap.h}:

@example
#ifndef __SIMPMAP_H__
#define __SIMPMAP_H__

#include <crystalspace.h>

class Simple
  : public csApplicationFramework, public csBaseEventHandler
@{
private:
  csRef<iEngine> engine;
  csRef<iLoader> loader;
  csRef<iGraphics3D> g3d;
  csRef<iKeyboardDriver> kbd;
  csRef<iVirtualClock> vc;
  iSector* room;
  csRef<iView> view;
 
  bool OnKeyboard (iEvent&);
  void ProcessFrame ();
  void FinishFrame ();
  bool LoadMap ();

public:
  Simple (iObjectRegistry* object_reg);
  ~Simple ();

  void OnExit ();
  bool OnInitialize (int argc, char* argv[]);
  bool Application ();
@};

#endif // __SIMPMAP_H__
@end example

Similarly for @file{simpmap.cpp}:

@example
#include "simpmap.h"

CS_IMPLEMENT_APPLICATION

Simple::Simple (iObjectRegistry* object_reg)
@{
  SetApplicationName ("Simple Map");
@}

Simple::~Simple ()
@{
@}

void Simple::ProcessFrame ()
@{
  // First get elapsed time from the virtual clock.
  csTicks elapsed_time = vc->GetElapsedTicks ();
  
  // Now rotate the camera according to keyboard state
  float speed = (elapsed_time / 1000.0) * (0.03 * 20);

  iCamera* c = view->GetCamera();
  if (kbd->GetKeyState (CSKEY_RIGHT))
    c->GetTransform ().RotateThis (CS_VEC_ROT_RIGHT, speed);
  if (kbd->GetKeyState (CSKEY_LEFT))
    c->GetTransform ().RotateThis (CS_VEC_ROT_LEFT, speed);
  if (kbd->GetKeyState (CSKEY_PGUP))
    c->GetTransform ().RotateThis (CS_VEC_TILT_UP, speed);
  if (kbd->GetKeyState (CSKEY_PGDN))
    c->GetTransform ().RotateThis (CS_VEC_TILT_DOWN, speed);
  if (kbd->GetKeyState (CSKEY_UP))
    c->Move (CS_VEC_FORWARD * 4 * speed);
  if (kbd->GetKeyState (CSKEY_DOWN))
    c->Move (CS_VEC_BACKWARD * 4 * speed);

  // Tell 3D driver we're going to display 3D things.
  if (!g3d->BeginDraw(
    engine->GetBeginDrawFlags() | CSDRAW_3DGRAPHICS))
    return;

  // Tell the camera to render into the frame buffer.
  view->Draw ();
@}

void Simple::FinishFrame ()
@{
  g3d->FinishDraw ();
  g3d->Print (0);
@}

bool Simple::OnKeyboard(iEvent& ev)
@{
  csKeyEventType eventtype = csKeyEventHelper::GetEventType(&ev);
  if (eventtype == csKeyEventTypeDown)
  @{
    utf32_char code = csKeyEventHelper::GetCookedCode(&ev);
    if (code == CSKEY_ESC)
    @{
      csRef<iEventQueue> q = 
        CS_QUERY_REGISTRY(GetObjectRegistry(), iEventQueue);
      if (q.IsValid()) q->GetEventOutlet()->Broadcast(cscmdQuit);
    @}
  @}
  return false;
@}

bool Simple::Initialize ()
@{
  if (!csInitializer::RequestPlugins(GetObjectRegistry(),
    CS_REQUEST_VFS,
    CS_REQUEST_OPENGL3D,
    CS_REQUEST_ENGINE,
    CS_REQUEST_FONTSERVER,
    CS_REQUEST_IMAGELOADER,
    CS_REQUEST_LEVELLOADER,
    CS_REQUEST_REPORTER,
    CS_REQUEST_REPORTERLISTENER,
    CS_REQUEST_END))
    return ReportError("Failed to initialize plugins!");

  if (!RegisterQueue(GetObjectRegistry()))
    return ReportError("Failed to set up event handler!");

  return true;
@}

bool Simple::Application()
@{
  if (!OpenApplication(GetObjectRegistry()))
    return ReportError("Error opening system!");

  g3d = CS_QUERY_REGISTRY(GetObjectRegistry(), iGraphics3D);
  if (!g3d) return ReportError("Failed to locate 3D renderer!");

  engine = CS_QUERY_REGISTRY(GetObjectRegistry(), iEngine);
  if (!engine) return ReportError("Failed to locate 3D engine!");

  vc = CS_QUERY_REGISTRY(GetObjectRegistry(), iVirtualClock);
  if (!vc) return ReportError("Failed to locate Virtual Clock!");

  kbd = CS_QUERY_REGISTRY(GetObjectRegistry(), iKeyboardDriver);
  if (!kbd) return ReportError("Failed to locate Keyboard Driver!");

  loader = CS_QUERY_REGISTRY(GetObjectRegistry(), iLoader);
  if (!loader) return ReportError("Failed to locate Loader!");

  view = csPtr<iView> (new csView (engine, g3d));
  iGraphics2D* g2d = g3d->GetDriver2D ();
  view->SetRectangle (0, 0, g2d->GetWidth (), g2d->GetHeight ());

  Run();

  return true;
@}

/*---------------*
 * Main function
 *---------------*/
int main (int argc, char* argv[])
@{
  return Simple().Main(argc, argv);
@}
@end example

One important note in the code above: we removed the following line:

@example
engine->SetLightingCacheMode (0);
@end example

That's because when we are loading from map file we actually want
the lighting information to be read from the cache (if present).
That's because relighting a map can be a time-consuming process.

@node Simple Loading The Map, Simple Locating the Camera, Simple Base Code, Tutorial Simple Map
@subsection Loading The Map
@cindex loading a map
@cindex vfs
@cindex mount point

Here we add the code to load a map. In this example we will load the
@samp{flarge} map which is included with Crystal Space.

In the second tutorial we already mentioned @sc{vfs} (@pxref{VFS}). This
is important in this case too since we are going to load the map from
the virtual filesystem. To do this we first add the new @code{LoadMap()}
routine right before the @code{Initialize()} function:

@example
bool Simple::LoadMap ()
@{
  // Set VFS current directory to the level we want to load.
  csRef<iVFS> VFS (CS_QUERY_REGISTRY (object_reg, iVFS));
  VFS->ChDir ("/lev/flarge");
  // Load the level file which is called 'world'.
  if (!loader->LoadMapFile ("world"))
    ReportError("Error couldn't load level!");

  engine->Prepare ();

  return true;
@}
@end example

This code will first use @code{iVFS::ChDir()} to set the current
directory in the virtual file system to @file{/lev/flarge}. In the
case of @samp{flarge} this @sc{mount point} is already created in the
config file @file{vfs.cfg}. If this is not the case for your own levels
you can either modify @file{vfs.cfg} or else call @code{iVFS::Mount()}
to map a physical file path (can be a @sc{zip} archive file as well)
to a virtual directory.

The call to @code{iLoader::LoadMapFile()} will take the given filename
(in this case @file{world}) and open it from the current @sc{vfs}
directory. Then it will parse that file and create the geometry which
is specified there.

If this is successful then you must call @code{iEngine::Prepare()} to
make sure that all lightmaps are correctly loaded from the cache
and other necessary setup work is done (i.e. textures are registered
and so on).

We additionally change the last part of @code{Application()} to
this:

@example
bool Simple::Application ()
@{
  @dots{}

  view = csPtr<iView> (new csView (engine, g3d));
  iGraphics2D* g2d = g3d->GetDriver2D ();
  view->SetRectangle (0, 0, g2d->GetWidth (), g2d->GetHeight ());

  if (!LoadMap ()) return false;

  @dots{}
@}
@end example

So first we create our view but doesn't yet set the current sector.
@code{LoadMap()} will do that based on the loaded level.

@node Simple Locating the Camera, , Simple Loading The Map, Tutorial Simple Map
@subsection Locating the Camera

@samp{flarge} contains a number of sectors and various objects, and those
are now all loaded in memory. However this is not enough. We also have
to set the camera to some sector and position in that world. In the
previous tutorials we simply used the sector that we just created
and a fixed position in that sector (keep in mind that in Crystal
Space a position in space is always defined as a sector in combination
with a position). When loading a map we can't work that way because
we don't know which sectors are in the map (unless we make an application
that can only read one level, but that's not very flexible) and we
also don't know where we can safely put our camera. In the map files
it is possible to specify one or more starting positions. We will
query the engine for such a starting position and initialize our
view (camera) to that. This happens with the following code which you should
add after @code{engine->Prepare()} in @code{LoadMap()}:

@example
  @dots{}

  // Find the starting position in this level.
  csVector3 pos (0, 0, 0);
  if (engine->GetCameraPositions ()->GetCount () > 0)
  @{
    // There is a valid starting position defined in the level file.
    iCameraPosition* campos = engine->GetCameraPositions ()->Get (0);
    room = engine->GetSectors ()->FindByName (campos->GetSector ());
    pos = campos->GetPosition ();
  @}
  else
  @{
    // We didn't find a valid starting position. So we default
    // to going to room called 'room' at position (0,0,0).
    room = engine->GetSectors ()->FindByName ("room");
  @}
  if (!room)
    ReportError("Can't find a valid starting position!");

  view->GetCamera ()->SetSector (room);
  view->GetCamera ()->GetTransform ().SetOrigin (pos);

  return true;
@}
@end example

First, we see how many camera positions there were defined in the
map by using @code{iEngine::GetCameraPositionCount()}. If this is 0
then the map didn't define a starting position. In that case we will
assume there is a sector called 'room' and we will start the camera
at (0,0,0) in that sector. But otherwise we will use the first
starting position defined in the map.

This is all. After adding this code this application will now load
the @samp{flarge} map and display it so you can run around in this level.
