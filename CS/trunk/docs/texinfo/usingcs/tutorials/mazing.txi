@c -*-texinfo-*-
@node Tutorial Mazing, , Tutorial Simple Map, Tutorials
@subsection Mazing Tutorial: Small Game
@cindex Tutorial, Mazing
@cindex Mazing Tutorial

This tutorial is a small but complete game with a maze generated by
code and four spheres that you have to shoot with your laser beam.
It is assumed you already know most of the basics by reading the Simple
Tutorial first (@pxref{Tutorial Simple}). You can find the full source code
of this tutorial in the @file{apps/tutorial/mazing} directory and you can
build it in Crystal Space using @samp{make mazing} or @samp{jam mazing}.

This tutorial features (besides things mentioned in the previous tutorials):
@itemize @bullet
@item
Creating a maze in code by using sectors (@code{iEngine::CreateSector()}, filled
with walls (@code{iEngine::CreateSectorWallsMesh()}), and connected through
portals (@code{iEngine::CreatePortal()}).
@item
Creating genmesh mesh objects for the adversaries and the laserbeam
(@pxref{MeshObject Genmesh}).
@item
Creating particle mesh objects for explosions (@pxref{MeshObject PartSys}).
@item
Doing collision detection manually (@code{csColliderWrapper} and
@code{csColliderHelper}).
@item
Handling game objects attached to Crystal Space objects (@pxref{User Objects}).
@item
And a lot more small tiny details that are nice to know.
@end itemize

@menu
* Mazing Classes:: Class Distribution
* Mazing Constants:: Constants
* Mazing RoomCoordinate Class:: RoomCoordinate Class
* Mazing Maze Class:: Maze Class
* Mazing Player Class:: Player Class
@end menu

@node Mazing Classes, Mazing Constants, Tutorial Mazing, Tutorial Mazing
@subsubsection Class Distribution

In this tutorial we will divide the logic into several classes:

@itemize @bullet
@item
@code{AppMazing}: this is the main application class. It handles the Crystal Space
event stuff and also the main game logic. i.e. it ties everything together.
@item
@code{RoomCoordinate}: this is a small class that is used to represent a coordinate
in our maze. A coordinate is a three dimensional integer coordinate that represents
a node in our three dimensional maze.
@item
@code{Maze}: this class is the representation of the maze. i.e. the world
where the game happens. In this game we will make a three dimensional maze where
every node of the maze is a sector. This class keeps track of those sectors.
@item
@code{Player}: the player with the collider (collision detection) is managed
by this class. This class also takes care of player movement.
@item
@code{Adversary}: this is the enemy! Every enemy in the game will have an instance
of this class. This class also manages the @emph{very} primitive artificial
intelligence.
@item
@code{Explosion}: whenever an adversary explodes there will be an explosion. For
every explosion we have an instance of this class.
@item
@code{Laser}: the player can fire with a laserbeam. There is one instance of this
class which manages visibility and collision detection of the beam.
@end itemize

@node Mazing Constants, Mazing RoomCoordinate Class, Mazing Classes, Tutorial Mazing
@subsubsection Constants

There are several constants that we use in this game. By using constants it
is easier to change the behaviour. Even better would be to read these fields
from a configuration file but that is beyond the scope of this tutorial:

@example
// World defines.
#define ROOM_DIMENSION 10.0
#define MAZE_DIMENSION 3

// Adversary defines.
#define ADVERSARY_DIMENSION 1
#define ADVERSARY_MOVETIME 1.0

// Explosion defines.
#define EXPLOSION_EMITTIME 2000
#define EXPLOSION_PARTTIME 500
#define EXPLOSION_PARTVARTIME 100
#define EXPLOSION_TIME (EXPLOSION_PARTTIME+EXPLOSION_EMITTIME+EXPLOSION_PARTVARTIME)

// Laserbeam defines.
#define LASER_WIDTH 0.05
#define LASER_LENGTH 100.0
#define LASER_LIFETIME 300	// Milliseconds the laser will be visible.
#define LASER_FLICKTIME 20
#define LASER_OFFSET csVector3(0,-.5,0)

// Movement defines.
#define MOVE_DISTANCE 5.0	// In one keypress we will move this far.
#define STEP_DISTANCE 1.0	// Step size for collision detection along path.
#define MOVECAMERA_SPEED 5.0	// Speed with which we move the camera.
#define ROTATE_ANGLE 0.5	// How much we want to rotate in one keypress.
#define ROTATECAMERA_SPEED 3.0	// Speed to rotate with.
#define PLAYER_SIZE 2.0

// These numbers define the position of the specific portal
// for the CreateRoom() function.
#define PORTAL_UP 0
#define PORTAL_DOWN 1
#define PORTAL_LEFT 2
#define PORTAL_RIGHT 3
#define PORTAL_FRONT 4
#define PORTAL_BACK 5
@end example

@node Mazing RoomCoordinate Class, Mazing Maze Class, Mazing Constants, Tutorial Mazing
@subsubsection RoomCoordinate Class

This is a very simple class that keeps track of a coordinate in the maze:

@example
class RoomCoordinate
@{
public:
  int x, y, z;
  RoomCoordinate () : x (0), y (0), z (0) @{ @}
  RoomCoordinate (int x, int y, int z) : x (x), y (y), z (z) @{ @}
  RoomCoordinate (const RoomCoordinate& rc) : x (rc.x), y (rc.y), z (rc.z) @{ @}
# ifdef CS_DEBUG
  static bool IsValid (int x, int y, int z)
  @{
    return (x >= 0 && x < MAZE_DIMENSION &&
	    y >= 0 && y < MAZE_DIMENSION &&
	    z >= 0 && z < MAZE_DIMENSION);
  @}
  bool IsValid () const
  @{
    return IsValid (x, y, z);
  @}
# endif
@};
@end example

One special thing in this class is the usage of the @samp{CS_DEBUG} define.
When your application is compiled in debug mode this define will be set. This
means that you can do additional checks in debug mode that will disappear
in optimize/release mode. This is very useful during development.

@node Mazing Maze Class, Mazing Player Class, Mazing RoomCoordinate Class, Tutorial Mazing
@subsubsection Maze Class

The @code{Maze} class is responsible for managing the game world. To do that
it keeps track of a three dimensional grid of sectors. Every sector represents
a node in the maze (a room). Nodes are connected using portals. Here is the
class declaration:

@example
class Maze
@{
private:
  AppMazing* app;
  iSector* rooms[MAZE_DIMENSION][MAZE_DIMENSION][MAZE_DIMENSION];
  csArray<RoomCoordinate> connections[MAZE_DIMENSION][MAZE_DIMENSION]
  	[MAZE_DIMENSION];
  bool occupied[MAZE_DIMENSION][MAZE_DIMENSION][MAZE_DIMENSION];

public:
  Maze (AppMazing* app);

  iSector* GetSector (int x, int y, int z) const
  @{
    return rooms[x][y][z];
  @}
  iSector* GetSector (const RoomCoordinate& rc) const
  @{
    return rooms[rc.x][rc.y][rc.z];
  @}
  bool CreateSector (int x, int y, int z);

  const csArray<RoomCoordinate>& GetConnections (const RoomCoordinate& rc) const
  @{
    return connections[rc.x][rc.y][rc.z];
  @}

  void MakeConnection (const RoomCoordinate& from, const RoomCoordinate& to);

  void FreeSpace (const RoomCoordinate& rc);
  void OccupySpace (const RoomCoordinate& rc);
  bool IsSpaceFree (const RoomCoordinate& rc) const;

  bool CreateGeometry ();
  bool CreateWallOrPortal (iThingFactoryState* factory_state,
  	const csVector3& v1, const csVector3& v2,
  	const csVector3& v3, const csVector3& v4,
	bool do_portal,
	const RoomCoordinate& source,
	const RoomCoordinate& dest);
  bool CreateRoom (iMaterialWrapper* wall_material,
  	int x, int y, int z,
	char* portals);
  bool CreateLight (const csColor& color,
  	int x, int y, int z);
@};
@end example

The important data structures here are:

@itemize @bullet
@item
@samp{rooms}: this is a three dimensional arrays of pointers to @code{iSector}. Every
sector is a node of the three dimensional maze.
@item
@samp{connections}: this is a three dimensional array of arrays of connections.
Basically this means that for every node in the maze we keep an array (represented
using a dynamic @code{csArray}) that holds coordinates of other nodes that are
connected to this one.
@item
@samp{occupied}: to make things simple we avoid having more then one adversary
in a single node. This three dimensional array tells us if a certain node is
occupied or not.
@end itemize

The most important setup function in this class is @code{CreateGeometry()}. That
one will do the actual creation of the maze. It is called from within the main
applications @code{SetupGame()} method.

I will show here the code of the @code{Maze} class in parts.

@example
Maze::Maze (AppMazing* app)
@{
  Maze::app = app;
  int x, y, z;
  for (x = 0 ; x < MAZE_DIMENSION ; x++)
    for (y = 0 ; y < MAZE_DIMENSION ; y++)
      for (z = 0 ; z < MAZE_DIMENSION ; z++)
        occupied[x][y][z] = false;
@}

void Maze::MakeConnection (const RoomCoordinate& from, const RoomCoordinate& to)
@{
  CS_ASSERT (from.IsValid ());
  CS_ASSERT (to.IsValid ());
  connections[from.x][from.y][from.z].Push (to);
@}

void Maze::FreeSpace (const RoomCoordinate& rc)
@{
  CS_ASSERT (rc.IsValid ());
  occupied[rc.x][rc.y][rc.z] = false;
@}

void Maze::OccupySpace (const RoomCoordinate& rc)
@{
  CS_ASSERT (rc.IsValid ());
  occupied[rc.x][rc.y][rc.z] = true;
@}

bool Maze::IsSpaceFree (const RoomCoordinate& rc) const
@{
  CS_ASSERT (rc.IsValid ());
  return !occupied[rc.x][rc.y][rc.z];
@}
@end example

First there is the constructor which simply initializes the @samp{occupied}
table so that all nodes are free. @code{MakeConnection()} will make a connection
between two nodes. It is called during the creation of the world. The other
functions are for managing the occupied space used by adversaries.

The use of the @samp{CS_ASSERT} macro is interesting. This macro will evalulate
the expression and cause the program to abort (even print out a callstack)
at runtime when the expression is not true. That means that you can use this to
validate that things are as they should be. This macro only operates in debug mode.
If your program is compiled in optimize/release mode it will do nothing. So feel
free to use it as much as you can. It may help find bugs when the program is
compiled in debug mode.

@example
bool Maze::CreateSector (int x, int y, int z)
@{
  CS_ASSERT (RoomCoordinate::IsValid (x, y, z));
  char sector_name[100];
  sprintf (sector_name, "room_%d_%d_%d", x, y, z);
  rooms[x][y][z] = app->GetEngine ()->CreateSector (sector_name);
  return rooms[x][y][z] != 0;
@}

bool Maze::CreateWallOrPortal (iThingFactoryState* factory_state,
  	const csVector3& v1, const csVector3& v2,
  	const csVector3& v3, const csVector3& v4,
	bool do_portal,
	const RoomCoordinate& source,
	const RoomCoordinate& dest)
@{
  if (do_portal)
  @{
    iPortal* portal;
    csVector3 verts[4];
    verts[0] = v1;
    verts[1] = v2;
    verts[2] = v3;
    verts[3] = v4;
    csRef<iMeshWrapper> portal_mesh = app->GetEngine ()->CreatePortal (0,
    	GetSector (source), csVector3 (0, 0, 0),
	GetSector (dest),
    	verts, 4, portal);
    MakeConnection (source, dest);
    if (!portal_mesh)
      return app->ReportError ("Error creating portal mesh!");
  @}
  else
  @{
    factory_state->AddQuad (v1, v2, v3, v4);
  @}
  return true;
@}

bool Maze::CreateRoom (iMaterialWrapper* wall_material,
	int x, int y, int z, char* portals)
@{
  iSector* room = GetSector (x, y, z);
  csRef<iMeshWrapper> walls = app->GetEngine ()
  	->CreateSectorWallsMesh (room, "walls");
  if (!walls)
    return app->ReportError ("Couldn't create the walls for the room!");

  csRef<iThingState> object_state = scfQueryInterface<iThingState> (
  	walls->GetMeshObject ());
  csRef<iThingFactoryState> factory_state = scfQueryInterface<
  	iThingFactoryState> (walls->GetMeshObject ()->GetFactory ());
  float sx = float (x) * ROOM_DIMENSION;
  float sy = float (y) * ROOM_DIMENSION;
  float sz = float (z) * ROOM_DIMENSION;
  float rd = ROOM_DIMENSION / 2.0;
  csBox3 box (
  	csVector3 (sx-rd, sy-rd, sz-rd),
  	csVector3 (sx+rd, sy+rd, sz+rd));

  RoomCoordinate start_rc (x, y, z);
  if (!CreateWallOrPortal (factory_state, 
    	box.GetCorner (CS_BOX_CORNER_xYz),
    	box.GetCorner (CS_BOX_CORNER_XYz),
    	box.GetCorner (CS_BOX_CORNER_XYZ),
    	box.GetCorner (CS_BOX_CORNER_xYZ),
	portals[PORTAL_UP] == '#',
	start_rc, RoomCoordinate (x+0, y+1, z+0)))
    return false;
  if (!CreateWallOrPortal (factory_state,
    	box.GetCorner (CS_BOX_CORNER_xyZ),
    	box.GetCorner (CS_BOX_CORNER_XyZ),
    	box.GetCorner (CS_BOX_CORNER_Xyz),
    	box.GetCorner (CS_BOX_CORNER_xyz),
	portals[PORTAL_DOWN] == '#',
	start_rc, RoomCoordinate (x+0, y-1, z+0)))
    return false;
  if (!CreateWallOrPortal (factory_state,
    	box.GetCorner (CS_BOX_CORNER_XyZ),
    	box.GetCorner (CS_BOX_CORNER_xyZ),
    	box.GetCorner (CS_BOX_CORNER_xYZ),
    	box.GetCorner (CS_BOX_CORNER_XYZ),
	portals[PORTAL_FRONT] == '#',
	start_rc, RoomCoordinate (x+0, y+0, z+1)))
    return false;
  if (!CreateWallOrPortal (factory_state,
    	box.GetCorner (CS_BOX_CORNER_xyz),
    	box.GetCorner (CS_BOX_CORNER_Xyz),
    	box.GetCorner (CS_BOX_CORNER_XYz),
    	box.GetCorner (CS_BOX_CORNER_xYz),
	portals[PORTAL_BACK] == '#',
	start_rc, RoomCoordinate (x+0, y+0, z-1)))
    return false;
  if (!CreateWallOrPortal (factory_state,
    	box.GetCorner (CS_BOX_CORNER_xyZ),
    	box.GetCorner (CS_BOX_CORNER_xyz),
    	box.GetCorner (CS_BOX_CORNER_xYz),
    	box.GetCorner (CS_BOX_CORNER_xYZ),
	portals[PORTAL_LEFT] == '#',
	start_rc, RoomCoordinate (x-1, y+0, z+0)))
    return false;
  if (!CreateWallOrPortal (factory_state,
    	box.GetCorner (CS_BOX_CORNER_Xyz),
    	box.GetCorner (CS_BOX_CORNER_XyZ),
    	box.GetCorner (CS_BOX_CORNER_XYZ),
    	box.GetCorner (CS_BOX_CORNER_XYz),
	portals[PORTAL_RIGHT] == '#',
	start_rc, RoomCoordinate (x+1, y+0, z+0)))
    return false;

  factory_state->SetPolygonMaterial (CS_POLYRANGE_ALL, wall_material);
  factory_state->SetPolygonTextureMapping (CS_POLYRANGE_ALL, rd);

  return true;
@}

bool Maze::CreateLight (const csColor& color,
  	int x, int y, int z)
@{
  float sx = float (x) * ROOM_DIMENSION;
  float sy = float (y) * ROOM_DIMENSION;
  float sz = float (z) * ROOM_DIMENSION;
  csRef<iLight> light = app->GetEngine ()
  	->CreateLight (0, csVector3 (sx, sy, sz), ROOM_DIMENSION * 1.5, color);
  if (!light) return false;
  GetSector (x, y, z)->GetLights ()->Add (light);
  return true;
@}

bool Maze::CreateGeometry ()
@{
  // We don't need a lighting cache. Disable it.
  app->GetEngine ()->SetLightingCacheMode (0);

  // Load the texture we are going to use for all walls.
  if (!app->GetLoader ()->LoadTexture ("wall_texture", "/lib/std/stone4.gif"))
    return app->ReportError ("Error loading 'stone4' texture!");

  iMaterialWrapper* wall_material = app->GetEngine ()->GetMaterialList ()
  	->FindByName ("wall_texture");

  int x, y, z;
  for (x = 0 ; x < MAZE_DIMENSION ; x++)
    for (y = 0 ; y < MAZE_DIMENSION ; y++)
      for (z = 0 ; z < MAZE_DIMENSION ; z++)
        if (!CreateSector (x, y, z))
	  return false;

  if (!CreateRoom (wall_material, 0, 0, 0, "....#.")) return false;
  if (!CreateRoom (wall_material, 0, 0, 1, "....##")) return false;
  if (!CreateRoom (wall_material, 0, 0, 2, "#..#.#")) return false;
  if (!CreateRoom (wall_material, 1, 0, 0, "...##.")) return false;
  if (!CreateRoom (wall_material, 1, 0, 1, "....##")) return false;
  if (!CreateRoom (wall_material, 1, 0, 2, "..#..#")) return false;
  if (!CreateRoom (wall_material, 2, 0, 0, "#.#.#.")) return false;
  if (!CreateRoom (wall_material, 2, 0, 1, "....##")) return false;
  if (!CreateRoom (wall_material, 2, 0, 2, ".....#")) return false;

  if (!CreateRoom (wall_material, 0, 1, 0, "#..#..")) return false;
  if (!CreateRoom (wall_material, 0, 1, 1, "...##.")) return false;
  if (!CreateRoom (wall_material, 0, 1, 2, ".#.#.#")) return false;
  if (!CreateRoom (wall_material, 1, 1, 0, "..#.#.")) return false;
  if (!CreateRoom (wall_material, 1, 1, 1, "#.#..#")) return false;
  if (!CreateRoom (wall_material, 1, 1, 2, "..##..")) return false;
  if (!CreateRoom (wall_material, 2, 1, 0, ".#..#.")) return false;
  if (!CreateRoom (wall_material, 2, 1, 1, "....##")) return false;
  if (!CreateRoom (wall_material, 2, 1, 2, "#.#..#")) return false;

  if (!CreateRoom (wall_material, 0, 2, 0, ".#.#..")) return false;
  if (!CreateRoom (wall_material, 0, 2, 1, "...#..")) return false;
  if (!CreateRoom (wall_material, 0, 2, 2, "...#..")) return false;
  if (!CreateRoom (wall_material, 1, 2, 0, "..##..")) return false;
  if (!CreateRoom (wall_material, 1, 2, 1, ".###..")) return false;
  if (!CreateRoom (wall_material, 1, 2, 2, "..##..")) return false;
  if (!CreateRoom (wall_material, 2, 2, 0, "..#...")) return false;
  if (!CreateRoom (wall_material, 2, 2, 1, "..#...")) return false;
  if (!CreateRoom (wall_material, 2, 2, 2, ".##...")) return false;

  if (!CreateLight (csColor (1, 0, 0), 0, 0, 0)) return false;
  if (!CreateLight (csColor (0, 0, 1), 0, 0, 2)) return false;
  if (!CreateLight (csColor (0, 1, 0), 1, 0, 1)) return false;
  if (!CreateLight (csColor (1, 1, 0), 1, 1, 1)) return false;
  if (!CreateLight (csColor (0, 1, 1), 0, 1, 1)) return false;
  if (!CreateLight (csColor (1, 1, 1), 2, 1, 2)) return false;
  if (!CreateLight (csColor (1, 0, 0), 1, 2, 1)) return false;
  if (!CreateLight (csColor (0, 0, 1), 0, 2, 0)) return false;
  if (!CreateLight (csColor (0, 1, 0), 2, 2, 0)) return false;

  return true;
@}
@end example

These functions create the actual geometry of the world. The main function
here is @code{CreateGeometry()}. This function will first load the wall texture
and then it will create all the sectors for the maze. After that it will call
@code{CreateRoom()} to create one of the nodes in the maze. The final parameter
of @code{CreateRoom()} is a string describing the connections to neighbour
nodes. Finally this function will also create a few lights using the
@code{CreateLight()} method.

The @code{CreateRoom()} function will create one thing mesh (@pxref{MeshObject Thing})
for the solid walls and then it will use @code{iEngine::CreatePortal()} to create
the individual portals to neighbour nodes wherever there needs to be a connection.
This is done in the @code{CreateWallOrPortal()} function. This function will
either add a wall polygon to the wall thing or else it will create a portal.

@node Mazing Player Class, , Mazing Maze Class, Tutorial Mazing
@subsubsection Player Class

The @code{Player} class manages the player and player movement including collision
detection.

@example
class Player
@{
private:
  AppMazing* app;

  csRef<iCollider> player_collider;

  // For the movement system.
  csVector3 desired_location;
  csVector3 desired_lookat;
  float amount_moved;
  float amount_rotated;
  csVector3 start_location;
  csVector3 start_lookat;

public:
  Player (AppMazing* app);

  bool InitCollisionDetection ();

  void StartMovement (const csVector3& dir);
  void StartRotation (const csVector3& rot);
  void MoveAndRotateCamera (float elapsed_seconds);
@};
@end example

First it keeps track of the @samp{player_collider}. This will be used for
detecting collision detection. Then it keeps track of where the player wants
to go too and in what direction it wants to look (@samp{desired_location} and
@samp{desired_lookat}). The function @code{StartMovement()} initiates a movement
in some direction (relative). The function @code{StartRotation()} initiates
a rotation in some rotational direction. It is important to note that these
functions don't actually do the movement and the rotation. This is done in
the function @code{MoveAndRotateCamera()}. This function takes the elapsed
seconds since the last frame as a parameter. This makes sure that movement speed
will be equal on fast and slow hardware. i.e. the movement speed is independent
from framerate. That's a very important principle to maintain in games.

@example
Player::Player (AppMazing* app)
@{
  Player::app = app;

  desired_location.Set (0, 0, 0);
  desired_lookat.Set (0, 0, 1);
  start_location.Set (0, 0, 0);
  start_lookat.Set (0, 0, 1);
  amount_moved = 0;
  amount_rotated = 0;
@}

bool Player::InitCollisionDetection ()
@{
  float ps = PLAYER_SIZE / 2.0;
  csPolygonMeshBox* box = new csPolygonMeshBox (csBox3 (
  	csVector3 (-ps, -ps, -ps), csVector3 (ps, ps, ps)));
  player_collider = app->GetCollisionDetectionSystem ()
  	->CreateCollider (box);
  box->DecRef ();
  if (player_collider == 0) return false;
  return true;
@}
@end example

First we have the constructor. In this constructor we set all the defaults for
the movement system. In @code{InitCollisionDetection()} we set up the collider
that the collision detection system is going to use. Basically we represent
the player as a box. The class @code{csPolygonMeshBox} can be used to quickly
create an implementation of @code{iPolygonMesh} for a box.

@example
void Player::StartMovement (const csVector3& dir)
@{
  iCamera* camera = app->GetCamera ();

  amount_moved = 0;
  csReversibleTransform camera_trans = camera->GetTransform ();
  start_location = camera_trans.GetOrigin ();

  // Calculate the spot where we want to move too depending on elapsed
  // time and current direction the camera is facing.
  csVector3 world_dir = camera_trans.This2OtherRelative (dir);
  desired_location = start_location + MOVE_DISTANCE * world_dir;

  // First we find all meshes that are near the path that we want to move.
  // To do that we take the center point of our movement vector and
  // calculate all objects that touch the circle around that point with
  // radius (MOVE_DISTANCE+PLAYER_SIZE) / 2.0.
  csRef<iMeshWrapperIterator> it = app->GetEngine ()->GetNearbyMeshes (
  	camera->GetSector (), (start_location + desired_location) / 2.0,
	(MOVE_DISTANCE + PLAYER_SIZE) / 2.0);

  if (!it->HasNext ())
  @{
    // We have no objects in the iterator so there can be no collision.
    // We can move freely.
    return;
  @}

  // If we have meshes then we will calculate collision detection for our
  // object along the path we want to move.
  desired_location = start_location;
  csVector3 test_location = start_location + STEP_DISTANCE * world_dir;
  iCollideSystem* cdsys = app->GetCollisionDetectionSystem ();
  float current_move = STEP_DISTANCE;
  while (current_move <= MOVE_DISTANCE)
  @{
    camera_trans.SetOrigin (test_location);

    // Test collision with our iterator.
    it->Reset ();
    while (it->HasNext ())
    @{
      iMeshWrapper* mesh = it->Next ();
      csColliderWrapper* collide_wrap = csColliderWrapper::GetColliderWrapper (
    	  mesh->QueryObject ());
      if (collide_wrap)
      @{
        csReversibleTransform mesh_trans = mesh->GetMovable ()
      	  ->GetFullTransform ();
	cdsys->ResetCollisionPairs ();
        if (cdsys->Collide (
      	      collide_wrap->GetCollider (), &mesh_trans,
	      player_collider, &camera_trans))
        @{
	  // Collision, so we can stop. 'desired_location' will contain
	  // the last valid location that we can move too.
	  return;
	@}
      @}
    @}
    desired_location = test_location;
    test_location += STEP_DISTANCE * world_dir;
    current_move += STEP_DISTANCE;
  @}
@}

void Player::StartRotation (const csVector3& rot)
@{
  float angle = ROTATE_ANGLE;
  csOrthoTransform trans = app->GetCamera ()->GetTransform ();
  start_lookat = trans.This2OtherRelative (csVector3 (0, 0, 1));
  trans.RotateThis (rot, angle);
  desired_lookat = trans.This2OtherRelative (csVector3 (0, 0, 1));
  amount_rotated = 0;
@}
@end example

The @code{StartMovement()} function will handle the movement in a certain
direction. It will first calculate where the relative direction would take the
player. Based on that it will try to do collision detection to move as close
as possible to the desired end position. If it finds a suitable spot that is
not embedded in a wall it will then store the final desired location so that
@code{MoveAndRotateCamera()} can use that to do the actual movement.

The @code{StartRotation()} function is easier. It will not do any collision
detection but instead just calculate where the rotation should go too.

Note that there is actually a bug in this code. Because we are ignoring collision
detection when rotating and because our player is represented by a box it is
actually possible to move and rotate at the same time and end up stuck in the
wall.

@example
void Player::MoveAndRotateCamera (float elapsed_seconds)
@{
  iCamera* camera = app->GetCamera ();

  // First we move the camera.
  amount_moved += MOVECAMERA_SPEED * elapsed_seconds;
  float move_val = 1 - pow (2.0f, -amount_moved);
  csVector3 current_pos = camera->GetTransform ().GetOrigin ();
  csVector3 new_pos = start_location * (1-move_val)
  	+ desired_location * move_val;
  camera->MoveWorld (new_pos - current_pos, false);

  // Now we rotate the camera.
  amount_rotated += ROTATECAMERA_SPEED * elapsed_seconds;
  float rotate_val = 1 - pow (2.0f, -amount_rotated);
  csVector3 new_lookat = start_lookat * (1-rotate_val)
  	+ desired_lookat * rotate_val;
  camera->GetTransform ().LookAt (new_lookat, csVector3 (0, 1, 0));
@}
@end example

Based on the desired end position and rotation this function will actually
move the player there. It will use the actual number of seconds that have
elapsed since the previous frame to ensure that movement is the same on
all hardware.


