@c -*-texinfo-*-
@node Config_Plugins
@subsubsection @code{[PlugIns]} section

This section tells the program which plug-in modules to load.  These lines 
look like @samp{@var{PluginType} = @var{PluginName}}.  @var{PluginType} is an 
arbitrary string, but is typically chosen from a small set of alternatives.  
Do not specify the same @var{PluginType} more than once.  @var{PluginName} 
must be a known plug-in module or driver which is registered for use by 
Crystal Space in the @file{scf.cfg} configuration file.  

@quotation
@emph{This section is confusing and probably does not belong here}.

All included plug-ins are registered with all included programs that need
them. So this only applies if you have a new plug-in or a new program :
If this is a statically linked plug-in, you must tell your program to link
to it in the program code with @code{REGISTER_STATIC_LIBRARY}.
If this is a dynamically linked plug-in, you must register @var{PluginName}
in the @file{scf.cfg} file with the line
@samp{@var{PluginName} = @var{SharedLibName}}.
SharedLibName should not end in @file{.so} or @file{.dll} as this is
appended by CS automatically.

The clue with @var{PluginTypes} is that all plug-ins of that same type share
a common interface.  No matter which 3D rasterizer you load, the methods
you have to call are the same.

If a plug-in, for example a 3D driver, needs a run-time library to be
selected (e.g. the DirectX run-time installation), this is normally not
enough. Yes, the plug-in only requires the run-time libs, but to compile
the plug-in you normally need the SDK as well. It means that if you finally
distribute your program, you have to include the run-time libs, but not the
@sc{sdk}.
@end quotation

You need not load a plug-in for every type. For example you may ommit the
sound renderer if sound is not required.

Options in the @samp{[PlugIns]} section follow these guidelines:

@itemize @bullet
@item
The same @var{PluginType} is never listed twice.

@item
Some plug-ins depend on others. For example the 3D engine depends on the
3D rasterizer. These plug-ins must be loaded in the correct order.  First
the 3D rasterizer, then the engine.  A plug-in that is being loaded may
only depend on those plug-ins that have already been loaded.
@end itemize

Currently available plug-ins are (sorted by type):

@table @code
@item VFS=
The virtual file system. There is only one possible VFS plug-in, called
@samp{crystalspace.kernel.vfs}.

@item VideoDriver=
The driver for all graphics operations. Possible values are:

@table @samp
@item crystalspace.graphics3D.software
Uses the system-specific 2D rasterizer to perform 3D graphics
operations on the basis of drawing single pixels.

@item crystalspace.graphics3D.opengl
Uses OpenGL for 3D output, and by this takes advantage of hardware
acceleration.  Requires installed OpenGL run-time libraries.

@item crystalspace.graphics3D.direct3D.DX5
Uses Direct3D (DirectX v5 or higher) for 3D output. Also uses hardware
acceleration.  Requires installed DirectX 5 or higher run-time libraries.

@item crystalspace.graphics3D.direct3D.dx61
Similar to the above.  Requires installed DirectX 6.1 or higher
run-time libraries, but gives better output than DX5.

@item crystalspace.graphics3D.glide.2
Uses Glide 2 for 3D output.  Requires Glide 2 run-time libraries.

@item crystalspace.graphics3D.glide.3
Uses Glide 3 for 3D output.  Requires Glide 3 run-time libraries.
@end table

@item SoundRender=
The sound renderer, used for all sound output.  Possible values are:

@table @samp
@item crystalspace.sound.render.software
This sound renderer uses some system-dependent sound API.  Should work
well but you won't get special effects like with A3D.

@item crystalspace.sound.render.a3D
This uses Aureal3D for sound output.

@item crystalspace.sound.render.ds3D
This uses DirectSound3D for sound output.  Requires DirectX run-time libraries.
@end table

@item NetDriver=
The network driver.  This performs all basic communication operations.

@table @samp
@item crystalspace.network.driver.sockets
This uses Sockets for network communication.
@end table

@item NetManager=
The network manager. This provides high-level network operations that are
only useful for games.

@emph{Warning}: This module is obsolete and will be decommissioned soon.
Do not use it.

@table @samp
@item crystalspace.network.manager.simple
A simple network manager.

@item crystalspace.network.manager.deadreckoning
A dead-reckoning network manager.
@end table

@item Engine=
The 3D engine.  Currently, there is only have one possible choice, and this 
will probably remain even if somebody writes another 3D engine that uses 
Crystal Space for 3D output, sound, etc@enddots{}  This is because the other 
engine will have a totally different interface.  The engine plug-in is called 
@samp{crystalspace.engine.core}.

@item other plug-ins
You may also load any additional desired plug-in modules or modules which are 
specific to a particular application.  This is useful if you write your own 
application with Crystal Space.  Loading a plug-in does nothing else than 
really loading the shared library (if it is a shared libraries) and creating 
an entry in the plug-in table.  You have to query the interface from within 
your program (by giving the system driver the PluginType), and then use the 
plug-in for something.  

Additionally available plug-in modules are:

@itemize @bullet
@item
Python = crystalspace.script.python

@item
CrystalClear = crystalclear.kernel
@end itemize
@end table
