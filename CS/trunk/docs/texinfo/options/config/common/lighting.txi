@c -*-texinfo-*-
@node Config Lighting, Config Console, Config VideoDriver, Config Common
@subsubsection @code{[Lighting]} section

@table @code
@item REFLECT=<number>
The number of reflections that are allowed for static lighting. The default
for this is 1 which means that light is not reflected by mirrors. This
number is actually the number of times that some light may affect the same
sector. This option only has effect in combination with the @code{-relight}
commandline option.

@item RADIOSITY=<yesno>
If yes the precalculated lighting routines will also reflect light on
normal polygons (and not only on mirrors). The number of allowed
reflections depends on the @samp{REFLECT} variable. Using this flag you get
a sort of simulation of radiosity. Note that it greatly increases the time
needed for precalculated lighting. This option only has effect in
combination with the @code{-relight} commandline option.

@item NEWRADIOSITY=<yesno>
Real radiosity system that operates on the lightmaps. This system is
currently still experimental.

@item ACCURATE_THINGS=<yesno>
With this option enabled (default) precalculated lighting is much more
accurate with regards to shadow calculation of Things. However this is also
a lot slower (only when calculating lighting information). This option
corresponds with the @code{-accthg}/@code{-noaccthg} commandline options.

@item COSINUS_FACTOR=<float>
Control how much the angle of the light with the polygon it hits affects
the final light value. Values ranges from -1 to 1. With -1 the polygons
will get no light at all. With 0 it will be perfect cosine rule. With 1 the
cosine is ignored and it will be like CrystalSpace was in the past. Note
that changing this value at runtime only has an effect on dynamic lights.
This option corresponds to the @code{-cosfact} commandline option and the
@samp{cosfact} console command.

@item LIGHTMAP_SIZE=<size>
Set the size of the lightmap boxes. Default is 16. Use 4 or 8 for more
accurate lightmaps (but lightmap size will increase and texture cache speed
will decrease). Use 32 for very blocky textures. Note that
@samp{LIGHTMAP_SIZE} should be a power of 2. Note that Crystal Space will
automatically recompute all the lightmaps when this value changes (this
make take a long time). Note that you can also specify this option in the
local @file{cryst.cfg} file.

@item LIGHTMAP_HIGHQUAL=<yesno>
With this option enabled (default yet) lightmaps are calculated at a higher
resolution internally and then scaled back to the value specified with
@samp{LIGHTMAP_SIZE}. This results in much nicer lightmaps but calculation
takes somewhat longer. Note that dynamic lights don't use this feature.
Note that you can also specify this option in the local @file{cryst.cfg}
file.

@item SPRITE_HIGHQUAL=<yesno>
With this option enabled (default no) sprites are lit using a higher
quality algorithm in which the distance between the light and every vertex
is calculated. The default setting doesn't do this and just calculates the
distance once to the center of the sprite.
@end table

@emph{Radiosity Settings}

By default radiosity calculations are turned off, and the regular lighting
is done. When radiosity is turned on, after the regular lighting calculation
radiosity is computed. A number of parameters can be set:

@table @code
@item Radiosity.Enable=<yesno>
yes to turn on radiosity precalculation. To recalculate
radiosity run walktest -relight on the level. No to turn off.
(default: no)

@item Radiosity.StopPriority=<float>
Internally radiosity computes a priority for each
polygon. The priority is in the range of 0..256, where 0 means nothing
to do. When the highest priority become lower then the stoppriority,
radiosity calculation will stop. (Default: 0.1)

@item Radiosity.StopImprovement=<float>
When the highest priority becomes lower than
the highest priority at the start of calculation divided by this value
calculation will stop. (Default: 100.0)

@item Radiosity.StopIterations=<number>
After processing this many polygons the radiosity
calculation will stop. This will prevent endless loops. If your level has 
many polygons you may need to increase the value. (Default: 10000)

@item Radiosity.SourcePatchSize=<number>
This value will make radiosity calculation use
the average of NxN size patches on source polygons when shooting light 
from one polygon to another (but not on destination polygons). Increasing
the value will speed up computation considerably, while reducing quality
only slightly. Try values of 1..256, depending on the LightmapSize. 
Use only powers of two. (Default: 16)

@item Radiosity.ColourBleed=<float>
This variable controls the amount of color emitted
by a polygon. The colour is taken by examining the texture of the polygon.
Thus a blue texture will reflect blueishly. Note that decreasing or
increasing this value will increase the amount of lighting in the
entire level by that amount. So 0.0 will be dark. And high values will
create huge amounts of light (and use more calculation). Try 0.0-4.0. 
(Default: 1.0)

@item Radiosity.DoStaticSpecular=<yesno>
yes will turn on specular lighting using
radiosity. Since this is precalculation, only a static 'fake' specular
effect can be given. Does not seem to give huge effects, but I left
in the code so you can play with it :-). (Default: no)

@item Radiosity.StaticSpecularAmount=<float>
The amount of specular lighting to add
when lighting. Try between 0 and 1. (Default: 0.70)

@item Radiosity.StaticSpecularTightness=<number>
tightness of the specular highlight.  a power of 2 of this variable is 
used for speed. Thus try 0-10. (Default: 4)

@end table
