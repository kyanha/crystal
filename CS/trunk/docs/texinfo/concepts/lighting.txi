@c -*-texinfo-*-
@node Lighting
@section Lighting
@cindex Lighting

Crystal Space supports three types of lighting : Static Lights,
Pseudo-Dynamic Lights and Dynamic Lights. They are different in the ways you
can change their attributes while the engine is running. Static Lights
cannot be changed at all, but produce best performance and least memory
consumption. Pseudo-Dynamic Lights can change their color and brightness,
but not their position. Dynamic Lights can also change their position.

Or, to be more accurate : If you change one of these things that
@samp{cannot be changed}, you'll have to do some time-expensive recalculation.

Crystal Space supports three different lighting tables. Every light in the
scene can emit some amount of each variety of light. For example, if the
three tables are red, green, and blue a light could emit light with intensity
@code{(.5, 0, 1)} which means: half intensity red, no green, and full
intensity blue. With the @code{MIXLIGHTS} setting you can control how the
three colors are defined and how the mixing happens (see below for a
description).

Every light has a position in world space coordinates and a current Sector.

Every light also has a radius (expressed in squared distance). This radius
indicates where the light levels of the three light tables will reach 
zero.

@menu
* Static Lights::
* Pseudo-Dynamic Lights::
* Dynamic Lights::
* Shadow Calculation::
@end menu

@node Static Lights
@subsection Static Lights
@cindex Static Lights

@emph{WARNING! Although the basic principle described here is still valid,
much more is going on now. I need to update this document.}

This document gives a @emph{VERY} short explanation of the static lighting
system used in version 0.10 of Crystal Space (not in the earlier versions).

Static lighting is based on @dfn{Lightmaps}. These are like textures except
that every pixel defines the combined brightness of all lights at its
position. Before the rendering loop starts, these lightmaps are precalculated
so there is little performance loss at runtime, where we only need to blend
texture and lightmap of a polygon.

Lightmaps are calculated as follows:

@itemize @bullet
@item
First we initialize all lightmaps to black (or the ambient color).

@item
For every light in the world we generate a view frustum as seen from the
position of that light. The frustum is defined as a set of 3D polygon or
light patches. Every light patch is clipped against the relevant portals
until nothing remains (light patch becomes empty). Every light patch in this
frustum is in fact a projection of the light on the normal polygons. It is in
that area that we need to update the lightmap for every polygon.

@item
For every polygon that was hit we cast beams from the light to every lightmap
point on the polygon (lightmap points are often defined every 16x16 texels
although you can change this in Crystal Space). We know that in principle the
beam of light should reach the polygon since the light patch gives the
boundary of where the light can reach the polygon. But the frustum was
generated ignoring Things. So it is possible that there is a Thing blocking a
specific beam of light. We need to test for that.

@item
If there is a succesful hit then we calculate the distance between the light
and the point on the polygon and update the intensity there.
@end itemize

Note that light patches are slightly expanded before clipping and also before
using in the lightmap-updater. This is to accomplish better results at
boundaries of polygons (still not perfect though).

To create the three lightmaps for every polygon a 2D bounding box in texture
space is calculated. This defines a rectangle that overlaps with the texture
on the polygon and is correctly aligned with it (so that every 16x16 texel
grid has one lightmap position). A consequence of this is that rotated
textures can waste a lot of lightmap space. For example, see the following
polygon:

@example
    +
   / \
  /   \
 /     \
+       +
 \     /
  \   /
   \ /
    +
@end example

and assume that the texture is aligned horizontally. Then we would need a
lightmap of the following size:

@example
+---+---+
|  / \  |
| /   \ |
|/     \|
+       +
|\     /|
| \   / |
|  \ /  |
+---+---+
@end example

Note that also the texture in the texture cache will have that size.

@node Pseudo-Dynamic Lights
@subsection Pseudo-Dynamic Lights
@cindex Pseudo-Dynamic Lights

The pseudo-dynamic lighting system is an extension to the static lighting
system described above. These pseudo-dynamic lights can not move but you can
change the intensity or color. When some light is made pseudo-dynamic (a
simple flag) the processing is a bit different. The shadow-computation
remains the same but every polygon that is hit by the pseudo-dynamic light
needs to have seperate lightmaps for every pseudo-dynamic light that hits the
polygon. So in the end all the polygons that are only hit by static lights
have just one lightmap (for the three tables) for all static lighting
information. Every polygon that is hit by one or more pseudo-dynamic lights
will have one or more extra lightmap tables for every pseudo-dynamic light
and one extra for all static lights. This information is then added together
to result in the final lightmap table that can then be used by the texture
cache routine (like explained above).

The lightmaps for the pseudo-dynamic lights are stored without the strength
of the light. So where the light shines brightest the value in the lightmap
will be 255, where it shines least bright the value will be 0. When combining
all pseudo-dynamic lightmaps and the static lightmap the strength of every
light will be multiplied with the distance value to result in the real
lightmap value. This also implies that there is only one extra lightmap for
every polygon/pseudo-dynamic light because the shadow information (which is
basicly what is represented in pseudo-dynamic lightmaps) is the same for all
three light-tables.

Here are some performance considerations for pseudo-dynamic lighting. There
is a memory penalty for every polygon that is hit by some pseudo-dynamic
lighting because extra lightmaps need to be created. So if you use no
pseudo-dynamic lighting you will suffer no penalty but if you use a very
large pseudo-dynamic light (with a large radius) it will probably hit a large
amount of polygons and you will have a considerable increase in memory
requirements.

There is also a performance penalty whenever the intensity of a
pseudo-dynamic light changes. This is because all the polygons that are hit
by the pseudo-dynamic light need to be recalculated (they are removed from
the texture cache). The texture cache will need to be made much faster before
this pseudo-dynamic lighting feature can really be used for continuous
lighting. Currently it is useable for switching on/off some not-too-big light
in some room.

If the intensity of a pseudo-dynamic light does not change there is no
performance hit at all.

@node Dynamic Lights
@subsection Dynamic Lights
@cindex Dynamic Lights

The latest Crystal Space versions also support true dynamic lights. These are
rendered atop of the normal lightmaps as explained above and support colors
and limited shadows.

@node Shadow Calculation
@subsection Shadow Calculation
@cindex Shadow Calculation

The algorithm to see if a given beam reaches a specific point on some polygon
is as follows. The beam is described as two vertices (@samp{start} and
@samp{end}):

@itemize @bullet
@item
We start at the Sector of the light.

@item
If the current Sector is equal to the Sector of the polygon then there is a
hit, since all polygons of a Sector are completely visible from anywhere in a
Sector.

@item
Otherwise, if the light is not in this Sector, the beam could reach this
Sector through a Portal. Since the beam certainly ends at the polygon (this
is given, the @samp{start} and @samp{end} vertices define a beam that will
(if not blocked) reach the polygon) and the beam passed through Portals to
reach here then the beam hits the polygon. So we do the following:

@itemize @bullet
@item
See which polygon of the current Sector intersects with the beam.

@item
If the polygon is on the same plane as the destination polygon then there is
a hit. The reason this is true has to do with the fact that the lightmaps are
slightly bigger than what is really needed. Bilinear interpolation is used to
finally light the polygon and it has to be able to correctly interpolate at
the boundaries of the polygon as well.

@item
If the polygon that is hit is a Portal we recurively continue with the
following Sector. If the recursive calls returns a hit then we have a hit.

@item
If the polygon is not a Portal we have no hit and we return from the
algorithm (the beam of light does not reach the polygon).
@end itemize

@item
In all cases that we had a hit according to the previous steps we come here
to check if there are no Things blocking the beam. For every Thing in the
current Sector check if the beam intersects with one of the polygons of the
Thing. If so then there is no hit. Otherwise there is a hit.
@end itemize

Some similar algorithm is used to for Things.
