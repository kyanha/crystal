@c -*-texinfo-*-
@node Makefile How-To, Threads in CS, Platform Details, Internals
@section Makefile How-To
@cindex Makefile How-To

@noindent
@emph{Written by Andrew Zabolotny, @email{bit@@eltech.ru}.}

This section describes the interior of the makefile for @sc{gnu} @samp{make}.
It will only help you if you use @sc{gnu} @samp{make}, and if you intend to
change the @sc{gnu} makefiles.

Crystal Space has a complex and sophisticated makefile system, this
document describes how it works and defines a set of rules that should be
followed, if possible, to keep makefiles clean and understandable.

The makefile system heavily relies on many features of @sc{gnu} @samp{make}.
This renders them very simple, but at the same time makes it heavily depend on
this tool; however as of today @sc{gnu} @samp{make} is available for almost
every platform, so this is not a too big of a price for the goods it brings.

This document is not intended as a @sc{gnu} @samp{make} manual; refer to
appropriate documents if you do not understand something.  The following text
supposes you are familiar with @sc{gnu} @samp{make} extensions; with at least
basic features if not with all.

@menu
* Makefile Structure:: Overall Structure
* Makefile Variables:: Variable Naming Conventions
* Makefile Output Directory:: Output Directory
@end menu

@node Makefile Structure, Makefile Variables, Makefile How-To, Makefile How-To
@subsection Overall Structure
@cindex Makefile Structure
@cindex Structure of Makefiles

The makefile system was designed to be very modular.  This means that there are
separate submakefiles for each unit that have to be built.  Besides, there is a
platform-dependent submakefile (referenced through the variable
@code{$(TARGET_MAKEFILE)}), user settings submakefiles (@file{mk/user.mak} and
the optional @file{mk/local.ma}), common definitions submakefile
(@file{mk/common.mak}) and several other minor submakefiles.  The top-level
@file{Makefile} (which is located in the root directory of Crystal Space source
tree, @file{CS}) takes care of including all other submakefiles as required.

Initially the build system is unconfigured.  The @dfn{configuration} process
identifies platform facilities and peculiarities and determines the
platform-specific submakefile to use, as well as several other definitions
required for building Crystal Space on a particular platform.  During
configuration phase a submakefile called @file{config.mak} is created in the
top-level build directory.  Here is a very tiny extract of a @file{config.mak}
created for Unix:

@example
# Automatically generated file, do not edit!
TARGET = unix
TARGET_MAKEFILE = libs/csutil/unix/unix.mak
MODE = optimize
USE_PLUGINS = yes
PROC = X86
CXX = gcc -c
CFLAGS.optimize += -mpentium -march=i586
CFLAGS.SYSTEM += -fno-exceptions
@end example

As you can see, the first statement defines the @samp{TARGET} platform and the
second defines the platform-specific submakefile.  The @samp{MODE} variable
defines the build mode (optimize, debug, or profile).  @samp{USE_PLUGINS} tells
whenever we will or will not use dynamic-linked plugin modules, as opposed to
linking all modules directly into the application as one monolithic entity.
The following statements defines several minor host platform and operating
system characteristics such as processor type, C++ compiler, and several
optimization switches that are supported by compiler.  In practice, a real
@file{config.mak} will contain a good deal more information which was
discovered by the configuration process.

The platform-specific submakefile defines features that are common for that
type of platform, but does not specify any peculiarities about a particular
installation.  Instead, the configuration process figures out the pecuriarities
of your system and sets up @file{config.mak} to reflect them.  The system
submakefile is included several times; the reason is that there are
platform-specific definitions that should be defined at the top of each
makefile, in the middle and so on.  To differentiate between them a variable
called @samp{MAKESECTION} is used.  For example, early in the root makefile it
is necessary to know which operating system, compiler, and processor we are
running on.  For this, the root makefile does the following:

@example
MAKESECTION=rootdefines
include $(SRCDIR)/mk/subs.mak
@end example

The @file{mk/subs.mak} makefile is a special makefile that takes care of
including all submakefiles: platform-specific and submakefiles for all plugins,
libraries, and applications.  In our case we care only about platform-specific
submakefile; effectively @samp{include mk/subs.mak} invokes:

@example
-include $(SRCDIR)/$(TARGET_MAKEFILE)
@end example

In @code{$(TARGET_MAKEFILE)} we check the @samp{MAKESECTION} variable, and
execute appropriate makefile statements.  In our case:

@example
ifeq ($(MAKESECTION),rootdefines)
SOMEVAR=somevalue
OTHERVAR=othervalue
endif # ifneq (,$(findstring defines,$(MAKESECTION)))
@end example

For building something the root makefile runs a submakefile called
@file{mk/cs.mak}.  Note that @file{cs.mak} is not @emph{included} but is run as
a separate make process via @samp{$(MAKE) -f mk/cs.mak @var{args}}.  This means
that all definitions made for root makefile are ignored in @file{cs.mak}, so
@file{cs.mak} needs again to include @file{mk/subs.mak} in appropriate places
with appropriate values for @samp{MAKESECTION}.  For example, to build the
@file{csutil} library, the top-level makefile executes the following command:

@example
$(MAKE) -f mk/cs.mak csutil
@end example

Currently the following values of @samp{MAKESECTION} are used:

@table @emph
@item Used in root @file{Makefile}.
@table @code
@item confighelp
The platform-specific submakefile is included from top-level makefile to define
the various ``help'' messages which the makefile can display.
@item rootdefines
Define all the variables required by the top-level makefile.
@item roottargets
Define all additional targets required by the top-level makefile.
@end table

@item Used in @file{cs.mak}.
@table @code
@item defines
Define all variables that are required for building any targets---the C/C++
compilers, flags and so on.
@item postdefines
Define any variables that depend on other variables.
@item targets
Define targets in addition to those in @file{cs.mak}; for instance, a library,
a driver, an executable and so on.
@end table
@end table

Note that @samp{MAKESECTION} variable is used not only in the platform-specific
submakefile, but in all submakefiles; for libraries, for plugins, and so on.

Each platform-specific submakefile augments thee value of a variable called
@samp{PLUGINS} which contain references to all platform-specific plugins that
are supported by this platform and which were not detected automatically by the
configuration process.  The drivers are referenced by their directory name
inside @file{CS/plugins} subdirectory.  For example, a @samp{PLUGINS} variable
that refers to the XFree86 shared-memory extension would look like this:

@example
PLUGINS += video/canvas/xextshm
@end example

To find the submakefiles for plugins, @file{$(SRCDIR)/plugins} is prepended to
all components of @samp{PLUGINS}; @file{/*.mak} is appended; and a wildcard
search is performed.  A possible result of above expansion might be:

@example
PLUGINS_SUBMAKEFILES = video/canvas/xextshm/xextshm.mak
@end example

These submakefiles are included each time @file{subs.mak} is included either
into the top-level makefile or into a submakefile.

To find the submakefiles for libraries, @file{subs.mak} looks for all
submakefiles contained one level deep in the @file{CS/libs} directory (i.e.
@file{libs/*/*.mak}).  For example, it might find these libraries:

@example
(~/CS)% ls libs/*/*.mak
libs/csappframe/csappframe.mak
libs/csgeom/csgeom.mak
libs/csgfx/csgfx.mak
libs/cstool/cstool.mak
libs/csutil/csutil.mak
libs/csws/csws.mak
@end example

Submakefiles for applications are located using the search mask
@file{apps/*/*.mak apps/*/*.mak apps/*/*/*.mak}, in this fashion:

@example
(~/CS)% ls apps/*/*.mak
apps/demo/demo.mak
apps/walktest/walktest.mak
apps/examples/cswseng/cswseng.mak
apps/import/map2cs/map2cs.mak
apps/tutorial/simple1/simple1.mak
apps/tutorial/simple2/simple2.mak
@end example

The library and application submakefiles also uses the @samp{MAKESECTION}
variable to insert statements into different places of the makefile.  If you
do not understand something, feel free to look through submakefiles that
reside in all major directories of the Crystal Space source tree.

@node Makefile Variables, Makefile Output Directory, Makefile Structure, Makefile How-To
@subsection Variable Naming Conventions
@cindex Makefile Variable Naming Conventions
@cindex Variable Naming Conventions, Makefile
@cindex Naming Conventions, Makefile Variables

For maximum flexibility (the makefile system should be usable by any compiler
on any platform).  @file{cs.mak} avoids any direct references to compiler
switches, tool names and so on.  Instead there are a number of variables (some
of which have default values, but can be changed by submakefiles) which should
be used by @file{cs.mak} as well as by submakefiles, if possible.

The main ``tool'' used to build Crystal Space is, naturally, the C++ compiler.
The variable name for C++ compiler is @samp{CXX}.  There are also places where
the plain C compiler is required; it is referenced by the @samp{CC} variable.
The flags for the C/C++ compilers (it is assumed they both understand same
command-line flags) are collected from a number of additional variables, as
summarized below.

@table @code
@item CFLAGS.GENERAL
General flags used in all compilation modes.
@item CFLAGS.optimize
Flags used in optimize mode.
@item CFLAGS.debug
Flags used in debug mode.
@item CFLAGS.profile
Flags used in profile mode.
@item CFLAGS.DLL
Flags used when compiling object files for dynamically-linked libraries (i.e.
@code{-fpic}).
@end table

The submakefiles also often need to know how to tell something to C/C++
compiler.  For example the path to some system-dependent include files or
libraries, or how to define a macro, and so on.  The @sc{gnu} C++ compiler,
for example, uses the @code{-I@var{path}} form to define a include path; the
Watcom-C compiler, on other hand, uses the @code{-i=@var{path}} form.  To
accommodate this, there are a number of variables that contain the equivalent
of required switches for currently selected compiler.  They are summarized
below.

@table @code
@item CFLAGS.@@
Flag to define the output file name.  The default (for Unix-like C compilers)
is @samp{-o $@@}.
@item CFLAGS.D
Flag to define a C-preprocessor macro. The default is @samp{-D}.
@item CFLAGS.I
Flag to specify an additional search path for @code{#include} directives.  The
default equivalent is @samp{-I}.
@end table

The linker is referenced through the variable @code{$(LINK)}.  There are also
a number of variables that defines linker flags.  They are summarized below.

@table @code
@item LFLAGS.GENERAL
General linker flags.
@item LFLAGS.optimize
Flags used in optimize mode.
@item LFLAGS.debug
Flags used in debug mode.
@item LFLAGS.profile
Flags used in profile mode.
@item LFLAGS.DLL
Flags used when building a dynamically loaded plug-in module.
@item LFLAGS.EXE
Flags used when building a executable.
@item LFLAGS.CONSOLE.EXE
Flags used when building a console executable (for example, @file{map2cs}).
Some platforms, such as MacOS/X, differentiate between a ``graphics''
executable and a ``console'' executable.
@end table

Also there are variables similar to @samp{CFLAGS.*} which tell the linker how
to link with an additional library and so on.

@table @code
@item LFLAGS.@@
Define output file name to @samp{$@@}.  The default is @samp{-o $@@}.
@item LFLAGS.L
Define an additional library search path.  The default is @samp{-L}.
@item LFLAGS.l
Add a library for linking. The default is @samp{-l}.
@end table

If your plugin, application, or library requires specific C/C++ compiler
flags, linking flags, libraries, the usual naming convention is the following:

@table @code
@item CFLAGS.@var{name}
Additional C/C++ flags.
@item LFLAGS.@var{name}
Additional linking flags.
@item LIBS.@var{name}
Additional libraries.
@item DEP.@var{name}
Additional dependencies.
@end table

For example, suppose your application, which is called Ping-Pong, requires
specific compilation flags, as well as dependencies (it depends on several
Crystal Space libraries) and extra libraries (suppose you link with an
additional @file{libpingpong.a}).  In this case the variables would be named
like this:

@example
CFLAGS.PINGPONG = $(CFLAGS.I)/usr/local/include/pingpong
LIBS.PINGPONG = $(LFLAGS.L)/usr/local/lib $(LFLAGS.l)pingpong
DEP.PINGPONG = CSGEOM CSUTIL
@end example

Another issue is that several types of files use different extensions on
different platforms.  For example, executable files on Unix typically have no
extension, whereas on Windows they typically have an @file{.exe} extension.  As
another example, object files have an @file{.o} extension on Unix and an
@file{.obj} extension on Windows.  To accommodate these differences, several
variables are used where appropriate, as summarized below.

@table @code
@item EXE
Typical extension for executables (ex: @samp{.exe}).
@item O
Typical extension for object files (ex: @file{.o}; usage: @samp{pingpong$O}).
@item LIB
Typical extension for libraries (ex: @samp{.a} or @samp{.lib}).
@item DLL
Typical extension for dynamically loaded libraries (@samp{.so} or @samp{.dll}).
@end table

Also on Unix systems libraries usually have the @samp{lib} prefix, (i.e. the
@samp{csutil} library would typically be named @file{libcsutil.a}).  On other
systems this is not the case; to resolve this problem a variable called
@samp{LIB_PREFIX} is used.  It is either set to @samp{lib} or it is empty
depending upon the environment.  Back to the example, if the submakefile
needed to define the rule to build @file{libpingpong.a}, it could be done in
this fashion:

@example
PINGPONG.LIB = $(LIB_PREFIX)pingpong$(LIB)
@end example

If we wanted to build a dynamic library, the name of target would be:

@example
PINGPONG.DLL = pingpong$(DLL)
@end example

As you can observe, the name of target variables also has a naming convention
of its own.  If the target is a static library, it is typically named
@samp{@var{NAME}.LIB}; if it is a dynamic library, it is called
@samp{@var{NAME}.DLL}; if it is an executable, it is typically named
@samp{@var{NAME}.EXE}.

@node Makefile Output Directory, , Makefile Variables, Makefile How-To
@subsection Output Directory
@cindex Output Directory, Makefile
@cindex Makefile Output Directory

To avoid polluting the entire directory hierarchy with temporary and
intermediate files, all output from the build process should be placed into a
separate directory tree intended specifically for such transient files.  By
default this directory is named as follows, and assigned to the makefile
variable @samp{OUT}.

@example
OUT = out/$(OS)/$(PROC)/$(MODE)$(OUTSUFX.$(MAKE_DLL))
@end example

So, if you're building a dynamic library for Linux on an Intel machine, the
output directory would be named @file{out/LINUX/X86/optimize.so/}.  To
reference to the output directory you should use the variable @code{$(OUT)} in
your submakefiles.  For example, the following rule tells @samp{make} how to
compile @file{.cpp} files:

@example
$(OUT)%$O: apps/gnipgnop/%.cpp
        $(DO.COMPILE.CPP)
@end example

This rule says that C++ source files in the @file{apps/gnipgnop} directory can
be compiled to an object file in the @code{$(OUT)} directory via the
@code{$(DO.COMPILE.CPP)} commands.

On ther other hand, if you need a separate rule for just one or several
specific files, you could do it this way:

@example
$(OUT)file1$O: apps/gnipgnop/file1.cpp
        $(DO.COMPILE.CPP) $(CFLAGS.FORFILE1)
$(OUT)file2$O: apps/gnipgnop/file2.cpp
        $(DO.COMPILE.CPP) $(CFLAGS.FORFILE2)
@end example
