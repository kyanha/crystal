@node csSys, csUtil, Lib Overview, Libraries
@section System Library (@code{csSys})
@cindex @code{csSys}
@cindex Libraries, @code{csSys}
@cindex System Library

The system library is the basic module in every Crystal Space application. It
contains one main class, the @dfn{system driver}. This driver helps in
several ways:

@itemize @bullet
@item
It handles the main system-specific operations, like loading dynamic libraries
for @sc{scf} (@pxref{SCF}).  So using it will make most of your application
system-independent.

@item
It tries to find global installations of the Crystal Space run-time libraries.

@item
It provides the input drivers, so you can access mouse, keyboard and
joystick.

@item
It loads and initializes the plug-ins (using @sc{scf}) and sends them their
private and broadcast events.

@item
It keeps a log file and provides functions for printing debugging messages,
warnings, and errors.

@item
It keeps track of the application's configuration file and automatically reads
all options required by the system or any plug-in.

@item
It processes the command-line parameters and also allows plug-in modules to
react to the parameters.

@item
It calls additional startup and shutdown functions of some basic plug-in
modules, called the @dfn{drivers}.

@item
All these methods are @dfn{virtual} methods, so you can override them.
@end itemize

@subheading How to Use the System Driver

The system driver is explicitly designed to be a superclass for your own system
driver class.  In particular, the @code{NextFrame()} and @code{HandleEvent()}
methods are generally overridden by most applications.

The system driver class is named @samp{SysSystemDriver}. This class contains
all system-specific functions. It is, itself, a subclass of
@samp{csSystemDriver}, which contains the system-independent stuff.

A typical application would perform the following steps:

@itemize @bullet
@item
Create an instance of its subclass of @samp{SysSystemDriver}.

@item
Call @code{System->Initialize()}. This will process the command-line, load
and initialize the plug-in modules and open the main configuration file.

@item
Load all application-specific data. You can, of course, load additional stuff
later, but if an error occurs (e.g. an important file is missing), the user
does not have to wait until complete start-up to see this error.

@item
Call @code{System->Open()}.  This will @dfn{open} the plug-in modules.  The
exact meaning of this operation is specific to each plug-in.  For instance, a
graphics-related module might change the graphics mode; a sound-related module
might enable sound output; and an input-related module might enable keyboard
processing.

Any events triggered by these drivers will be sent to your application via the
@code{HandleEvent()} function. If you override this function, you must still
call the old function.

@item
Call @code{System->Loop()}.  This function will only return when your program
exits the main event loop.  Of course you can control when this happens, and
you can restart the loop later, but for most applications exiting the main loop
means exiting the application.

Once you have entered this loop, the system driver will call the
@code{NextFrame()} method every frame. This happens at irregular time steps,
so you should use the @code{GetElapsedTime()} function to see how much time
has passed.

@item
Close and delete the system driver. You don't have to call
@code{System->Close()} explicitly, as this will be done automatically when
you delete the object.
@end itemize
