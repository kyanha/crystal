@c -*-texinfo-*-
@node CSWS, csPhyziks, Libraries, Libraries
@section Crystal Space Windowing System (@sc{csws})
@cindex CSWS
@cindex Libraries,CSWS
@cindex Windowing System

@noindent
@emph{Written by Andrew Zabolotny, @email{bit@@eltech.ru}.}

The main goal of Crystal Space Windowing System (@sc{csws}) is to provide a
clean, effective and cross-platform base for creating Crystal Space-related
utilites.  Currently there is only one such utility under development:
Crystal Space maze editor, MazeD.

@menu
* CSWS Concepts:: Concepts
* CSWS Components:: Components
* CSWS Events:: Events
* CSWS Clipping:: Clipping
* CSWS Tutorial:: Quick Tutorial
@end menu

@node CSWS Concepts, CSWS Components, CSWS, CSWS
@subsection Concepts

There is nothing new in @sc{csws} regarding the window system.  All base
conceptions for building such an system were invented long ago, at least when
first X-windows system was built or even earlier.

The system is event-based, events are generated by hardware (mouse, keyboard)
or software (components can send messages to each other).  Event-system is
system-dependent as well as graphics subsystem.  They were developed first as
part of Crystal Space itself, then some modifications were made to better fit
@sc{csws} requirements.  @sc{csws} itself is completely system-independent,
i.e. you can easily develop programs that will compile and work with no
problems under any system supported by Crystal Space.

Since Crystal Space always uses buffered visuals, the screen repainting is
always done on the invisible page.  This means flickering on redraw is almost
impossible in @sc{csws}, while it is common on usual @sc{gui}s with
bad-written programs.  If visual has more than one backbuffer (like @sc{os/2}
port), the image is automatically re-syncronized on all back-buffers.

Other Crystal Space-specific feature is the division of event processing into
@dfn{frames}.  Since Crystal Space is a animation engine it operates in terms
of frames, i.e. when the frame begins, all pending events in queue are
processed, then all invalid components are redrawn, and at last the image is
blitted onto the screen.

@subheading Basic Concepts

This section provides an overview of the basic concepts of coordinate system
and color palette.  These discussions provide a solid foundation for
subsequent discussions.

@subsubheading Coordinate System

The coordinate system is based on most-used (yet undesirable) system where
top-left corner is (0,0) and bottom-right corner is (@var{width},
@var{height}).  It would be better to use the more desirable coordinate system
which is used, for example in @sc{os/2} and OpenGL, but most programmers are
already familiar with the the less disirable one.

Most @sc{csws} functions works with rectangles (@samp{csRect} class).  The
@samp{csRect} class has four data fields: @samp{xmin}, @samp{xmax},
@samp{ymin}, and @samp{ymax}, which are self-explanatory.  Here is a example
of the rectangle (@var{xmin} = 0, @var{ymin} = 0, @var{xmax} = 3, @var{ymax} =
2):

@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --##########--+--+--
     #//|//|//#  |  |
 1 --#--+--+--#--+--+--
     #//|//|//#  |  |
 2 --##########--+--+--
     |  |  |  |  |  |
 3 --+--+--+--+--+--+--
     |  |  |  |  |  |
...--+--+--+--+--+--+--
@end example

Vertical line @samp{X = 3} and horizontal line @samp{Y = 2} do @emph{not}
belong to the rectangle.  The hashed pixels belong to the rectangle.  So, if
you have two windows: (0, 0) - (3, 2) and (3, 0) - (6, 2) they do @emph{not}
overlap.

@subsubheading Palette

@sc{csws} has been designed to operate transparently and independent of screen
geometry or number of colors.  To allow normal operation in different pixel
format conditions colors are kept in a dynamically-built table which is
referenced through indexes in that table.  To allow different palettes for
windowing system each component does not use colors directly when drawing,
instead each component has a pointer to a table which contains color values.
So, for example, a component can have a palette which's first element is used
as background color, second is used to display text in window and so on.  By
changing only the palette table we can change at once how all these components
are looking.

There is a number of pre-defined colors with names of the form
@samp{cs_Color_@var{XXX}}, for example @samp{cs_Color_Black},
@samp{cs_Color_White} etc.  Components do not draw with
@samp{cs_Color_@var{XXX}} constants, they just indicate the index into their
palette.  All standard component palettes are contained in @file{cswspal.cpp}
and @file{cswspal.h} files.

@node CSWS Components, CSWS Events, CSWS Concepts, CSWS
@subsection Components

The base class for windowing system is @samp{csComponent}.  @samp{csComponent}
is a very complex class with lots of built-in functionality.  This allows for
easier creation of new components for specific needs.  Most @samp{csComponent}
methods are virtual, allowing to override them as needed.  There are some
basic methods, which are described below.  Other methods are described as
needed during this document.

@subsubheading Drawing: @code{csComponent::Draw()}

Each component should know how to paint itself.  When windowing system thinks
a part of a component image or entire component image is invalid (for example,
when a window is moved from the top of other components), it adds that
rectangle to the @dfn{dirty} rectangle of the component.  The dirty rectangle
is initially empty, then all invalid rectangles are added to it.  At the end
of each frame windowing system sends a broadcast event with @samp{cscmdRedraw}
command code.  When component catches this event, it calls @code{Redraw()}
method which in turn calls @code{csComponent::Draw()}.  After
@code{csComponent::Draw()} returns control, the dirty rectangle is emptied
again.

All draw operations are clipped first against dirty rectangle and then against
all component childs and neightbours.  So drawing inside a component does not
change even a pixel in other components, even if component is partialy covered
by other components.

There are a number of drawing operations that you can use.  Other operations
can be synthesized from existing.  All coordinates used for drawing are
component-origin related, so (0,0) corresponds to component top-left corner.

Here is a list of the primitive drawing methods:

@itemize @bullet
@item
@code{Line(@var{x1}, @var{y1}, @var{x2}, @var{y2}, @var{colorindex})}

Draw a line from (@var{x1}, @var{y1}) to (@var{x2}, @var{y2}).  Example:
@code{Line(0, 0, 3, 3)} produces the following output:

@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--+--+--+--+--+--
     |//|  |  |  |  |
 1 --+--#--+--+--+--+--
     |  |//|  |  |  |
 2 --+--+--#--+--+--+--
     |  |  |//|  |  |
 3 --+--+--+--#--+--+--
     |  |  |  |//|  |
...--+--+--+--+--+--+--
@end example

@item
@code{Box(@var{xmin}, @var{ymin}, @var{xmax}, @var{ymax}, @var{colorindex})}

Draw a filled box that is closed between lines @code{(X >= @var{xmin})},
@code{(X < @var{xmax})}, @code{(Y >= @var{ymin})} and @code{(Y < @var{ymax})}.
Example: @code{Box(0, 0, 3, 2)} will produce the following output:

@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--#--#--+--+--+--
     |//|//|//|  |  |
 1 --#--#--#--+--+--+--
     |//|//|//|  |  |
 2 --+--+--+--+--+--+--
     |  |  |  |  |  |
...--+--+--+--+--+--+--
@end example

@item
@code{Text(@var{x}, @var{y}, @var{foregroundindex}, @var{backgroundindex}, @var{textstring})}

Display a text string starting from (@var{x}, @var{y}) with color
@var{foregroundindex} and background @var{backgroundindex}.  If
@var{backgroundindex} is -1, the text is drawn transparently.  To determine
text width and height you can use the @code{TextWidth(@var{textstring})} and
@code{TextHeight()} functions.  There are a number of built-in @sc{csws}
fonts, they can be used by calling @code{SetFont(cs_Font_@var{XXXX})}.  Note
that both @code{TextWidth()} and @code{TextHeight()} depends on current font.

@item
@code{Sprite2D(@var{sprite2d}, @var{x}, @var{y}, @var{w}, @var{h})}

Draw a 2D sprite or bitmap.  @var{sprite2d} is a object of @samp{csPixmap}
class.  Sprite can have transparent colors, this way you can define
@dfn{holes} in textures.  (You can omit @var{w} and @var{h} to use normal
sprite size.)

@item
@code{Rect3D(@var{xmin}, @var{ymin}, @var{xmax}, @var{ymax}, @var{darkindex}, @var{lightindex})}

Draw a 3D-looking rectangle.  This method just draws four lines to form a
non-filled rectangle.  Example: @code{Rect3D(0, 0, 4, 4)}.

@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--#--#--#--+--+--
     |LL|LL|LL|DD|  |
 1 --#--+--+--#--+--+--
     |LL|  |  |DD|  |
 2 --#--+--+--#--+--+--
     |LL|  |  |DD|  |
 3 --#--#--#--#--+--+--
     |LL|DD|DD|DD|  |
 4 --+--+--+--+--+--+--
     |  |  |  |  |  |
@end example

@item
@code{ObliqueRect3D(@var{xmin}, @var{ymin}, @var{xmax}, @var{ymax}, @var{cornersize}, @var{darkindex}, @var{lightindex})}

Draw a rectangle with oblique corners of given size.  For example, calling
@code{ObliqueRect3D(0, 0, 10, 7, 3)} draws an oblique rectangle such as the
following:

@example
     0  1  2  3  4  5  6  7  8  9 ...
     |  |  |  |  |  |  |  |  |  |  |
 0 --+--+--#--#--#--#--#--#--#--#--+--
     |  |  |LL|LL|LL|LL|LL|LL|LL|DD|
 1 --+--#--+--+--+--+--+--+--+--#--+--
     |  |LL|  |  |  |  |  |  |  |DD|
 2 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 3 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 4 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 5 --#--+--+--+--+--+--+--+--#--+--+--
     |LL|  |  |  |  |  |  |  |DD|  |
 6 --#--#--#--#--#--#--#--#--+--+--+--
     |LL|DD|DD|DD|DD|DD|DD|DD|  |  |
...--+--+--+--+--+--+--+--+--+--+--+--
@end example

@item
@code{SetClipRect(@var{xmin}, @var{ymin}, @var{xmax}, @var{ymax})}

Define a local clipping rectangle for subsequent drawing operations. For
example, when drawing a button you may want to set clipping rectangle after
drawing button borders so that button text accidentally won't draw over its
borders even if it does not fit. To disable clipping you can define an empty
rectangle (@code{SetClipRect(0, 0, 0, 0)});
@end itemize

@subsubheading Event Handling: @code{csComponent::HandleEvent(csEvent&)}

This is the main component entry point for handling windowing system events.
Each time user presses a key, moves mouse etc windowing system generates a
event and sends it to appropiate component.  The normal event flow is
top-down, i.e. the root window receives events first, then passes them if
appropiate to its childs which passes it to their respective childs and so on.
However, there are some basical constraints on event flow that you should know
about:

@itemize @bullet
@item
@code{HandleEvent()} should return a boolean value that states whenever this
object used the event or not.  If the event has been used, no other component
will receive it anymore, otherwise windowing system looks for other appropiate
candidates for this event.  The only exception from this rule are broadcast
events that are sent to all childs independently of the fact that component
@emph{eaten} event or not.

@item
Mouse events are received only by the topmost component mouse pointer is over
and its parents.  If other behaviour is desired, a component should capture
the mouse by calling @code{app->CaptureMouse(this)}---in this case mouse
events are sent by application object directly to the object that captured the
mouse, bypassing normal event flow.  To revert to normal mode of operation
component should call @code{app->CaptureMouse(NULL)}.

@item
Keyboard events are sent only to components from @dfn{focus chain}
(@pxref{CSWS Focus Chain}).  If a different behaviour is desired, component
should capture keyboard events by calling @code{app->CaptureKeyboard(this)}.
To disable capturing keyboard events component should call
@code{app->CaptureKeyboard(NULL)}.

@item
Command events are not sent to child windows.  A reply to command event is
normally expected from the component it has been sent to, not from any of its
childs.  Moreover, re-sending command events to childs can be dangerous since
the event can be sent by one of its childs, and the application can get caught
in an endless loop.  Re-sending command events to parents is a normal
practice, for example all menus re-send command events to their parents since
commands are usually sent to menus by their childs (menu items or even
sub-menus).

@item
Broadcast events are the only type of events that are guaranteed to reach
every object in a subtree of components.
@end itemize

There is another method called @code{csComponent::PreHandleEvent()} which is
much like @code{HandleEvent()} except that it is called for each event pulled
from event queue before @code{HandleEvent()}, and without rules above, i.e.
any component can preprocess any hardware-generated event before it is sent
along normal event handling chain.  This can be used for popup menus, hot keys
and so on.  If @code{PreHandleEvent()} returns true, the event is considered
@emph{eaten} and is discarded.  Be careful with this feature to avoid
interfering with normal component functions.

And last method related to event processing is
@code{csComponent::PostHandleEvent()}.  It is called when no component handled
the event and it is called for all components in @emph{parent-to-child} order.
It can be used to process events that nobody wants, for example it is used to
process hotkeys on buttons (if active component is for example, a input line,
and user presses @kbd{A} key it should be entered into input text, while if
active component is a non text-hungry component (for example, a list box) the
@kbd{A} key can be used by some button to activate itself).

@subsubheading Fields of @samp{csComponent}
The @samp{csComponent} class has a number of data fields.  The most important
are summarized here.

@table @samp
@item csRect bound
This defines the physical bounds of the component.  All drawing operations
happens inside and are clipped to this bound.  Component does not have control
over any other pixel outside this bound.  The bounds are defined relative to
parent's origin.  For example, if we have a component with bounds (@var{xmin}
= 20, @var{ymin} = 10, @var{xmax} = 100, @var{ymax} = 50) and it has a child
at (10, 10, 30, 40) then its real (physical) pixel coordinates are (20+10,
10+10, 20+30, 10+40).  A child is always clipped to the bounds of all its
parents (however, there is a exception from this rule).

@item int state
Contains the state flags of the component.  There are two types of state flags
(although @sc{csws} does not make a difference between them)--@dfn{dynamic}
flags and @dfn{option} flags.  Option flags usually define some static aspect
of component---for example, whenever component is selectable (i.e. if it can
become the focused element), or it is partially transparent (see
irregularily-shaped components) etc.  Dynamic flags often changes during
component's life, for example component visibility flag, ``component focused''
flag and so on.  The component state flags starts with the @samp{CSS_} prefix.

You should never manually change state flags.  Instead, there are two methods
for this: @code{SetState(@var{mask}, @var{state})} and
@code{GetState(@var{mask})}.  For example, if component is not selectable and
you want to make it selectable, call @code{component.SetState(CSS_SELECTABLE,
true)}.  The @code{SetState()} method is virtual and is often overriden to
execute some specific functions when component state changes.  For example,
default @code{SetState()} handler shows or hides the component if
@samp{CSS_VISIBLE} flag state changes.

@item csRect dirty
Contains the @dfn{dirty} rectangle.  If it is non-empty, the dirty area of
component is redrawn just before the end-of-frame.

@item int DragStyle
Contains a combination of bits (defined by constants with names such as
@code{CS_DRAG_@var{XXX}}) that defines which sides of component can be dragged
with mouse when you call first the @code{csComponent::Drag()} method.  By
default it is equal to @samp{CS_DRAG_ALL}.  Note that if component won't call
@code{csComponent::Drag()} you won't be able to resize the component even if
@samp{DragStyle} is equal to @samp{CS_DRAG_ALL}.

@item csApp *app
This is the ``main'' application object; the root of entire window tree.  It
is a descendant of @samp{csApp} class which is a superclass of
@samp{csComponent}.  @samp{csApp} has some application-global methods such as
@samp{CaptureMouse}, @samp{CaptureKeyboard}, it contains the global mouse
pointer object and many other.

@item csComponent *parent
Contains the @dfn{parent} component.  Components are chained into a tree, each
component knows its neightbours (through @samp{next} and @samp{prev} fields),
each parent knows its focused child, and can traverse its list of childs by
starting from focused, then going to @emph{focused-to-next} and so on.

@item csComponent *prev
@itemx csComponent *next
Contains the next and previous neightbours in parent's child list.  They are
never @code{NULL}, chains are always closed.  If a component is the only child
of another, its next and prev fields points to himself.

@anchor{CSWS Focus Chain}
@item csComponent *focused
This is the focused child component.  For example, keyboard events are sent
only to components in @dfn{focused} chain, i.e. to @samp{app},
@samp{app->focused}, @samp{app->focused->focused} and so on.  If component
does not have any child components, focused is @code{NULL}.  This is the only
possible case when ``focused'' can be @code{NULL}.

@item csComponent *top
This is the top component in Z-order.  Mouse events are processed in Z-order
unlike keyboard events.  The focused event is not neccessarily the top
component, although usually this is true.  If component has
@samp{CSS_TOPSELECT} flag set, when user activates (focuses) a component, it
is made the topmost, however if it has this flag reset, its Z-order does not
change.

@item int id
This is component's identifier.  This is a user-definable value, but it is
expected to be unique within all childs of a parent component.  You can search
for child components with given identification by calling
@code{parent->GetChild(int @var{find_id})}.
@end table

@node CSWS Events, CSWS Clipping, CSWS Components, CSWS
@subsection Events

There are several event types (other event types can be defined as needed, but
existing set covers all current @sc{csws} needs).  There is the base event
class called @samp{csEvent}.  It has several public data fields, the mostly
used is Type which contains the event type.  There are following currently
defined event types:

@table @code
@item csevNothing
The so-called ``empty'' event; mostly used internally by @sc{csws}.

@item csevKeyDown
Key has been pressed event.

@item csevKeyUp
Key has been released event.  On @samp{csevKeyUp} and @samp{csevKeyDown}
events the following data fields in event object are also valid:

@table @code
@item Key.Code
Contains code of key that has been pressed or released.  It can be a literal
value (@samp{A}, @samp{z}, @samp{$}) or one of predefined
@samp{CSKEY_@var{XXX}} values (@samp{CSKEY_UP}, @samp{CSKEY_ESC},
@samp{CSKEY_SPACE}, @samp{CSKEY_ENTER}, etc.).

@item Key.Modifiers
Contains the state of shift keys at time when this event has been generated.
Note that it not neccessarily is the same as current key state.  To decode its
value you should use the pre-defined @samp{CSMASK_@var{XXX}} constants.  For
example to check if the @kbd{@key{Alt}} modifier was pressed, and only this
modifier you might use this code:

@example
if ((Event.Key.Modifiers & CSMASK_ALLSHIFTS) ==
  CSMASK_ALT)
@{
  @dots{} ALT + Event.Key.Code pressed @dots{}
@}
@end example

@noindent
Or, alternately, to check if @kbd{@key{Alt}} was pressed, but not necessarily
the only modifier key pressed, you could do it this way:

@example
if (Event.Key.Modifiers & CSMASK_ALT)
@{
  @dots{} (at least ALT) + Event.Key.Code pressed @dots{}
@}
@end example

@noindent
Also there is a bit in @samp{Modifiers} called @samp{CSMASK_FIRST} that is set
only when key is pressed for first time.  With this you can separate actual
key presses from autorepeated keyboard events.
@end table

@item csevMouseMove
Mouse moved event.

@item csevMouseDown
A mouse button was pressed event.

@item csevMouseUp
A mouse button was released event.  On all mouse events the following data
fields in event object are also valid:

@table @code
@item Mouse.x
@itemx Mouse.y
The screen position where mouse event happened.  Mouse position is always
converted to component coordinate system, i.e. @samp{Mouse.x == 0} and
@samp{Mouse.y == 0} means that mouse is at component top-left system.

@item Button
Mouse button number, counting from 1. Not valid for ``mouse moved'' event.

@item Key.Modifiers
Contains the state of shift keys at time when this event has been generated.
See above for comments on shift keys.
@end table

@item csevCommand
A command event.  Command events are generated by windowing system components,
not by hardware.  For example, when a button is pressed, it sends a command
event with some command code to its parent component.  There is only one data
field for this type of events called @samp{Info} of type @samp{void*}.  It can
point to any event-related information.

@item csevBroadcast
Broadcast events are much like command events, except that no component can
intercept (@emph{eat}) it, and they are feed to all child, grandchild etc.
components in a component tree (starting from the component that received
first this event).
@end table

To check if the event is generated by keyboard, you can use the predefined
@code{IS_KEYBOARD_EVENT(Event)} macro.  To check for mouse events, you can use
the @code{IS_MOUSE_EVENT(Event)} macro.

@node CSWS Clipping, CSWS Tutorial, CSWS Events, CSWS
@subsection Clipping

Clipping is the process of removing parts of output covered by other
components.  @sc{csws} has full clipping implemented for all existing graphics
primitives.  There is no drawing operation that can influence other
component's image except transparent windows.  Clipping is performed in the
following fasion.  First primitive is clipped against @emph{dirty} rectangle
(to cut off excessive output), then it is clipped against all its neightbours,
then against @samp{clip parent} window and all its neightbours and so on.

@subsubheading Clip Parents

All components have a @samp{parent} component and a @samp{clipparent}
component.  What they are used for? Usually @samp{clipparent} is equal to
@samp{parent} so there is no difference between them.  But in some rare cases
there is a need to perform clipping in a different way.  For example, popup
menus that belong to a window usually should not be clipped against that
window, but rather to the parent of parent window or even clipped only to
desktop.  In this case you should assign a different clip parent to that
component.  This can be performed by using @code{InsertClipChild()} method.
For example, to make a menu clip to application's bounds, you should call:

@example
app->InsertClipChild(menu);
@end example

You should not assign directly to @samp{clipparent} variable since
@code{InsertClipChild()} does much extra work.  For example it inserts the
so-called ``clip children'' into component's clip child list, removes
component from former @code{clipparent}'s ``clip children'' list and so on.

@subsubheading Partially Transparent Components

You can set a state flag called @samp{CSS_TRANSPARENT} to mark
semi-transparent components.  Transparent components works differently in the
following ways:

@itemize @bullet
@item
When a part of such a component is invalidated, the same area of parent
component is invalidated as well.

@item
Mouse events for such components are considered ``eaten'' only if component's
@code{HandleEvent()} method returned @samp{true}.  Otherwise, the event is
sent to the component placed below the transparent component.

@item
The output of windows below transparent components is not clipped.  Instead
the area of transparent component covered by output is invalidated so that it
gets redrawn at the end of frame.
@end itemize

@node CSWS Tutorial, , CSWS Clipping, CSWS
@subsection Quick Tutorial

In the following discussion I will try to explain how to build simple
applications using Crystal Space Windowing System.  I hope you will understand
enough to start writing your own applications; I also hope you will get a
deeper knowledge of @sc{csws} during your development (or lab) sessions.

@subsubheading A Simple Application

The simplest possible application should do the following:

@itemize @bullet
@item
Create an application object (@samp{csApp}).
@item
Run the application; meaning run the main event processing loop.
@item
Finish the application; that is, delete the object.
@end itemize

@noindent
Let's try:

@example
#include "csws/csws.h"

int main(int argc, char const* const argv[])
@{
  csApp app("CSWS test application", argc, argv);
  if (app.InitialSetup())
    app.Loop();
@}
@end example

Pretty simple, eh? So the result is simple as well.  We got a gray background,
a mouse and nothing more.  What the program does is:

@itemize @bullet
@item
First, it creates a @samp{csApp} object called @samp{app}.  To initialize the
application you pass three parameters: the window title (for system that
support a window title) and argument vector passed to @code{main()} so that
Crystal Space low-level layer can process arguments such as @samp{-mode},
@samp{-depth} and so on.

@item
The next step is to call @code{InitialSetup()} method.  The @code{csApp}'s
@code{InitialSetup()} method does nothing except returning @samp{true}, but
you probably will want to override it to initialize your application there.
Create a popup menu, insert it into the desktop, add some windows, read
configuration files etc.

@item
And finally we run the main application loop.  The event consuming loop does
the following.  While there are events in input queue it read an event and
passes it to @code{HandleEvent()}.  If there weren't any events in the loop,
it calls @code{Idle()} method to give some time slices to other running
applications (if @code{csSystemDriver::Sleep()} method is implemented
properly).  If some window needs redrawing, it is redrawn.  After this the
screen is updated and everything starts again from the beginning.
@end itemize

If you observe, the above program does not delete the @samp{csApp} object.
That's because it is a automatic variable and not a pointer, so its
automatically deleted when program finishes.  If you would use a pointer, you
should explicitely delete the @samp{app} pointer with @samp{delete app}
command.
