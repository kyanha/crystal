@node csUtil, SCF, csSys, Libraries
@section Utility Library (@code{csUtil})
@cindex csUtil
@cindex Libraries,csUtil
@cindex Utility Library

The utility library consists of many smaller modules that are too small to
live as a separate library. The biggest part of it is the @sc{scf} library.
@xref{SCF}.

Then there are a series of classes implementing arrays of some sort.
There are currently six types of arrays in CS. All are templated and
type-safe.  See later sections for additional information.

@itemize @bullet
@item
@code{csArray<T>},
@item
@code{csGrowingArray<T>}
@item
@code{csRefArray<T>}
@item
@code{csRefArrayObject<T>}
@item
@code{csPArray<T>},
@item
@code{csPDelArray<T>}
@end itemize

Also in csutil are the @file{.cfg} file reader and the random
number generator.

The other classes might or might not be useful, so if you need some very
common functionality in your application, you should look in the @sc{api}
reference to see if it is already implemented. The usage of these classes
will not be explained further, as most functions are self-explanatory. The
comments in the @sc{api} reference and the header files should also help.

Exceptions should be made here for the @code{csObject} class and for typed
vectors. They will be explained in the next sections.

@menu
* csObject:: @code{csObject}
* Typed Arrays:: @code{Typed Arrays}
@end menu

@node csObject, Typed Arrays, csUtil, csUtil
@subsection @code{csObject}
@cindex @code{csObject}

The @code{csObject} class can be used to build object hierarchies. It supports
building a simple tree structure. To use this functionality, you should derive
your classes from @code{csObject}. @code{csObject} implements the
@code{iObject} interface and can store any number of @code{iObject} children.
Furthermore, every @code{csObject} has a name.

All child objects are @code{IncRef}'ed when added and @code{DecRef}'ed when
removed. An object also stores a pointer to its parent (which is not
reference-counted to avoid circular references). Note that this pointer will
always point to the last parent if the object is added to more than one
parent. When the object is removed from a parent, the pointer is set to
@code{NULL}, even if the object is still a child of another parent!

Although the children of an object are only available as @code{iObject}'s,
you can use @code{SCF_QUERY_INTERFACE} to query other interfaces from them.
Some convenience macros are also available:
@table @code
@item CS_GET_CHILD_OBJECT(object,Interface)
Get the first child object that implements the given interface.

@item CS_GET_NAMED_CHILD_OBJECT(object,Interface,name)
Get the first child object with the given name that implements the given
interface. This will continue to search through the objects if an object
with the right name but not the right interface was found, i.e. it handles
multiple objects with the same name correctly.

@item CS_GET_FIRST_NAMED_CHILD_OBJECT(object,Interface,name)
Same as the above but stops at the first object with the given name, even if
it does not implement the requested interface (in that case, @code{NULL} is
returned). This is slightly faster.
@end table
Note that all these macros increase the reference count of the returned
object by 1.

@node Typed Arrays, , csObject, csUtil
@subsection Typed Arrays
@cindex Typed Arrays

Crystal Space currently has several styles of typed Arrays.  These arrays grow
as needed to accommodate additions and insertions.

@itemize
@item
@code{csArray<T>}: This is a generic, all-purpose dynamic array class.  It is
suitable for any C++ type, including basic types (such as @samp{int}) and
user-defined types (such as objects).  This class guarantees proper
construction and destruction of objects as they are added to, and removed from
the array.  Include file is @file{csutil/array.h}.

@item
@code{csGrowingArray<T>}: Similar to @code{csArray<T>}, this array type can be
used to store arbitrary objects, with the exception that it @emph{does not
invoke constructors and destructors} of contained objects.  Use this class at
your own peril; @code{csArray<T>} is almost always a better choice.  The only
conceivable instance in which use of this class might be warranted is when
micro-optimization is required; when you need to avoid the overhead of object
construction, but this is highly dangerous and should be avoided in almost all
cases.  This class is mainly useful in cases where you have simple objects
(structures) and efficiency is of utmost importance.  Also, this array provides
read access to the actual memory vector, which can be useful if you need to
communicate with some external @sc{api}.  Include file is
@file{csutil/garray.h}.

@item
@code{csRefArray<T>}: This is the preferred way to store an array of pointers
to reference-counted objects.  This array type automatically invokes each
object's @code{IncRef()} method at insertion time, and @code{DecRef()} at
removal time.  All @sc{scf} objects (@pxref{SCF}) support these methods, as do
objects derived from @code{csRefCount}.  Since @code{csRefArray<T>} is a
templated class, it will also work with any other object which provides
@code{IncRef()} and @code{DecRef()} methods.  Include file is
@file{csutil/refarr.h}.

@item
@code{csRefArrayObject<T>}: This is a variant of @code{csRefArray<T>} which can
hold objects that have a method @code{QueryObject()} which returns something
from which you can call @code{GetName()}.  In practice it means this is useful
for all Crystal Space objects that implement @code{iObject}.  In addition to
the features of @code{csRefArray<T>} this class adds the ability to find
elements by name.  Include file is @file{csutil/nobjvec.h}.

@item
@code{csPArray<T>}: @emph{This class is deprecated.} This array class only
works works with with pointers to objects.  It does not initialize its
elements.  It does not invoke an object's @code{IncRef()} and @code{DecRef()}
methods.  Client code is fully responsible for cleaning up the items in this
array.  In short, it is an extremely dangerous array class and shold not be
used in new code.  @emph{Do not use this array type.} Instead, you should use
@code{csArray<T>}.  Include file is @file{csutil/ptrarr.h}.

@item
@code{csPDelArray<T>}: @emph{This class is deprecated.} This is similar to
@code{csPArray<T>}.  It is for pointers only.  It differs from
@code{csPArray<T>} in that it invokes @samp{delete} for elements removed from
the array.  Other than that difference, all of the warnings which apply to
@code{csPArray<T>} also apply to this class.  You should not use this class for
new code.  Instead, use @code{csArray<T>} or @code{csRefArray<T>}, depending
upon your requirements.  Include file is @file{csutil/ptrarr.h}.
@end itemize
