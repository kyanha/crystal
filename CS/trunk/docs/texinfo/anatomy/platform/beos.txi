@c -*-texinfo-*-
@node BeOS details, , OS2 details, Platform_Details
@subsection Detailed information for BeOS

This is the description of the BeOS port internals.

Written by David Huen(@email{smh1008@@cus.cam.ac.uk}) @*
Heavily amended by Eric Sunshine (@email{sunshine@@sunshineco.com})
1999/10/27 (on account of his major overhaul and re-engineering of the port).

@menu
* BeOS details Introduction:: Introduction
* BeOS system driver:: Description of the BeOS SysSystemDriver
* BeOS Operation of SysSystemDriver:: Operation of SysSystemDriver
* Description of BeOS 2D Graphics Driver::
* Operation of BeOS 2D Graphics Driver::
* BeOS Bug List and To-Do Items:: Bug List and To-Do Items
@end menu

@node BeOS details Introduction, BeOS system driver, BeOS details, BeOS details
@subsubsection Introduction

I have expended many hours on working out how CrystalSpace works in BeOS with
a view to improving its existing performance and eventually extending its
functionality. My main interest in CS is as a testbed to explore the extent
to which SMP can impact 3D graphics engines. Unfortunately, I'll have to
understand the current implementation thoroughly before I can begin to
explore SMP possibilities.

Anyway, I thought that if I'm going to invest all this time and effort, I
might as well write up what I have learned to make it easier for others to
pick up CS. What I write specifically addresses the BeOS port when used in
conjunction with the Walktest example although it may be relevant to some of
the other ports as well.

This document serves as an aide-memoire for myself on BeOS CS and I will be
periodically releasing updates to it.

@node BeOS system driver, BeOS Operation of SysSystemDriver, BeOS details Introduction, BeOS details
@subsubsection Description of the BeOS SysSystemDriver

CrystalSpace-based applications are derived from a single class of type
@code{SysSystemDriver}.It is necessary to understand how this class relates
to the standard BeOS class @code{BApplication}.

For example, in the demo application, @file{walktest.cpp}, the main block
begins with a creating an instance of Walktest:
@example
CHK(Sys = new Walktest());
@end example
(see @file{apps/walktest/walktest.cpp})

Walktest itself is derived from @code{SysSystemDriver} (which is derived from
@code{csSystemDriver}) so @code{SysSystemDriver::SysSystemDriver} is invoked.
This in turn creates an instance of @code{CrystApp}:
@example
CHK (new CrystApp(this));
@end example
(see @file{CS/libs/cssys/be/csbe})

A pointer to the newly-created CrystApp is automatically assigned to the
global variable @code{be_app}.

CrystApp is derived from BApplication and the CrystApp constructor:
@example
CrystApp::CrystApp(ISystem* isys)
@end example
takes the argument @samp{isys} and assigns it to the pointer @samp{driver}
within @code{CrystApp}. driver then points to the walktest object and can
access all methods exported by the @code{ISystem} interface. The high level
@code{SysSystemDriver} can be queried and controlled via the @file{driver}
pointer.

@node BeOS Operation of SysSystemDriver, Description of BeOS 2D Graphics Driver, BeOS system driver, BeOS details
@subsubsection Operation of SysSystemDriver

This description follows the execution of walktest.

The main block creates the Walktest object (derived from
@code{SysSystemDriver}) at the start and sets up a pointer Sys to it.
It then picks up info from the configuration files, sets up the world,
plug-in modules, console object (@code{csSimpleConsole}), loads textures,
execute the script, etc. Right at the end it invokes the method
@code{Sys->Loop()}, which invokes the inherited
@code{SysSystemDriver::Loop()} method. This method sets up the BeOS 2D
Graphics interface to obtain the display view from it.

On first passage, it starts a thread with
@code{SysSystemDriver::LoopThread()} and calls @code{app->Run()} which begins
message processing on the Walktest (@code{SysSystemDriver}) object.
@code{Loop()} can be called recursively by the Crystal Space Windowing System
(CSWS) when it wants to begin a modal loop (for instance, when an alert panel
is launched), so this case is handled specially.

The @code{LoopThread()} method runs in its own thread separately. It
repeatedly calls @code{SysSystemDriver::NextFrame()} as quickly as the CPU
can process it. Termination is detected by checking the instance variables
Shutdown and ExitLoop which are set appropriately by different parts of the
system. ExitLoop is set when CSWS wants to exit from a modal loop, and
Shutdown is set when CrystalSpace wants to shut down the application
entirely. @code{NextFrame()} is a method in @code{SysSystemDriver}, though it
is overridden in walktest. @code{Walktest::NextFrame} does all the stuff
needed to setup and draw the next frame.

@node Description of BeOS 2D Graphics Driver, Operation of BeOS 2D Graphics Driver, BeOS Operation of SysSystemDriver, BeOS details
@subsubsection Description of BeOS 2D Graphics Driver

The BeOS-specific 2D Graphics class is @code{csGraphics2DBeLib} and it is
derived from the general 2D graphics class csGraphics2D.

@node Operation of BeOS 2D Graphics Driver, BeOS Bug List and To-Do Items, Description of BeOS 2D Graphics Driver, BeOS details
@subsubsection Operation of BeOS 2D Graphics Driver

During system initialisation in @code{csSystemDriver::Initialize()} an
instance of the 3D graphics driver is created by the SCF system. The 3D
driver then uses SCF to create an instance of the 2D Be driver.
@code{teInstance()}. This method creates a new @code{Graphics3DSoftware} and
returns a pointer to its interface.

When @code{csGraphics3DSoftware::Initialize()} executes, it calls
@code{csGraphics2DBeLib::Initialize()}. This method begins by calling
@code{csGraphics2D::Initialize()} which initialises default values for
parameters like pixel format, screen size and the actual methods used to
implement the virtual methods @code{GetPixelAt()}, @code{DrawPixel()},
@code{WriteChar()} and @code{DrawPixmap()}.
@code{csGraphics2DBeLib::Initialize()} then uses BScreen to access the
current @code{color_space} setting and uses it to set the correct values for
all these parameters. it also creates a bitmap of the required
@code{color_space} pointed to by private @code{BBitMap*} bitmap.

@code{csGraphics3DSoftware::Open()} calls @code{csGraphics2DBeLib::Open()}
(defined in @file{cs2d/be/belibg2d.cpp}) which begins by calling the
inherited @file{csGraphics2D::Open()} method (defined in
@file{cs2d/common/graph2d.cpp}). @code{csGraphics2D::Open()} creates an
@code{int} array with the number of scanlines designated in @file{cryst.cfg}
and sets up the static @code{csGraphics2D::ScanLine} pointer to it. It then
initialises it with precalculated addresses of each scanline in the bitmap. A
new instance of @code{CrystView} and attached to a new instance of
@code{CrystWindow}. [N.B.: If changeable screen sizes are to be implemented,
Scanline may have to be deleted and recreated.]

@code{CrystView} is derived from @code{BView} and implements handlers for key
and mouse actions. CrystWindow is derived from @code{BDirectWindow}. It
notifies the system driver that the application should terminate when the
user closes the window. CrystApp doesn't currently use @code{BDirectWindow}
in the prescribed manner, e.g. using a separate drawing thread to render it.
This doesn't matter currently as direct framebuffer manipulation is not
currently used but could eventually take on a greater significance when that
is done.

The current implementation of the software renderer calls
@samp{Gfx3D->Print()} from @code{Walktest::DrawFrame()}.
@code{csGraphics3DSoftware::Print()} then calls @samp{m_piG2D->Print(area);}
which invokes the 2D method @code{csGraphics2DBeLib::Print(csRect* area)}.

As currently implemented, the software renderer draws to a @code{BBitMap} of
the same @code{color_space} as screen. This bitmap is pointed to by the
static: @samp{unsigned char* csGraphics2D::Memory = NULL;}

The @code{Print()} method displays the bitmap by locking the window, blitting
the @code{BBitmap} to the @code{CrystView}, then unlocking the window.

@node BeOS Bug List and To-Do Items, , Operation of BeOS 2D Graphics Driver, BeOS details
@subsubsection Bug List and To-Do Items

This is the list of BeOS-specific bugs compiled by Eric Sunshine
(@email{sunshine@@sunshineco.com}). These bugs are being actively eradicated.

@itemize @bullet
@item
The BeOS system driver should determine the directory in which the
application resides, and set that as the current working directory. This
would (presumably) allow the programs to be launched from the Tracker
application by merely double-clicking on them.

@item
Add full-screen support. Be careful about the resolution, since CS can use
any arbitrary window dimension.

@item
Application should be able to redraw rendering window when BeOS asks for a
redraw even if CS is busy (that is, not pushing out a continuous stream of
frames). There are already cases where this is needed, and will be very
important when a pause feature is added.

@item
Pause when not foreground application. Make sure that screen redraws
correctly even when paused.

@item
The various 2D graphics drivers (software, OpenGL, Glide) should all be
derived from a common class rather than being nearly identical copies of one
another.

@item
It is probably safe to remove @file{Crystal.rsrc} from @file{libs/cssys}
since it is unused at this time.

@item
Should be using @code{DirectWindow} rather than @code{DirectBitmap} where
supported since @code{DirectWindow} puts much less load on the CPU.
Auto-detect if @code{DirectWindow} is available and use it if so. Note,
though, that David Huen says this might not be worthwhile.

@item
It is possible to close the window while the application is starting, yet the
application does not terminate.

@item
Glide driver does not compile.

@item
It is probably not safe to be inserting mouse and keyboard events into CS's
event queue from the main thread while the queue is being processed by a
secondary thread. It is also probably unsafe to cascade mouse moved events
from inside @samp{LoopThread} thread.

@item
Ked Shayer (@email{c.shayer2@@ukonline.co.uk}) suggests using NASM for the
assembler code.
@end itemize

This is the list of problems which have recently been fixed.

@itemize @bullet
@item
Project spews compilation warnings.

@item
Project fails to support png, which causes a number of programs to fail.

@item
Project fails to support jpeg, which causes a number of programs to fail.

@item
Shooter does not work (needs png).

@item
Cswstest does not work (needs png).

@item
MazeD does not work (needs png).

@item
Squawk does not work (needs jpeg).

@item
Version string says @samp{Unix-Intel-GCC} but should say
@samp{BeOS-Intel-GCC}.

@item
Network socket library does not compile (BeOS does not support sockets).

@item
NetworkDriverDemo does not work (needs socket library).

@item
OpenGL compiles with warnings.

@item
Squawk is displaying detritus text from the console in the gaps between 3D
views every other frame. This is a double-buffer problem (in Squawk itself).

@item
The makefile @file{glrender.mak} tries linking with libraries which do not
exist on BeOS.

@item
CSWS exhibits serious display anomalies since the 2D driver does not properly
implement the double-buffer protocol.

@item
Something in the make process is executing @samp{rm -f} during @samp{clean}.

@item
Center window instead of launching it in the upper left corner of screen.

@item
Remove all of the unused @samp{simulated depth} code.

@item
Modified key strokes are not translated properly. Can not use shift,
alternate, and control modifiers in walktest. Control keys are not
translated correctly.

@item
MazeD does not respond to the mouse at all (which makes it entirely useless).
Mouse handling is highly broken.

@item
Re-engineer the mouse-moved messages.  Currently they are too numerous for CS and cause CSWS to crawl when it is drawing a software cursor.  Perhaps try cascading the mouse-moved messages in between NextFrame() calls.

@item
Implement @code{csGraphics2DBeLib::SetMouseCursor()}.

@item
Be-specific @code{SysSystemDriver::Loop()} does not implement the recursive
case correctly. Consequently modal loops initiated by MazeD (and CSWS
specifically) will not work.  Be careful enough to ensure that it safely
exits from recursive invocations whenever Shutdown becomes true (such as when
the window is closed).

@item
The application does not exit when CS requests termination.

@item
The window is not closed when @kbd{ALT-q} is used to terminate the
application.

@item
Closing the main window causes the application to terminate without going
through the normal CS shutdown sequence.

@item
Update the OpenGL driver to match the implementation of the default 2D
(software) driver.

@item
Squawk crashes upon initialization when using OpenGL driver.

@item
Application bombs at termination when using OpenGL driver.

@item
Document building @file{libjpeg.a}. People have trouble with this.

@item
Remove double-buffering support. It serves no meaningful purpose in this
windowed environment, and is a waste of memory.
@end itemize
