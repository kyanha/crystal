@c -*-texinfo-*-

@macro BeOS{}
@sc{b}e@sc{os}
@end macro

@node BeOS Details, , OS2 Details, Platform Details
@subsection BeOS
@cindex @sc{b}e@sc{os} Details

@emph{Written by David Huen, @email{smh1008@@cus.cam.ac.uk}; heavily amended
by Eric Sunshine, @email{sunshine@@sunshineco.com}, after Eric performed a
major overhaul and re-engineering of the port.  Last updated 12 May 2000.}

This section attempts to explain some of the inner workings of the @BeOS{}
port of Crystal Space.  Configuration, compilation, and installation
instructions, are also available, @ref{BeOS}.

I (David) have expended many hours on working out how Crystal Space works in
@BeOS{} with a view to improving its existing performance and eventually
extending its functionality.  My main interest in Crystal Space is as a
testbed to explore the extent to which @sc{smp} can impact 3D graphics
engines.  Unfortunately, I'll have to understand the current implementation
thoroughly before I can begin to explore @sc{smp} possibilities.

Anyway, I thought that if I'm going to invest all this time and effort, I
might as well write up what I have learned to make it easier for others to
pick up Crystal Space.  What I write specifically addresses the @BeOS{} port
when used in conjunction with the Walktest example although it may be relevant
to some of the other ports as well.

This document serves as an aide-memoire for myself on @BeOS{} Crystal Space.

@menu
* BeOS SysSystemDriver Creation:: @code{SysSystemDriver} Creation
* BeOS SysSystemDriver Operation:: @code{SysSystemDriver} Operation
* BeOS 2D Driver:: 2D Graphics Driver
* BeOS Notes:: Final Notes
@end menu

@node BeOS SysSystemDriver Creation, BeOS SysSystemDriver Operation, BeOS Details, BeOS Details
@subsubsection @code{SysSystemDriver} Creation

Crystal Space-based applications are typically derived from a single class of
type @samp{SysSystemDriver}.  It is necessary to understand how this class
relates to the standard @BeOS{} class @samp{BApplication}.

For example, in the demo application, @file{CS/apps/walktest/walktest.cpp},
the main block begins with a creating an instance of @samp{WalkTest}:

@example
Sys = new WalkTest();
@end example

@samp{WalkTest} itself is derived from the @BeOS{}-specific
@samp{SysSystemDriver} (which is derived from @samp{csSystemDriver}).
@samp{SysSystemDriver} creates an instance of @code{CrystApp} (see
@file{CS/libs/cssys/be/csbe.cpp}):

@example
app = new CrystApp(this);
@end example

A pointer to the newly-created @samp{CrystApp} is automatically assigned to
the global variable @samp{be_app}.

@example
CrystApp::CrystApp(iSystem*)
@end example

@samp{CrystApp} is derived from @samp{BApplication}.  and the @samp{CrystApp}
constructor takes the argument of type @samp{iSystem*} and assigns it to the
pointer @samp{driver} within @code{CrystApp}.  @samp{driver} then points to
the @samp{WalkTest} object and can access all methods exported by the
@samp{iSystem} interface.  The high level @samp{SysSystemDriver} can be
queried and controlled via the @samp{driver} pointer.

@node BeOS SysSystemDriver Operation, BeOS 2D Driver, BeOS SysSystemDriver Creation, BeOS Details
@subsubsection @code{SysSystemDriver} Operation

This description traces the execution of @samp{WalkTest}.

The main block creates the @samp{WalkTest} object (which is derived from
@samp{SysSystemDriver}) at the start and points @samp{Sys} at it.  It then
picks up information from the configuration files, sets up the world, plug-in
modules, console object (@samp{csSimpleConsole}), loads textures, executes the
script, etc.  Right at the end it invokes the method @code{Sys->Loop()}, which
invokes the inherited @code{SysSystemDriver::Loop()} method.  This method sets
up the @BeOS{} 2D graphics interface to obtain the display view from it.

On first passage, it starts a thread with @code{SysSystemDriver::LoopThread()}
and calls @code{app->Run()} which begins message processing on the
@samp{WalkTest} (@code{SysSystemDriver}) object.  @code{Loop()} can be called
recursively by the Crystal Space Windowing System , @sc{csws} (@pxref{CSWS})
when it wants to begin a modal loop (for instance, when an alert panel is
launched), so this case is handled specially.

The @code{LoopThread()} method runs in its own thread separately.  It
repeatedly calls @code{SysSystemDriver::NextFrame()} as quickly as the
@sc{cpu} can process it.  Termination is detected by checking the instance
variables @samp{Shutdown} and @samp{ExitLoop} which are set appropriately by
different parts of the system.  @samp{ExitLoop} is set when @sc{csws} wants to
exit from a modal loop, and @samp{Shutdown} is set when Crystal Space wants to
shut down the application entirely.  @code{NextFrame()} is a method in
@samp{SysSystemDriver}, though it is overridden in @samp{WalkTest}.
@code{Walktest::NextFrame()} does all the stuff needed to setup and draw the
next frame.

@node BeOS 2D Driver, BeOS Notes, BeOS SysSystemDriver Operation, BeOS Details
@subsubsection 2D Graphics Driver

The @BeOS{}-specific 2D graphics class (for the software renderer) is
@samp{csGraphics2DBeLib} and it is derived from the general 2D graphics class
@samp{csGraphics2D}.

During system initialization in @code{csSystemDriver::Initialize()} an
instance of the 3D graphics driver is created by the @sc{scf} system.  The 3D
driver then uses @sc{scf} to create an instance of the 2D @BeOS{} driver using
@code{CreateInstance()}.  This method creates a new @samp{Graphics3DSoftware}
and returns a pointer to its interface.

An important step performed by the method
@code{csGraphics3DSoftware::Initialize()} is the invocation of
@code{csGraphics2DBeLib::Initialize()}, which begins by calling the method
@code{csGraphics2D::Initialize()}.  This method initializes the default values
for parameters like pixel format, screen size and the actual methods used to
implement the virtual methods @code{GetPixelAt()}, @code{DrawPixel()},
@code{WriteChar()} and @code{DrawPixmap()}.
@code{csGraphics2DBeLib::Initialize()} then uses the @samp{BScreen} class to
access the current @samp{color_space} setting and uses it to set the correct
values for all these parameters.  it also creates a bitmap of the required
@samp{color_space} pointed to by private @samp{BBitMap*} bitmap.

@code{csGraphics3DSoftware::Open()} calls @code{csGraphics2DBeLib::Open()}
which is (defined in @file{plugins/video/canvas/be/belibg2d.cpp}) which begins
by calling the inherited @file{csGraphics2D::Open()} method (defined in
@file{plugins/video/canvas/common/graph2d.cpp}).  @code{csGraphics2D::Open()}
creates an @samp{int} array with the number of scanlines designated in
@file{cryst.cfg} and sets up the static @samp{csGraphics2D::ScanLine} pointer
to it.  It then initialises it with precalculated addresses of each scanline
in the bitmap.  A new instance of @samp{CrystView} and attached to a new
instance of @samp{CrystWindow}.

@samp{CrystView} is derived from @samp{BView} and implements handlers for key
and mouse actions.  @samp{CrystWindow} is derived from @samp{BDirectWindow}.
It notifies the system driver that the application should terminate when the
user closes the window.  @samp{CrystApp} doesn't currently use
@samp{BDirectWindow} in the prescribed manner, e.g.  using a separate drawing
thread to render it.  This doesn't matter currently as direct framebuffer
manipulation is not currently used but could eventually take on a greater
significance when that is done.

The software renderer calls @code{G3D->Print()} from
@code{Walktest::DrawFrame()}.  This invokes
@code{csGraphics3DSoftware::Print()} which then calls @code{G2D->Print()}
which finally invokes @code{csGraphics2DBeLib::Print()}.

As currently implemented, the software renderer draws to a @samp{BBitmap} of
the same @samp{color_space} as the screen.  This raw contents of the bitmap
are referenced by the static @samp{csGraphics2D::Memory} variable.

The @code{Print()} method displays the bitmap by locking the window, blitting
the @samp{BBitmap} to the @samp{CrystView}, then unlocking the window.

@node BeOS Notes, , BeOS 2D Driver, BeOS Details
@subsubsection Final Notes

This section lists future plans as well as problems or potential problems with
the @BeOS{} port of Crystal Space and was compiled by Eric Sunshine
(@email{sunshine@@sunshineco.com}), who is also working to shorten this list
as time permits.

@itemize @bullet
@item
Add full-screen support for software mode.  Be careful about the resolution,
since Crystal Space can use any arbitrary window dimension.

@item
The application should be able to redraw the rendering window when @BeOS{}
asks for a redraw even if Crystal Space is busy (that is, not pushing out a
continuous stream of frames).  There are already cases where this is needed,
and will be very important when a pause feature is added.

@item
Pause when not foreground application.  Make sure that screen redraws
correctly even when paused.

@item
The various 2D graphics drivers (software, OpenGL, Glide) should all be
derived from a common class rather than being nearly identical copies of one
another.

@item
Consider using @samp{DirectWindow} rather than @samp{DirectBitmap} where
supported since @samp{DirectWindow} puts much less load on the @sc{cpu}.
Auto-detect if @samp{DirectWindow} is available and use it if so.  Note,
though, that David Huen says this might not be worthwhile on account of the
fact that the software renderer reads from the frame buffer, and this can be a
slow operation on some hardware.

@item
It is possible to close the window while the application is starting, yet the
application does not terminate.

@item
Fix the Glide driver.  It does not compile.

@item
It is probably not safe to be inserting mouse and keyboard events into Crystal
Space's event queue from the main thread while the queue is being processed by
a secondary thread.  It is also probably unsafe to cascade mouse moved events
from inside @code{LoopThread()} thread.

@item
Ked Shayer (@email{c.shayer2@@ukonline.co.uk}) suggests using @sc{nasm} for
the assembler code.
@end itemize

@unmacro BeOS
