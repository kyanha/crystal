@node SCF
@section Crystal Space Shared Class Facility (@sc{scf})
@cindex @sc{scf}, Shared Class Facility
@cindex Shared Class Facility (@sc{scf})

This library is intended for separating C++ class implementations from
programs that use them; this is achieved by separating class implementations
into a separate module (currently only shared libraries are supported).  There
is very little requirements to the shared library itself: this helps to
address many problems regarding shared library facility differences
encountered on different platforms.  In fact, it is possible to use some
different mechanism for @sc{scf}, for example inter-process communication
(through pipes, shared memory or whatever); communication through network or
through a @sc{com} or @sc{corba} request broker, although currently there are
only two minimal configurations supported: using shared libraries and using
static linkage (for platforms that don't have shared library support).

@node @sc{scf} how it works
@subsection How it works

This paragraph contains technical details about @sc{scf}.  If you're not
interested in details, you can skip directly to next chapter which explains
how @sc{scf} should be used from end-user point of view.

@sc{scf} is somewhat similar to @sc{com}.  That's because historically Crystal
Space initially used @sc{com} for inter-module communications.  Thanks to Dan
Ogles for the initial implementation of a cross-platform @sc{com} library; his
implementation was a good testbed for this @sc{scf} implementation.

The differences between @sc{com} and @sc{scf} are due to increased need in a
easier-to-use and maybe a more lightweighted interface than @sc{com}.  The
@sc{com} implementation caused some problems (because of bugs in @sc{egcs}
1.1.X and in the NeXT C++ compiler).  Also it has some problems due to native
Windows types used in @sc{com}; this experience has been taken into account
while developing @sc{scf}.

The main paradigm of @sc{scf}, as in @sc{com}/@sc{corba}/Java/etc is
interface.  You define an @emph{interface}, that is, a set of abstract methods
that you want to access within some object.  @sc{scf} interfaces are plain C++
structs (or classes, it doesn't matter much except that if you're using
classes you will have to add the @samp{public:} keyword).  Theoretically
interface can contain even member variables and inline methods (but no
non-virtual methods and constructors), @emph{but} this practice is not
encouraged because later someone can want to add an
@sc{com}/@sc{corba}/whatever layer between client and the actual object, and
this will not be possible if interface would contain variables or inline
methods.  If you don't plan to use @sc{com}/@sc{corba} later, you can use
variables and inline functions as much as you want.

Here is an example of an interface:

@example
struct iDog
@{
  virtual bool IsAlive () = 0;
  virtual const char *GetName () = 0;
  virtual void SetName (const char *iName) = 0;
  virtual void Barf (int iHowLoud) = 0;
  virtual void Run (int iSpeed, float iDirection) = 0;
  virtual bool GetChildren (IObjVector *oBrood) = 0;
@};
@end example

Note the last method that gets a pointer of @code{IObjVector} type.
@code{IObjVector} is yet another interface.  We could pass a pointer to an
@code{csObjVector} (the implementation of that interface) as well, but this
will mean both modules (caller and callee) should have same idea about what a
@code{csObjVector} is@dots{} and if it happened you compiled the shared
library with a slightly different version of @code{csObjVector} (that, say,
had one member variable less) you will end up with an @sc{sigsegv}.

Now let's write @emph{a particular implementation} of the above interface.

@example
#include "idog.h"

class MyDog : public iDog
@{
  @dots{} member functions/variables go here @dots{}

  char *Name;
public:
  virtual bool IsAlive ();
  virtual const char *GetName ();
  virtual void SetName (const char *iName);
  virtual void Barf (int iHowLoud);
  virtual void Run (int iSpeed, float iDirection);
  virtual bool GetChildren (IObjVector *oBrood);

  @dots{} some additional member functions/variables go here @dots{}
@};

bool MyDog::IsAlive ()
@{
  return true;
@};

const char *MyDog::GetName ()
@{
  return Name;
@}

void MyDog::SetName (const char *iName)
@{
  if (Name)
    free (Name);
  Name = strcpy (iName);
@}

@dots{} and so on @dots{}

@end example

Now we put the actual implementation into a separate module (i.e.  into a
shared library), and include into client just the interface file
@file{idog.h}.  Now, since the client don't have an idea how we should build a
object of the @code{MyDog} class, we also should provide a function that will
return a newly-allocated object of that class.  This is further called a
@samp{class factory} (in fact, a class factory is a bit more than just this,
but about this later).  Here is how we do it:

@example
static iDog *Create_iDog ()
@{
  return new MyDog ();
@}
@end example

Okay, we did it.  Now back to the client: to work with a object that
implements the @code{iDog} interface we need to load the shared library, get a
pointer to @code{Create_MyDog} function, call it and get a new @code{MyDog}
object.  Further we work with this pointer as if it were pointing an
@code{iDog} object:

@example
handle = LoadLibrary ("libdog.so");
iDog (*Create_iDog) () = GetLibrarySymbol ("Create_IDog");
iDog *dog = Create_iDog ();
printf ("Doggy's name is %s\n", dog->GetName ());
dog->Barf (100);
@dots{}

@end example

Of course, you don't have to do all this stuff manually with current @sc{scf}
implementation.  The @sc{scf} library provides a number of macros and
functions that almost hides the implementation details from end-user.

@node @sc{scf} usage
@subsection @sc{scf} library usage

The only include file you need in both your client and server modules is
@file{csscf.h}.  It contain a number of macros and functions that you will
need for easier use of @sc{scf}.  For the client, you will also have to add
the @file{csscf.cpp} source code file to your project, on the server-side you
don't need it (inline macros defined in @file{csscf.h} are enough).

To simplify things, all exported classes are supposed to be derived from some
basical interface called iBase.  Thus, any interface is supposed to implement
some basical functionality.  Currently @code{iBase} defines three interface
functions:

@table @code
@item void IncRef ();
This function should be called each time you get a new reference to a object
and store it for a long-time usage.

@item void DecRef ();
Call this function to decrement the object's reference count.  When reference
count reaches zero, the object is automatically deleted (if it is not an
interface embedded within another object, see below).

@item iBase *QueryInterface (const char *iItfName, int iVersion);
This method will return a pointer to an interface or to an embedded interface
(see the description of embedded interfaces below).
@end table

To simplify things even more, @file{csscf.h} file provides several macros that
provide default declaration and default implementation of these three methods.
@code{DECLARE_IBASE} macro will declare above three methods within any class
definition that is derived from @code{iBase}.  The @code{IMPLEMENT_IBASE} will
add the default implementation of these function to your module.  Example:

@example
struct iTest : public iBase
@{
  ...
@};

class Test : public ITest
@{
  DECLARE_IBASE;
@};

IMPLEMENT_IBASE (Test)
@end example

In reality, we need a bit more macros because the @code{QueryInterface()}
function is not static - it depends on the interfaces implemented by given
object.  In fact, @code{IMPLEMENT_IBASE} defines the @code{IncRef},
@code{DecRef()} and the beginning of the @code{QueryInterface} function, but
not the end of that function (i.e.  the closing brace).  That's because you
have to use an additional macro called @code{IMPLEMENTS_INTERFACE} that will
add the code required to support all implemented interface inside the
@code{QueryInterface()}:

@example
IMPLEMENT_IBASE (Test)
  IMPLEMENTS_INTERFACE (ITest)
IMPLEMENT_IBASE_END
@end example

The @code{DECLARE_IBASE} macro also defines two member variables:
@code{csfRefCount} and @code{csfParent}.  @code{csfRefCount} is the counter
for external references to this object and is used by @code{IncRef()} and
@code{DecRef()} methods.  The @code{csfParent} method points to parent object
and is also used by @code{IncRef()} and @code{DecRef()}.  Objects are chained
in a tree-like fashion, and an call to @code{IncRef} will also call
@code{csfParent->IncRef()}; same about @code{DecRef()}.  The root of the chain
is the class factory, that is, a object that is used to create objects of a
specific class.  The object tree looks like this:

@example
[ClassFactory]
  +--[Object]
       +--[Embedded interface]
       +--[Embedded interface]
            +--[Sub-embedded interface]
@end example

Thus, if we call the @code{IncRef} method for @samp{Sub-embedded interface},
we also will increment reference count for Object and ClassFactory.

You also should call the @code{CONSTRUCT_IBASE(Parent)} inside your class
constructor, this macro will initialize @code{scfRefCount} to zero and
@code{scfParent} to the value you pass to this macro.  In fact, constructor of
any class should receive at least one argument (@code{iBase *}) which should
then be passed to @code{CONSTRUCT_IBASE} macro.

@node @sc{scf} classes implementing multiple interfaces
@subsection Classes implementing multiple interfaces

Sometimes we will want one object to implement several interfaces.  For
example, the 3D graphics driver could provide a basic @code{IGraphics3D}
interface and several additional optional interfaces such as @code{IHalo},
@code{IBumpMap} and so on.  There are two ways to do that: through multiple
inheritance and through embedding a object that implements another interface
within the @samp{carrier} object.  To simplify the following text we'll refer
them as @samp{multiple interface} and @samp{embedded interface} methods.

@node @sc{scf} multiple interfacing
@subsubsection Multiple interfacing

You can declare a class to inherit from several interfaces at once.  This is
useful if all implemented interfaces will need to access often same member
variables.  For example, both the @code{IHalo} and @code{IBumpMap}
implementations will need to access many member variables from
@code{IGraphics3D} such as pixel format, screen dimensions and so on.  You
declare such classes this way:

@example
class MyGraphics3D : public IGraphics3D, public IHalo, public IBumpMap
@{
public:
  ...
@};
@end example

When implementing the methods imposed by @code{iBase} interface you should use
@code{IMPLEMENT_INTERFACE()} macro once for each implemented interface:

@example
IMPLEMENT_IBASE (MyGraphics3D)
  IMPLEMENTS_INTERFACE (IGraphics3D)
  IMPLEMENTS_INTERFACE (IHalo)
  IMPLEMENTS_INTERFACE (IBumpMap)
IMPLEMENT_IBASE_END
@end example

@node @sc{scf} Embedded interfaces
@subsubsection Embedded interfaces

Other way to implement several interfaces in one object is to embed another
object that implements another interface into the main, @samp{carrier} object.
This method is preferable when a secondary interfaces seldom needs access to
@samp{carrier} object's members, because you will need to access them through
@code{scfParent} pointer.  Here is an example:

@example
class MyGraphics3D : public IGraphics3D
@{
  // declare the IHalo embedded interface
  class MyHalo : public IHalo
  @{
    DECLARE_EMBEDDED_IBASE (MyGraphics3D);
    ...
  @} scfIHalo;
  // declare the IBumpMap embedded interface
  class MyBumpMap : public IBumpMap
  @{
    DECLARE_EMBEDDED_IBASE (MyGraphics3D);
    ...
  @} scfIBumpMap;

public:
  DECLARE_IBASE;
  ...
@};
@end example

Note that you don't need to use some @samp{special} names for classes; use
anything you want (i.e.  the @samp{My} prefix is not required; you could name
above class @samp{GraphixThreeDeeImplementation}, this is true for embedded
classes as well).  But most macros that have the word @samp{EMBEDDED} within
their names (see below) relies on embedded object names to be
@code{scf##InterfaceName}, that is, @code{scfiBase}, @code{scfiTest},
@code{scfiGraphics3D} and so on.

When you declare the @code{iBase} methods within an embedded class, you can
use the @code{DECLARE_EMBEDDED_IBASE(OuterClass)} macro instead of
@code{DECLARE_IBASE}.  In this case the @code{scfParent} member will be of
@code{OuterClass*} type rather than @code{iBase*}; this will allow member
class to talk with his parent directly, thus allowing for direct member
variables/functions access.  In fact, @code{DECLARE_IBASE} macro expands to
@code{DECLARE_EMBEDDED_IBASE(iBase)}.

You also should use @code{IMPLEMENT_EMBEDDED_IBASE} macro instead of
@code{IMPLEMENT_IBASE} because @code{IMPLEMENT_IBASE} will destroy the object
when its reference count will reach zero; if you will do the same for an
embedded interface you will fail because the object is allocated/freed at the
same time when parent object is.  This way:

@example
IMPLEMENT_IBASE (MyGraphics3D)
  IMPLEMENTS_INTERFACE (IGraphics3D)
  IMPLEMENTS_EMBEDDED_INTERFACE (IHalo)
  IMPLEMENTS_EMBEDDED_INTERFACE (IBumpMap)
IMPLEMENT_IBASE_END
@end example

And finally, in parent object's constructor you should initialize all embedded
interface objects with the @code{CONSTRUCT_EMBEDDED_IBASE(InterfaceName)}
macro.  This will initialize @code{scfRefCount} and @code{scfParent} fields
within @code{scf##InterfaceName} member variables to appropiate values (zero
and @samp{this}).  Here is how we do it:

@example
MyGraphics3D::MyGraphics3D (iBase *iParent)
@{
  CONSTRUCT_IBASE (iParent);
  CONSTRUCT_EMBEDDED_IBASE (IHalo);
  CONSTRUCT_EMBEDDED_IBASE (IBumpMap);
  ...
@}
@end example

You should not call @code{CONSTRUCT_IBASE} within embedded object's
constructor (in fact, it can not have a constructor at all) since all work
needed to initialize @code{iBase} fields is done in carrier object's
constructor.

@node @sc{scf} Interface versions
@subsection @sc{scf} Interface versions

Unlike @sc{com}, @sc{scf} supports interface versions.  That is, a shared
class could implement verion 0.3.6 of given interface, and if client requests
that interface of a version lower or equal than 0.3.6, a correct interface
pointer is returned.  For this to work you need to define inside each
@file{i###.h} file a constant called @code{VERSION_i###} that defines the
current version of given interface.  To correctly support different versions
of interfaces you should follow the following guidelines:

@itemize @bullet
@item
Do not insert new methods into existing interfaces.  Instead, you should
append them after last defined method.

@item
If your change made the interface invalid for clients that expect older
versions of interfaces (for example, you broke the previous rule), increase
the major version number, and set minor and micro versions to zero.

@item
If your changes are relatively minor, but you do a major release, increase the
minor version number and drop the micro version to zero.

@item
If you're in developement process, and did a minor change to the interface,
increase the micro version.
@end itemize

The possible range for major and minor version numbers is 0..255, and the
range for micro version number is 0..65535.

When you query an interface, you always should tell what interface version are
you looking for.  If module cannot provide an interface compatible with the
requested version, the @code{QueryInterface()} will return @code{NULL} (same
as if interface wouldn't be available at all).  You can use
@code{scfCompatibleVersion()} to check whenever requested version is
compatible with interface version.  In fact, the @code{IMPLEMENTS_INTERFACE}
and @code{IMPLEMENTS_EMBEDDED_INTERFACE} macros use this function.

For easier definition of versioned interfaces you can use the
@code{SCF_VERSION} macro.  This way:

@example
SCF_VERSION (MyGraphics3D, 0, 0, 1);

struct MyGraphics3D : public iBase
@{
  ...
@}
@end example

@node @sc{scf} Client side
@subsection Client side

Now let's explain how to use all this mess from client side.  First, we should
be able to create objects that implements the interfaces we want.  For this,
you should use the @code{CREATE_INSTANCE} macro.  It receives two arguments:
the name of external class, and the name of the interface it implements.  So,
if we know class @code{MyGraphics3D} implements the @code{IGraphics3D}
interface, you should write:

@example
IGraphics3D *G3D = CREATE_INSTANCE (MyGraphics3D, IGraphics3D);
if (!G3D)
@{
  fprintf (stderr, "Cannot create an object of the MyGraphics3D class!\n");
  abort ();
@}
@end example

Now you can use the object any way you like, just like standard C++:

@example
G3D->BeginDraw ();
G3D->DrawLine (...);
G3D->DrawPolygon (...);
G3D->EndDraw ();
@end example

When you are done using the @code{G3D} pointer (say, when program exits), you
should free that object by calling @code{G3D->DecRef()}.  After this you
cannot use @code{G3D} anymore; you should create another instance of
@code{IGraphics3D} for this.

To query an embedded interface, you will want to use the
@code{QUERY_INTERFACE} macro; it also receives two arguments, first being the
object you are querying for the embedded interface and second being the name
of the interface you want.  Example:

@example
IHalo *halo = QUERY_INTERFACE (G3D, IHalo);
if (!halo)
@{
  fprintf (stderr, "The 3D graphics driver doesn't support halo drawing!\n");
  return;
@}
@end example

@node @sc{scf} Example
@subsection Example

Here is a completely working example.  It implements an shared class that has
a base and an embedded interface.  Here are the interface files for the
@code{iDog} interface (the base interface of our class) and the @code{iName}
interface (the interface embedded into our class):

File @file{idog.h}:
@example
#include "csscf.h"

// the version number of our interface
SCF_VERSION (iDog, 0, 0, 1)

struct iDog : public iBase
@{
  virtual void Walk () = 0;
  virtual void Barf (char *iWhat) = 0;
@};
@end example

File @file{iname.h}:
@example
#include "csscf.h"

// the version number of our interface
SCF_VERSION (iName, 0, 0, 1);

struct iName : public iBase
@{
  virtual char *GetName () = 0;
  virtual void SetName (char *iName) = 0;
@};
@end example

Now here is the implementation of a class that provides both above
interfaces:

File @file{dog.cpp}:
@example
#include "idog.h"
#include "iname.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

class csDog : public iDog
@{
  char *Name;

  // Embedded interface
  class csName : public iName
  @{
  public:
    DECLARE_EMBEDDED_IBASE (csDog);

    virtual char *GetName ();
    virtual void SetName (char *iName);
  @} scfiName;
  friend class csName;

public:
  DECLARE_IBASE;

  csDog (iBase *iParent);
  virtual void Walk ();
  virtual void Barf (char *iWhat);
@};

//--------------- implementation ----------------

IMPLEMENT_IBASE (csDog)
  IMPLEMENTS_INTERFACE (iDog)
  IMPLEMENTS_EMBEDDED_INTERFACE (iName)
IMPLEMENT_IBASE_END

csDog::csDog (iBase *iParent)
@{
  CONSTRUCT_IBASE (iParent);
  CONSTRUCT_EMBEDDED_IBASE (scfiName);
  Name = NULL;
@}

void csDog::Walk ()
@{
  printf ("%s: I'm walking\n", Name);
@}

void csDog::Barf (char *iWhat)
@{
  printf ("I'm %s: barf, barf, %s\n", Name, iWhat);
@}

// iName interface for dog

IMPLEMENT_EMBEDDED_IBASE (csDog::csName)
  IMPLEMENTS_INTERFACE (iName)
IMPLEMENT_IBASE_END

char *csDog::csName::GetName ()
@{
  return scfParent->Name;
@}

void csDog::csName::SetName (char *iName)
@{
  if (scfParent->Name)
    free (scfParent->Name);
  scfParent->Name = strdup (iName);
@}

// ... and now export all classes

IMPLEMENT_FACTORY (csDog)

EXPORT_CLASS_TABLE (Dog)
  EXPORT_CLASS (csDog, "A Dog that barfs")
EXPORT_CLASS_TABLE_END
@end example

The above three files should be compiled together to get a shared library.
The shared library should export the @code{Create_csDog} function (implemented
with the @code{IMPLEMENT_FACTORY} macro).  On most platforms this is achieved
automatically, on OS/2 you will need to write an @file{.def} file for this
(you need it anyway).  And finally, here is the source code for a client
application that uses the @code{csDog} class:

File @file{doggy.cpp}:
@example
#include <stdio.h>
#include "csscf.h"
#include "inifile.h"

#include "idog.h"
#include "iname.h"

int main ()
@{
  csIniFile config ("scf.cfg");
  scfInitialize (&config);

  iDog *dog = CREATE_INSTANCE (csDog, iDog);
  if (!dog)
    fprintf (stderr, "No csDog shared class!\n");
  else
  @{
    iName *name = QUERY_INTERFACE (dog, iName);
    if (!name)
      fprintf (stderr, "dog does not support iName interface!\n");
    else
    @{
      name->SetName ("Droopy");
      dog->Walk ();
      dog->Barf ("hello!");
      printf ("Dog's name is %s\n", name->GetName ());
      name->DecRef ();
    @}
    dog->DecRef ();
  @}

  scfFinish ();
@}
@end example

Easy, eh? Now the last thing: @sc{scf} uses a file called @file{scf.cfg} for
storing class name <-> shared library name mapping.  File format is easy:
@code{ClassName = SharedLibraryName}.  So, for the above example to work you
have to add a line that reads @samp{csDog = libdog.so} (or @file{.dll}) to the
respective system-dependent section of @file{scf.cfg}.

Alternatively, you can register classes at run time. This way:

@example
scfRegisterClass ("csDog", "libDog.dll");
@end example

@node @sc{scf} Advanced techniques
@subsection Advanced techniques

@sc{scf} library implements some things that you will need if you're an
@emph{advanced guy} type man (I'm personally not one :-).  Here I will
describe them in details.

@node @sc{scf} dynamic class registration
@subsubsection Dynamic class registration

You can register and deregister @sc{scf} classes at run time.  You can even
dynamically replace one class with another if you will use same ID during
registration.  There are two functions that can be used to dynamically
register classes, one for registering classes in shared libraries and one for
registering classes within client module.  To register a class that is located
inside a shared library, use this function:

@example
extern bool scfRegisterClass (const char *iClassID, const char *iLibraryName);
@end example

The prototype should be self-describing.  If you have a class that is linked
into the executable, you should prepare a structure of the @code{scfClassInfo}
type and pass it to the following function:

@example
extern bool scfRegisterClass (scfClassInfo *iClassInfo);
@end example

You should fill the ClassID and Factory fields (the @code{Description} field
is not used except in scfreg).

You can unregister an class that is already registered with the following
function:

@example
extern bool scfUnregisterClass (char *iClassID);
@end example

@node @sc{scf} Non-registered classes
@subsubsection Non-registered classes

Sometimes you don't want to register your classes with the @sc{scf} kernel.
That is, you create your objects manually, using @samp{new} or whatever.  In
this case your object is not a part of the class tree (see above) and thus
don't have a parent.  In this case you have to pass @code{NULL} to the
@code{CONSTRUCT_IBASE} macro in constructor.  This way:

@example
MyClass::MyClass ()
@{
  CONSTRUCT_IBASE (NULL)
@}
@end example

If you also want your object to not be automatically deleted when reference
count reaches zero, you can use the @code{IMPLEMENT_EMBEDDED_IBASE} instead of
@code{IMPLEMENT_IBASE}, as if your object would be an embedded interface.
Embedded interfaces don't have the habbit of deleting themselves when their
reference count reaches zero.  In this case you should take care and delete
your object manually.

@node @sc{scf} author
@subsection The author

Original @sc{scf} design & concept by Andrew Zabolotny, 1999

This particular @sc{scf} implementation is Copyright @copyright{} 1999 by
Andrew Zabolotny, @email{bit@@eltech.ru}

Written for the Crystal Space project,
distributed under GNU Library General Public License (LGPL).
@xref{License}.
