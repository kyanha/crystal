<html>
<head>
<title>Crystal Space Tutorial</title>
</head>

<body>

<em>
(small note with regards to this tutorial: this tutorial speaks of things
which may not yet exist. It is written with the future in mind)
</em><p>

<table width="100%" border=0><tr><td bgcolor=#FFFFFF><font size=+3>
Introduction
</font></td></tr></table><p>

Crystal Space is a package of components and libraries which can all be useful
for creating computer games. Although some of the packages are intended more
for 3D gaming this is not as such a restriction of the package. Components as
the sound driver function just as well in a 2D gaming environment and the
networking component can even be used in a text oriented environment. This
hilights one of the important characteristics of Crystal Space: the components
and libraries are more or less independent of each other. If you don't want
networking, then just don't use the networking drivers. If you don't want
scripting then don't include that. All packages are designed to be functional
on their own or with a minimal number of other packages. There are some
dependencies of course. For example, the 3D Engine requires a 3D Rasterizer
to display its output. On the other hand, you could very well use the 3D
Rasterizer without the 3D Engine.
<p>

Although there is a high level of independence, there is also a high level of
integration. The components and libraries were also designed to be used together
and as such offer a flexible scheme of integration.
<p>

In the previous paragraphs we frequently mentioned <em>components</em> and
<em>libraries</em>. In some contexts these words can mean the same. A component
can be the contents of a library for example. You can also have libraries of
components. In the case of Crystal Space we place a special distinction between
the two. When we speak of a component we generally refer to a library which uses
the COM mechanism for communication. This means that it follows a very strict set
of rules which should be followed when creating, using, and destroying components.
Libraries, on the other hand, are just libraries which offer a collection of
C++ classes. Libraries can also export COM interfaces if needed but they are
not native COM components.
<p>

In the rest of this document we will often say <em>modules</em> to refer to both the
components and libraries.
<p>

We will not go into much detail over why we choose COM and why not CORBA
for example. That's a matter of much debate and not very useful at this stage.
I will just mention a few reasons why we choose COM instead of plain C++/C
libraries:
<ul>
	<li>Very strict decoupling of the interface of a component and the
	    data/implementation.
	<li>Adherence to a standard (albeit a Microsoft related one) mechanism.
	<li>Interfacing possibilities with COM-aware languages like Visual
	    Basic, JAVA, or Delphi.
	<li>Binary compatibility. With C++ libraries you can only use them
	    with code compiled on the same compiler.
</ul>
On the other hand, the plain C++ libraries also have their advantages:
<ul>
	<li>Although overhead for COM is not much a plain C++ library
	    has even less overhead and the possibility to inline member
	    functions.
	<li>Some consider COM to have an ugly syntax. While that is a
	    matter of opinion it is one shared with a considerable number
	    of people.
</ul>
<p>

One way to view the integration through COM is as a communications network
with the interfaces defining the protocol. Components can only speak to other
components by using the protocol or the interface.
<p>

<table width="100%" border=0><tr><td bgcolor=#FFFFFF><font size=+3>
What Is In It?
</font></td></tr></table><p>

Crystal Space currently contains the following modules:

<h2>
3D Engine (library: csengine)
</h2>
This is one of the corner stones of Crystal Space and also what originally
sparked the birth of the Crystal Space project. It needs the 3D Rasterizer
component to display output and also requires a number of other libraries
(csutil, csgeom, csgfxldr). The 3D Engine exports a number of
COM interfaces to allow access through the COM mechanism.
<p>

<h2>
3D Rasterizer (component: cs3d)
</h2>
This component is required by the 3D Engine but is also useful standalone.
It needs a 2D Driver. There are currently four implementations of
this component: Software, OpenGL, Glide, and Direct3D.
<p>

<h2>
2D Driver (component: cs2d)
</h2>
This component manages the creation of the Crystal Space window used for
rendering and also supports limited 2D drawing capabilities (including 2D
sprites). It can be used standalone but it is currently very limited and not
very useful (may change in the future). There are several implementations of
this component. All are specific to some 3D Rasterizer (for example, the OpenGL
3D Rasterizer on Unix requires the OpenGL 2D XLib Driver).
<p>

<h2>
Utility library (library: csutil)
</h2>
This library contains various utilities. There is an Archive class which
can read/write ZIP archives. There is a vector class, a sparse matrix class
and some other useful goodies. This library requires the use
of the external ZLib library which is used to read/write ZIP archives.
<p>

<h2>
Geometry library (library: csgeom).
</h2>
Various geometry related stuff can be found here: matrices, vectors, BSP
trees, clipper, planes, ...
<p>

<h2>
Graphics Loader Library (library: csgfxldr).
</h2>
Routines to support loading various graphic file formats and put them
internally in the same format. This library supports JPG, GIF, TGA, PNG,
and BMP.
<p>

<h2>
Sound Loader Library (library: cssndldr).
</h2>
Routines to support loading various sound file formats and put them
internally in the same format. This library supports WAV, AIFF, AU, ...
<p>

<h2>
Crystal Space Window System (library: csws).
</h2>
A window system nicely integrated with Crystal Space. It is also
platform independent.
<p>

<h2>
System Dependent Stuff (library: cssys).
</h2>
All system dependent stuff (non-graphics and non-sound related) is in this
library.
<p>

<h2>
Input System (library: csinput).
</h2>
An input library (mouse, keyboard, joystick, ...).
<p>

<h2>
World Parser (library: csparser).
</h2>
A library which parses ASCII world files and creates a world in
the 3D Engine.
<p>

<h2>
Sound Driver (component: cssnddrv).
</h2>
System dependent sound drivers. There are currently drivers for
Macintosh, OSS (Linux), and Windows. There is also a Null driver
for systems without sound.
<p>

<h2>
Sound Renderer (component: cssndrdr).
</h2>
System dependent sound renderers. There are currently renderers for
a3d, ds3d, eax, and software. There is also a Null renderer used
with the Null sound driver.
<p>

<h2>
Network Driver (component: csnetdrv).
</h2>
System dependent network drivers. There is currently only a sockets
driver and a Null driver in case you don't want networking.
<p>

<h2>
Network Manager (component: csnetman).
</h2>
System dependent network managers. There is currently only a simple
manager and a Null driver in case you don't want a manager.
<p>

<h2>
Physics (???).
</h2>
This module is not written yet but it will have support routines
for calculation of various physical properties.
<p>

<h2>
Scripting (???).
</h2>
Another non-existant module.
<p>

<h2>
Artificial Intelligence (???).
</h2>
Another non-existant module.
<p>

<table width="100%" border=0><tr><td bgcolor=#FFFFFF><font size=+3>
Getting Started
</font></td></tr></table><p>

When you downloaded the Crystal Space package it included an 'include'
directory. This directory contains all header files you need to be able to
use the Crystal Space components and libraries in your own applications. On one
hand, the include directory contains COM interface definitions. We have
definitions in IDL (Interface Definition Language) and as plain C++ header
files. These general start with 'i' (like 'iworld.h'). On the other hand we
also have plain C++ include files for interfacing with the libraries of
Crystal Space. You can move this include directory somewhere on your
system. On Linux you could move it to /usr/include/cs for example. It's
your choice.
<p>

Crystal Space also has a reference manual. If you downloaded the 'csapi'
package the you should have it and <a href="../csapi/aindex.html">this
link</a> may work to get you to the reference.
<p>

<table width="100%" border=0><tr><td bgcolor=#FFFFFF><font size=+3>
Tutorials
</font></td></tr></table><p>

In this part various tutorials are given. The ultimate purpose of this document
is to provide tutorials for all major areas of Crystal Space. In all the tutorial
news code is marked <b>bold</b> while code repeated from a previous section uses
plain style.
<p>

<table width="100%" border=0><tr><td bgcolor=#E0D0C0><font size=+1>
Tutorial 1: Basic Usage of the Engine
</font></td></tr></table><p>

In this tutorial I give a step-by-step explanation on how you can use the
3D Engine from within your application. This tutorial is mainly based on the
<em>Simple</em> application which you can compile and run to see what it does.
There are various ways to use Crystal Space. The <em>Simple</em> application
uses inheritance to create a subclass of the system dependent main class
(<em>SysSystemDriver</em>) but you don't need to do it like this.
<p>

<em>
<b>Side-note:</b> The API of Crystal Space is still maturing. There are
various things which will likely change in the future and you will often
encounter ugly things and requirements. For example, in the code below
you will find that you need to have the functions <em>debug_dump()</em>
and <em>cleanup()</em> defined in your application. Crystal Space depends on them.
This will change in the future.
</em>
<p>

<h3>
Starting...
</h3>

First a little explanation. <em>SysSystemDriver</em> is a system dependent
class which is reponsible for controlling the main Crystal Space stuff.
It loads and initializes the needed components (drivers) and also manages
the main loop. The <em>Simple</em> application creates a subclass of this
to provide it with its own functionality. So we start by creating an include
file 'simple.h' with the following contents:
<p>

<font size=-1><code>
<b>
#include "cssys/common/sysdriv.h"<br>
<br>
class csWorld;<br>
<br>
class Simple : public SysSystemDriver<br>
{<br>
public:<br>
&nbsp;&nbsp;csWorld* world;<br>
<br>
public:<br>
&nbsp;&nbsp;Simple ();<br>
&nbsp;&nbsp;virtual ~Simple ();<br>
&nbsp;&nbsp;void InitApp ();<br>
};<br>
</b>
</code></font>
<p>

In the source file 'simple.cpp' we put the following:
<p>

<font size=-1><code>
<b>
#include "sysdef.h"<br>
#include "simple.h"<br>
#include "csengine/world.h"<br>
#include "csengine/sector.h"<br>
#include "csengine/camera.h"<br>
#include "csengine/csview.h"<br>
#include "csengine/light/light.h"<br>
#include "csengine/polygon/polygon.h"<br>
#include "cssys/common/system.h"<br>
#include "igraph3d.h"<br>
#include "itxtmgr.h"<br>
<br>
Simple* Sys = NULL;<br>
<br>
Simple::Simple ()<br>
{<br>
&nbsp;&nbsp;world = NULL;<br>
}<br>
<br>
Simple::~Simple ()<br>
{<br>
&nbsp;&nbsp;delete world;<br>
}<br>
<br>
void cleanup ()<br>
{<br>
&nbsp;&nbsp;delete Sys;<br>
}<br>
<br>
void debug_dump ()<br>
{<br>
}<br>
<br>
void Simple::InitApp ()<br>
{<br>
&nbsp;&nbsp;if (!Open ("Simple Crystal Space Application"))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Sys-&gt;Printf (MSG_FATAL_ERROR, "Error opening system!\n");<br>
&nbsp;&nbsp;&nbsp;&nbsp;cleanup ();<br>
&nbsp;&nbsp;&nbsp;&nbsp;exit (1);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;world-&gt;Initialize (GetISystemFromSystem (this), piGI, NULL);<br>
}<br>
<br>
int main (int argc, char* argv[])<br>
{<br>
&nbsp;&nbsp;Sys = new Simple ();<br>
&nbsp;&nbsp;Sys-&gt;world = new csWorld ();<br>
&nbsp;&nbsp;if (!Sys-&gt;Initialize (argc, argv, Sys-&gt;world-&gt;GetEngineConfigCOM ()))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Sys-&gt;Printf (MSG_FATAL_ERROR, "Error initializing system!\n");<br>
&nbsp;&nbsp;&nbsp;&nbsp;cleanup ();<br>
&nbsp;&nbsp;&nbsp;&nbsp;exit (1);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;Sys-&gt;InitApp ();<br>
&nbsp;&nbsp;Sys-&gt;Loop ();<br>
&nbsp;&nbsp;cleanup ();<br>
}<br>
</b>
</code></font>
<p>

This is almost the simplest possible application and it is absolutely
useless :-) Also don't run it on an operating system where you can't kill
a running application because it has no way to exit.
<p>

Before we start making this application more useful lets have a look at what
actually happens here. The main routine first creates an instance of our
<em>Simple</em> class. The next step is the creation of the world. The world
is actually the main 3D Engine class and is one of the most important classes
for interfacing with the engine (see <a href="../csapi/csWorld.html">csWorld
reference</a> for more information).
<p>

Only after the world is created can you initialize the system. The reason is
that the system needs to know the world to be able to parse command line
options for it (<em>@@@ It is possible that this changes slightly in the future</em>).
We call <a href="../csapi/SysSystemDriver.html#Initialize"><em>Initialize()</em></a> on
our <em>Simple</em> instance. This is a function
inherited from <a href="../csapi/SysSystemDriver.html"><em>SysSystemDriver</em></a>
and is responsible for initializing all needed graphics stuff.
It is also responsible for parsing the command line
and feeding all the options to the appropriate handlers. Note that you should
always test for failure of such routines. There may be various reasons for failure
(<em>@@@ In the future we will provide routines to query the failure reason</em>).
The function <a href="../csapi/csWorld.html#GetEngineConfigCOM"><em>GetEngineConfigCOM()</em></a>
returns a COM interface (<em>IConfig</em>) that the system can use to query all settings that
the 3D Engine supports. This can then be used for controlling those settings by the command
line and other stuff.
<p>

Then we call <em>InitApp()</em> which is one of our own functions. This will
initialize everything for our application (more on this later).
<p>

The call to <a href="../csapi/SysSystemDriver.html#Loop"><em>Loop()</em></a>
puts Crystal Space in the main event loop. This
is where the application really starts running and interacting with the user.
This call returns as soon as an exit message was received by the system at
which point we <em>cleanup()</em> everything.
<p>

The <em>InitApp()</em> function initializes the rest of the application.
First it opens the system which basicly means that all graphics subsystems
are opened (the window will be opened). This function can also fail so again
test for this.
<p>

Finally it initializes the world for the given graphics system. The first
parameter to <a href="../csapi/csWorld.html#Initialize"><em>csWorld::Intialize()</em></a>
should be a pointer to the system dependent COM interface (<em>ISystem</em>). The 3D
Engine will use this for various things like output messages on the console.
The <em>GetISystemFromSystem()</em> macro converts a pointer to a
<a href="../csapi/SysSystemDriver.html"><em>SysSystemDriver</em></a> instance to an interface
pointer suitable for COM. <em>piGI</em> is a public member of <a href="../csapi/SysSystemDriver.html">
<em>SysSystemDriver</em></a> which is given to the 3D Engine to query the graphics subsystem
(for example, to ask what depth the display is using). It is a COM interface (<em>IGraphicsInfo</em>).
The last argument is not used in this application and will be removed in the future.
<p>

<h3>
Quitting the Application
</h3>

To make the testing somewhat easier we will add a way to exit the application.
What about exiting when the 'esc' key is pressed? Let's do it.
First change 'simple.h' as follows:
<p>

<font size=-1><code>
#include "cssys/common/sysdriv.h"<br>
<br>
class csWorld;<br>
<br>
class Simple : public SysSystemDriver<br>
{<br>
public:<br>
&nbsp;&nbsp;csWorld* world;<br>
<br>
public:<br>
&nbsp;&nbsp;Simple ();<br>
&nbsp;&nbsp;virtual ~Simple ();<br>
&nbsp;&nbsp;void InitApp ();<br>
<br>
&nbsp;&nbsp;<b>virtual void NextFrame (long elapsed_time, long current_time);</b><br>
&nbsp;&nbsp;<b>void eatkeypress (int key, bool shift, bool alt, bool ctrl);</b><br>
};<br>
</code></font>
<p>

<a href="../csapi/SysSystemDriver.html#NextFrame"><em>NextFrame()</em></a> is a function which
is called every frame by the system. It can be used for drawing the world but for now we will only use it to
do event handling. <em>eatkeypress()</em> is our own function which does key handling.
<p>

We add the following two definitions to 'simple.cpp':
<p>

<font size=-1><code>
<b>
void Simple::eatkeypress (int key, bool shift, bool alt, bool ctrl)<br>
{<br>
&nbsp;&nbsp;(void)shift; (void)alt; (void)ctrl;<br>
&nbsp;&nbsp;switch (key)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;case CSKEY_ESC: Shutdown = true; break;<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
void Simple::NextFrame (long elapsed_time, long current_time)<br>
{<br>
&nbsp;&nbsp;SysSystemDriver::NextFrame (elapsed_time, current_time);<br>
<br>
&nbsp;&nbsp;// Handle all events.<br>
&nbsp;&nbsp;csEvent *Event;<br>
&nbsp;&nbsp;while ((Event = EventQueue-&gt;Get ()))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;switch (Event-&gt;Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case csevKeyDown:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eatkeypress (Event-&gt;Key.Code, Event-&gt;Key.ShiftKeys &amp; CSMASK_SHIFT,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event-&gt;Key.ShiftKeys &amp; CSMASK_ALT, Event-&gt;Key.ShiftKeys &amp; CSMASK_CTRL);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case csevMouseDown:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case csevMouseMove:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case csevMouseUp:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;delete Event;<br>
&nbsp;&nbsp;}<br>
}<br>
</b>
</code></font>
<p>

Every frame <a href="../csapi/SysSystemDriver.html#NextFrame"><em>NextFrame()</em></a>
is called. Several events (like keyboard and mouse events) could have been
accumulated in the mean time. You can query all accumulated events with the
code shown above. In case it is a key press we call <em>eatkeypress()</em> to perform
the appropriate actions.  Currently <em>eatkeypress()</em> only listens to the escape key to quit
the application. So compile this application and run it. You should now
be able to quit it with the 'esc' key.
<p>

<h3>
Creating The World
</h3>

Now we have a very exciting application which opens a black window and
waits for the 'esc' key to quit. We assume this is the application you
always wanted to have? No?  Ok then, let's create some 3D stuff.
Edit 'simple.cpp' and change <em>InitApp()</em> as follows:
<p>

<font size=-1><code>
void Simple::InitApp ()<br>
{<br>
&nbsp;&nbsp;if (!Open ("Simple Crystal Space Application"))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Sys-&gt;Printf (MSG_FATAL_ERROR, "Error opening system!\n");<br>
&nbsp;&nbsp;&nbsp;&nbsp;cleanup ();<br>
&nbsp;&nbsp;&nbsp;&nbsp;exit (1);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;world-&gt;Initialize (GetISystemFromSystem (this), piGI, NULL);<br>
<br>
<b>
&nbsp;&nbsp;csTextureHandle* tm = CSLoader::LoadTexture (world, "stone", "stone4.gif");<br>
<br>
&nbsp;&nbsp;csSector* room = world-&gt;NewSector ();<br>
&nbsp;&nbsp;csPolygon3D* p;<br>
&nbsp;&nbsp;p = room-&gt;NewPolygon (tm);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 0, 5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 0, 5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 0, -5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 0, -5);<br>
&nbsp;&nbsp;p-&gt;SetTextureSpace (p-&gt;Vobj (0), p-&gt;Vobj (1), 3);<br>
<br>
&nbsp;&nbsp;p = room-&gt;NewPolygon (tm);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 20, -5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 20, -5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 20, 5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 20, 5);<br>
&nbsp;&nbsp;p-&gt;SetTextureSpace (p-&gt;Vobj (0), p-&gt;Vobj (1), 3);<br>
<br>
&nbsp;&nbsp;p = room-&gt;NewPolygon (tm);<br><br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 20, 5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 20, 5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 0, 5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 0, 5);<br>
&nbsp;&nbsp;p-&gt;SetTextureSpace (p-&gt;Vobj (0), p-&gt;Vobj (1), 3);<br>
<br>
&nbsp;&nbsp;p = room-&gt;NewPolygon (tm);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 20, 5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 20, -5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 0, -5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 0, 5);<br>
&nbsp;&nbsp;p-&gt;SetTextureSpace (p-&gt;Vobj (0), p-&gt;Vobj (1), 3);<br>
<br>
&nbsp;&nbsp;p = room-&gt;NewPolygon (tm);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 20, -5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 20, 5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 0, 5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 0, -5);<br>
&nbsp;&nbsp;p-&gt;SetTextureSpace (p-&gt;Vobj (0), p-&gt;Vobj (1), 3);<br>
<br>
&nbsp;&nbsp;p = room-&gt;NewPolygon (tm);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 20, -5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 20, -5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (-5, 0, -5);<br>
&nbsp;&nbsp;p-&gt;AddVertex (5, 0, -5);<br>
&nbsp;&nbsp;p-&gt;SetTextureSpace (p-&gt;Vobj (0), p-&gt;Vobj (1), 3);<br>
<br>
&nbsp;&nbsp;csStatLight* light;<br>
&nbsp;&nbsp;light = new csStatLight (-3, 5, 0, 10, 1, 0, 0, false);<br>
&nbsp;&nbsp;room-&gt;AddLight (light);<br>
&nbsp;&nbsp;light = new csStatLight (3, 5, 0, 10, 0, 0, 1, false);<br>
&nbsp;&nbsp;room-&gt;AddLight (light);<br>
&nbsp;&nbsp;light = new csStatLight (0, 5, -3, 10, 0, 1, 0, false);<br>
&nbsp;&nbsp;room-&gt;AddLight (light);<br>
<br>
&nbsp;&nbsp;world-&gt;Prepare (piG3D);<br>
</b>
}<br>
</code></font>
<p>

This extra code first loads a texture with <a href="../csapi/CSLoader.html#LoadTexture"><em>LoadTexture()</em></a>.
The first parameter is the name of the texture as it will be known in the engine.
The second parameter is the actual filename (note, if you don't have the stone4.gif texture you
can use another one. The only requirement is that it must have sizes which are a power of 2
(e.g. 64x64)). The resulting <a href="../csapi/csTextureHandle.html"><em>csTextureHandle</em></a>
can be given to polygons or other engine objects which require textures.
<p>

Then we create our room with <a href="../csapi/csWorld.html#NewSector"><em>NewSector()</em></a>.
This room will initially be empty. A room in Crystal Space is represented by <a href="../csapi/csSector.html">
<em>csSector</em></a> which is basicly a convex set of polygons.
<p>

Now we create the six walls of our room. To do this we call <a href="../csapi/csSector.html#NewPolygon">
<em>NewPolygon()</em></a> for every wall. This call expects one parameter:
the texture to use. <em>NewPolygon()</em>
returns a pointer to a <a href="../csapi/csPolygon3D.html"><em>csPolygon3D</em></a>. This polygon
will be empty so you need to add vertices and also define how the texture should be mapped
on that polygon. To add vertices we use <a href="../csapi/csPolygon3D.html#AddVertex"><em>AddVertex()</em></a>
which expects a location in object space. To define how the texture is mapped on the polygon
we use <a href="../csapi/csPolygon3D.html#SetTextureSpace"><em>SetTextureSpace()</em></a>. There
are several versions of this function. The one we use in this tutorial is one of the simplest but
it offers the least control. In this particular case we take the first two vertices of the
polygon and use that for the u-axis of the texture. The v-axis will be calculated perpendicular
to the u-axis. The parameter <em>3</em> indicates that the texture will be scaled so
that one texture tile is exactly 3x3 world units big.
<p>

Finally we create some lights in our room to make sure that we actually are able to
see the walls. The class <a href="../csapi/csStatLight.html"><em>csStatLight</em></a>
represents a static light (cannot move and change intensity) which perfectly suits our
needs. We create three such lights and add them to the room with <a href="../csapi/csSector.html#AddLight">
<em>AddLight()</em></a>. When creating a light we use eight parameters. The first three
are the location of the light in the world. Then follows a radius. The light will not affect
polygons which are outside the sphere described by the center of the light and the radius.
The three following parameters are the color of the light in RGB format (1,1,1 means white
and 0,0,0 means black). The last parameter indicates wether or not we want to have a
pseudo-dynamic light. A pseudo-dynamic light still cannot move but it can change intensity.
There are some performance costs associated with pseudo-dynamic lights so it is not enabled
by default.
<p>

The last call to <a href="../csapi/csWorld.html#Prepare"><em>Prepare()</em></a> prepare
the world for rendering your scene. It will prepare all textures and create all lightmaps
if needed. Only after this call can you start rendering your world. The <em>piG3D</em>
parameter to <em>Prepare()</em> is a COM interface pointer to the 3D rasterizer
(<em>IGraphics3D</em>). <em>piG3D</em> is a public member of <a href="../csapi/SysSystemDriver.html">
<em>SysSystemDriver</em></a>. It is used by <em>Prepare()</em> because the lightmaps
may have to be converted to a format more suitable for the chosen 3D renderer.
<p>

Ok, now we have created our room and properly initialized it. If you would compile and
run this application you would still see a black screen. Why? Because we have not created
a camera through which you can see.

<h3>
The Camera
</h3>

In Crystal Space we have a class <a href="../csapi/csView.html"><em>csView</em></a>
which encapsulates both a <a href="../csapi/csCamera.html"><em>csCamera</em></a> and
a <a href="../csapi/csClipper.html"><em>csClipper</em></a>. In principle you can use
those classes directly but using <em>csView</em> is easier. First edit 'simple.h'
and make the following changes:
<p>

<font size=-1><code>
#include "cssys/common/sysdriv.h"<br>
<br>
class csWorld;<br>
<b>class csView</b>;<br>
<br>
class Simple : public SysSystemDriver<br>
{<br>
public:<br>
&nbsp;&nbsp;csWorld* world;<br>
&nbsp;&nbsp;<b>csView* view;</b><br>
<br>
public:<br>
&nbsp;&nbsp;Simple ();<br>
&nbsp;&nbsp;virtual ~Simple ();<br>
&nbsp;&nbsp;void InitApp ();<br>
<br>
&nbsp;&nbsp;virtual void NextFrame (long elapsed_time, long current_time);<br>
&nbsp;&nbsp;void eatkeypress (int key, bool shift, bool alt, bool ctrl);<br>
};<br>
</code></font>
<p>

Then edit 'simple.cpp' and make the following changes to the constructor
and destructor of <em>Simple</em>:
<p>

<font size=-1><code>
Simple::Simple ()<br>
{<br>
&nbsp;&nbsp;world = NULL;<br>
&nbsp;&nbsp;<b>view = NULL;</b><br>
}<br>
<br>
Simple::~Simple ()<br>
{<br>
&nbsp;&nbsp;<b>delete view;</b><br>
&nbsp;&nbsp;delete world;<br>
}<br>
</code></font>
<p>

At the end of our <em>InitApp()</em> function we add the following:
<p>

<font size=-1><code>
void Simple::InitApp ()<br>
{<br>
&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;world-&gt;Prepare (piG3D);<br>
<br>
<b>
&nbsp;&nbsp;view = new csView (world, piG3D);<br>
&nbsp;&nbsp;view-&gt;SetSector (room);<br>
&nbsp;&nbsp;view-&gt;GetCamera ()-&gt;SetPosition (csVector3 (0, 5, 0));<br>
&nbsp;&nbsp;view-&gt;SetRectangle (2, 2, FrameWidth - 4, FrameHeight - 4);<br>
<br>
&nbsp;&nbsp;ITextureManager* txtmgr;<br>
&nbsp;&nbsp;piG3D-&gt;GetTextureManager (&amp;txtmgr);<br>
&nbsp;&nbsp;txtmgr-&gt;AllocPalette ();<br>
</b>
}<br>
</code></font>
<p>

So first we create a <a href="../csapi/csView.html"><em>view</em></a> for our
world and 3D graphics renderer. The view has a current sector which is
passed to the camera and is set by <a href="../csapi/csView.html#SetSector"><em>
SetSector()</em></a>. The camera also has a position in that sector which you
can set by first getting the camera with <a href="../csapi/csView.html#GetCamera">
<em>GetCamera()</em></a> and then setting the position (which is a <a href="../csapi/csVector3.html">
<em>csVector3</em></a>) with <a href="../csapi/csCamera.html#SetPosition"><em>SetPosition()</em></a>.
The view also holds a clipping region which corresponds to the area on the window
that is going to be used for drawing the world. Crystal Space supports convex
polygons to be used as viewing areas, but in case we use a simple rectangle which
has almost the size of the window. We set this viewing rectangle with <a href="../csapi/csView.html#SetRectangle">
<em>SetRectangle()</em></a>.
<p>

The last code we added allocates the palette. Note that is needed even if you
are running on a truecolor display which has no palette. That's because the code
does some other things beside setting up a palette.
<p>

Now, this still isn't enough. We have a camera but the camera is not used.
We still need to enhance <a href="../csapi/SysSystemDriver.html#NextFrame"><em>NextFrame()</em></a>
so that every frame the world is drawn through the camera. Change <em>NextFrame()</em>
as follows:
<p>

<font size=-1><code>
void Simple::NextFrame (long elapsed_time, long current_time)<br>
{<br>
&nbsp;&nbsp;SysSystemDriver::NextFrame (elapsed_time, current_time);<br>
<br>
&nbsp;&nbsp;...<br>
<br>
<b>
&nbsp;&nbsp;if (piG3D-&gt;BeginDraw (CSDRAW_3DGRAPHICS) != S_OK) return;<br>
&nbsp;&nbsp;view-&gt;Draw ();<br>
&nbsp;&nbsp;piG3D-&gt;FinishDraw ();<br>
&nbsp;&nbsp;piG3D-&gt;Print (NULL);<br>
</b>
}<br>
</b>
</code></font>
<p>

First we indicate to the 3D rasterizer that we want to start drawing
3D graphics. This calls makes sure that the needed buffers are set up
and performs all necessary initialization. Then we draw through our
view by calling <a href="../csapi/csView.html#Draw"><em>Draw()</em></a>
which updates the view area with the 3D world data as seen through 
the camera. After this we finish 3D drawing with <em>FinishDraw()</em>
and then update the display by calling <em>Print()</em>. The <em>NULL</em>
pointer given to <em>Print()</em> is the area that you want to update
(it is a rectangle). If null the whole window is updated.
<p>

Compile and run this example. For the first time you should see something.
A solid wall!! Congratulations, you have created your first almost useful Crystal
Space application :-)
<p>

<h3>
Moving Around
</h3>

Hmm, staring at that solid wall gets a bit boring after some time. The problem
is that we can't move the camera to change our viewpoint. Let's add some code
to do exactly this! Edit 'simple.cpp' again and change <em>eatkeypress()</em>
as follows:
<p>

<font size=-1><code>
void Simple::eatkeypress (int key, bool shift, bool alt, bool ctrl)<br>
{<br>
&nbsp;&nbsp;(void)shift; (void)alt; (void)ctrl;<br>
&nbsp;&nbsp;<b>float speed = .03;</b><br>
&nbsp;&nbsp;switch (key)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;case CSKEY_ESC: Shutdown = true; break;<br>
<b>
&nbsp;&nbsp;&nbsp;&nbsp;case CSKEY_RIGHT: view-&gt;GetCamera ()-&gt;Rotate (VEC_ROT_RIGHT, speed); break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;case CSKEY_LEFT: view-&gt;GetCamera ()-&gt;Rotate (VEC_ROT_LEFT, speed); break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;case CSKEY_UP: view-&gt;GetCamera ()-&gt;Rotate (VEC_TILT_UP, speed); break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;case CSKEY_DOWN: view-&gt;GetCamera ()-&gt;Rotate (VEC_TILT_DOWN, speed); break;<br>
</b>
&nbsp;&nbsp;}<br>
}<br>
</code></font>
<p>

That's all! With this simple change you can rotate the camera with the arrow keys. Try
it out to see the effect. To rotate the camera we use <a href="../csapi/csCamera.html#Rotate"><em>
Rotate()</em></a> which expects a vector to rotate along and an angle given in radians (the <em>speed</em>
parameter). There are a number of predefined vectors which you can use. Four of them are used
in this example.
<p>

That's it for now. In this tutorial you learned how to setup the Crystal Space
system for use. How to create a simple room with some lights and how to handle
some basic camera operations.
<p>

</body>
</html>

