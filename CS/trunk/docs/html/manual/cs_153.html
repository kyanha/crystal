<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: CSWS Components</TITLE>

<META NAME="description" CONTENT="Crystal Space: CSWS Components">
<META NAME="keywords" CONTENT="Crystal Space: CSWS Components">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC381"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_152.html#SEC377"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_154.html#SEC385"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_150.html#SEC375"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_151.html#SEC376"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_157.html#SEC391"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC963">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 6.4.2 Components </H3>
<!--docid::SEC381::-->
<P>

The base class for windowing system is `<SAMP>csComponent</SAMP>'.  `<SAMP>csComponent</SAMP>'
is a very complex class with a lot of built-in functionality.  This allows for
easier creation of new components for specific needs.  Most `<SAMP>csComponent</SAMP>'
methods are virtual, allowing you to override them if needed.  There are some
basic methods, which are described below.  Other methods are described as
needed later in this document.
</P><P>

<A NAME="SEC382"></A>
<H4> Drawing: <CODE>csComponent::Draw()</CODE> </H4>
<!--docid::SEC382::-->
<P>

Each component should know how to paint itself.  When windowing system thinks
a part of a component image or entire component image is invalid (for example,
when a window is moved from the top of other components), it adds that
rectangle to the <EM>dirty</EM> rectangle of the component.  The dirty rectangle
is initially empty, then all invalid rectangles are added to it.  At the end
of each frame windowing system sends a broadcast event with `<SAMP>cscmdRedraw</SAMP>'
command code.  When component catches this event, it calls <CODE>Redraw()</CODE>
method which in turn calls <CODE>csComponent::Draw()</CODE>.  After
<CODE>csComponent::Draw()</CODE> returns control, the dirty rectangle is emptied
again.  Before calling the <CODE>Draw()</CODE> method, <CODE>Redraw()</CODE> sets the
component's clipping rectangle to the dirty rectangle, so usually you don't
have to take care to not draw outside the dirty rectangle; clipping will take
care of it for you (to minimize the number of draw operations).
</P><P>

All draw operations are clipped first against dirty rectangle and then against
all component children and neighbors.  So drawing inside a component does not
change even a pixel in other components, even if component is partially covered
by other components.
</P><P>

There are a number of drawing operations that you can use.  Other operations
can be synthesized from existing.  All coordinates used for drawing are
component-origin related, so (0,0) corresponds to component top-left corner.
</P><P>

Here is a list of the primitive drawing methods:
</P><P>

<UL>
<LI>
<CODE>Line(<VAR>x1</VAR>, <VAR>y1</VAR>, <VAR>x2</VAR>, <VAR>y2</VAR>, <VAR>colorindex</VAR>)</CODE>
<P>

Draw a line from (<VAR>x1</VAR>, <VAR>y1</VAR>) to (<VAR>x2</VAR>, <VAR>y2</VAR>).  Example:
<CODE>Line(0, 0, 3, 3)</CODE> produces the following output:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--+--+--+--+--+--
     |//|  |  |  |  |
 1 --+--#--+--+--+--+--
     |  |//|  |  |  |
 2 --+--+--#--+--+--+--
     |  |  |//|  |  |
 3 --+--+--+--#--+--+--
     |  |  |  |//|  |
...--+--+--+--+--+--+--
</pre></td></tr></table></P><P>

<LI>
<CODE>Box(<VAR>xmin</VAR>, <VAR>ymin</VAR>, <VAR>xmax</VAR>, <VAR>ymax</VAR>, <VAR>colorindex</VAR>)</CODE>
<P>

Draw a filled box that is closed between lines <CODE>(X &#62;= <VAR>xmin</VAR>)</CODE>,
<CODE>(X &#60; <VAR>xmax</VAR>)</CODE>, <CODE>(Y &#62;= <VAR>ymin</VAR>)</CODE> and <CODE>(Y &#60; <VAR>ymax</VAR>)</CODE>.
Example: <CODE>Box(0, 0, 3, 2)</CODE> will produce the following output:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--#--#--+--+--+--
     |//|//|//|  |  |
 1 --#--#--#--+--+--+--
     |//|//|//|  |  |
 2 --+--+--+--+--+--+--
     |  |  |  |  |  |
...--+--+--+--+--+--+--
</pre></td></tr></table></P><P>

<LI>
<CODE>Text(<VAR>x</VAR>, <VAR>y</VAR>, <VAR>foregroundindex</VAR>, <VAR>backgroundindex</VAR>, <VAR>textstring</VAR>)</CODE>
<P>

Display a text string starting from (<VAR>x</VAR>, <VAR>y</VAR>) with color
<VAR>foregroundindex</VAR> and background <VAR>backgroundindex</VAR>.  If
<VAR>backgroundindex</VAR> is -1, the text is drawn transparently.  To determine
text width and height you can use the <CODE>TextWidth(<VAR>textstring</VAR>)</CODE> and
<CODE>TextHeight()</CODE> functions.  There are a number of built-in CSWS
fonts, they can be used by calling <CODE>SetFont(cs_Font_<VAR>XXXX</VAR>)</CODE>.  Note
that both <CODE>TextWidth()</CODE> and <CODE>TextHeight()</CODE> depends on current font.
</P><P>

<LI>
<CODE>Sprite2D(<VAR>sprite2d</VAR>, <VAR>x</VAR>, <VAR>y</VAR>, <VAR>w</VAR>, <VAR>h</VAR>)</CODE>
<P>

Draw a 2D sprite or bitmap.  <VAR>sprite2d</VAR> is a object of `<SAMP>csPixmap</SAMP>'
class.  Sprite can have transparent colors, this way you can define
<EM>holes</EM> in textures.  (You can omit <VAR>w</VAR> and <VAR>h</VAR> to use normal
sprite size.)
</P><P>

<LI>
<CODE>Rect3D(<VAR>xmin</VAR>, <VAR>ymin</VAR>, <VAR>xmax</VAR>, <VAR>ymax</VAR>, <VAR>darkindex</VAR>, <VAR>lightindex</VAR>)</CODE>
<P>

Draw a 3D-looking rectangle.  This method just draws four lines to form a
non-filled rectangle.  Example: <CODE>Rect3D(0, 0, 4, 4)</CODE>.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--#--#--#--+--+--
     |LL|LL|LL|DD|  |
 1 --#--+--+--#--+--+--
     |LL|  |  |DD|  |
 2 --#--+--+--#--+--+--
     |LL|  |  |DD|  |
 3 --#--#--#--#--+--+--
     |LL|DD|DD|DD|  |
 4 --+--+--+--+--+--+--
     |  |  |  |  |  |
</pre></td></tr></table></P><P>

<LI>
<CODE>ObliqueRect3D(<VAR>xmin</VAR>, <VAR>ymin</VAR>, <VAR>xmax</VAR>, <VAR>ymax</VAR>, <VAR>cornersize</VAR>, <VAR>darkindex</VAR>, <VAR>lightindex</VAR>)</CODE>
<P>

Draw a rectangle with oblique corners of given size.  For example, calling
<CODE>ObliqueRect3D(0, 0, 10, 7, 3)</CODE> draws an oblique rectangle such as the
following:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     0  1  2  3  4  5  6  7  8  9 ...
     |  |  |  |  |  |  |  |  |  |  |
 0 --+--+--#--#--#--#--#--#--#--#--+--
     |  |  |LL|LL|LL|LL|LL|LL|LL|DD|
 1 --+--#--+--+--+--+--+--+--+--#--+--
     |  |LL|  |  |  |  |  |  |  |DD|
 2 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 3 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 4 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 5 --#--+--+--+--+--+--+--+--#--+--+--
     |LL|  |  |  |  |  |  |  |DD|  |
 6 --#--#--#--#--#--#--#--#--+--+--+--
     |LL|DD|DD|DD|DD|DD|DD|DD|  |  |
...--+--+--+--+--+--+--+--+--+--+--+--
</pre></td></tr></table></P><P>

<LI>
<CODE>SetClipRect(<VAR>xmin</VAR>, <VAR>ymin</VAR>, <VAR>xmax</VAR>, <VAR>ymax</VAR>)</CODE>
<P>

Define a local clipping rectangle for subsequent drawing operations. For
example, when drawing a button you may want to set clipping rectangle after
drawing button borders so that button text accidentally won't draw over its
borders even if it does not fit. To disable clipping you can define an empty
rectangle (<CODE>SetClipRect(0, 0, 0, 0)</CODE>);
</P><P>

<LI>
<CODE>Pixel(<VAR>x</VAR>, <VAR>y</VAR>)</CODE>
<P>

Plot the pixel at <CODE>&#60;<VAR>x</VAR>,<VAR>y</VAR></CODE> with the current color.
</P><P>

<LI>
<CODE>Clear(<VAR>color</VAR>)</CODE>
<P>

Clears the entire area of the component.  Equivalent to:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre><CODE>Box(0, 0, <VAR>bound</VAR>.Width(), <VAR>bound</VAR>.Height(), color)</CODE>.
</pre></td></tr></table></P><P>

<LI>
<CODE>ClearZbuffer(<VAR>xmin</VAR>, <VAR>ymin</VAR>, <VAR>xmax</VAR>, <VAR>ymax</VAR>)</CODE>
<P>

Clear the Z-buffer in the given rectangle.  Useful if you draw 3D Z-buffered
polygons inside your window.
</P><P>

<LI>
<CODE>Polygon3D(<VAR>poly</VAR>, <VAR>mode</VAR>)</CODE>
<P>

Draw a 3D polygon (clipped to the window).  The `<SAMP><VAR>poly</VAR></SAMP>' structure is
of the `<SAMP>G3DPolygonDPFX</SAMP>' type, which is defined in `<TT>igraph3d.h</TT>'.  This
structure should be filled, as usual with the vertices, texturing information,
and so on.  The `<SAMP><VAR>mode</VAR></SAMP>' parameters is the same as the one in
<CODE>iGraphics3D::DrawPolygonFX()</CODE>; that is, it defines the mode in which to
draw the polygon (<EM>gouraud</EM>, <EM>mix mode</EM>, <EM>alpha</EM>, and so on).
</UL>
<P>

<A NAME="SEC383"></A>
<H4> Event Handling: <CODE>csComponent::HandleEvent(iEvent&#38;)</CODE> </H4>
<!--docid::SEC383::-->
<P>

This is the main component entry point for handling windowing system events.
Each time user presses a key, moves mouse etc windowing system generates a
event and sends it to appropriate component.  The normal event flow is top-down,
i.e.  the root window receives events first, then passes them if appropriate to
its children which passes it to their respective children and so on.  However,
there are some basic constraints on event flow that you should know about:
</P><P>

<UL>
<LI>
<CODE>HandleEvent()</CODE> should return a boolean value that states whenever this
object used the event or not.  If the event has been used, no other component
will receive it anymore, otherwise windowing system looks for other appropriate
candidates for this event.  The only exception from this rule are broadcast
events that are sent to all children independently of the fact that component
<EM>eaten</EM> event or not.
<P>

<LI>
Mouse events are received only by the topmost component mouse pointer is over
and its parents.  If other behavior is desired, a component should capture
the mouse by calling <CODE>app-&#62;CaptureMouse(this)</CODE>---in this case mouse
events are sent by application object directly to the object that captured the
mouse, bypassing normal event flow.  To revert to normal mode of operation
component should call <CODE>app-&#62;CaptureMouse(0)</CODE>.
<P>

<LI>
Keyboard events are sent only to components from <EM>focus chain</EM>
(see  <A HREF="cs_153.html#CSWS Focus Chain">CSWS Focus Chain</A>).  If a different behavior is desired, component
should capture keyboard events by calling <CODE>app-&#62;CaptureKeyboard(this)</CODE>.
To disable capturing keyboard events component should call
<CODE>app-&#62;CaptureKeyboard(0)</CODE>.
<P>

<LI>
Command events are not sent to child windows.  A reply to command event is
normally expected from the component it has been sent to, not from any of its
children.  Moreover, re-sending command events to children can be dangerous
since the initial event can be sent by one of child components, and the
application can get caught in an endless loop.  Re-sending command events to
parents is a normal practice, for example all menus re-send command events to
their parents since commands are usually sent to menus by their children (menu
items or even sub-menus).  In general, most components that generates events
sends them to their parents: buttons, scrollbars, input fields, list boxes, and
so on.  The `<SAMP>csDialog</SAMP>' component handles unknown command events in a
special way: it re-sends the event to the parent, thus if you inserted a dialog
into a window, and some buttons into the dialog, you don't have to subclass the
dialog in order to receive button notifications in <CODE>csDialog</CODE>'s
<CODE>HandleEvent()</CODE>.  Instead you can subclass the window.  In most cases you
will want to subclass the window anyway).
<P>

<LI>
Broadcast events are the only type of events that are guaranteed to reach every
object in a subtree of components.  That is, if you send a broadcast event to
some component, every child of that component is <EM>guaranteed</EM> to receive
that event as well.  For this reason broadcast commands are used to notify all
components, regardless of hierarchy, about some event.  For example the
`<SAMP>cscmdRedraw</SAMP>' broadcast tells every component to repaint itself.
(However, you should not handle this event yourself since that is done by
<CODE>csComponent::HandleEvent()</CODE>, automatically.)
<P>

</UL>
<P>

Aside from the exceptions above, in all other cases the events are processed
from the root of the component's hierarchy (e.g.  the `<SAMP>csApp</SAMP>' object) down
along every branch and can reach every component in the tree (unless the event
is <EM>eaten</EM> somewhere).  Other than broadcast events, any "true" return
code from a component's <CODE>HandleEvent()</CODE> method means that the event has
been <EM>eaten</EM> and should not be sent to any other components.  The
tree-like event propagation is performed by <CODE>csComponent::HandleEvent()</CODE>,
in addition to a lot of other important things, thus you always should call the
parent class' <CODE>HandleEvent()</CODE> method to avoid confusing the windowing
system.
</P><P>

There is another method called <CODE>csComponent::PreHandleEvent()</CODE> which is
much like <CODE>HandleEvent()</CODE> except that it is called for each event pulled
from event queue before <CODE>HandleEvent()</CODE>, and without rules above, i.e.
any component can preprocess any hardware-generated event before it is sent
along normal event handling chain.  This can be used for popup menus, hot keys
and so on.  If <CODE>PreHandleEvent()</CODE> returns true, the event is considered
<EM>eaten</EM> and is discarded.  Be careful with this feature to avoid
interfering with normal component functions.
</P><P>

And last method related to event processing is
<CODE>csComponent::PostHandleEvent()</CODE>.  It is called when no component handled
the event and it is called for all components in <EM>parent-to-child</EM> order.
It can be used to process events that nobody wants, for example it is used to
process hotkeys on buttons (if active component is for example, a input line,
and user presses <KBD>A</KBD> key it should be entered into input text, while if
active component is a non text-hungry component (for example, a list box) the
<KBD>A</KBD> key can be used by some button to activate itself).
</P><P>

<A NAME="SEC384"></A>
<H4> `<SAMP>csComponent</SAMP>' Members </H4>
<!--docid::SEC384::-->
<P>

The `<SAMP>csComponent</SAMP>' class has a number of data fields.  The most important
are summarized here.
</P><P>

<DL COMPACT>
<DT><CODE>csRect bound</CODE>
<DD>This defines the physical bounds of the component.  All drawing operations
happens inside and are clipped to this bound.  Component does not have control
over any other pixel outside this bound.  The bounds are defined relative to
parent's origin.  For example, if we have a component with bounds (<VAR>xmin</VAR>
= 20, <VAR>ymin</VAR> = 10, <VAR>xmax</VAR> = 100, <VAR>ymax</VAR> = 50) and it has a child
at (10, 10, 30, 40) then its real (physical) pixel coordinates are (20+10,
10+10, 20+30, 10+40).  A child is always clipped to the bounds of all its
parents (however, there is a exception from this rule).
<P>

<DT><CODE>int state</CODE>
<DD>Contains the state flags of the component.  There are two types of state flags
(although CSWS does not make a difference between them)--<EM>dynamic</EM>
flags and <EM>option</EM> flags.  Option flags usually define some static aspect
of component--for example, whenever component is selectable (i.e. if it can
become the focused element), or it is partially transparent (see
irregularly-shaped components) etc.  Dynamic flags often changes during
component's life, for example component visibility flag, "component focused"
flag and so on.  The component state flags starts with the `<SAMP>CSS_</SAMP>' prefix.
<P>

You should never manually change state flags.  Instead, there are two methods
for this: <CODE>SetState(<VAR>mask</VAR>, <VAR>state</VAR>)</CODE> and
<CODE>GetState(<VAR>mask</VAR>)</CODE>.  For example, if component is not selectable and
you want to make it selectable, call <CODE>component.SetState(CSS_SELECTABLE,
true)</CODE>.  The <CODE>SetState()</CODE> method is virtual and is often overridden to
execute some specific functions when component state changes.  For example,
default <CODE>SetState()</CODE> handler shows or hides the component if
`<SAMP>CSS_VISIBLE</SAMP>' flag state changes.
</P><P>

<DT><CODE>csRect dirty</CODE>
<DD>Contains the <EM>dirty</EM> rectangle.  If it is non-empty, the dirty area of
component is redrawn just before the end-of-frame.
<P>

<DT><CODE>int DragStyle</CODE>
<DD>Contains a combination of bits (defined by constants with names such as
<CODE>CS_DRAG_<VAR>XXX</VAR></CODE>) that defines which sides of component can be dragged
with mouse when you call first the <CODE>csComponent::Drag()</CODE> method.  By
default it is equal to `<SAMP>CS_DRAG_ALL</SAMP>'.  Note that if component won't call
<CODE>csComponent::Drag()</CODE> you won't be able to resize the component even if
`<SAMP>DragStyle</SAMP>' is equal to `<SAMP>CS_DRAG_ALL</SAMP>'.
<P>

<DT><CODE>csApp *app</CODE>
<DD>This is the "main" application object; the root of entire window tree.  It
is a descendant of `<SAMP>csApp</SAMP>' class which is a superclass of
`<SAMP>csComponent</SAMP>'.  `<SAMP>csApp</SAMP>' has some application-global methods such as
`<SAMP>CaptureMouse</SAMP>', `<SAMP>CaptureKeyboard</SAMP>', it contains the global mouse
pointer object and many other.
<P>

<DT><CODE>csComponent *parent</CODE>
<DD>Contains the <EM>parent</EM> component.  Components are chained into a tree, each
component knows its neighbors (through `<SAMP>next</SAMP>' and `<SAMP>prev</SAMP>' fields),
each parent knows its focused child, and can traverse its list of children by
starting from focused, then going to <EM>focused-to-next</EM> and so on.
<P>

<DT><CODE>csComponent *prev</CODE>
<DD><DT><CODE>csComponent *next</CODE>
<DD>Contains the next and previous neighbors in parent's child list.  They are
never <CODE>0</CODE>, chains are always closed.  If a component is the only child
of another, its next and prev fields points to himself.
<P>

<A NAME="CSWS Focus Chain"></A>
<DT><CODE>csComponent *focused</CODE>
<DD>This is the focused child component.  For example, keyboard events are sent
only to components in <EM>focused</EM> chain, i.e. to `<SAMP>app</SAMP>',
`<SAMP>app-&#62;focused</SAMP>', `<SAMP>app-&#62;focused-&#62;focused</SAMP>' and so on.  If component
does not have any child components, focused is <CODE>0</CODE>.  This is the only
possible case when "focused" can be <CODE>0</CODE>.
<P>

<DT><CODE>csComponent *top</CODE>
<DD>This is the top component in Z-order.  Mouse events are processed in Z-order
unlike keyboard events.  The focused event is not necessarily the top
component, although usually this is true.  If component has
`<SAMP>CSS_TOPSELECT</SAMP>' flag set, when user activates (focuses) a component, it
is made the topmost, however if it has this flag reset, its Z-order does not
change.
<P>

<DT><CODE>int id</CODE>
<DD>This is component's identifier.  This is a user-definable value, but it is
expected to be unique within all children of a parent component.  You can
search for child components with given identification by calling
<CODE>parent-&#62;GetChild(int <VAR>find_id</VAR>)</CODE>.
</DL>
<P>

<A NAME="CSWS Events"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_152.html#SEC377"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_154.html#SEC385"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_150.html#SEC375"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_151.html#SEC376"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_157.html#SEC391"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC963">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
