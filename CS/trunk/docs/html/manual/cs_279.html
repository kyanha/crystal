<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: Release Notes 98</TITLE>

<META NAME="description" CONTENT="Crystal Space: Release Notes 98">
<META NAME="keywords" CONTENT="Crystal Space: Release Notes 98">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC839"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_278.html#SEC823"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_280.html#SEC887"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_277.html#SEC822"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_277.html#SEC822"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC962"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC962">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H2> C.2 Release Notes from 0.96 to 0.98 </H2>
<!--docid::SEC839::-->
<P>

This section documents the major changes between versions 0.96 and 0.98 of
Crystal Space.
</P><P>

<A NAME="SEC840"></A>
<H3> Lighting Changes </H3>
<!--docid::SEC840::-->
<P>

The following methods have been removed:
</P><P>

<UL>
<LI>
<CODE>iMeshWrapper::DeferUpdateLighting()</CODE>
<LI>
<CODE>iMeshWrapper::UpdateLighting()</CODE>
</UL>
<P>

Instead there is a new function <CODE>iMeshWrapper::SetLightingUpdate()</CODE> with
which you can exhibit the same control.  The big difference is that you don't
have to call this function every time a light or object moves.  This is all
updated automatically now.
</P><P>

Also removed the <CODE>CS_NLIGHT_</CODE> flags. <CODE>iEngine::GetNearbyLights()</CODE>
has been modified so that the flags parameter is no longer accepted.
</P><P>

<A NAME="SEC841"></A>
<H3> Bezier Curve Changes </H3>
<!--docid::SEC841::-->
<P>

The notion of curve templates has been reworked. `<SAMP>iCurveTemplate</SAMP>' has
been removed and it's functionality has moved to `<SAMP>iCurve</SAMP>' itself.
As a consequence of this change the bezier addon loader has been removed.
Also curves have been separated from the thing plugin and now live in the
`<TT>bezier</TT>' plugin. So, a curve like this in the past:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#60;addon&#62;
  &#60;plugin&#62;crystalspace.mesh.loader.thing.bezier&#60;/plugin&#62;
  &#60;params&#62;
    &#60;name&#62;b1&#60;/name&#62;
    &#60;material&#62;mosaic&#60;/material&#62;
    &#60;v&#62;0&#60;/v&#62; &#60;v&#62;1&#60;/v&#62; &#60;v&#62;2&#60;/v&#62;
    &#60;v&#62;3&#60;/v&#62; &#60;v&#62;4&#60;/v&#62; &#60;v&#62;5&#60;/v&#62;
    &#60;v&#62;6&#60;/v&#62; &#60;v&#62;7&#60;/v&#62; &#60;v&#62;8&#60;/v&#62;
  &#60;/params&#62;
&#60;/addon&#62;
&#60;meshfact name="tunnel"&#62;
  &#60;plugin&#62;crystalspace.mesh.loader.factory.thing&#60;/plugin&#62;
  &#60;params&#62;
    &#60;curvecenter x="0" y="0" z="0" /&#62;
    &#60;curvescale&#62;80&#60;/curvescale&#62;
    &#60;curvecontrol x="5" y="2" z="0" u="1" v="0" /&#62;
    <small>...</small>
    &#60;curve name="bez"&#62;b1&#60;/curve&#62;
  &#60;/params&#62;
&#60;/meshfact&#62;
</pre></td></tr></table></P><P>

should now become (note the new plugin line):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#60;meshfact name="tunnel"&#62;
  &#60;plugin&#62;crystalspace.mesh.loader.factory.bezier&#60;/plugin&#62;
  &#60;params&#62;
    &#60;curvecenter x="0" y="0" z="0" /&#62;
    &#60;curvescale&#62;80&#60;/curvescale&#62;
    &#60;curvecontrol x="5" y="2" z="0" u="1" v="0" /&#62;
    <small>...</small>
    &#60;curve name="b1"&#62;
      &#60;material&#62;mosaic&#60;/material&#62;
      &#60;v&#62;0&#60;/v&#62; &#60;v&#62;1&#60;/v&#62; &#60;v&#62;2&#60;/v&#62;
      &#60;v&#62;3&#60;/v&#62; &#60;v&#62;4&#60;/v&#62; &#60;v&#62;5&#60;/v&#62;
      &#60;v&#62;6&#60;/v&#62; &#60;v&#62;7&#60;/v&#62; &#60;v&#62;8&#60;/v&#62;
    &#60;/curve&#62;
  &#60;/params&#62;
&#60;/meshfact&#62;
</pre></td></tr></table></P><P>

On the API side nothing much changes except that when you use
the bezier mesh plugin you need to use `<SAMP>iBezierState</SAMP>' and
`<SAMP>iBezierFactoryState</SAMP>'.
</P><P>

The `<SAMP>iThingEnvironment</SAMP>' no longer has code to maintain bezier curve
templates.
</P><P>

<A NAME="SEC842"></A>
<H3> iThingState and iPolygon3D Changes </H3>
<!--docid::SEC842::-->
<P>

The interface `<SAMP>iThingState</SAMP>' no longer inherits from
`<SAMP>iObject</SAMP>', thus the <CODE>QueryObject()</CODE> function has been removed.
</P><P>

`<SAMP>iThingState</SAMP>' has been split into `<SAMP>iThingState</SAMP>' and
`<SAMP>iThingFactoryState</SAMP>'. A thing mesh no longer implements both a mesh
object and a mesh object factory. Instead things now work like usual
mesh objects where <CODE>iMeshObjectType::NewFactory()</CODE> creates a
factory that implements `<SAMP>iThingFactoryState</SAMP>' and
<CODE>iMeshObjectFactory::NewInstance()</CODE> creates an instance that implements
`<SAMP>iThingState</SAMP>'. The engine convenience functions to create a thing
mesh will automatically create both the factory and mesh so you don't
have to worry about that. You can use <CODE>iThingState::GetFactory()</CODE>
from a thing mesh object to get the `<SAMP>iThingFactoryState</SAMP>' so you can
build the polygons. Note that <CODE>SCF_QUERY_INTERFACE()</CODE> of
`<SAMP>iThingFactoryState</SAMP>' no longer works on a thing mesh object. You must
use <CODE>GetFactory()</CODE>.
</P><P>

<CODE>iThingState::GetVertexC()</CODE> has been removed. It is no longer possible
to get camera space information from a thing.
</P><P>

The method <CODE>iThingFactoryState::GetFlags()</CODE> has been removed.  Use the new
method <CODE>iMeshObjectFactory::GetFlags()</CODE> instead.
</P><P>

The interface `<SAMP>iPolygon3D</SAMP>' is completely removed.  The
`<SAMP>iThingFactoryState</SAMP>' now contains a lot of new functions to create and
manipulate polygons.  Here is an example:
</P><P>

First the old code:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  iPolygon3D* p;
  p = state-&#62;CreatePolygon ("First one");
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;SetMaterial (mat);
  p = state-&#62;CreatePolygon ("Second one");
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;SetMaterial (mat);
  <small>...</small>
</pre></td></tr></table></P><P>

Here the new code:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  state-&#62;AddQuad (
    csVector3 (<small>...</small>),
    csVector3 (<small>...</small>),
    csVector3 (<small>...</small>),
    csVector3 (<small>...</small>));
  state-&#62;SetPolygonName (CS_POLYRANGE_LAST, "First one");
  state-&#62;AddQuad (
    csVector3 (<small>...</small>),
    csVector3 (<small>...</small>),
    csVector3 (<small>...</small>),
    csVector3 (<small>...</small>));
  state-&#62;SetPolygonName (CS_POLYRANGE_LAST, "Second one");
  state-&#62;SetPolygonMaterial (CS_POLYRANGE_ALL, mat);
</pre></td></tr></table></P><P>

If you want to add a box that can be seen from the inside (typically a room)
then you can do it like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  state-&#62;AddInsideBox (csVector3 (-5, 0, -5), csVector3 (5, 20, 5));
  state-&#62;SetPolygonMaterial (CS_POLYRANGE_LAST, mat);
  state-&#62;SetPolygonTextureMapping (CS_POLYRANGE_LAST, 3);
</pre></td></tr></table></P><P>

<A NAME="SEC843"></A>
<H3> Light Changes </H3>
<!--docid::SEC843::-->
<P>

The interfaces `<SAMP>iStatLight</SAMP>' and `<SAMP>iDynLight</SAMP>' have been removed
and their functionality has been merged into `<SAMP>iLight</SAMP>' (this includes
the function <CODE>iDynLight::Setup()</CODE>. There is now a new function
<CODE>iLight::GetDynamicType()</CODE> which returns one of the following
constants depending on the type of the light:
</P><P>

<UL>
<LI>
<CODE>CS_LIGHT_DYNAMICTYPE_STATIC</CODE>: for static lights.
<LI>
<CODE>CS_LIGHT_DYNAMICTYPE_PSEUDO</CODE>: for pseudo-dynamic lights.
<LI>
<CODE>CS_LIGHT_DYNAMICTYPE_DYNAMIC</CODE>: for fully dynamic lights.
</UL>
<P>

The method <CODE>iLight::IsDynamic()</CODE> was removed;
use <CODE>iLight::GetDynamicType()</CODE> to get the same information.
</P><P>

The following functions have been modified to work with `<SAMP>iLight</SAMP>'
instead of `<SAMP>iStatLight</SAMP>' and `<SAMP>iDynLight</SAMP>':
</P><P>

<UL>
<LI>
<CODE>iEngine::CreateLight()</CODE>.
<LI>
<CODE>iEngine::FindLight()</CODE>.
<LI>
<CODE>iEngine::FindLightID()</CODE>.
<LI>
<CODE>iEngine::ForceRelight()</CODE>.
</UL>
<P>

The last parameter of <CODE>iEngine::CreateLight()</CODE> routine has
changed to be the dynamic type of the light (one of the above
`<SAMP>CS_LIGHT_DYNAMICTYPE</SAMP>' constants) instead of a boolean. Thus, the
<CODE>iEngine::CreateDynLight()</CODE> method has been superceded by this
function.
</P><P>

All functions related to dynamic lights have been removed. Dynamic
lights are now treated exactly like static lights. For example, you have to
call <CODE>iSector::GetLights()</CODE> and then <CODE>Add()</CODE> to add the light to the
sector. The <CODE>iLight::Setup()</CODE> function remains, however, and is
specific to dynamic lights.
</P><P>

<A NAME="SEC844"></A>
<H3> Polygon Texture Mapping Changes </H3>
<!--docid::SEC844::-->
<P>

The following interfaces have been removed: `<SAMP>iPolyTexNone</SAMP>',
`<SAMP>iPolyTexGouraud</SAMP>', `<SAMP>iPolyTexFlat</SAMP>', and  `<SAMP>iPolyTexLightMap</SAMP>'.
The combined API from `<SAMP>iPolyTexNone</SAMP>' and the `<SAMP>iPolyTexLightMap</SAMP>'
have moved to `<SAMP>iThingFactoryState</SAMP>'.
</P><P>

It is no longer possible to set mixmode and alpha for individual polygons
Instead use the new <CODE>iThingState::SetMixMode()</CODE> function to set the
mixmode globally.  If needed you will have to separate the transparent polygon
in a separate thing mesh.
</P><P>

It is also no longer possible to get camera space information from polygons.
</P><P>

The <CODE>&#60;shading&#62;</CODE> keyword in polygons in map files now accepts a boolean
value instead of `<SAMP>NONE</SAMP>', `<SAMP>FLAT</SAMP>', `<SAMP>GOURAUD</SAMP>', or `<SAMP>LIGHTMAP</SAMP>'.
With this you can enable/disable lightmapping.
</P><P>

If you want gouraud shaded polygons you should use the `<TT>genmesh</TT>'
mesh object plugin instead.
</P><P>

<A NAME="SEC845"></A>
<H3> Polygon Planes </H3>
<!--docid::SEC845::-->
<P>

Polygon planes are removed. So it is no longer possible to use
the plane addon loader to define texture mapping for a polygon outside
of the polygon itself. To fix this you must specify all texture mapping
information in the `<SAMP>texmap</SAMP>' statement of the polygon. `<TT>map2cs</TT>'
now correctly outputs polygons like this (no longer outputs planes) and
`<TT>levtool</TT>' can convert old style maps to new format like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>levtool -planes yourmap.zip
</pre></td></tr></table></P><P>

`<SAMP>iThingEnvironment</SAMP>' no longer has code to maintain polygon texture
mapping planes.
</P><P>

The plane loader and saver addons have been removed from the thing
loader plugin.
</P><P>

Removed `<SAMP>iPolyTxtPlane</SAMP>' interface.
</P><P>

<A NAME="SEC846"></A>
<H3> Portal Changes </H3>
<!--docid::SEC846::-->
<P>

Several methods in `<SAMP>iPortal</SAMP>' have changed slightly. For example,
<CODE>SetMirror()</CODE> now expects a plane instead of a polygon.
</P><P>

In the map loader the syntax for specifying warp vectors for portals has
changed from `<SAMP>v</SAMP>' to `<SAMP>wv</SAMP>' and `<SAMP>w</SAMP>' to `<SAMP>ww</SAMP>'.
</P><P>

Portals in thing have been removed completely! Instead there is now a separate
portal container object which belongs in the engine (otherwise it is just
a mesh like any other mesh). To create a portal you can use the convenience
functions <CODE>iEngine::CreatePortal()</CODE> and
<CODE>iEngine::CreatePortalContainer()</CODE>. Here is an example of old code
and how to change it to new code:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  <small>...</small> create thing in sourceSector <small>...</small>
  iPolygon3D* p = state-&#62;CreatePolygon ();
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  p-&#62;CreateVertex (csVector3 (<small>...</small>));
  iPortal* portal = p-&#62;CreatePortal (destSector);
</pre></td></tr></table></P><P>

New code:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  csPoly3D poly;
  poly.AddVertex (csVector3 (<small>...</small>));
  poly.AddVertex (csVector3 (<small>...</small>));
  poly.AddVertex (csVector3 (<small>...</small>));
  poly.AddVertex (csVector3 (<small>...</small>));
  iPortal* portal;
  csRef&#60;iMeshWrapper&#62; portal_mesh = engine-&#62;CreatePortal (
        "my_portal", sourceSector, csVector3 (0, 0, 0),
        destSector, poly.GetVertices (), poly.GetVertexCount (),
        portal);
</pre></td></tr></table></P><P>

In map files the old way to create portals in a polygon is still supported.
Internally it will also create a portal container (as a child mesh of
the thing it is in). The new way to create portals is by using the new
`<SAMP>portals</SAMP>' and `<SAMP>portal</SAMP>' keywords in sectors or as children of
other meshes.
</P><P>

<A NAME="SEC847"></A>
<H3> Datatype Changes </H3>
<!--docid::SEC847::-->
<P>

The `<SAMP>csSome</SAMP>', `<SAMP>csConstSome</SAMP>' and `<SAMP>uint</SAMP>' types have been removed.
Use `<SAMP>void*</SAMP>', `<SAMP>const void*</SAMP>' and `<SAMP>unsigned int</SAMP>' instead.
</P><P>

<A NAME="SEC848"></A>
<H3> Procedural Textures  </H3>
<!--docid::SEC848::-->
<P>

Instead of only built-in types, procedural textures have been moved into 
plugins. That means that the <CODE>&#60;type&#62;</CODE> token now works the same way
as the <CODE>&#60;plugin&#62;</CODE> token for meshes. That is, either specify a full
class ID (e.g. `<SAMP>crystalspace.proctex.loader.fire</SAMP>'), or a shortcut
specified in the <CODE>&#60;plugins&#62;</CODE> token of the world. To simulate the
old <CODE>&#60;type&#62;</CODE> behaviour, paste the following lines into a map's 
<CODE>&#60;plugin&#62;</CODE> section:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#60;plugin name="dots"&#62;crystalspace.texture.loader.dots&#60;/plugin&#62;
&#60;plugin name="fire"&#62;crystalspace.texture.loader.fire&#60;/plugin&#62;
&#60;plugin name="water"&#62;crystalspace.texture.loader.water&#60;/plugin&#62;
&#60;plugin name="plasma"&#62;crystalspace.texture.loader.plasma&#60;/plugin&#62;
</pre></td></tr></table></P><P>

This requires that you move the <CODE>&#60;plugin&#62;</CODE> block in front of the 
<CODE>&#60;textures&#62;</CODE> block, as otherwise the shortcuts won't be recognised.
</P><P>

The behaviour of procedural textures also differs as a material of the same
name was created along with the texture; this isn't the case any more, you
have to create a material which uses the procedural texture manually.
</P><P>

In addition, the loader now doesn't distinguish between normal and procedural
textures any more, both are loaded with the same <CODE>&#60;texture&#62;</CODE> block. The 
syntax recognized is a combination of both old <CODE>&#60;texture&#62;</CODE> and 
<CODE>&#60;proctex&#62;</CODE> tokens--so renaming all <CODE>&#60;proctex&#62;</CODE> to <CODE>&#60;texture&#62;</CODE>
tags is sufficient to convert a level (apart from fixing the <CODE>&#60;type&#62;</CODE>
tokens.)
</P><P>

<A NAME="SEC849"></A>
<H3> Regions </H3>
<!--docid::SEC849::-->
<P>

Region handling has changed considerably. The engine no longer has the
concept of a current region. The engine still manages all regions though.
Objects also no longer register themselves to the current region. It is
the responsability of the object creator to do that. The standard loader
has support for adding objects to a region now.
</P><P>

The following functions have been removed from `<SAMP>iEngine</SAMP>':
</P><P>

<UL>
<LI>
<CODE>SelectRegion()</CODE>
<LI>
<CODE>GetCurrentRegion()</CODE>
<LI>
<CODE>AddToCurrentRegion()</CODE>
</UL>
<P>

There is one new function <CODE>iEngine::CreateRegion()</CODE> which will create
a new region.
</P><P>

In `<SAMP>iLoader</SAMP>' the functions <CODE>LoadMapFile()</CODE> and
<CODE>ThreadedLoadMapFile()</CODE> now expect an optional pointer to a region
in addition with a boolean to restrict searching to that region.
</P><P>

In addition to all these changes the <CODE>&#60;region&#62;</CODE> keyword in map files is no
longer supported.
</P><P>

<A NAME="SEC850"></A>
<H3> Mesh Objects / Factories and iPolygonMesh </H3>
<!--docid::SEC850::-->
<P>

Some mesh factories used to support the querying of the `<SAMP>iPolygonMesh</SAMP>'
interface (e.g. Thing, Sprite3D, Genmesh). Due to the way this was 
implemented internally this caused leaks. So, querying `<SAMP>iPolygonMesh</SAMP>' 
directly from the object is now discouraged. Although it may still work in 
some cases, this feature may be dropped without further notice and may not 
work in all cases. 
</P><P>

Similar for mesh objects. Querying `<SAMP>iPolygonMesh</SAMP>' is discouraged here,
as well.
</P><P>

Instead, if you want the polygon mesh from an object, use the
<CODE>GetObjectModel()</CODE> method from the `<SAMP>iMeshObject</SAMP>' interface;
respectively query for the `<SAMP>iObjectModel</SAMP>' interface in case of a factory,
and utilize one of the <CODE>GetPolygonMeshXXX()</CODE> methods, depending on what
you need (the old interface query returned the collision detection mesh.) This
has also the advantages that you can get different meshes for different
purposes (currently, visibility culling and collision detection in addition the
the base mesh), and that those meshes can be overridden by user-defined meshes
(e.g. if the collision detection mesh needs to have a shape different from the
visible mesh.)
</P><P>

In `<SAMP>iPolygonMesh</SAMP>' the <CODE>IsDeformable()</CODE> method has been replaced
with the more general <CODE>GetFlags()</CODE>. In addition to that <CODE>Cleanup()</CODE>
is removed and instead <CODE>Lock()</CODE> and <CODE>Unlock()</CODE> are added.
</P><P>

`<SAMP>iPolygonMesh</SAMP>' now has <CODE>GetTriangles()</CODE> and <CODE>GetTriangleCount()</CODE>.
Check out the API docs for implementation details.
</P><P>

<A NAME="SEC851"></A>
<H3> Iterator Changes </H3>
<!--docid::SEC851::-->
<P>

Changed the following iterators to conform to the following iterator standard:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>bool iterator-&#62;HasNext() // returns true if there are more items.
T* iterator-&#62;Next()      // returns next element or 0.
void Reset()             // resets iterator (not all implement this).
</pre></td></tr></table></P><P>

<UL>
<LI>
<CODE>iVisibilityObjectIterator</CODE>
<LI>
<CODE>iLightIterator</CODE>
<LI>
<CODE>iSectorIterator</CODE>
<LI>
<CODE>iObjectIterator</CODE>
<LI>
<CODE>iStreamIterator</CODE>
<LI>
<CODE>iObjectRegistryIterator</CODE>
<LI>
<CODE>csTypedObjectIterator</CODE>
<LI>
<CODE>csModelDataActionIterator</CODE>
<LI>
<CODE>csModelDataPolygonIterator</CODE>
<LI>
<CODE>csModelDataTextureIterator</CODE>
<LI>
<CODE>csModelDataMaterialIterator</CODE>
<LI>
<CODE>csModelDataObjectIterator</CODE>
<LI>
<CODE>csNodeIterator</CODE>
</UL>
<P>

<A NAME="SEC852"></A>
<H3> AWS Changes </H3>
<!--docid::SEC852::-->
<P>

<CODE>iAWS::CreateCustomCanvas()</CODE> was removed.  To set up AWS with a
canvas, use <CODE>iAWS::SetupCanvas()</CODE> instead. 
</P><P>

<CODE>iAWS::CreateTransition()</CODE> and <CODE>iAWS::CreateTransitionEx()</CODE> have been
changed to take a <VAR>delay</VAR> parameter specified in `<SAMP>csTicks</SAMP>' instead of
using a <VAR>step_size</VAR> parameter.  This change ensures that transitions take
the same amount of time on computers having different processor speeds.
<CODE>iAWS::ComponentIsInTransition()</CODE> has been added to allow users to query
if a specified `<SAMP>iAwsComponent</SAMP>' is in the midst of a transition.
</P><P>

<A NAME="SEC853"></A>
<H3> Array Changes </H3>
<!--docid::SEC853::-->
<P>

All arrays have been modified to inherit from `<SAMP>csArray</SAMP>'. This means
that there are some slight API changes because some methods were
not consistent with `<SAMP>csArray</SAMP>'.
</P><P>

`<SAMP>csGrowingArray</SAMP>' has been renamed to `<SAMP>csDirtyAccessArray</SAMP>' in order to
better reflect its intention, which is that it publishes a method allowing the
client to obtain access to the raw memory block containing the items in
contiguous memory.  This potentially unsafe operation is not available in the
other array templates.  Use this class only in very special-purpose cases where
you need to construct a list of objects dynamically and then pass the address
of the raw memory containing those objects to some foreign function which does
not understand <CODE>csArray&#60;&#62;</CODE>.
</P><P>

<A NAME="SEC854"></A>
<H3> csPArray Removed </H3>
<!--docid::SEC854::-->
<P>

`<SAMP>csPArray</SAMP>' has been removed in favor of the <CODE>csArray&#60;&#62;</CODE> template.
So, use <CODE>csArray&#60;T*&#62;</CODE> instead of <CODE>csPArray&#60;T&#62;</CODE>.
</P><P>

<A NAME="SEC855"></A>
<H3> csStrVector and iStrVector Removed </H3>
<!--docid::SEC855::-->
<P>

`<SAMP>csStrVector</SAMP>' and `<SAMP>iStrVector</SAMP>' have been removed in favor of
`<SAMP>csStringArray</SAMP>' and `<SAMP>iStringArray</SAMP>'.  This means that functions like
<CODE>iVFS::MountRoot()</CODE> and <CODE>iVFS::FindFiles()</CODE> now return an
`<SAMP>iStringArray</SAMP>'.
</P><P>

<A NAME="SEC856"></A>
<H3> csVector and csBasicVector Removed </H3>
<!--docid::SEC856::-->
<P>

`<SAMP>csVector</SAMP>' and `<SAMP>csBasicVector</SAMP>' have been removed. Instead you
should use one of the templated arrays: <CODE>csArray&#60;&#62;</CODE>, <CODE>csPDelArray&#60;&#62;</CODE>,
or <CODE>csRefArray&#60;&#62;</CODE>.
</P><P>

If you were using a regular `<SAMP>csVector</SAMP>' then this can usually be
replaced directly by <CODE>csArray&#60;type*&#62;</CODE> with `<SAMP>type</SAMP>' the type you
were storing in the vector.
</P><P>

If you subclassed from `<SAMP>csVector</SAMP>' in order to override <CODE>FreeItem()</CODE>
then you have to decide what to do depending on the code in <CODE>FreeItem()</CODE>.
If that code performed a `<SAMP>delete</SAMP>' then you can use <CODE>csPDelArray&#60;&#62;</CODE>.
If that code performed a <CODE>DecRef()</CODE> then you can use <CODE>csRefArray&#60;&#62;</CODE>
but you still have to be careful because <CODE>csRefArray&#60;&#62;</CODE> will automatically
invoke <CODE>IncRef()</CODE> for objects that are pushed on the array. In other cases
you probably need to handle deletion manually.
</P><P>

`<SAMP>csVector</SAMP>' also allowed you to override <CODE>Compare()</CODE> and
<CODE>CompareKey()</CODE>, and these methods were utilized automatically by
<CODE>QuickSort()</CODE>, <CODE>FindSortedKey()</CODE>, <CODE>InsertSorted()</CODE>, and
<CODE>FindKey()</CODE>.  <CODE>csArray&#60;&#62;</CODE>, on the other hand, accepts a comparison
function as an argument to its sorting and searching methods, thus providing
much greater flexibility than `<SAMP>csVector</SAMP>'.  You can transform your
<CODE>csVector</CODE>-based code as follows.  First, the old code:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>class MyVector : public csVector
{
public:
  virtual ~MyVector ()
  {
    DeleteAll ();
  }
  virtual void FreeItem (void* item)
  {
    delete (MyType*)item;
  }
  virtual int Compare (void* i1, void* i2, int mode) const
  {
    <small>...</small>
  }
  virtual int CompareKey (void* i, const void* key, int mode) const
  {
    <small>...</small>
  }
};
</pre></td></tr></table></P><P>

This can be transformed roughly to the following class:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>class MyVector : public csPDelArray&#60;MyType&#62;
{
public:
  static int Compare (MyType const&#38; i1, MyType const&#38; i2)
  {
    <small>...</small>
  }
  static int CompareKey (MyType const&#38; i, MyKey const&#38; key)
  {
    <small>...</small>
  }
};
</pre></td></tr></table></P><P>

The methods <CODE>csArray&#60;&#62;::Sort()</CODE> and <CODE>csArray&#60;&#62;::InsertSorted()</CODE>
accept an optional comparison function (<CODE>MyVector::Compare()</CODE>, in the
example).  To use a custom comparison function, invoke these functions like
this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>MyVector v = <small>...</small>;
v.Sort(MyVector::Compare);
<small>...</small>
MyType o = <small>...</small>;
v.InsertSorted(o, MyVector::Compare);
</pre></td></tr></table></P><P>

If you do not provide a comparison function, then the array elements are
compared against each other with <CODE>T::operator&#60;(T)</CODE> where `<SAMP>T</SAMP>' is the
type of the element contained in the array.  This default comparison semantic
works nicely for all built-in types, as well as for complex types which define
a `<SAMP>&#60;</SAMP>' operator.
</P><P>

The methods <CODE>csArray&#60;&#62;::FindKey()</CODE> and <CODE>csArray&#60;&#62;::FindSortedKey()</CODE>
accept a comparison <EM>functor</EM> which is constructed from the key for which
you are searching and an optional comparison function
(<CODE>MyVector::CompareKey()</CODE>, in the example).  Invoke these functions like
this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>int r;
MyKey key = <small>...</small>;
MyVector v = <small>...</small>;
r = v.FindKey(csArrayCmp&#60;MyType,MyKey&#62;(key, MyVector::CompareKey));
r = v.FindSortedKey(
              csArrayCmp&#60;MyType,MyKey&#62;(key, MyVector::CompareKey));
</pre></td></tr></table></P><P>

In this example, the key's type is `<SAMP>MyKey</SAMP>' (the type expected by
<CODE>MyVector::CompareKey()</CODE>).  It is possible and often convenient for
`<SAMP>MyType</SAMP>' and `<SAMP>MyKey</SAMP>' to be the same type (for instance, you might
search for an integer in an array of integers).  When the types of
`<SAMP>MyType</SAMP>' and `<SAMP>MyKey</SAMP>' differ, `<SAMP>MyType</SAMP>' is often a composite type,
and `<SAMP>MyKey</SAMP>' is the type of one attribute of `<SAMP>MyType</SAMP>', however you are
not in any way limited to this arrangements.  If you do not provide a
comparison function when constructing the functor, then the the elements are
compared with the search key via <CODE>T::operator&#60;(K)</CODE> and
<CODE>K::operator&#60;(T)</CODE> where `<SAMP>T</SAMP>' and `<SAMP>K</SAMP>' are the type of the
contained element and the type of the key, respectively.  This default
comparison semantic is especially useful when the contained elements and key
have the same type, provided that the type supports a useful `<SAMP>&#60;</SAMP>' operator.
For example, if you have an array of integers which you want to sort and then
search, you can use the default comparison semantics, rather than writing a
custom comparison function, as shown here:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csArray&#60;int&#62; v = <small>...</small>;
v.Sort();
int r = v.FindSortedKey(csArrayCmp&#60;int,int&#62;(33));
</pre></td></tr></table></P><P>

<A NAME="SEC857"></A>
<H3> Hash and Set Templates </H3>
<!--docid::SEC857::-->
<P>

The new template classes <CODE>csHash&#60;&#62;</CODE> and <CODE>csSet&#60;&#62;</CODE> are available for
use by new code; and older code will be upgraded over time to use these
template classes.  The older `<SAMP>csHashMap</SAMP>' and `<SAMP>csHashSet</SAMP>' classes are
now deprecated.
</P><P>

<A NAME="SEC858"></A>
<H3> csHashMap Changes </H3>
<!--docid::SEC858::-->
<P>

The deprecated `<SAMP>csHashIterator</SAMP>' can no longer iterate over all objects.
To do that you need to use `<SAMP>csGlobalHashIterator</SAMP>'.
</P><P>

<A NAME="SEC859"></A>
<H3> Event-Related Changes </H3>
<!--docid::SEC859::-->
<P>

Signatures of the <CODE>iEvent::Find()</CODE> methods have been unified so that they
all now accept a reference into which to store the found item.  Previously,
some <CODE>Find()</CODE> methods used a reference for this purpose, while others used
a pointer.  In addition, rather than accepting a pointer to a pointer of type
`<SAMP>iEvent</SAMP>', the <CODE>Find()</CODE> method for finding an event now takes a
reference to a <CODE>csRef&#60;iEvent&#62;</CODE>.
</P><P>

Previously, <CODE>iEventQueue::Post()</CODE> had a special case where it assumed that
the caller was giving up ownership of the posted `<SAMP>iEvent</SAMP>' if the caller
had allocated the event manually, rather than obtaining the event via
<CODE>iEventQueue::CreateEvent()</CODE> or <CODE>iEventOutlet::CreateEvent()</CODE>. In
this case, <CODE>Post()</CODE> would hijack the caller's reference to the
`<SAMP>iEvent</SAMP>' for itself.  This special case allowed the caller to write code,
such as the following, which appeared to leak a reference to the event, but
which did not in fact do so.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>iEvent* e = new csEvent(...);
eventq-&#62;Post(e);
</pre></td></tr></table></P><P>

Now, however, <CODE>iEventQueue::Post()</CODE> takes the more sane approach of
treating all incoming events identically.  It never hijacks ownership of the
event by stealing the caller's reference.  Instead, <CODE>Post()</CODE> uniformly
invokes <CODE>IncRef()</CODE> on each incoming event in order to claim its own
reference.  This means that callers are no longer burdened by having to
determine whether or not the caller's reference is going to be hijacked.
Thus, the above code should now be re-written as:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csRef&#60;iEvent&#62; e;
e.AttachNew(new csEvent(...));
eventq-&#62;Post(e);
</pre></td></tr></table></P><P>

Events created with <CODE>iEventQueue::CreateEvent()</CODE> or
<CODE>iEventOutlet::CreateEvent()</CODE> are unaffected by this change since the
client has never had to worry about <CODE>Post()</CODE> hijacking the reference in
these cases.
</P><P>

<A NAME="SEC860"></A>
<H3> New Renderer-Related Changes </H3>
<!--docid::SEC860::-->
<P>

The mesh object API has changed considerably, thus we recommend looking
at the documentation on that to see how to modify your own mesh object for
the new API.  In this section we describe API modifications that
are relevant for user applications.
</P><P>

For `<SAMP>iLight</SAMP>': <CODE>SetRadius()</CODE>, <CODE>GetRadius()</CODE>, and
<CODE>GetSquaredRadius()</CODE> have been replaced with <CODE>SetInfluenceRadius()</CODE>,
<CODE>GetInfluenceRadius()</CODE>, and <CODE>GetInfluenceRadiusSq()</CODE>.
</P><P>

For `<SAMP>iMaterialEngine</SAMP>' and related: <CODE>GetTextureWrapper()</CODE> for
layers now expects a `<SAMP>csStringID</SAMP>' instead of an integer.
</P><P>

<A NAME="SEC861"></A>
<H3> SCF Changes </H3>
<!--docid::SEC861::-->
<P>

<EM>Written by Eric Sunshine, <A HREF="mailto:sunshine@sunshineco.com">sunshine@sunshineco.com</A>.</EM>
</P><P>

The monolithic and inflexible plugin-registry database, `<TT>scf.cfg</TT>', has
been eliminated.  Instead, plugin modules are now self-describing via a
meta-information resource associated with each module.  It is possible to
access this meta-information without actually loading the plugin, thus avoiding
a time-consuming and costly operation.
</P><P>

A plugin's meta-information is now stored in an XML-format file rather
than being hard-coded via the plugin's C++ code.  The meta-information file is
named after the associated plugin module, except with filename extension
`<TT>.csplugin</TT>'.  For instance, the meta-information for the `<TT>vfs.so</TT>' (or
`<TT>vfs.dll</TT>') plugin will be named `<TT>vfs.csplugin</TT>'.
</P><P>

Since the meta-information is now maintained via an external resource, the
following SCF macros, which were used to export this information from the
C++ code, have been removed:
</P><P>

<UL>
<LI>
<CODE>SCF_EXPORT_CLASS_TABLE()</CODE>
<LI>
<CODE>SCF_EXPORT_CLASS()</CODE>
<LI>
<CODE>SCF_EXPORT_CLASS_DEP()</CODE>
<LI>
<CODE>SCF_EXPORT_CLASS_TABLE_END</CODE>
</UL>
<P>

To deal with this change in your own code, simply remove the entire
<CODE>SCF_EXPORT_CLASS_TABLE()</CODE> block from the C++ code which implements the
plugin module.
</P><P>

Creation of the meta-information resource file involves a straight-forward
translation of the information from the obsolete SCF macros into a
structured XML-format file.  For example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>SCF_EXPORT_CLASS_TABLE(foo)
  SCF_EXPORT_CLASS(
    MyClass1,
    "myproj.myplugin.foo1",
    "My first custom foo class")
  SCF_EXPORT_CLASS_DEP(
    MyClass2,
    "myproj.myplugin.foo2",
    "My second custom foo class",
    "myproj.myplugin.bar1,myproj.myplugin.bar2")
SCF_EXPORT_CLASS_TABLE_END
</pre></td></tr></table></P><P>

This table exports two C++ classes, `<SAMP>MyClass1</SAMP>' and `<SAMP>MyClass2</SAMP>' under
the SCF class names `<SAMP>myproj.myplugin.foo1</SAMP>' and
`<SAMP>myproj.myplugin.foo2</SAMP>', respectively.  Furthermore, the second exported
class has a dependency upon two other SCF classes,
`<SAMP>myproj.myplugin.bar1</SAMP>' and `<SAMP>myproj.myplugin.bar2</SAMP>'.  To convert
this to an XML-format meta-information resource, just copy the above
values into the appropriate XML nodes.  For instance:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#60;?xml version="1.0"?&#62;
&#60;!-- myplugin.csplugin --&#62;
&#60;plugin&#62;
  &#60;scf&#62;
    &#60;classes&#62;
      &#60;class&#62;
        &#60;name&#62;myproj.myplugin.foo1&#60;/name&#62;
        &#60;implementation&#62;MyClass1&#60;/implementation&#62;
        &#60;description&#62;My first custom foo class&#60;/description&#62;
      &#60;/class&#62;
      &#60;class&#62;
        &#60;name&#62;myproj.myplugin.foo2&#60;/name&#62;
        &#60;implementation&#62;MyClass2&#60;/implementation&#62;
        &#60;description&#62;My second custom foo class&#60;/description&#62;
        &#60;requires&#62;
          &#60;class&#62;myproj.myplugin.bar1&#60;/class&#62;
          &#60;class&#62;myproj.myplugin.bar2&#60;/class&#62;
        &#60;/requires&#62;
      &#60;/class&#62;
    &#60;/classes&#62;
  &#60;/scf&#62;
&#60;/plugin&#62;
</pre></td></tr></table></P><P>

The top-level node of a meta-information file is named <CODE>&#60;plugin&#62;</CODE>.  All
SCF-related information is contained within an <CODE>&#60;scf&#62;</CODE> child node.
Plugin modules can export multiple named SCF classes.  Each exported class
is represented by a <CODE>&#60;class&#62;</CODE> node within the <CODE>&#60;classes&#62;</CODE> group.  The
<CODE>&#60;name&#62;</CODE> node of a <CODE>&#60;class&#62;</CODE> is the class' SCF name.  The
<CODE>&#60;implementation&#62;</CODE> node references the C++ class which actually implements
the named SCF class.  This is the same name that is provided as an
argument to the <CODE>SCF_IMPLEMENT_FACTORY()</CODE> macro.  When an SCF class
depends upon other SCF classes, the dependencies are indicated via the
optional <CODE>&#60;requires&#62;</CODE> group, which contains one <CODE>&#60;class&#62;</CODE> node per
dependency.
</P><P>

Meta-information in the `<TT>.csplugin</TT>' file is extensible; it is not
restricted to SCF-only usage.  Plugin authors can choose to publish
supplementary information about plugins in addition to the SCF information
already published.  As a hypothetical example, image loading plugins might
desire to publish <EM>image indentification</EM> information which would allow the
image loading multiplexor to selectively request image loading plugins
<EM>on-demand</EM>, rather than requesting all plugins unconditionally, even if
they are not needed.  Here is a possible meta-information table for a PNG
image loader (with the <CODE>&#60;scf&#62;</CODE> node collapsed to `<SAMP><small>...</small></SAMP>' for the
sake of illustration):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#60;?xml version="1.0"?&#62;
&#60;!-- cspngimg.csplugin --&#62;
&#60;plugin&#62;
  &#60;scf&#62;...&#60;/scf&#62;
  &#60;imageloader&#62;
    &#60;imagetype&#62;
      &#60;class&#62;crystalspace.graphic.image.io.png&#60;/class&#62;
      &#60;identify&#62;
        &#60;mimetype&#62;image/png&#60;/mimetype&#62;
        &#60;extension&#62;png&#60;/extension&#62;
        &#60;extension&#62;PNG&#60;/extension&#62;
        &#60;scan length="4" bytes="\0x89PNG"/&#62;
     &#60;/identify&#62;
    &#60;/imagetype&#62;
  &#60;/imageloader&#62;
&#60;/plugin&#62;
</pre></td></tr></table></P><P>

In this example, the PNG loader meta-information tells the multiplexor
several different ways to identify a PNG image:
</P><P>

<UL>
<LI>
By checking MIME type, if available.
<LI>
By checking file extension, if available.
<LI>
By checking for the <EM>magic</EM> identification string `<SAMP>\0x89PNG</SAMP>' in the
raw image data.
</UL>
<P>

If the hypothetical multiplexor identifies the image as PNG, only then
will it actually request the PNG loader plugin.
</P><P>

If you know the physical pathname of a plugin module, then you can retrieve its
meta-information via <CODE>csGetPluginMetadata()</CODE> (`<TT>csutil/csshlib.h</TT>'),
which returns an `<SAMP>iDocument</SAMP>'.  Alternately, if you know the name of an
SCF class which a plugin exports, then you can retrieve the plugin's
meta-information, by calling <CODE>iSCF::GetPluginMetadata()</CODE>.
</P><P>

At program launch time, SCF discovers plugins automatically by searching a
set of directories, and creates an internal database associating available
SCF class names with the plugin modules which implement them.  The
directories which SCF searches by default are:
</P><P>

<UL>
<LI>
The application resource directory as returned by <CODE>csGetResourceDir()</CODE>.
On most platforms, this is the same as the directory containing the
application, however, on MacOS/X, it is the `<TT>Resources</TT>' directory within
the Cocoa application wrapper.
<P>

<LI>
The directory containing the application (or containing the Cocoa application
wrapper for MacOS/X) as returned by <CODE>csGetAppDir()</CODE>.
<P>

<LI>
The installed Crystal Space resource directories as returned by
<CODE>csGetConfigPath()</CODE>.  This is often the value of the `<SAMP>CRYSTAL</SAMP>'
environment variable, or the `<SAMP>CrystalSpaceRoot</SAMP>' default setting on MacOS/X
(which is often stored within the `<SAMP>NSGlobalDomain</SAMP>' domain).
</UL>
<P>

If you would like SCF to scan additional directories, you can invoke
either of these two functions (multiple times, if necessary):
</P><P>

<UL>
<LI>
<CODE>scfInitialize(csPluginPaths const*)</CODE>
<LI>
<CODE>iSCF::ScanPluginsPath(char const*, bool, char const*)</CODE>
</UL>
<P>

Finally, if you need to manually register a single plugin module with SCF
for which you know the native pathname (not a VFS pathname), you can
invoke <CODE>iSCF::RegisterPlugin()</CODE>.
</P><P>

For those relatively rare cases when a <EM>named</EM> SCF class is built
directly into an application, rather than being implemented via a plugin, the
class must be registered with SCF manually since SCF will not
otherwise be able to discover it automatically as is the case with named
classes exported from plugin modules.  Manual registration is accomplished with
the <CODE>SCF_REGISTER_STATIC_CLASS()</CODE> macro.  This macro existed previously,
but accepted a different set of arguments.  The new arguments are:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>SCF_REGISTER_STATIC_CLASS(
  C++Class,
  "scf.class.name",
  "description",
  "comma-separated dependency list" or NULL)
</pre></td></tr></table></P><P>

Invoke this macro in one of the source files of your application; usually in
the source file which implements the class.  This macro should be invoked at
file scope (that is, not from inside a function).  For instance:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>SCF_REGISTER_STATIC_CLASS(
  MyClass2,
  "myproj.myplugin.foo2",
  "My second custom foo class",
  "myproj.myplugin.bar1,myproj.myplugin.bar2")
</pre></td></tr></table></P><P>

If you used to use <CODE>SCF_REGISTER_STATIC_LIBRARY()</CODE> or
<CODE>SCF_REGISTER_STATIC_CLASS_DEP()</CODE> for this same purpose, you must now
instead use <CODE>SCF_REGISTER_STATIC_CLASS()</CODE>.  (A macro named
<CODE>SCF_REGISTER_STATIC_LIBRARY()</CODE> still exists, but it has a completely
different purpose than the original version, and is typically only used by very
low-level mechanisms, rather than by end-users.  See
`<TT>CS/include/csutil/scf.h</TT>' for the gory details, if you are curious.)
</P><P>

The Crystal Space `<TT>configure</TT>' script option
`<SAMP>--enable-meta-info-embedding</SAMP>' controls whether or not the build system
embeds the plugin meta-information into plugin modules (if supported by the
platform), and whether or not the plugin loader looks for embedded
meta-information.  If this option is disabled, or if embedding is not supported
by the platform, then the meta-information is laid down alongside the built
plugin module (`<TT>.so</TT>' or `<TT>.dll</TT>') in a text file with the same name as
the plugin module, except with extension `<TT>.csplugin</TT>'.  The
meta-information embedding option is enabled by default for most platforms, but
is disabled by default for Unix platforms.
</P><P>

<EM>Warning</EM>: Meta-information embedding on Unix is accomplished via the
`<TT>libbfd</TT>' library which carries a GPL license.  This license is
incompatible with Crystal Space's LGPL license.  Unlike the LGPL
which is compatible with closed-source projects, the GPL license is not.
For this reason, embedding is disabled by default on Unix, and must be enabled
explicitly with the `<TT>configure</TT>' script's
`<SAMP>--enable-meta-info-embedding</SAMP>' option.  Enable this option on Unix only if
you are certain that your project is compatible with the GPL license.
</P><P>

The platform-specific plugin loaders are capable of reading embedded plugin
meta-information, as well as meta-information in stand-alone `<TT>.csplugin</TT>'
files.  Even when configured for embedding, the plugin loaders will still be
able to recognize and utilize external `<TT>.csplugin</TT>' resources.  This means
that Crystal Space-based projects with unsophisticated build systems, which are
incapable of embedding meta-information into the plugin module, can still
create usable plugins simply by placing a copy of the `<TT>.csplugin</TT>' file
alongside the plugin executable (`<TT>.so</TT>' or `<TT>.dll</TT>').
</P><P>

External projects which are based upon Crystal Space's Jam build system
(`<TT>CS/mk/jam</TT>') inherit, for free, the capability of embedding
meta-information within plugin modules (if supported by the platform).  Simply
grab the newer `<TT>.jam</TT>' files from `<TT>CS/mk/jam</TT>', and add a few
definitions to the project's `<TT>Jamconfig</TT>' file.  The exact set of
definitions is platform-specific, so consult the appropriate Jam file
(`<TT>unix.jam</TT>', `<TT>win32.jam</TT>', or `<TT>macosx.jam</TT>') to determine
precisely which which definitions are required.  Here is a list of definitions
required at the time of writing:
</P><P>

<DL COMPACT>
<DT>Unix
<DD><CODE>EMBED_META = yes</CODE><BR>
<CODE>LIBBFD.AVAILABLE = yes</CODE><BR>
<CODE>OBJCOPY.AVAILABLE = yes</CODE><BR>
<CODE>CMD.OBJCOPY = objcopy</CODE>
<P>

<DT>Windows
<DD><CODE>EMBED_META = yes</CODE>
<P>

<DT>MacOS/X (not yet supported)
<DD><CODE>EMBED_META = yes</CODE>
</DL>
<P>

The `<TT>scfreg</TT>' tool whose job was to manipulate the monolithic SCF
plugin-registry database, `<TT>scf.cfg</TT>', has been eliminated since it is no
longer required.
</P><P>

<A NAME="SEC862"></A>
<H4> Other SCF Changes </H4>
<!--docid::SEC862::-->
<P>

The macros <CODE>SCF_DESTRUCT_IBASE()</CODE> and <CODE>SCF_DESTRUCT_EMBEDDED_IBASE()</CODE>
have been introduced.  Just as a destructor reverses initialization performed
by a constructor, these new macros reverse the initialization performed by the
corresponding <CODE>SCF_CONSTRUCT_IBASE()</CODE> and
<CODE>SCF_CONSTRUCT_EMBEDDED_IBASE()</CODE> macros.  Typically, you should invoke
these macros within your class' destructor, just as you invoke the
corresponding SCF construction macros in your class' constructor.
</P><P>

The <CODE>SCF_CREATE_INSTANCE()</CODE> macro now returns <CODE>csPtr&#60;&#62;</CODE> to be
consistent with the other SCF instantiation and query macros.  This means
that you should now assign the result of <CODE>SCF_CREATE_INSTANCE()</CODE> to a
<CODE>csRef&#60;&#62;</CODE>.
</P><P>

The method <CODE>iSCF::QueryClassList()</CODE>, which used to return a raw
`<SAMP>iStringArray*</SAMP>' that the client had to dispose of manually, now returns a
<CODE>csRef&#60;iStringArray&#62;</CODE>.
</P><P>

The macros <CODE>SCF_SET_REF()</CODE>, <CODE>SCF_INC_REF()</CODE>, and <CODE>SCF_DEC_REF()</CODE>
have been removed. Instead you should use <CODE>csRef&#60;&#62;</CODE>.
</P><P>

The method <CODE>iSCF::GetInterfaceName(scfInterfaceID)</CODE> has been added to
complement the existing <CODE>iSCF::GetInterfaceID()</CODE>.
</P><P>

The query template class <CODE>scfInterface&#60;&#62;</CODE> has been introduced.  This class
provides a means to query static information about SCF interfaces, such as
an interface's version number.  Presently, this class allows access to the
following static information:
</P><P>

<UL>
<LI>
<CODE>GetID()</CODE>---Retrieves the interface's low-level identifier as an
`<SAMP>scfInterfaceID</SAMP>', which is typically a small integer.  SCF identifies
interfaces internally by an ID for performance reasons.
<P>

<LI>
<CODE>GetName()</CODE>---Retrieves the interface's name as a null-terminated
C-string.
<P>

<LI>
<CODE>GetVersion()</CODE>---Retrieves the interface's current version number.
</UL>
<P>

Here is an example illustrating how to retrieve various pieces of information
about an interface.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>int ver = scfInterface&#60;iFoo&#62;::GetVersion();
scfInterfaceID ident = scfInterface&#60;iFoo&#62;::GetID();
char const* name = scfInterface&#60;iFoo&#62;::GetName();
</pre></td></tr></table></P><P>

An important benefit of the new <CODE>scfInterface&#60;&#62;</CODE> template class is that it
is now possible for template authors to perform queries for interface-related
information.  For example, the author of a new template class may know an
SCF interface via only the opaque identifier <CODE>T</CODE>, yet it is still
possible to query <CODE>T</CODE>'s version using
<CODE>scfInterface&#60;T&#62;::GetVersion()</CODE>.
</P><P>

The old hidden, semi-private API for obtaining interface information via
the global `<SAMP>name_VERSION</SAMP>' constant and global <CODE>name_scfGetID()</CODE>
function has been removed.  Conversion from the old API to the new is
straight forward.  For example:
</P><P>

<UL>
<LI>
<CODE>iFoo_VERSION</CODE> => <CODE>scfInterface&#60;iFoo&#62;::GetVersion()</CODE>
<LI>
<CODE>iFoo_scfGetID()</CODE> => <CODE>scfInterface&#60;iFoo&#62;::GetID()</CODE>
</UL>
<P>

A consequence of this change is that it is no longer possible to invoke the
<CODE>SCF_VERSION()</CODE> macro inside an alternate namespace.  If previously you
were invoking this macro within your project's own namespace, you must relocate
the invocation so that it appears outside the namespace.  For example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;csutil/scf.h&#62;

namespace MyProject
{
  struct iMyInterface : public iBase
  {
    <small>...</small>
  };
}

SCF_VERSION(MyProject::iMyInterface, 1, 0, 0);
</pre></td></tr></table></P><P>

<A NAME="SEC863"></A>
<H3> csSys Library Removed </H3>
<!--docid::SEC863::-->
<P>

The `<TT>cssys</TT>' library has been merged into the `<TT>csutil</TT>' library.  This
eliminates many problems resulting from the large number of circular
dependencies which existed between these two libraries.  From the client
viewpoint, this change manifests in two ways:
</P><P>

<UL>
<LI>
Disappearance of the static link library `<TT>libcssys.a</TT>' (Unix) or
`<TT>cssys.lib</TT>' (Windows).  To account for this change, simply eliminate the
reference to this library from your build scripts, makefiles, or project files.
<P>

<LI>
Disappearance of the `<TT>CS/include/cssys</TT>' directory.  Headers have been
moved to the `<TT>csutil</TT>' include directory.  To account for this change,
simply change <CODE>#include &#60;cssys/header.h&#62;</CODE> to
<CODE>#include &#60;csutil/header.h&#62;</CODE>.
<P>

</UL>
<P>

<A NAME="SEC864"></A>
<H3> csEngine Library Removed </H3>
<!--docid::SEC864::-->
<P>

The `<TT>csengine</TT>' library has been removed.  Direct use of this library has
long been deprecated, so its removal will probably go unnoticed by most or all
projects.  Any projects which were using this library must now instead interact
with the 3D engine via the `<TT>engine</TT>' plugin and the SCF interfaces in
the `<TT>CS/include/iengine</TT>' directory.
</P><P>

<A NAME="SEC865"></A>
<H3> csAppFrame Library Removed </H3>
<!--docid::SEC865::-->
<P>

The `<TT>csappframe</TT>' library has been merged into the `<TT>cstool</TT>' library.
Furthermore, the <CODE>main()</CODE> function, which client application's got for
free when linking against this library, has been removed since it proved to be
an obstacle to making Crystal Space libraries available as <EM>shared</EM>
libraries. Instead, you must now provide your own <CODE>main()</CODE> function, like
this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>// main.cpp
CS_IMPLEMENT_APPLICATION

class MyApp : public csApplicationFramework
{
  /* <small>...</small> */
};

int main (int argc, char* argv[]) 
{
  MyApp myApp;
  return myApp.Main (argc, argv);
}
</pre></td></tr></table></P><P>

<A NAME="SEC866"></A>
<H3> csString and iString Changes </H3>
<!--docid::SEC866::-->
<P>

The <CODE>csString::strlwr()</CODE> method was renamed to <CODE>Downcase()</CODE>.  A
complementary <CODE>Upcase()</CODE> method was added for completeness.  These methods
were also added to `<SAMP>iString</SAMP>'.  A <CODE>Slice()</CODE> method was added to
`<SAMP>iString</SAMP>' and `<SAMP>csString</SAMP>' which copies a sub-portion of a string.
<CODE>Slice()</CODE> is similar to the existing <CODE>SubString()</CODE> method, but
follows a more natural calling convention.  Several `<SAMP>iString</SAMP>' methods
which were incorrectly returning raw `<SAMP>iString*</SAMP>' or `<SAMP>iString&#38;</SAMP>' now
correctly return <CODE>csRef&#60;iString&#62;</CODE>.
</P><P>

`<SAMP>csString</SAMP>' now makes a distinction between a null-string (think
`<SAMP>(char const*)0</SAMP>'), and a zero-length string (think <CODE>""</CODE>).  Client
code can check for these conditions in the normal fashion by invoking
<CODE>csString::GetData()</CODE> or <CODE>operator char const*()</CODE> to retrieve a
C-string representation of the string.  If the result is zero, then it is a
null-string.  If the result is non-zero but <CODE>csString::Length()</CODE> returns
zero, then it is a zero-length string.  The new convenience method
<CODE>csString::GetDataSafe()</CODE> will always return a valid C-string, even if the
underlying `<SAMP>csString</SAMP>' represents a null-string (in which case a
zero-length C-string <CODE>""</CODE> will be returned).  This means that the result
of <CODE>GetDataSafe()</CODE> can be used directly without performing a null check.
</P><P>

In previous releases, `<SAMP>csString</SAMP>' would also sometimes return a null
pointer or a zero-length string from <CODE>csString::GetData()</CODE> or
<CODE>operator char const*()</CODE>, but there was no controlled way to know when one
or the other would be returned since `<SAMP>csString</SAMP>' was doing so haphazardly.
Worse, several of the `<SAMP>csString</SAMP>' methods failed to check the underlying
representation, and would crash if the string's state was not what the methods
expected.  Now, however, `<SAMP>csString</SAMP>' itself makes a proper distinction
between these cases, and the user has direct (and documented) control over when
a `<SAMP>csString</SAMP>' will represent a null-string or a zero-length string.
</P><P>

<A NAME="SEC867"></A>
<H3> csMD5 Changes </H3>
<!--docid::SEC867::-->
<P>

A <CODE>csMD5(csString const&#38;)</CODE> constructor was added to complement the
existing <CODE>csMD5(char const*)</CODE> constructor.  The new method
<CODE>csMD5::Digest:HexString()</CODE> returns a hexadecimal string representation of
the MD5 digest using lowercase hexadecimal characters.
<CODE>csMD5::Digest::HEXString()</CODE> returns uppercase hexadecimal characters.
</P><P>

<A NAME="SEC868"></A>
<H3> Beam Intersection Changes </H3>
<!--docid::SEC868::-->
<P>

<CODE>IntersectSegment()</CODE> for `<SAMP>iThingFactoryState</SAMP>' and `<SAMP>iThingState</SAMP>'
has been removed. Use <CODE>iMeshObject::HitBeamObject()</CODE> instead.
</P><P>

<CODE>iMeshObject::HitBeamObject()</CODE> now has an optional polygon index
parameter so you can get the index of the polygon that was hit.
</P><P>

<CODE>iSector::HitBeam()</CODE> which doesn't support portals now returns a polygon
index instead of a polygon pointer.
</P><P>

<CODE>iSector::HitBeam()</CODE> that supports portals has been renamed
to <CODE>HitBeamPortals()</CODE>. It additionally returns a polygon index.
Same for <CODE>iPortal::HitBeam()</CODE> which has also been renamed
to <CODE>HitBeamPortals()</CODE>.
</P><P>

<CODE>iCamera::GetHit()</CODE> has been removed.  Instead, use the completely
equivalent function <CODE>iSector::HitBeamPortals()</CODE>.
</P><P>

<CODE>iVisibilityCuller::IntersectSegment()</CODE> now returns a polygon index
instead of a portal.
</P><P>

<A NAME="SEC869"></A>
<H3> Directory and Path Queries </H3>
<!--docid::SEC869::-->
<P>

The following low-level functions, declared in `<TT>csutil/syspath.h</TT>' can be
used to query various directories and paths.  Each of these functions expects
to be passed <CODE>argv[0]</CODE> obtained from the program's <CODE>main()</CODE> function.
</P><P>

<DL COMPACT>
<DT><CODE>csGetAppPath()</CODE>
<DD>Returns the absolute path of the application executable file.
<P>

<DT><CODE>csGetAppDir()</CODE>
<DD>Returns the absolute path of the directory containing the application
executable file; or the path of the directory containing the Cocoa application
wrapper on MacOS/X for GUI applications.
<P>

<DT><CODE>csGetResourceDir()</CODE>
<DD>Returns the absolute path of the directory in which the application's resources
reside.  On many platforms, resources, such as configuration files, data files,
etc., reside in the same directory as the application itself.  On such
platforms, this function will typically return the same directory as
<CODE>csGetAppDir()</CODE>.  On MacOS/X, however, for GUI applications, this
function will return the `<TT>Resources</TT>' directory within the Cocoa
application wrapper.
</DL>
<P>

Since it is rarely convenient to squirrel-away <CODE>argv[0]</CODE>, the following
higher-level methods, declared in `<TT>iutil/cmdline.h</TT>', are also available
for obtaining the same information once the application has been initialized.
These methods do not require access to <CODE>argv[0]</CODE>.  You can obtain a handle
to the shared `<SAMP>iCommandLineParser</SAMP>' from the object registry,
`<SAMP>iObjectRegistry</SAMP>', which is declared in `<TT>iutil/objreg.h</TT>'.
</P><P>

<UL>
<LI>
<CODE>iCommandLineParser::GetAppPath()</CODE>
<LI>
<CODE>iCommandLineParser::GetAppDir()</CODE>
<LI>
<CODE>iCommandLineParser::GetResourceDir()</CODE>
</UL>
<P>

<A NAME="SEC870"></A>
<H3> VFS Changes </H3>
<!--docid::SEC870::-->
<P>

VFS (see section <A HREF="cs_159.html#SEC393">7.2 Virtual File System (VFS)</A>) now understands two new pseudo-variables, `<SAMP>$*</SAMP>' and
`<SAMP>$^</SAMP>', in its configuration file, `<TT>vfs.cfg</TT>', and during programmatic
mounts.  The full list of pseudo-variables is:
</P><P>

<DL COMPACT>
<DT><CODE>$/</CODE>
<DD>Platform-specific path delimiter (`<TT>/</TT>' on Unix and MacOS/X; `<TT>\</TT>' on
Windows).
<P>

<DT><CODE>$@</CODE>
<DD>Crystal Space installation directory; same as <CODE>csGetConfigPath()</CODE>.
<P>

<DT><CODE>$*</CODE>
<DD>Application resource directory; same as <CODE>csGetResourceDir()</CODE>.
<P>

<DT><CODE>$^</CODE>
<DD>Directory where application resides, or directory containing Cocoa application
wrapper on MacOS/X; same as <CODE>csGetAppDir()</CODE>.
</DL>
<P>

The expansions of the `<SAMP>$@</SAMP>', `<SAMP>$*</SAMP>', and `<SAMP>$^</SAMP>' variables always
contain a trailing path delimiter.
</P><P>

At initialization time, VFS now searches for its configuration file,
`<TT>vfs.cfg</TT>', in the application resource directory
(<CODE>csGetResourceDir()</CODE>), then in the directory containing the application
(<CODE>csGetAppDir()</CODE>), and finally in the Crystal Space installation directory
(<CODE>csGetConfigPath()</CODE>).  The first `<TT>vfs.cfg</TT>' file found during this
search is the one used to initialize the facility.  In the past, VFS
searched for `<TT>vfs.cfg</TT>' only in the Crystal Space installation directory.
</P><P>

The VFS volume `<TT>/temp</TT>' has been renamed to `<TT>/varia</TT>' in the
default `<TT>vfs.cfg</TT>' file in order to avoid confusion with the like-named
VFS volume `<TT>/tmp</TT>', which represents user-writable temporary storage.
The `<TT>/varia</TT>' volume (n&eacute;e `<TT>/temp</TT>'), on the other hand, resides
within `<TT>${prefix}/etc/crystal</TT>' (where `<TT>${prefix}</TT>' is the
installation location), and this location usually is not writable by the
typical user.  External projects may, of course, still create any VFS
volume desired, including `<TT>/temp</TT>', by supplying a project-specific
`<TT>vfs.cfg</TT>'.
</P><P>

<A NAME="SEC871"></A>
<H3> Internationalization </H3>
<!--docid::SEC871::-->
<P>

Some work to improve internationalization support in Crystal Space has been
performed.  Crystal Space now has more complete support for Unicode input and
output.
</P><P>

<A NAME="SEC872"></A>
<H4> Unicode Helpers </H4>
<!--docid::SEC872::-->
<P>

The `<SAMP>csUnicodeTransform</SAMP>' class provides functions to deal with and convert
between UTF-8, UTF-16, and UTF-32 encoded strings.
</P><P>

<A NAME="SEC873"></A>
<H4> UTF-8 strings </H4>
<!--docid::SEC873::-->
<P>

Several portions of the CrystalSpace API now accept UTF-8-encoded
strings. These include:
</P><P>

<UL>
<LI>
Console
<UL>
<LI>
<CODE>csPrintf()</CODE>
<LI>
<CODE>csPrintfV()</CODE>
<LI><CODE>csFPutErr()</CODE>
</UL>
<LI>
Canvas
<UL>
<LI>
<CODE>iGraphics2D::Write()</CODE>
</UL>
<LI>
Reporter
<UL>
<LI>
<CODE>csReport()</CODE>
<LI>
<CODE>csReportV()</CODE>
<LI>
<CODE>iReporter::Report()</CODE>
<LI>
<CODE>iReporter::ReportV()</CODE>
</UL>
<LI>
Native Window
<UL>
<LI>
<CODE>iNativeWindowManager::Alert()</CODE>
<LI>
<CODE>iNativeWindowManager::AlertV()</CODE>
<LI>
<CODE>iNativeWindow::SetTitle()</CODE>
</UL>
</UL>
<P>

<A NAME="SEC874"></A>
<H3> Keyboard Events </H3>
<!--docid::SEC874::-->
<P>

Keyboard events have changed.  The event data related to keyboard events is no
longer stored in a structure inside `<SAMP>iEvent</SAMP>', but instead now resides
within `<SAMP>iEvent</SAMP>''s property bag.  That means the way to access the event
data has changed slightly; you now either query for the data via
<CODE>iEvent::Find()</CODE> to get a specific property, or you access it via the the
`<SAMP>csKeyEventHelper</SAMP>' class.
</P><P>

Another change is that the `<SAMP>csevKeyDown</SAMP>' and `<SAMP>csevKeyUp</SAMP>' events have
been collapsed to a single `<SAMP>csevKeyboard</SAMP>' event; the up/down information
is transported along with the event data.
</P><P>

The notion of <EM>scan code</EM> and <EM>characters</EM> has been replaced with
<EM>raw</EM> and <EM>cooked</EM> codes.  Basically, the raw code identifies the key
uniquely, while the cooked code is a processed version of it.  An important
aspect of this is that both the raw and cooked codes are Unicode characters.
Special keys (such as function keys) are encoded as characters from a Unicode
private use area.  Almost all event handling code should consult the raw code
because the raw code is invariant; that is, an <KBD>a</KBD> is an `a' even if the
<KBD>ALT</KBD> or <KBD>SHIFT</KBD> key, or both, are depressed.  This is useful for
games, for instance, which need to map keys to particular actions.  Cooked
codes are useful typically only for text input, such as within a text input
field.
</P><P>

You can find additional information in Crystal Space's public API
documentation in the Event Handling and Keyboard Events sections.
</P><P>

To understand how to adjust your code for these changes, see the following
examples.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>iEvent&#38; e = <small>...</small>;
if (e.Type == csevKeyDown &#38;&#38; e.Key.Code == CSKEY_ESC)
{
</pre></td></tr></table></P><P>

Change to:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>if (e.Type == csevKeyboard &#38;&#38;
    csKeyEventHelper::GetEventType(&#38;e) == csKeyEventTypeDown) &#38;&#38;
    csKeyEventHelper::GetCookedCode(&#38;e) == CSKEY_ESC))
{
</pre></td></tr></table></P><P>

Another example:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>iEvent&#38; e = <small>...</small>;
switch (e.Type)
{
  case csevKeyDown:
    Foo();
    break;
  case csevKeyUp:
    Bar();
    break;
}
</pre></td></tr></table></P><P>

Change to:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>switch (e.Type)
{
  case csevKeyboard:
    if (csKeyEventHelper::GetEventType(&#38;e) == csKeyEventTypeDown)
      Foo();
    else
      Bar();
    break;
}
</pre></td></tr></table></P><P>

<A NAME="SEC875"></A>
<H3> iGraphics2D::WriteBaseline() Deprecated </H3>
<!--docid::SEC875::-->
<P>

The functionality provided by <CODE>WriteBaseline()</CODE> is now available by 
specifying the `<SAMP>CS_WRITE_BASELINE</SAMP>' flag when calling 
<CODE>iGraphics2D::Write()</CODE>. Hence, <CODE>WriteBaseline()</CODE> is superfluous and
has been deprecated.
</P><P>

<A NAME="SEC876"></A>
<H3> csInitializer Changes </H3>
<!--docid::SEC876::-->
<P>

<CODE>csInitializer::RequestPlugins(csArray&#60;csPluginRequest&#62;)</CODE> has been added
to complement the existing <CODE>RequestPlugins(...)</CODE> which accepts a variable
number of arguments.  The new overload allows the list of requested plugins to
be composed at run-time, whereas the older variable-argument method required
the list be known at compile-time, which was not always convenient or possible.
</P><P>

<A NAME="SEC877"></A>
<H3> Pollution Reduction  </H3>
<!--docid::SEC877::-->
<P>

The following symbols have been renamed in order to avoid pollution of the
global namespace.
</P><P>

<UL>
<LI>
<CODE>STATIC_CAST()</CODE> => <CODE>CS_STATIC_CAST()</CODE>
<LI>
<CODE>DYNAMIC_CAST()</CODE> => <CODE>CS_DYNAMIC_CAST()</CODE>
<LI>
<CODE>REINTERPRET_CAST()</CODE> => <CODE>CS_REINTERPRET_CAST()</CODE>
<LI>
<CODE>CONST_CAST()</CODE> => <CODE>CS_CONST_CAST()</CODE>
</UL>
<P>

<A NAME="SEC878"></A>
<H3> Texture manager change </H3>
<!--docid::SEC878::-->
<P>

The <CODE>iTextureManager::SetVerbose()</CODE> function has been removed. It
was not useful.
</P><P>

<A NAME="SEC879"></A>
<H3> Font changes </H3>
<!--docid::SEC879::-->
<P>

<CODE>iFont::SetSize()</CODE> has been removed. Instead, the font size is 
supplied when the font is created with <CODE>iFontServer::LoadFont()</CODE>.
This change has been made to fix the problem that multiple LoadFont()
calls were returning the same instance of a font, and thus subsequent calls 
of <CODE>SetSize()</CODE> affected a font globally (e.g. all Arial fonts would
be the same size). The new behaviour is to return only an existing
instance of a font when both the font name and font size match.  If there is
no existing instance with the requested name and size, then a new instance
is created and returned.
</P><P>

Font-related client code, such as the following:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csRef&#60;iFont&#62; font = fontserver-&#62;LoadFont ("myfont.ttf");
font-&#62;SetSize (23);
g2d-&#62;Write (font, <small>...</small>);
</pre></td></tr></table></P><P>

Should be changed to:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csRef&#60;iFont&#62; font = fontserver-&#62;LoadFont ("myfont.ttf", 23);
g2d-&#62;Write (font, <small>...</small>);
</pre></td></tr></table></P><P>

<A NAME="SEC880"></A>
<H3> Mesh flag change </H3>
<!--docid::SEC880::-->
<P>

There is a new flag <CODE>CS_ENTITY_INVISIBLEMESH</CODE> which controls visibility
(and ONLY visibility) of a mesh. There is also a new flag
<CODE>CS_ENTITY_NOHITBEAM</CODE> which controls if calling <CODE>HitBeam()</CODE> will
ever return that mesh. The old <CODE>CS_ENTITY_INVISIBLE</CODE> has been changed
so that it is now a combination of both flags.
</P><P>

An important change is that setting the <CODE>CS_ENTITY_INVISIBLEMESH</CODE> flag
on a parent in a hierarchy will no longer make the children invisible. You
now have to set the invisible flag manually on all children in the hierarchy.
</P><P>

<A NAME="SEC881"></A>
<H3> Skeletal Sprites </H3>
<!--docid::SEC881::-->
<P>

Support for skeletal sprites has been removed, along with the following related
interfaces.  Use the `<SAMP>sprcal3d</SAMP>' mesh object instead.  It is more flexible
and works correctly.  These interfaces have been retired:
</P><P>

<UL>
<LI>
<CODE>iSkeletonState</CODE>
<LI>
<CODE>iSkeletonLimbState</CODE>
<LI>
<CODE>iSkeletonConnection</CODE>
<LI>
<CODE>iSkeletonConnectionState</CODE>
<LI>
<CODE>iSkeletonLimb</CODE>
</UL>
<P>

In addition, the motion manager plugin has been removed, along with the
following related interfaces:
</P><P>

<UL>
<LI>
<CODE>iMotionTemplate</CODE>
<LI>
<CODE>iMotionManager</CODE>
<LI>
<CODE>iSkeletonBone</CODE>
</UL>
<P>

<A NAME="SEC882"></A>
<H3> Skyboxes </H3>
<!--docid::SEC882::-->
<P>

Meshes that use the <CODE>CS_ENTITY_CAMERA</CODE> flag no longer have to be placed
in a render priority that has the `<SAMP>camera</SAMP>' flag set. This render
priority flag is no longer required (but <CODE>CS_ENTITY_CAMERA</CODE> still is!).
</P><P>

<A NAME="SEC883"></A>
<H3> CS_FX_GOURAUD removed </H3>
<!--docid::SEC883::-->
<P>

Gouraud is much more commonly used than flat shading and is thus the default 
now. To achieve the opposite behaviour (ie the behaviour when 
<CODE>CS_FX_GOURAUD</CODE> was not present), use the <CODE>CS_FX_FLAT</CODE> flag.
</P><P>

<A NAME="SEC884"></A>
<H3> Collision Detection Changes </H3>
<!--docid::SEC884::-->
<P>

The most important change is that OPCODE is now prefered over
RAPID. The OPCODE plugin is free of restrictions (as opposed
to RAPID which can't be used in commercial programs), it is faster,
and uses a lot less memory. In future we will remove the RAPID plugin.
</P><P>

The <CODE>iCollideSystem::CollidePath()</CODE> utility method has been relocated to
<CODE>csColliderHelper::CollidePath()</CODE>. In addition there are a few extra
overloads that can make life easier for calculating collisions on a path.
</P><P>

<A NAME="SEC885"></A>
<H3> Isometric Engine </H3>
<!--docid::SEC885::-->
<P>

The isometric engine has been removed.  It was beyond repair.  The
`<SAMP>isotest</SAMP>' application remains, though, and demonstrates how you can
simulate an isometric look with the normal 3D engine.
</P><P>

<A NAME="SEC886"></A>
<H3> Some Plugins Removed </H3>
<!--docid::SEC886::-->
<P>

The following plugins and programs also have been removed (along with any 
parts of the API they provided exclusively), because they are unmaintained
and not currently usable. For more discussion see mailing list posts at:
</P><P>

<A HREF="http://sourceforge.net/mailarchive/message.php?msg_id=8645194">http://sourceforge.net/mailarchive/message.php?msg_id=8645194</A><BR>
<A HREF="http://sourceforge.net/mailarchive/message.php?msg_id=8296024">http://sourceforge.net/mailarchive/message.php?msg_id=8296024</A><BR>
<A HREF="http://sourceforge.net/mailarchive/message.php?msg_id=8296017">http://sourceforge.net/mailarchive/message.php?msg_id=8296017</A><BR>
<A HREF="http://sourceforge.net/mailarchive/message.php?msg_id=8295883">http://sourceforge.net/mailarchive/message.php?msg_id=8295883</A><BR>
</P><P>

<UL>
<LI><CODE>terrbig</CODE> (use new terrain features in the new renderer)
<LI>skeletal sprites (use cal3d)
<LI><CODE>cloth</CODE>
<LI><CODE>cocoa2d</CODE> graphics driver for MacOSX
<LI><CODE>rle</CODE> video codec
<LI><CODE>milk2spr</CODE> (use the cal3d conversion)
<LI><CODE>svgalib</CODE> graphics driver
<LI><CODE>cssocket</CODE> (provided <CODE>iNetworkDriver</CODE>, <CODE>iNetworkListener</CODE>, and <CODE>iNetworkConnection</CODE>)
<LI><CODE>ensocket</CODE> (provided <CODE>iNetworkDriver2</CODE> and <CODE>iNetworkSocket2</CODE>)
<LI><CODE>netman</CODE>
<LI><CODE>picogui</CODE>
</UL>
<P>

<A NAME="Release Notes 96"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_278.html#SEC823"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_280.html#SEC887"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_277.html#SEC822"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_277.html#SEC822"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC962"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC962">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
