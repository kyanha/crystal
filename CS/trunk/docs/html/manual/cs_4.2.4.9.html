<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Crystal Space: 4.2.4.9 AppMazing Main Class</title>

<meta name="description" content="Crystal Space: 4.2.4.9 AppMazing Main Class">
<meta name="keywords" content="Crystal Space: 4.2.4.9 AppMazing Main Class">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Mazing-AppMazing-Class"></a>
<a name="4.2.4.9"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="cs_4.2.4.8.html#4.2.4.8" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="cs_4.3.html#4.3" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="cs_4.html#4." title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="cs_4.2.4.html#4.2.4" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="cs_5.html#5." title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="cs_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="cs_Index.html#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="cs_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 4.2.4.9 AppMazing Main Class </h4>

<p><code>AppMazing</code> is the main application class. Besides the usual Crystal
Space setup code it also contains the game logic.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">class AppMazing :
  public csApplicationFramework, public csBaseEventHandler
{
private:
  /**
   * A reference to the 3D renderer plugin.
   */
  csRef&lt;iGraphics3D&gt; g3d;

  /**
   * A reference to the 3D engine plugin.
   */
  csRef&lt;iEngine&gt; engine;

  /**
   * The main loader.
   */
  csRef&lt;iLoader&gt; loader;

  /**
   * The view.
   */
  csRef&lt;iView&gt; view;

  /**
   * The collision detection system.
   */
  csRef&lt;iCollideSystem&gt; cdsys;

  /**
   * The virtual clock.
   */
  csRef&lt;iVirtualClock&gt; vc;

  /**
   * The factory for our adversary.
   */
  csRef&lt;iMeshFactoryWrapper&gt; adversary_factory;

  /**
   * The factory for our laser beam.
   */
  csRef&lt;iMeshFactoryWrapper&gt; laserbeam_factory;

  /**
   * The factory for our explosion.
   */
  csRef&lt;iMeshFactoryWrapper&gt; explosion_factory;

  /**
   * Set up everything that needs to be rendered on screen.  This routine is
   * called from the event handler in response to a cscmdProcess broadcast
   * message.
   */
  virtual void ProcessFrame();

  /**
   * Finally, render the screen.  This routine is called from the event handler
   * in response to a cscmdFinalProcess broadcast message.
   */
  virtual void FinishFrame();

  /**
   * Handle keyboard events, such as key presses and releases.  This routine is
   * called from the event handler in response to a csevKeyboard event.
   */
  virtual bool OnKeyboard(iEvent&amp;);

  //--- Game Data ------------------------------------------------------

  Player player;
  Maze maze;
  Laser laser;
  /// A list of all adversaries.
  csRefArray&lt;Adversary&gt; adversaries;

  /// A list of all explosions in progress.
  csArray&lt;Explosion&gt; explosions;

  /// Start an explosion.
  void StartExplosion (iSector* sector, const csVector3&amp; pos);
  /// Handle all explosions.
  void HandleExplosions (csTicks elapsed_ticks);

  //--- Setup of Game --------------------------------------------------
  bool CreateFactories ();
  bool CreateAdversary (int x, int y, int z);

  bool InitCollisionDetection ();

  bool SetupGame ();

public:
  /**
   * Constructor.
   */
  AppMazing();

  /**
   * Destructor.
   */
  virtual ~AppMazing();

  iCamera* GetCamera () const { return view-&gt;GetCamera (); }
  iEngine* GetEngine () const { return engine; }
  iLoader* GetLoader () const { return loader; }
  iCollideSystem* GetCollisionDetectionSystem () const { return cdsys; }
  Maze* GetMaze () { return &amp;maze; }

  /**
   * Explode an adversary.
   */
  void ExplodeAdversary (Adversary* adv);

  /**
   * Final cleanup.
   */
  virtual void OnExit();

  /**
   * Main initialization routine.  This routine should set up basic facilities
   * (such as loading startup-time plugins, etc.).  In case of failure this
   * routine will return false.  You can assume that the error message has been
   * reported to the user.
   */
  virtual bool OnInitialize(int argc, char* argv[]);

  /**
   * Run the application.  Performs additional initialization (if needed), and
   * then fires up the main run/event loop.  The loop will fire events which
   * actually causes Crystal Space to &quot;run&quot;.  Only when the program exits does
   * this function return.
   */
  virtual bool Application();
  
  // Declare the name of this event handler.
  CS_EVENTHANDLER_NAMES(&quot;application.mazing&quot;)
      
  /* Declare that we're not terribly interested in having events
     delivered to us before or after other modules, plugins, etc. */
  CS_EVENTHANDLER_NIL_CONSTRAINTS
};
</pre></td></tr></table>
<p>TODO... fill in extra info...
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">CS_IMPLEMENT_APPLICATION

AppMazing::AppMazing() :
	csApplicationFramework(),
	player (this),
	maze (this),
	laser (this)
{
  SetApplicationName(&quot;mazing&quot;);
}

AppMazing::~AppMazing()
{
}

bool AppMazing::CreateFactories ()
{
  csRef&lt;iGeneralFactoryState&gt; fstate;

  //---------------------------------------------------------------------
  // Adversary factory.
  adversary_factory = engine-&gt;CreateMeshFactory (
  	&quot;crystalspace.mesh.object.genmesh&quot;, &quot;adversary&quot;);
  if (!adversary_factory) return false;

  fstate = scfQueryInterface&lt;iGeneralFactoryState&gt; (
  	adversary_factory-&gt;GetMeshObjectFactory ());
  csEllipsoid ellips (
  	csVector3 (0, 0, 0),
	csVector3 (ADVERSARY_DIMENSION, ADVERSARY_DIMENSION,
		ADVERSARY_DIMENSION));
  fstate-&gt;GenerateSphere (ellips, 10);

  if (!loader-&gt;LoadTexture (&quot;adversary_texture&quot;, &quot;/lib/stdtex/misty.jpg&quot;))
    return ReportError (&quot;Error loading 'misty' texture!&quot;);
  iMaterialWrapper* adversary_material = engine-&gt;GetMaterialList ()
  	-&gt;FindByName (&quot;adversary_texture&quot;);
  fstate-&gt;SetMaterialWrapper (adversary_material);

  //---------------------------------------------------------------------
  // Beam factory.
  laserbeam_factory = engine-&gt;CreateMeshFactory (
  	&quot;crystalspace.mesh.object.genmesh&quot;, &quot;laserbeam&quot;);
  if (!laserbeam_factory) return false;

  fstate = scfQueryInterface&lt;iGeneralFactoryState&gt; (
  	laserbeam_factory-&gt;GetMeshObjectFactory ());
  csBox3 laser_box (
  	csVector3 (-LASER_WIDTH, -LASER_WIDTH, 0),
  	csVector3 (LASER_WIDTH, LASER_WIDTH, LASER_LENGTH));
  fstate-&gt;GenerateBox (laser_box);
  fstate-&gt;SetLighting (false);
  fstate-&gt;SetColor (csColor (1.0, 1.0, 1.0));
  // We don't want to hit the player against the laserbeam when it is
  // visible so we disable the collision detection mesh here.
  laserbeam_factory-&gt;GetMeshObjectFactory ()-&gt;GetObjectModel ()
  	-&gt;SetPolygonMeshColldet (0);

  if (!loader-&gt;LoadTexture (&quot;laserbeam_texture&quot;, &quot;/lib/stdtex/blobby.jpg&quot;))
    return ReportError (&quot;Error loading 'blobby' texture!&quot;);
  iMaterialWrapper* laserbeam_material = engine-&gt;GetMaterialList ()
  	-&gt;FindByName (&quot;laserbeam_texture&quot;);
  fstate-&gt;SetMaterialWrapper (laserbeam_material);

  //---------------------------------------------------------------------
  // Beam object.
  csRef&lt;iMeshWrapper&gt; laserbeam = engine-&gt;CreateMeshWrapper (
  	laserbeam_factory, &quot;laserbeam&quot;);
  if (!laserbeam)
    return ReportError (&quot;Error creating laserbeam mesh!&quot;);
  // Set our laser beam to NOHITBEAM so that we can use HitBeam() methods
  // to find out what our laser hits without HitBeam() returning the
  // laser itself.
  laserbeam-&gt;GetFlags ().Set (CS_ENTITY_NOHITBEAM);
  laser.SetMeshWrapper (laserbeam);

  //---------------------------------------------------------------------
  // Explosion factory.
  explosion_factory = engine-&gt;CreateMeshFactory (
  	&quot;crystalspace.mesh.object.particles&quot;, &quot;explosion&quot;);
  if (!explosion_factory) return false;
  csRef&lt;iParticlesFactoryState&gt; pstate = scfQueryInterface&lt;
  	iParticlesFactoryState&gt; (explosion_factory-&gt;GetMeshObjectFactory ());

  if (!loader-&gt;LoadTexture (&quot;explosion_texture&quot;, &quot;/lib/std/spark.png&quot;))
    return ReportError (&quot;Error loading 'spark' texture!&quot;);
  iMaterialWrapper* explosion_material = engine-&gt;GetMaterialList ()
  	-&gt;FindByName (&quot;explosion_texture&quot;);
  pstate-&gt;SetMaterial (explosion_material);
  pstate-&gt;SetParticleRadius (0.2);
  pstate-&gt;SetParticlesPerSecond (50);
  pstate-&gt;SetInitialParticleCount (10);
  pstate-&gt;SetPointEmitType ();
  pstate-&gt;SetRadialForceType (2.0, CS_PART_FALLOFF_LINEAR);
  pstate-&gt;SetForce (6.0);
  pstate-&gt;SetDiffusion (1.0);
  pstate-&gt;SetEmitTime (float (EXPLOSION_EMITTIME) / 1000.0);
  pstate-&gt;SetTimeToLive (float (EXPLOSION_PARTTIME) / 1000.0);
  pstate-&gt;SetTimeVariation (float (EXPLOSION_PARTVARTIME) / 1000.0);
  pstate-&gt;SetConstantColorMethod (csColor4 (1.0, 0.8, 0.5));
  pstate-&gt;SetMixMode (CS_FX_ADD);
  pstate-&gt;EnableZSort (false);

  return true;
}

bool AppMazing::CreateAdversary (int x, int y, int z)
{
  float sx = float (x) * ROOM_DIMENSION;
  float sy = float (y) * ROOM_DIMENSION;
  float sz = float (z) * ROOM_DIMENSION;
  csRef&lt;iMeshWrapper&gt; adversary = engine-&gt;CreateMeshWrapper (adversary_factory,
  	&quot;adversary&quot;, maze.GetSector (x, y, z), csVector3 (sx, sy, sz));
  if (!adversary)
    return ReportError (&quot;Couldn't create adversary mesh!&quot;);

  RoomCoordinate rc (x, y, z);
  Adversary* adv = new Adversary (this, adversary, rc);
  adversaries.Push (adv);
  adversary-&gt;QueryObject ()-&gt;ObjAdd ((iObject*)adv);
  adv-&gt;DecRef ();
  
  return true;
}

bool AppMazing::InitCollisionDetection ()
{
  csColliderHelper::InitializeCollisionWrappers (cdsys, engine, 0);
  return player.InitCollisionDetection ();
}

bool AppMazing::SetupGame ()
{
  if (!maze.CreateGeometry ())
    return ReportError(&quot;Error creating the geometry!&quot;);

  if (!CreateFactories ())
    return ReportError (&quot;Error creating mesh factories!&quot;);

  engine-&gt;Prepare ();

  // Create a view.
  view = csPtr&lt;iView&gt; (new csView (engine, g3d));
  view-&gt;GetCamera ()-&gt;SetSector (engine-&gt;FindSector (&quot;room_0_0_0&quot;));
  view-&gt;GetCamera ()-&gt;GetTransform ().SetOrigin (csVector3 (0, 0, 0));
  iGraphics2D* g2d = g3d-&gt;GetDriver2D ();
  view-&gt;SetRectangle (0, 0, g2d-&gt;GetWidth (), g2d-&gt;GetHeight ());

  if (!InitCollisionDetection ())
    return false;

  if (!CreateAdversary (0, 0, 2)) return false;
  if (!CreateAdversary (1, 1, 1)) return false;
  if (!CreateAdversary (1, 0, 2)) return false;
  if (!CreateAdversary (2, 2, 2)) return false;
  return true;
}

void AppMazing::ExplodeAdversary (Adversary* adv)
{
  iMeshWrapper* mesh = adv-&gt;GetMesh ();
  StartExplosion (mesh-&gt;GetMovable ()-&gt;GetSectors ()-&gt;Get (0),
      	mesh-&gt;GetMovable ()-&gt;GetTransform ().GetOrigin ());
  engine-&gt;RemoveObject (mesh);
  adversaries.Delete (adv);
}

void AppMazing::StartExplosion (iSector* sector, const csVector3&amp; pos)
{
  csRef&lt;iMeshWrapper&gt; explo = engine-&gt;CreateMeshWrapper (explosion_factory,
  	&quot;explosion&quot;, sector, pos);
  if (!explo)
  {
    ReportError (&quot;Error creating explosion mesh!&quot;);
    return;
  }
  explo-&gt;SetZBufMode (CS_ZBUF_TEST);
  Explosion exp (explo, EXPLOSION_TIME);
  explosions.Push (exp);
}

void AppMazing::HandleExplosions (csTicks elapsed_ticks)
{
  size_t i = 0;
  while (i &lt; explosions.Length ())
  {
    if (explosions[i].Handle (elapsed_ticks)) i++;
    else
    {
      engine-&gt;RemoveObject (explosions[i].GetMesh ());
      explosions.DeleteIndex (i);
    }
  }
}

void AppMazing::ProcessFrame()
{
  // First we move the camera.
  csTicks elapsed_time = vc-&gt;GetElapsedTicks ();
  float elapsed_seconds = float (elapsed_time) / 1000.0;

  // Handle the laser.
  laser.Handle (elapsed_time);

  // Handle explosions.
  HandleExplosions (elapsed_time);

  // Move the camera.
  player.MoveAndRotateCamera (elapsed_seconds);

  // Let all the adversaries think about what to do.
  size_t i;
  for (i = 0 ; i &lt; adversaries.Length () ; i++)
    adversaries[i]-&gt;ThinkAndMove (elapsed_seconds);

  // Tell 3D driver we're going to display 3D things.
  if (!g3d-&gt;BeginDraw (engine-&gt;GetBeginDrawFlags () | CSDRAW_3DGRAPHICS))
    return;

  view-&gt;Draw ();
}

void AppMazing::FinishFrame()
{
  g3d-&gt;FinishDraw();
  g3d-&gt;Print(0);
}

bool AppMazing::OnKeyboard(iEvent&amp; ev)
{
  // We got a keyboard event.
  if (csKeyEventHelper::GetEventType(&amp;ev) == csKeyEventTypeDown)
  {
    // The user pressed a key (as opposed to releasing it).
    utf32_char code = csKeyEventHelper::GetCookedCode(&amp;ev);
    switch (code)
    {
      case CSKEY_ESC:
        {
          // The user pressed escape, so terminate the application.  The proper
	  // way to terminate a Crystal Space application is by broadcasting a
          // csevQuit event.  That will cause the main run loop to stop.  To do
          // so we retrieve the event queue from the object registry and then
	  // post the event.
          csRef&lt;iEventQueue&gt; q =
            csQueryRegistry&lt;iEventQueue&gt; (GetObjectRegistry());
          if (q.IsValid())
            q-&gt;GetEventOutlet()-&gt;Broadcast(csevQuit(GetObjectRegistry()));
        }
        return true;
      case 'e':
	player.StartMovement (csVector3 (0, 1, 0));
	return true;
      case 'q':
	player.StartMovement (csVector3 (0, -1, 0));
	return true;
      case 'a':
	player.StartMovement (csVector3 (-1, 0, 0));
	return true;
      case 'd':
	player.StartMovement (csVector3 (1, 0, 0));
	return true;
      case 'w':
	player.StartMovement (csVector3 (0, 0, 1));
	return true;
      case 's':
	player.StartMovement (csVector3 (0, 0, -1));
	return true;
      case CSKEY_UP:
	player.StartRotation (csVector3 (-1, 0, 0));
	return true;
      case CSKEY_DOWN:
	player.StartRotation (csVector3 (1, 0, 0));
	return true;
      case CSKEY_LEFT:
	player.StartRotation (csVector3 (0, -1, 0));
	return true;
      case CSKEY_RIGHT:
	player.StartRotation (csVector3 (0, 1, 0));
	return true;
      case ' ':
	laser.Start ();
	return true;
    }
  }
  return false;
}

bool AppMazing::OnInitialize(int argc, char* argv[])
{
  iObjectRegistry* r = GetObjectRegistry();

  // Load application-specific configuration file.
  if (!csInitializer::SetupConfigManager(r, 0, GetApplicationName()))
    return ReportError(&quot;Failed to initialize configuration manager!&quot;);

  // RequestPlugins() will load all plugins we specify.  In addition it will
  // also check if there are plugins that need to be loaded from the
  // configuration system (both the application configuration and CS or global
  // configurations).  It also supports specifying plugins on the command line
  // via the --plugin= option.
  if (!csInitializer::RequestPlugins(r,
	CS_REQUEST_VFS,
	CS_REQUEST_OPENGL3D,
	CS_REQUEST_ENGINE,
	CS_REQUEST_FONTSERVER,
	CS_REQUEST_IMAGELOADER,
	CS_REQUEST_LEVELLOADER,
        CS_REQUEST_PLUGIN (&quot;crystalspace.collisiondetection.opcode&quot;,
		iCollideSystem),
	CS_REQUEST_REPORTER,
	CS_REQUEST_REPORTERLISTENER,
	CS_REQUEST_END))
    return ReportError(&quot;Failed to initialize plugins!&quot;);

  // &quot;Warm up&quot; the event handler so it can interact with the world
  csBaseEventHandler::Initialize(r);
 
  // Set up an event handler for the application.  Crystal Space is fully
  // event-driven.  Everything (except for this initialization) happens in
  // response to an event.
  if (!RegisterQueue (r, csevAllEvents(GetObjectRegistry())))
    return ReportError(&quot;Failed to set up event handler!&quot;);

  return true;
}

void AppMazing::OnExit()
{
}

bool AppMazing::Application()
{
  iObjectRegistry* r = GetObjectRegistry();

  // Open the main system. This will open all the previously loaded plugins
  // (i.e. all windows will be opened).
  if (!OpenApplication(r))
    return ReportError(&quot;Error opening system!&quot;);

  // Now get the pointer to various modules we need.  We fetch them from the
  // object registry.  The RequestPlugins() call we did earlier registered all
  // loaded plugins with the object registry.  It is also possible to load
  // plugins manually on-demand.
  g3d = csQueryRegistry&lt;iGraphics3D&gt; (r);
  if (!g3d)
    return ReportError(&quot;Failed to locate 3D renderer!&quot;);

  engine = csQueryRegistry&lt;iEngine&gt; (r);
  if (!engine)
    return ReportError(&quot;Failed to locate 3D engine!&quot;);

  loader = csQueryRegistry&lt;iLoader&gt; (r);
  if (!loader)
    return ReportError(&quot;Failed to locate the map loader!&quot;);

  cdsys = csQueryRegistry&lt;iCollideSystem&gt; (r);
  if (!cdsys)
    return ReportError(&quot;Failed to locate the collision detection system!&quot;);

  vc = csQueryRegistry&lt;iVirtualClock&gt; (r);
  if (!vc)
    return ReportError(&quot;Failed to locate the virtual clock!&quot;);

  // Setup game.
  if (!SetupGame ())
    return false;

  // Start the default run/event loop.  This will return only when some code,
  // such as OnKeyboard(), has asked the run loop to terminate.
  Run();

  return true;
}

int main(int argc, char** argv)
{
  csPrintf (&quot;mazing version 1.0 by Jorrit Tyberghein.\n&quot;);

  /* Runs the application.  
   *
   * csApplicationRunner&lt;&gt; cares about creating an application instance 
   * which will perform initialization and event handling for the entire game. 
   *
   * The underlying csApplicationFramework also performs some core 
   * initialization.  It will set up the configuration manager, event queue, 
   * object registry, and much more.  The object registry is very important, 
   * and it is stored in your main application class (again, by 
   * csApplicationFramework). 
   */
  return csApplicationRunner&lt;AppMazing&gt;::Run (argc, argv);
}
</pre></td></tr></table>
<p>TODO... fill in extra info...
</p>


<hr size="1">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="cs_4.2.4.8.html#4.2.4.8" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="cs_4.3.html#4.3" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="cs_4.html#4." title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="cs_4.2.4.html#4.2.4" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="cs_5.html#5." title="Next chapter"> &gt;&gt; </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
