<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Crystal Space: 4.2.1.3 Creating a &ldquo;World&rdquo;</title>

<meta name="description" content="Crystal Space: 4.2.1.3 Creating a &ldquo;World&rdquo;">
<meta name="keywords" content="Crystal Space: 4.2.1.3 Creating a &ldquo;World&rdquo;">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Simple-World"></a>
<a name="0"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="Simple-Event-Handling.html#0" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="Simple-Camera.html#0" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="Using-Crystal-Space.html#0" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="Tutorial-Simple.html#0" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="Working-with-Engine-Content.html#0" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="cs_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="cs_Index.html#0" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="cs_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<hr size="1">
<h4 class="subsubsection"> 4.2.1.3 Creating a &ldquo;World&rdquo; </h4>

<p>Now we have a very exciting application which opens a black window and waits
for the <kbd>ESC</kbd> key to quit.  We assume this is the application you always
wanted to have?  No?  Ok then, let's create some 3D stuff.
</p>
<p>We'll add a texture manager, a room (technically called a
<em>sector</em>) and some lights.  First, add a pointer to our main
sector and a function <code>CreateRoom()</code> to the <samp>&lsquo;Simple&rsquo;</samp> class
header file:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">...
struct iSector;
...
class Simple
{
private:
  ...
  iSector* room;
  float rotX, rotY;
  ...
  void CreateRoom ();
  ...
</pre></td></tr></table>
<p>Now add these chunks of code (texture manager, room, lights) to
<tt>&lsquo;simple.cpp&rsquo;</tt>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">bool Simple::Application ()
{
  ...
  // First disable the lighting cache. Our app is simple enough
  // not to need this.
  engine-&gt;SetLightingCacheMode (0);
  ...
  // These are used store the current orientation of the camera.
  rotY = rotX = 0;
  ...
  CreateRoom ()
  ...
}
...
void Simple::CreateRoom ()
{
  // Load the texture from the standard library.  This is located in
  // CS/data/standard.zip and mounted as /lib/std using the Virtual
  // File System (VFS) plugin.
  if (!loader-&gt;LoadTexture (&quot;stone&quot;, &quot;/lib/std/stone4.gif&quot;))
    ReportError(&quot;Error loading 'stone4' texture!&quot;);

  iMaterialWrapper* tm =
    engine-&gt;GetMaterialList ()-&gt;FindByName (&quot;stone&quot;);

  room = engine-&gt;CreateSector (&quot;room&quot;);
  csRef&lt;iMeshWrapper&gt; walls (
    engine-&gt;CreateSectorWallsMesh (room, &quot;walls&quot;));
  iMeshObject* walls_object = walls-&gt;GetMeshObject ();
  iMeshObjectFactory* walls_factory = walls_object-&gt;GetFactory();
  csRef&lt;iThingFactoryState&gt; walls_state = 
    scfQueryInterface&lt;iThingFactoryState&gt; (walls_factory);
  walls_state-&gt;AddInsideBox (
    csVector3 (-5, 0, -5), csVector3 (5, 20, 5));
  walls_state-&gt;SetPolygonMaterial (CS_POLYRANGE_LAST, tm);
  walls_state-&gt;SetPolygonTextureMapping (CS_POLYRANGE_LAST, 3);

  csRef&lt;iLight&gt; light;
  iLightList* ll = room-&gt;GetLights ();

  light = engine-&gt;CreateLight (0, csVector3 (-3, 5, 0), 10,
        csColor (1, 0, 0));
  ll-&gt;Add (light);

  light = engine-&gt;CreateLight (0, csVector3 (3, 5,  0), 10,
        csColor (0, 0, 1));
  ll-&gt;Add (light);

  light = engine-&gt;CreateLight (0, csVector3 (0, 5, -3), 10,
        csColor (0, 1, 0));
  ll-&gt;Add (light);

  engine-&gt;Prepare ();
}
</pre></td></tr></table>
<p>This extra code first loads a texture with <code>LoadTexture()</code>.
The first parameter is the name of the texture as it will be known in the
engine; and the second is the
actual filename on the <small>VFS</small> volume (see section <a href="VFS.html#0">Virtual File System (<small>VFS</small>)</a>).  Note, if you don't have
the <tt>&lsquo;stone4.gif&rsquo;</tt> texture you can use another one.  The only requirement
is that it must have sizes which are a power of 2 (e.g. 64x64); note that
Crystal Space will scale them automatically if this requirement is not met
but this can
reduce quality. This function returns a <samp>&lsquo;iTextureWrapper&rsquo;</samp> which we
don't use.  Instead we use the <samp>&lsquo;iMaterialWrapper&rsquo;</samp> which is created
automatically by <code>LoadTexture()</code>.
</p>
<p>Then, we create our room with <code>CreateSector()</code>.  This room will initially
be empty.  A room in Crystal Space is represented by <samp>&lsquo;iSector&rsquo;</samp> which is
basically a container which can hold geometrical objects. Objects
in Crystal Space are represented by <em>mesh objects</em> (see section <a href="MeshObject.html#0">Mesh Object Plug-In System</a>).
There are several types of mesh objects in Crystal Space. Every type of
mesh object represents some different way to represent geometry. In this
tutorial we are only going to use the &ldquo;thing&rdquo; mesh object type. This mesh
object type is very useful for walls of indoor maps or buildings.
</p>
<p>Now, we want to create the six walls of our room. First, we make our thing mesh
object. Because this is a very common case there is a convenience function
in the engine (called <code>CreateSectorWallsMesh()</code>) which will create a
thing mesh and add it to the given sector. The only thing that has to be
done after this is add polygons to that mesh. The geometry of a mesh is 
generally stored in its <em>factory</em>, thus we need to obtain an interface
to the &ldquo;thing&rdquo; factory.
</p>
<p>To do this we first need to obtain the interface to the <samp>&lsquo;iMeshObject&rsquo;</samp>
interface. The <samp>&lsquo;iMeshWrapper&rsquo;</samp> interface, as returned by 
<code>CreateSectorWallsMesh()</code>, has a method <code>GetMeshObject()</code> which
gives us just that.
</p>
<p>In the next step, we need to query the <em>mesh factory</em>. Again, the 
previously obtained <samp>&lsquo;iMeshObject&rsquo;</samp> has a method which returns an interface
to the mesh factory.
</p>
<p>And lastly, to obtain the interface to control &ldquo;thing&rdquo;-specific aspects of
the mesh factory, we query the interface called <samp>&lsquo;iThingFactoryState&rsquo;</samp> 
from the mesh factory interface.
We use the function <code>scfQueryInterface&lt;&gt;()</code> which is part of <small>SCF</small>
(see section <a href="SCF.html#0">Shared Class Facility (<small>SCF</small>)</a>). This will see if the mesh factory actually implements 
<samp>&lsquo;iThingFactoryState&rsquo;</samp> (which should be the case here) and, if so, it will 
return a pointer to the implementation of <samp>&lsquo;iThingFactoryState&rsquo;</samp>. 
All mesh objects and factories implement some kind of state interface which is 
used to set up or query the state of that mesh object or factory.
Note that all interfaces which you query using <code>scfQueryInterface&lt;&gt;()</code>
must be assigned to a variable of type <code>csRef&lt;&gt;</code>. This ensures that the
reference to the interface is released once it is no longer needed.
</p>
<p>We now have the factory state (<samp>&lsquo;iThingFactoryState&rsquo;</samp>) which we can now use 
to create polygons. There are various functions to create individual polygons, 
if you want that, but in this case we use a convenience function to create a 
box that can be seen from the inside. That will serve as the walls of our room.
The <code>AddInsideBox()</code> function does this. It will create six polygons
arranged so that they are visible from inside.
(Note that in Crystal Space a polygon is visible if vertices are oriented
clock-wise). The box coordinates given to <code>AddInsideBox()</code> are in object
space (in contrast with world space and camera space).
</p>
<p>The <code>SetPolygonMaterial()</code> function will set the material of the
polygons. The first parameter is a range. We use <samp>&lsquo;CS_POLYRANGE_LAST&rsquo;</samp>
here to indicate that we are interested in setting the materials of the last
created polygons (i.e. all polygons created with <code>AddInsideBox()</code>).
</p>
<p>The texture is mapped onto the polygon using <code>SetPolygonTextureMapping()</code>.
There are several versions of this function.  The one we use in this tutorial
is one of the simplest but it offers the least control.  In this particular
case we take the first two vertices of each polygon that was created for the
box and use that as the u-axis of the texture.  The v-axis will be calculated
perpendicular to the u-axis.  The 3rd parameter indicates that the texture will
be scaled so that one texture tile is exactly 3x3 world units in size.
</p>
<p>Finally, we create some lights in our room to make sure that we actually are
able to see the walls.  The interface <samp>&lsquo;iLight&rsquo;</samp> represents a light.
In this case we created some static lights which can not move and change
intensity.  We create three such lights
and add them to the room with <code>AddLight()</code>. Note that the list of lights
in a sector is represented by an object implementing <samp>&lsquo;iLightList&rsquo;</samp>. To
get this list you call <code>iSector::GetLights()</code>.
</p>
<p>When creating a light we use several parameters.
First we have the name of the light. This is not used
often and mostly you can set this to 0. The second parameter is
the location of the light in the world. Then follows a radius. The light will
not affect polygons which are outside the sphere described by the center of
the light and the radius.  The next parameter is the color of the light in
<small>RGB</small> format (&lt;1,1,1&gt; means white and &lt;0,0,0&gt; means black).
The last parameter indicates whether or not we want to have a pseudo-dynamic
light.  A pseudo-dynamic light still cannot move but it can change intensity.
There are some performance costs associated with pseudo-dynamic lights so
it is not enabled by default.
</p>
<p>The call to <code>Prepare()</code> prepares the engine for rendering your scene.  It
will prepare all textures and create all lightmaps if needed.  Only after this
call can you start rendering your world, because lightmaps may have to be
converted to a format more suitable for the chosen 3D renderer.
</p>
<p>Ok, now we have created our room and properly initialized it.  If you
compile and run this application you would still see a black screen.  Why?
Because we have not created a camera through which you can view the room.
</p>
<hr size="1">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="Simple-Event-Handling.html#0" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="Simple-Camera.html#0" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="Using-Crystal-Space.html#0" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="Tutorial-Simple.html#0" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="Working-with-Engine-Content.html#0" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="cs_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="cs_Index.html#0" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="cs_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
