<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on April, 18 2005 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Crystal Space: 6.2.2 Using SCF</title>

<meta name="description" content="Crystal Space: 6.2.2 Using SCF">
<meta name="keywords" content="Crystal Space: 6.2.2 Using SCF">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="SCF-Using"></a>
<a name="SEC363"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="cs_6.2.1.html#SEC362" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="cs_6.2.3.html#SEC364" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="cs_6.html#SEC357" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="cs_6.2.html#SEC361" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="cs_7.html#SEC378" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="cs_SEC_Top.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="cs_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="cs_SEC987.html#SEC987" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="cs_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 6.2.2 Using <small>SCF</small> </h3>

<p>The only include header file you need to include to utilize <small>SCF</small>
functionality is <tt>`scf.h'</tt>.  It contains a number of macros and functions
that you will need for easier use of <small>SCF</small>.
</p>
<p>Much basic functionality of <small>SCF</small> is provided by a central object.  It can
be accessed as <samp>`iSCF::SCF'</samp> and is of type <samp>`iSCF*'</samp> (which is also a
valid <small>SCF</small> interface).  This object is global and can be accessed from
<em>anywhere</em>, even from dynamic libraries (plugin modules).  It is used by
several parts of <small>SCF</small>.  Note that this object is only available after
calling <code>scfInitialize()</code>, the main initialization function of <small>SCF</small>.
In typical use, howerver, you rarely need to interact directly with
<samp>`iSCF::SCF'</samp>.  Instead, you invoke several convenient <small>SCF</small> macros which
interact with <samp>`iSCF::SCF'</samp> on your behalf.
</p>
<p>All <small>SCF</small> classes should be derived from the basic interface <samp>`iBase'</samp>.
This interface declares the bare minimum set of methods which all <small>SCF</small>
classes should provide:
</p>
<dl compact="compact">
<dt> <code>void IncRef()</code></dt>
<dd><p>This function should be called each time you get a new reference to a object
and store it for a long-time usage.  Rather than invoking this method manually,
you can use a smart-pointer to automate reference counting
(see section <a href="cs_5.8.1.html#SEC218">Correctly Using Smart Pointers</a>).
</p>
</dd>
<dt> <code>void DecRef()</code></dt>
<dd><p>Call this function to decrement the object's reference count.  When the
reference count reaches zero, the object is deleted automatically, provided
that it is not an interface embedded within another object,
<a href="cs_6.2.3.html#SCF-Embedded-Interfaces">SCF Embedded Interfaces</a>.  There should be one matching <code>DecRef()</code>
for each <code>IncRef()</code> invocation.
</p>
</dd>
<dt> <code>void AddRefOwner(iBase**)</code></dt>
<dd><p>Call this function to set up a <em>weak reference</em> to the object .  A weak
reference is one which is invalidated automatically when the referenced object
is destroyed.  This is useful in cases when some object wants to hold a pointer
to an <small>SCF</small> object without actually owning a reference to the <small>SCF</small>
object.  Owning a reference prevents the <small>SCF</small> object from being destroyed,
whereas holding a weak reference merely says that you are interested in this
object as long as it is alive, but that you don't want to forcibly keep it
alive.  The argument to this method is a pointer to a variable which can hold a
pointer to an <small>SCF</small> object.  Rather than invoking this method manually, you
typically would use a weak-reference template to automate the reference
management (<tt>`CS/include/csutil/weakref.h'</tt>).
</p>
</dd>
<dt> <code>void RemoveRefOwner(iBase**)</code></dt>
<dd><p>Call this function to remove a weak reference to the object.
</p>
</dd>
<dt> <code>iBase* QueryInterface(scfInterfaceID InterfaceID, int Version); This</code></dt>
<dd><p>method will return a pointer to an interface or to an embedded interface,
(see <a href="cs_6.2.3.html#SCF-Embedded-Interfaces">SCF Embedded Interfaces</a>).  The <em>Interface ID</em> is synonymous to
the name of the interface.  In previous versions of <small>SCF</small> this method used
to accept a string containing the name of the interface.  This has been
replaced by the <em>ID</em> for performance reasons.  You can get the <small>ID</small> of
an interface by invoking <code>iSCF::SCF-&gt;GetInterfaceID(name)</code>.
</p></dd>
</dl>

<p>To simplify things even further, <tt>`scf.h'</tt> provides several macros that
provide default declarations and default implementations of these
methods.  The <samp>`SCF_DECLARE_IBASE'</samp> macro will declare these methods
within any class definition that is derived from <samp>`iBase'</samp>.  The
<code>SCF_IMPLEMENT_IBASE()</code> macro will add the default implementation of these
methods to your module.  Finally, the <code>SCF_IMPLEMENT_FACTORY()</code> macro will
implement the factory function for your class which returns new instances of
the class to callers.
</p>
<p>Example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">// Abstract interface file (itest.h)
struct iTest : public iBase
{
  &hellip;
};

// Concrete implementation header (test.h)
class Test : public iTest
{
public:
  SCF_DECLARE_IBASE;
};

// Concrete implementation source (test.cpp)
SCF_IMPLEMENT_FACTORY(Test)

SCF_IMPLEMENT_IBASE(Test)
</pre></td></tr></table>
<p>In reality, we need a few more macros because the <code>QueryInterface()</code>
function is not static--it depends upon the interfaces implemented by given
object.  In fact, <code>SCF_IMPLEMENT_IBASE()</code> defines <code>IncRef()</code>,
<code>DecRef()</code>, <code>AddRefOwner()</code>, <code>RemoveRefOwner()</code>, and the
beginning of the <code>QueryInterface()</code> function, but not the end of that
function (i.e. the closing brace).  That's because you have to use an
additional macro called <code>SCF_IMPLEMENTS_INTERFACE()</code> which will add the
code required to support all implemented interface inside
<code>QueryInterface()</code>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">SCF_IMPLEMENT_FACTORY(Test)

SCF_IMPLEMENT_IBASE(Test)
  SCF_IMPLEMENTS_INTERFACE(iTest)
SCF_IMPLEMENT_IBASE_END
</pre></td></tr></table>
<p>The <code>SCF_DECLARE_IBASE()</code> macro also defines a few member variables:
<samp>`scfRefCount'</samp>, <samp>`scfWeakRefOwners'</samp>, and <samp>`scfParent'</samp>.
<samp>`scfRefCount'</samp> is the accumulator for external references to this object
and is used by <code>IncRef()</code> and <code>DecRef()</code> methods.
<code>scfWeakRefOwners</code> maintains the list of weak reference owners, if any.
The <samp>`scfParent'</samp> variable points to the parent object, if any, and is also
used by <code>IncRef()</code> and <code>DecRef()</code>.  Objects are chained together in a
tree-like fashion, and an call to <code>IncRef()</code> will also call
<code>scfParent-&gt;IncRef()</code>; same with <code>DecRef()</code>.  The root of the chain
is the class factory, that is, an object that is used to create objects of a
specific class.  The object tree looks like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">ClassFactory
    &rArr; Object
        &rArr; Embedded interface
        &rArr; Embedded interface
            &rArr; Sub-embedded interface
</pre></td></tr></table>
<p>Thus, if we call the <code>IncRef()</code> method for <em>Sub-embedded interface</em>,
we also will increment reference count for <em>Object</em> and
<em>ClassFactory</em>.
</p>
<p>You also should call <code>SCF_CONSTRUCT_IBASE(<var>parent</var>)</code> inside your class
constructor, this macro will initialize <samp>`scfRefCount'</samp> to zero and
<samp>`scfParent'</samp> to <var>parent</var>.  The constructor of many <small>SCF</small> classes
should receive at least one argument of type <samp>`iBase*'</samp>, which it should
pass along to the <code>SCF_CONSTRUCT_IBASE()</code> macro.  It is also valid to
specify <samp>`NULL'</samp> as the parent if the instance should have no parent.
Likewise, you should call <code>SCF_DESTRUCT_IBASE()</code> inside your class
destructor.  This will reverse the initialization performed by the
corresponding <code>SCF_CONSTRUCT_IBASE()</code> invocation.
</p>
<hr size="1">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="cs_6.2.1.html#SEC362" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="cs_6.2.3.html#SEC364" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="cs_6.html#SEC357" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="cs_6.2.html#SEC361" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="cs_7.html#SEC378" title="Next chapter"> &gt;&gt; </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
