<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: SCF Explained</TITLE>

<META NAME="description" CONTENT="Crystal Space: SCF Explained">
<META NAME="keywords" CONTENT="Crystal Space: SCF Explained">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC360"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_139.html#SEC359"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_141.html#SEC361"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_136.html#SEC356"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_139.html#SEC359"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_150.html#SEC375"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC957">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 6.2.1 How it Works </H3>
<!--docid::SEC360::-->
<P>

This section contains technical details about SCF. If you're not
interested in details, you can skip directly to the next section which
explains how SCF should be used from the end-user's point of view.
</P><P>

SCF is somewhat similar to COM. This is because historically
Crystal Space initially used COM for inter-module communication. Thanks
to Dan Ogles for the initial implementation of a cross-platform COM
library; his implementation was a good test-bed for this SCF
implementation.
</P><P>

The differences between COM and SCF are due to the increased need for
an easier-to-use and more lightweight mechanism than COM.  The COM
implementation caused some problems (because of historic bugs in EGCS
1.1.x and incompatibilities with platforms to which Crystal Space has ported).
Also it has some problems due to the native Windows types used in COM;
this experience was taken into account while developing SCF.
</P><P>

The main paradigm of SCF, as in COM/CORBA/Java/etc. is the
<EM>interface</EM>.  You define an <EM>interface</EM>, that is, a set of abstract
methods that you want to access within some object.  SCF interfaces are
plain C++ structs (or classes, it doesn't matter much except that if you're
using classes to which you will have to add the `<SAMP>public:</SAMP>' keyword).
Theoretically, interfaces can contain member variables and inline methods
(though not non-virtual methods or constructors), <EM>but</EM> this practice is
not encouraged because later someone may want to add a COM, CORBA,
etc.  layer between the client and the actual object, and this will not be
possible if the interfaces contains variables, inline methods, or non-virtual
methods.  If you don't plan to use COM or CORBA later, then you can
use variables and inline functions as much as you like in your own code, but
their use in Crystal Space code is highly discouraged.
</P><P>

Here is an example of an interface in a file named `<TT>idog.h</TT>':
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>struct iDog
{
  virtual bool IsAlive() = 0;
  virtual char const* GetName() = 0;
  virtual void SetName (char const*) = 0;
  virtual void Shout(int Volume) = 0;
  virtual void Run(int Speed, float Direction) = 0;
  virtual bool GetChildren(iObjVector* oBrood) = 0;
};
</pre></td></tr></table></P><P>

Note the last method that gets a pointer of `<SAMP>iObjVector</SAMP>' type.
`<SAMP>iObjVector</SAMP>' is yet another interface.  We could pass a pointer to a
`<SAMP>csObjVector</SAMP>' (the implementation of that interface) as well, but this
will mean both modules (caller and callee) should have same idea about what a
`<SAMP>csObjVector</SAMP>' is, and if it happened that you compiled the shared library
with a slightly different version of `<SAMP>csObjVector</SAMP>' (that, say, had one
member variable fewer) you will end up with a SIGSEGV crash.  By instead
specifying the abstract `<SAMP>iObjVector</SAMP>', there is no need to link the
`<SAMP>csObjVector</SAMP>' class into both the caller and the callee.
</P><P>

Now let's write a particular <EM>implementation</EM> of the above interface.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include "idog.h"

class MyDog : public iDog
{
private:
  // private member functions &#38; variables <small>...</small>
  char* Name;
public:
  virtual bool IsAlive();
  virtual char const* GetName();
  virtual void SetName(char const*);
  virtual void Shout(int Volume);
  virtual void Run(int Speed, float Direction);
  virtual bool GetChildren(iObjVector* oBrood);
  <small>...</small> public member functions &#38; variables <small>...</small>
};

bool MyDog::IsAlive()
{
  return true;
};

char const* MyDog::GetName()
{
  return Name;
}

void MyDog::SetName(char const* NewName)
{
  if (Name != 0)
    free (Name);
  Name = strcpy (NewName);
}

// And so on <small>...</small>
</pre></td></tr></table></P><P>

Now, we put the actual implementation into a separate module (i.e. into a
shared library), and include within the client just the interface file
`<TT>idog.h</TT>'. Since the client does not have any idea how we should build
an object of the `<SAMP>MyDog</SAMP>' class, we also provide a function that will
return a newly-allocated object of that class. This is called the
<EM>class factory</EM> (in fact, a class factory is a bit more than just this,
but more about this later). Here is how to do it:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>static iDog* MyDog_Create()
{
  return new MyDog();
}
</pre></td></tr></table></P><P>

Okay, we did it. Now back to the client. To work with an object that
implements the `<SAMP>iDog</SAMP>' interface we need to load the shared library, get
a pointer to the <CODE>MyDog_Create()</CODE> function, call it and get a new
`<SAMP>MyDog</SAMP>' object. Further we work with this pointer as if it were pointing
to an `<SAMP>iDog</SAMP>' object:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>csLibraryHandle handle = csLoadLibrary("./libdog.so");
iDog (*iDog_Create)() = csGetLibrarySymbol(handle, "MyDog_Create");
iDog* dog = iDog_Create();
printf("Doggy's name is %s\n", dog-&#62;GetName());
dog-&#62;Shout(100);
<small>...</small>
</pre></td></tr></table></P><P>

Of course, you don't have to do all this stuff manually with the SCF
implementation. The SCF library provides a number of useful macros and
functions which hide these ugly implementation details from end-user.
</P><P>

<A NAME="SCF Using"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_139.html#SEC359"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_141.html#SEC361"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_136.html#SEC356"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_139.html#SEC359"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_150.html#SEC375"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_286.html#SEC957">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
