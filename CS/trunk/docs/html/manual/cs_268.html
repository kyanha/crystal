<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HTML>
<HEAD>
<TITLE>Crystal Space: MacOS/X Cocoa Video Optimization</TITLE>

<META NAME="description" CONTENT="Crystal Space: MacOS/X Cocoa Video Optimization">
<META NAME="keywords" CONTENT="Crystal Space: MacOS/X Cocoa Video Optimization">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC802"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_267.html#SEC801"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_269.html#SEC803"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_264.html#SEC798"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_265.html#SEC799"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_271.html#SEC805"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_292.html#SEC943">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H4> 8.1.1.3 Cocoa Video Optimization </H4>
<!--docid::SEC802::-->
<P>

This section describes video optionization techniques which have been
implemented for the high-level Cocoa-based 2D driver.  This discussion does not
pertain to the OpenGL or CoreGraphics drivers.
</P><P>

The OpenGL renderer provides the best video performance when
hardware-acceleration is available.  When it is not available, the software
renderer coupled with the CoreGraphics driver provides the next best solution.
As a fallback option there is also a pure Cocoa-based driver which restricts
itself to very high-level Cocoa API.  Since the Cocoa-based driver does
not employ lower-level facilities, such as OpenGL or CoreGraphics, it is slower
than those alternatives but it is also more likely to function correctly in
unexpected configurations or in the unusual event that the other two drivers
can not be used.  The pure Cocoa driver is used together with the software
renderer, but only when requested explicitly with the command-line option
`<SAMP>--canvas=crystalspace.graphics2d.cocoa</SAMP>'.  It is never used by default.
Alternately, it can be requested via a Cocoa <EM>defaults</EM> setting.  For
example, to force all applications to use this canvas, you could invoke the
following command from the command-line:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>defaults write CrystalSpace.Global Video.Software.Canvas \
  crystalspace.graphics2d.cocoa
</pre></td></tr></table></P><P>

The Cocoa-based graphics driver had its origins on the NextStep operating
system using slow NeXT hardware which was not specially optimized for
game-level graphics performance.  Most of the optimizations employed in this
driver are based upon characteristics of NeXT hardware and are thus probably
not terribly relevant to today's hardware.
</P><P>

Unlike programs on some other platforms, NextStep and OpenStep applications did
not have direct access to the display hardware (except via the highly private
"Interceptor" API), therefore achieving reasonable video performance was
a challenge.  The YellowBox API featured in MacOS/X Server 1.0 (Rhapsody)
saw the introduction of the `<SAMP>NSDirectBitmap</SAMP>', `<SAMP>NSDirectPalette</SAMP>', and
`<SAMP>NSDirectScreen</SAMP>' classes which were intended to allow lower-level access
to the display hardware, however their interfaces were not fully developed at
that time, and were thus mostly unusable.  Only with the advent of MacOS/X has
access to hardware-level acceleration become possible with the introduction of
the public CoreGraphics and OpenGL APIs.
</P><P>

With the high-level Cocoa-based driver all drawing to the display is performed
by a separate program called the <EM>WindowServer</EM>.  Whenever an applications
needs to draw to the screen, it actually sends drawing commands across an
IPC connection to the WindowServer, and the WindowServer performs the
drawing on the application's behalf.  This negatively impacts video performance
in essentially three ways.
</P><P>

<UL>
<LI>
Inter-process communication (IPC) between the application and the
WindowServer is performed serially and tends to be a bottle-neck.  Furthermore,
IPC is generally slower than direct memory access.
<P>

<LI>
Image data resides in different address spaces since the application and
WindowServer are separate processes.  This means that the image data must
somehow be copied from one address space to the other.  Copying large amounts
of data is typically very time-consuming.
<P>

<LI>
Since the application does not own the frame-buffer, it also does not have
access to the frame-buffer's data format.  This means that after receiving the
image data, the WindowServer generally has to rearrange it so that it matches
the format of the frame-buffer.  This can be a particularly time-consuming
operation since it may require quite a lot of bit-fiddling over quite a lot of
bytes.  For instance, the application may supply image data in the format
RRRRGGGGBBBBAAAA, which may need to be converted to RRRRRGGGGGGBBBBB
by the WindowServer.  A further constraint is that the Cocoa
`<SAMP>NSBitmapImageRep</SAMP>' class typically only understands a limited number of
pixel formats, so even if the frame-buffer's precise format is known, there is
no guarantee that `<SAMP>NSBitmapImageRep</SAMP>' will support it.
</UL>
<P>

The Cocoa-based 2D driver implements video optimizations discussed in the
<CITE>NextStep 3.0 WindowServer Release Notes</CITE> in order to work around these
problems as much as possible.  The implemented optimizations are:
</P><P>

<UL>
<LI>
Image data is aligned on a page boundary, allowing it to be sent to the
WindowServer as out-of-band data in a Mach message.  This is very fast since
the data need only be mapped into the WindowServer's address space rather than
actually being copied.  Page-alignment is guaranteed by using
<CODE>NSAllocateMemoryPages()</CODE>.
<P>

<LI>
Image samples are organized in a meshed format.
<P>

<LI>
Data for each pixel includes alpha information.
<P>

<LI>
12-bit RGB data is stored in 16-bits with alpha nybble set to <CODE>0x0f</CODE>.
24-bit RGB data is stored in 32-bits with alpha byte set to <CODE>0xff</CODE>.
<P>

<LI>
The image's "<CODE>rowbytes</CODE> modulo 16" equals the destination buffer's
"<CODE>rowbytes</CODE> modulo 16" and the source data pointer is cacheline-aligned
(16 byte aligned) with the destination data pointer.  This is accomplished by
using a Retained-mode window and aligning the left edge of the destination
view on an x-coordinate which is a multiple of 8 for 12-bit color depth, and a
multiple of 4 for 24-bit color depth.
<P>

<LI>
The Cocoa `<SAMP>NSView</SAMP>' subclass which displays the image uses the identity
transform.  That is, it is not flipped, scaled, rotated, etc.
<P>

<LI>
The method <CODE>-[NSBitmapImageRep draw]</CODE> is used to blit the image in the
destination view.  This ensures that the image data is passed to to the
WindowServer as out-of-band data in a Mach message via the proprietary
`<SAMP>nextimage</SAMP>' PostScript operator.
</UL>
<P>

The bulk of these these optimizations were geared toward traditional NeXT
(<CODE>m68k</CODE>) hardware and probably have little or no significance on modern
hardware.  In some cases using these optimizations on original NeXT hardware,
could result in a very dramatic improvement in video performance.
</P><P>

Some further optimizations are employed which are not discussed in the
WindowServer release notes.  These include:
</P><P>

<UL>
<LI>
Disabling PostScript <EM>clipping</EM> in the view in which the image is
displayed.  (This item was applicable to only NextStep.  In Cocoa clipping can
not be disabled.)
<P>

<LI>
Allocating a <EM>graphics state</EM> (or `gstate', in original PostScript
terminology) for the view.  This saves valuable time whenever focusing on the
view, though at the expense of memory.  Without the allocated graphics state
cache, the view would otherwise have to perform certain time-consuming
preparation tasks each time before drawing.
<P>

<LI>
The window which displays the view is `Retained' rather than `Buffered'.  This
means that drawing occurs directly on-screen rather than going into a
backing-store which would then have to be flushed to the screen with an
expensive memory copy as an extra step.
</UL>
<P>

It is worth noting that none of the aforementioned video optimizations deal
with 2-bit gray, 8-bit gray, or 8-bit color.  Consequently this implementation
does not even attempt to perform any optimization in these cases and simply
hands the WindowServer 12-bit color data and lets the WindowServer massage it
as appropriate.  The upshot is that for displays other than 12- and 24-bit
RGB, video performance will probably suffer since the WindowServer will
have to massage and dither color data itself.  It is further worth noting,
though, that the majority of NextStep, OpenStep and MacOS/X Server 1.0
(Rhapsody) installations on NeXT and Intel hardware used either 12- or 24-bit
RGB frame buffers so the actual impact of this limitation may not have
been particularly severe.
</P><P>

<A NAME="MacOS/X Cocoa Frame Buffer"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_267.html#SEC801"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_269.html#SEC803"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_264.html#SEC798"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_265.html#SEC799"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_271.html#SEC805"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_292.html#SEC943">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="cs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated using
<A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
