<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: iEventOutlet Struct Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>iEventOutlet Struct Reference<br>
<small>
[<a class="el" href="group__event__handling.html">Event handling</a>]</small>
</h1>The iEventOutlet is the interface to an object that is provided by an event queue to every event plug when it registers itself.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="iutil_2event_8h-source.html">iutil/event.h</a>&gt;</code>
<p>
<p>Inheritance diagram for iEventOutlet:
<p><center><img src="structiEventOutlet.png" usemap="#iEventOutlet_map" border="0" alt=""></center>
<map name="iEventOutlet_map">
<area href="structiBase.html" alt="iBase" shape="rect" coords="0,0,90,24">
<area href="classcsEventOutlet.html" alt="csEventOutlet" shape="rect" coords="0,112,90,136">
</map>
<a href="structiEventOutlet-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiEvent.html">iEvent</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventOutlet.html#a0">CreateEvent</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a event object on behalf of the event queue.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventOutlet.html#a1">Post</a> (<a class="el" href="structiEvent.html">iEvent</a> *)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a previously created event into system event queue.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventOutlet.html#a2">Key</a> (<a class="el" href="group__util.html#ga21">utf32_char</a> codeRaw, <a class="el" href="group__util.html#ga21">utf32_char</a> codeCooked, bool iDown)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a keyboard event into event queue.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventOutlet.html#a3">Mouse</a> (int iButton, bool iDown, int x, int y)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a mouse event into event queue.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventOutlet.html#a4">Joystick</a> (int iNumber, int iButton, bool iDown, int x, int y)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a joystick event into event queue.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventOutlet.html#a5">Broadcast</a> (int iCode, void *iInfo=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a broadcast event into event queue.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventOutlet.html#a6">ImmediateBroadcast</a> (int iCode, void *iInfo)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a special routine which is called for example when the application is going to be suspended (suspended means "frozen", that is, application is forced to not run for some time).  <a href="#a6"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The iEventOutlet is the interface to an object that is provided by an event queue to every event plug when it registers itself. 
<p>
Any event plug will interact with event outlet to put events into system queue and so on.<p>
The event queue is responsible for detecting potentially conflicting situations when several event plugs may generate a event from same original event (e.g. a key press will cause several keydown events coming from several event source plugins). In this case the event sources are queried for how strong their "wish" to generate certain types of events is, and the one with the strongest "wish" wins. Then the respective outlet is set up such that any unwanted events coming from 'disqualified' event plugs are discarded. 
<p>

<p>
Definition at line <a class="el" href="iutil_2event_8h-source.html#l00437">437</a> of file <a class="el" href="iutil_2event_8h-source.html">event.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a5" doxytag="iEventOutlet::Broadcast"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventOutlet::Broadcast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>iCode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>iInfo</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Put a broadcast event into event queue. 
<p>
This is a generalized way to put any broadcast event into the system event queue. Command code may be used to tell user application that application's focused state has changed (cscmdFocusChanged), that a graphics context has been resized (cscmdContextResize), that it has been closed (cscmdContextClose), to finish the application immediately (cscmdQuit) and so on. 
<p>
Implemented in <a class="el" href="classcsEventOutlet.html#a7">csEventOutlet</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="iEventOutlet::CreateEvent"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiEvent.html">iEvent</a>&gt; iEventOutlet::CreateEvent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a event object on behalf of the event queue. 
<p>
A general function for generating virtually any type of event. Since all events for a particular event queue should be created from the same heap, you should generate first a event object (through CreateEvent method) then you fill it whatever you like and finally you insert it into the event queue with the <a class="el" href="structiEventOutlet.html#a1">Post()</a> method. 
<p>
Implemented in <a class="el" href="classcsEventOutlet.html#a2">csEventOutlet</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="iEventOutlet::ImmediateBroadcast"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventOutlet::ImmediateBroadcast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>iCode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>iInfo</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is a special routine which is called for example when the application is going to be suspended (suspended means "frozen", that is, application is forced to not run for some time). 
<p>
This happens for example when user switches away from a full-screen application on any OS with MGL canvas driver, or when it presses &lt;Pause&gt; with the OS/2 DIVE driver, or in any other drivers that supports forced pausing of applications.<p>
This generates a `normal' broadcast event with given command code; the crucial difference is that the event is being delivered to all clients *immediately*. The reason is that the application is frozen right after returning from this routine thus it will get the next chance to process any events only after it will be resumed (which is kind of too late to process this kind of events). 
<p>
Implemented in <a class="el" href="classcsEventOutlet.html#a8">csEventOutlet</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="iEventOutlet::Joystick"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventOutlet::Joystick           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>iNumber</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iButton</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>iDown</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Put a joystick event into event queue. 
<p>
iNumber is joystick number (from 0 to CS_MAX_JOYSTICK_COUNT-1).<p>
If iButton == 0, this is a joystick move event and iDown is ignored. Otherwise an joystick up/down event is generated. iButton can be from 1 to CS_MAX_JOYSTICK_BUTTONS (or 0 for a joystick move event). 
<p>
Implemented in <a class="el" href="classcsEventOutlet.html#a6">csEventOutlet</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="iEventOutlet::Key"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventOutlet::Key           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__util.html#ga21">utf32_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>codeRaw</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__util.html#ga21">utf32_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>codeCooked</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>iDown</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Put a keyboard event into event queue. 
<p>
Note that codeRaw is the key code, either the alphanumeric symbol that is emmited by the given key when no shift keys/modes are active (e.g. 'a', 'b', '.', '/' and so on) or one of CSKEY_XXX values (with value above 255) and the codeCooked parameter is the translated key, after applying all modeshift keys. <p>
If you pass 0 as codeCooked, a synthesized value is created based upon codeRaw using an simple internal translation table that takes care of Control/Shift/Alt for English characters. However, in general, it is best if the entity posting the event can provide both codes. 
<p>
Implemented in <a class="el" href="classcsEventOutlet.html#a4">csEventOutlet</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="iEventOutlet::Mouse"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventOutlet::Mouse           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>iButton</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>iDown</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Put a mouse event into event queue. 
<p>
If iButton == 0, this is a mouse motion event, and iDown argument is ignored. Otherwise an mousedown or mouseup event is generated at respective location. iButton can be in the range from 1 to CS_MAX_MOUSE_BUTTONS (or 0 for mouse move event). 
<p>
Implemented in <a class="el" href="classcsEventOutlet.html#a5">csEventOutlet</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="iEventOutlet::Post"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventOutlet::Post           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiEvent.html">iEvent</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Put a previously created event into system event queue. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>The event you pass to this method should be heap-allocated rather than stack-allocated since the event will be queued for later dispatch and because receivers of the event may claim their own references to it. The typical way to create a heap-allocated event is with <a class="el" href="structiEventQueue.html#a8">iEventQueue::CreateEvent()</a>, <a class="el" href="structiEventOutlet.html#a0">iEventOutlet::CreateEvent()</a>, or via the C++ 'new' operator. The <a class="el" href="structiEventOutlet.html#a0">CreateEvent()</a> methods have the benefit that they pool "dead" events and re-issue them to you when needed, thus they are quite efficient. </dd></dl>

<p>
Implemented in <a class="el" href="classcsEventOutlet.html#a3">csEventOutlet</a>.    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>iutil/<a class="el" href="iutil_2event_8h-source.html">event.h</a></ul>
<hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.9.1 
</small></address> </div></body> </html>
