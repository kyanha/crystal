<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/ref.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>csutil/ref.h</h1><a href="ref_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">  Crystal Space Smart Pointers</span>
00003 <span class="comment">  Copyright (C) 2002 by Jorrit Tyberghein and Matthias Braun</span>
00004 <span class="comment"></span>
00005 <span class="comment">  This library is free software; you can redistribute it and/or</span>
00006 <span class="comment">  modify it under the terms of the GNU Library General Public</span>
00007 <span class="comment">  License as published by the Free Software Foundation; either</span>
00008 <span class="comment">  version 2 of the License, or (at your option) any later version.</span>
00009 <span class="comment"></span>
00010 <span class="comment">  This library is distributed in the hope that it will be useful,</span>
00011 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00012 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00013 <span class="comment">  Library General Public License for more details.</span>
00014 <span class="comment"></span>
00015 <span class="comment">  You should have received a copy of the GNU Library General Public</span>
00016 <span class="comment">  License along with this library; if not, write to the Free</span>
00017 <span class="comment">  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00018 <span class="comment">*/</span>
00019 
00020 <span class="preprocessor">#ifndef __CS_REF_H__</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define __CS_REF_H__</span>
00022 <span class="preprocessor"></span>
00027 <span class="preprocessor">#include "csextern.h"</span>
00028 
00029 <span class="preprocessor">#define CS_VOIDED_PTR 0xffffffff</span>
00030 <span class="preprocessor"></span>
00031 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span><a class="code" href="classcsRef.html">csRef</a>;
00032 
00033 <span class="preprocessor">#if defined(CS_DEBUG)</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#  define CS_TEST_VOIDPTRUSAGE</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#  undef CS_TEST_VOIDPTRUSAGE</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00038 <span class="preprocessor"></span>
00039 <span class="preprocessor">#ifdef CS_REF_TRACKER</span>
00040 <span class="preprocessor"></span><span class="preprocessor"> #include &lt;typeinfo&gt;</span>
00041 <span class="preprocessor"> #include "csutil/reftrackeraccess.h"</span>
00042 
00043 <span class="preprocessor"> #define CSREF_TRACK(x, cmd, refCount, obj, tag)    \</span>
00044 <span class="preprocessor">  {                                                 \</span>
00045 <span class="preprocessor">    const int rc = obj ? refCount : -1;             \</span>
00046 <span class="preprocessor">    if (obj) cmd;                                   \</span>
00047 <span class="preprocessor">    if (obj)                                        \</span>
00048 <span class="preprocessor">    {                                               \</span>
00049 <span class="preprocessor">      csRefTrackerAccess::SetDescription (obj,      \</span>
00050 <span class="preprocessor">        typeid(T).name());                          \</span>
00051 <span class="preprocessor">      csRefTrackerAccess::Match ## x (obj, rc, tag);\</span>
00052 <span class="preprocessor">    }                                               \</span>
00053 <span class="preprocessor">  }</span>
00054 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_INCREF(obj,tag)    \</span>
00055 <span class="preprocessor">  CSREF_TRACK(IncRef, obj-&gt;IncRef(), obj-&gt;GetRefCount(), obj, tag);</span>
00056 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_DECREF(obj,tag)    \</span>
00057 <span class="preprocessor">  CSREF_TRACK(DecRef, obj-&gt;DecRef(), obj-&gt;GetRefCount(), obj, tag);</span>
00058 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_ASSIGN(obj,tag)    \</span>
00059 <span class="preprocessor">  CSREF_TRACK(IncRef, (0), obj-&gt;GetRefCount() - 1, obj, tag);</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00061 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_INCREF(obj,tag) \</span>
00062 <span class="preprocessor">  if (obj) obj-&gt;IncRef();</span>
00063 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_DECREF(obj,tag) \</span>
00064 <span class="preprocessor">  if (obj) obj-&gt;DecRef();</span>
00065 <span class="preprocessor"></span><span class="preprocessor"> #define CSREF_TRACK_ASSIGN(obj,tag)</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00067 <span class="preprocessor"></span>
00078 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00079"></a><a class="code" href="classcsPtr.html">00079</a> <span class="keyword">class  </span><a class="code" href="classcsPtr.html">csPtr</a>
00080 {
00081 <span class="keyword">private</span>:
00082   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsRef.html">csRef</a>&lt;T&gt;;
00083   T* obj;
00084 
00085 <span class="keyword">public</span>:
00086   <a class="code" href="classcsPtr.html">csPtr</a> (T* p) : obj (p) { CSREF_TRACK_ASSIGN(obj, <span class="keyword">this</span>); }
00087 
00088   <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
00089   <span class="keyword">explicit</span> <a class="code" href="classcsPtr.html">csPtr</a> (<a class="code" href="classcsRef.html">csRef&lt;T2&gt;</a> <span class="keyword">const</span>&amp; r) : obj((T2*)r) 
00090   { 
00091     CSREF_TRACK_INCREF (obj, <span class="keyword">this</span>);
00092   }
00093 
00094 <span class="preprocessor">#ifdef CS_TEST_VOIDPTRUSAGE</span>
00095 <span class="preprocessor"></span>  ~<a class="code" href="classcsPtr.html">csPtr</a> ()
00096   {
00097     <span class="comment">// If not assigned to a csRef we have a problem (leak).</span>
00098     <span class="comment">// So if this assert fires for you, then you are calling</span>
00099     <span class="comment">// a function that returns a csPtr and not using the result</span>
00100     <span class="comment">// (or at least not assigning it to a csRef). This is a memory</span>
00101     <span class="comment">// leak and you should fix that.</span>
00102     CS_ASSERT_MSG (<span class="stringliteral">"csPtr&lt;&gt; was not assigned to a csRef&lt;&gt; prior destruction"</span>, 
00103       obj == (T*)CS_VOIDED_PTR);
00104   }
00105 <span class="preprocessor">#endif</span>
00106 <span class="preprocessor"></span>
00107   <a class="code" href="classcsPtr.html">csPtr</a> (<span class="keyword">const</span> <a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp; copy)
00108   {
00109     obj = copy.<a class="code" href="classcsPtr.html#r0">obj</a>;
00110 <span class="preprocessor">#ifdef CS_TEST_VOIDPTRUSAGE</span>
00111 <span class="preprocessor"></span>    ((<a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp;)copy).obj = (T*)CS_VOIDED_PTR;
00112 <span class="preprocessor">#endif</span>
00113 <span class="preprocessor"></span>  }
00114 };
00115 
00122 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00123"></a><a class="code" href="classcsRef.html">00123</a> <span class="keyword">class  </span><a class="code" href="classcsRef.html">csRef</a>
00124 {
00125 <span class="keyword">private</span>:
00126   T* obj;
00127 
00128 <span class="keyword">public</span>:
<a name="l00134"></a><a class="code" href="classcsRef.html#a0">00134</a>   <a class="code" href="classcsRef.html#a0">csRef</a> () : obj (0) {}
00135 
<a name="l00141"></a><a class="code" href="classcsRef.html#a1">00141</a>   <a class="code" href="classcsRef.html#a0">csRef</a> (<span class="keyword">const</span> <a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp; newobj)
00142   {
00143     obj = newobj.<a class="code" href="classcsPtr.html#r0">obj</a>;
00144 <span class="preprocessor">#   ifdef CS_TEST_VOIDPTRUSAGE</span>
00145 <span class="preprocessor"></span>    CS_ASSERT_MSG (<span class="stringliteral">"csPtr&lt;&gt; was already assigned to a csRef&lt;&gt;"</span>,
00146       newobj.<a class="code" href="classcsPtr.html#r0">obj</a> != (T*)CS_VOIDED_PTR);
00147 <span class="preprocessor">#   endif</span>
00148 <span class="preprocessor"></span>    <span class="comment">// The following line is outside the ifdef to make sure</span>
00149     <span class="comment">// we have binary compatibility.</span>
00150     ((<a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp;)newobj).obj = (T*)CS_VOIDED_PTR;
00151   }
00152 
<a name="l00157"></a><a class="code" href="classcsRef.html#a2">00157</a>   <a class="code" href="classcsRef.html#a0">csRef</a> (T* newobj) : obj (newobj)
00158   {
00159     CSREF_TRACK_INCREF (obj, <span class="keyword">this</span>);
00160   }
00161   
00165   <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
<a name="l00166"></a><a class="code" href="classcsRef.html#a3">00166</a>   <a class="code" href="classcsRef.html#a0">csRef</a> (<a class="code" href="classcsRef.html">csRef&lt;T2&gt;</a> <span class="keyword">const</span>&amp; other) : obj ((T2*)other)
00167   {
00168     CSREF_TRACK_INCREF (obj, <span class="keyword">this</span>);
00169   }
00170 
<a name="l00174"></a><a class="code" href="classcsRef.html#a4">00174</a>   <a class="code" href="classcsRef.html#a0">csRef</a> (<a class="code" href="classcsRef.html">csRef</a> <span class="keyword">const</span>&amp; other) : obj (other.obj)
00175   {
00176     CSREF_TRACK_INCREF (obj, <span class="keyword">this</span>);
00177   }
00178 
<a name="l00182"></a><a class="code" href="classcsRef.html#a5">00182</a>   <a class="code" href="classcsRef.html#a5">~csRef</a> ()
00183   {
00184     CSREF_TRACK_DECREF (obj, <span class="keyword">this</span>);
00185   }
00186 
<a name="l00196"></a><a class="code" href="classcsRef.html#a6">00196</a>   <a class="code" href="classcsRef.html">csRef</a>&amp; <a class="code" href="classcsRef.html#a6">operator = </a>(<span class="keyword">const</span> <a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp; newobj)
00197   {
00198     T* oldobj = obj;
00199     <span class="comment">// First assign and then DecRef() of old object!</span>
00200     obj = newobj.<a class="code" href="classcsPtr.html#r0">obj</a>;
00201 <span class="preprocessor">#   ifdef CS_TEST_VOIDPTRUSAGE</span>
00202 <span class="preprocessor"></span>    CS_ASSERT_MSG (<span class="stringliteral">"csPtr&lt;&gt; was already assigned to a csRef&lt;&gt;"</span>,
00203       newobj.<a class="code" href="classcsPtr.html#r0">obj</a> != (T*)CS_VOIDED_PTR);
00204 <span class="preprocessor">#   endif</span>
00205 <span class="preprocessor"></span>    <span class="comment">// The following line is outside the ifdef to make sure</span>
00206     <span class="comment">// we have binary compatibility.</span>
00207     ((<a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a>&amp;)newobj).obj = (T*)CS_VOIDED_PTR;
00208     CSREF_TRACK_DECREF (oldobj, <span class="keyword">this</span>);
00209     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00210   }
00211 
<a name="l00224"></a><a class="code" href="classcsRef.html#a7">00224</a>   <a class="code" href="classcsRef.html">csRef</a>&amp; <a class="code" href="classcsRef.html#a6">operator = </a>(T* newobj)
00225   {
00226     <span class="keywordflow">if</span> (obj != newobj)
00227     {
00228       T* oldobj = obj;
00229       <span class="comment">// It is very important to first assign the new value to</span>
00230       <span class="comment">// 'obj' BEFORE calling DecRef() on the old object. Otherwise</span>
00231       <span class="comment">// it is easy to get in infinite loops with objects being</span>
00232       <span class="comment">// destructed forever (when ref=0 is used for example).</span>
00233       obj = newobj;
00234       CSREF_TRACK_INCREF (newobj, <span class="keyword">this</span>);
00235       CSREF_TRACK_DECREF (oldobj, <span class="keyword">this</span>);
00236     }
00237     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00238   }
00239 
<a name="l00262"></a><a class="code" href="classcsRef.html#a8">00262</a>   <span class="keywordtype">void</span> <a class="code" href="classcsRef.html#a8">AttachNew</a> (<a class="code" href="classcsPtr.html">csPtr&lt;T&gt;</a> newObj)
00263   {
00264     <span class="comment">// Note: The parameter usage of csPtr&lt;T&gt; instead of csPtr&lt;T&gt;&amp; is</span>
00265     <span class="comment">// deliberate and not to be considered a bug.</span>
00266 
00267     <span class="comment">// Just Re-use csPtr assignment logic</span>
00268     *<span class="keyword">this</span> = newObj;
00269   }
00270 
00272   <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
<a name="l00273"></a><a class="code" href="classcsRef.html#a9">00273</a>   <a class="code" href="classcsRef.html">csRef</a>&amp; <a class="code" href="classcsRef.html#a6">operator = </a>(<a class="code" href="classcsRef.html">csRef&lt;T2&gt;</a> <span class="keyword">const</span>&amp; other)
00274   {
00275     T* p = (T2*)other;
00276     this-&gt;<a class="code" href="classcsRef.html#a6">operator=</a>(p);
00277     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00278   }
00279 
<a name="l00281"></a><a class="code" href="classcsRef.html#a10">00281</a>   <a class="code" href="classcsRef.html">csRef</a>&amp; <a class="code" href="classcsRef.html#a6">operator = </a>(<a class="code" href="classcsRef.html">csRef</a> <span class="keyword">const</span>&amp; other)
00282   {
00283     this-&gt;<a class="code" href="classcsRef.html#a6">operator=</a>(other.<a class="code" href="classcsRef.html#r0">obj</a>);
00284     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00285   }
00286 
<a name="l00288"></a><a class="code" href="classcsRef.html#n0">00288</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#n0">operator == </a>(<span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r2)
00289   {
00290     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#r0">obj</a> == r2.<a class="code" href="classcsRef.html#r0">obj</a>;
00291   }
<a name="l00293"></a><a class="code" href="classcsRef.html#n1">00293</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#n1">operator != </a>(<span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r2)
00294   {
00295     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#r0">obj</a> != r2.<a class="code" href="classcsRef.html#r0">obj</a>;
00296   }
<a name="l00298"></a><a class="code" href="classcsRef.html#n2">00298</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#n0">operator == </a>(<span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1, T* obj)
00299   {
00300     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#r0">obj</a> == obj;
00301   }
<a name="l00303"></a><a class="code" href="classcsRef.html#n3">00303</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#n1">operator != </a>(<span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1, T* obj)
00304   {
00305     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#r0">obj</a> != obj;
00306   }
<a name="l00308"></a><a class="code" href="classcsRef.html#n4">00308</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#n0">operator == </a>(T* obj, <span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1)
00309   {
00310     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#r0">obj</a> == obj;
00311   }
<a name="l00313"></a><a class="code" href="classcsRef.html#n5">00313</a>   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#n1">operator != </a>(T* obj, <span class="keyword">const</span> <a class="code" href="classcsRef.html">csRef</a>&amp; r1)
00314   {
00315     <span class="keywordflow">return</span> r1.<a class="code" href="classcsRef.html#r0">obj</a> != obj;
00316   }
00317 
<a name="l00319"></a><a class="code" href="classcsRef.html#a11">00319</a>   T* <a class="code" href="classcsRef.html#a11">operator -&gt; </a>()<span class="keyword"> const</span>
00320 <span class="keyword">  </span>{ <span class="keywordflow">return</span> obj; }
00321   
<a name="l00323"></a><a class="code" href="classcsRef.html#a12">00323</a>   <a class="code" href="classcsRef.html#a12">operator T* </a>()<span class="keyword"> const</span>
00324 <span class="keyword">  </span>{ <span class="keywordflow">return</span> obj; }
00325   
<a name="l00327"></a><a class="code" href="classcsRef.html#a13">00327</a>   T&amp; <a class="code" href="classcsRef.html#a13">operator* </a>()<span class="keyword"> const</span>
00328 <span class="keyword">  </span>{ <span class="keywordflow">return</span> *obj; }
00329 
<a name="l00334"></a><a class="code" href="classcsRef.html#a14">00334</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsRef.html#a14">IsValid</a> ()<span class="keyword"> const</span>
00335 <span class="keyword">  </span>{ <span class="keywordflow">return</span> (obj != 0); }
00336 };
00337 
00338 <span class="preprocessor">#undef CSREF_TRACK_INCREF</span>
00339 <span class="preprocessor"></span><span class="preprocessor">#undef CSREF_TRACK_DECREF</span>
00340 <span class="preprocessor"></span><span class="preprocessor">#undef CSREF_TRACK_ASSIGN</span>
00341 <span class="preprocessor"></span>
00342 <span class="preprocessor">#endif // __CS_REF_H__</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.3 
</small></address> </div></body> </html>
