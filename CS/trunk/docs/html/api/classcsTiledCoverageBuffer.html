<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csTiledCoverageBuffer Class Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>csTiledCoverageBuffer Class Reference</h1><!-- doxytag: class="csTiledCoverageBuffer" -->The tiled coverage Buffer.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="tcovbuf_8h-source.html">csgeom/tcovbuf.h</a>&gt;</code>
<p>
<a href="classcsTiledCoverageBuffer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a0">csTiledCoverageBuffer</a> (int w, int h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new coverage buffer with the given dimensions.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a1">~csTiledCoverageBuffer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the coverage buffer.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a2">Setup</a> (int w, int h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup coverage buffer for given size.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a3">Initialize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the coverage buffer to empty.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a4">TestPolygon</a> (<a class="el" href="classcsVector2.html">csVector2</a> *verts, size_t num_verts, float min_depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a polygon would modify the coverage buffer if it was inserted.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a5">InsertPolygonInverted</a> (<a class="el" href="classcsVector2.html">csVector2</a> *verts, size_t num_verts, float max_depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an inverted polygon in the coverage buffer.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a6">InsertPolygonInvertedNoDepth</a> (<a class="el" href="classcsVector2.html">csVector2</a> *verts, size_t num_verts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an inverted polygon in the coverage buffer.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a7">InsertPolygon</a> (<a class="el" href="classcsVector2.html">csVector2</a> *verts, size_t num_verts, float max_depth, <a class="el" href="classcsBox2Int.html">csBox2Int</a> &amp;modified_bbox)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a polygon in the coverage buffer.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a8">InsertPolygonNoDepth</a> (<a class="el" href="classcsVector2.html">csVector2</a> *verts, size_t num_verts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a polygon in the coverage buffer.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a9">InsertOutline</a> (const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;trans, float fov, float sx, float sy, <a class="el" href="classcsVector3.html">csVector3</a> *verts, size_t num_verts, bool *used_verts, int *edges, size_t num_edges, bool splat_outline, <a class="el" href="classcsBox2Int.html">csBox2Int</a> &amp;modified_bbox)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an outline in the coverage buffer.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a10">PrepareTestRectangle</a> (const <a class="el" href="classcsBox2.html">csBox2</a> &amp;rect, <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare data for TestRectangle.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a11">TestRectangle</a> (const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;data, float min_depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test a rectangle with the coverage buffer.  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a12">QuickTestRectangle</a> (const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;data, float min_depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quickly test a rectangle with the coverage buffer.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a13">MarkCulledObject</a> (const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark the given rectangle as being culled away.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a14">CountNotCulledObjects</a> (const <a class="el" href="classcsBox2Int.html">csBox2Int</a> &amp;bbox)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of objects that were already culled away previously for the given rectangle.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a15">PrepareWriteQueueTest</a> (const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;data, float min_depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare a write queue test for the given rectangle.  <a href="#a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a16">AddWriteQueueTest</a> (const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;maindata, const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;data, bool &amp;relevant)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a rectangle for a write queue test.  <a href="#a16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a17">TestPoint</a> (const <a class="el" href="classcsVector2.html">csVector2</a> &amp;point, float min_depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test a point with the coverage buffer.  <a href="#a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a18">StatusNoDepth</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return status of coverage buffer (ignoring depth information).  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a23"></a><!-- doxytag: member="csTiledCoverageBuffer::GetSupportedTests" ref="a23" args="() const " -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a23">GetSupportedTests</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a24"></a><!-- doxytag: member="csTiledCoverageBuffer::UnitTest" ref="a24" args="()" -->
virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiString.html">iString</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a24">UnitTest</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a25"></a><!-- doxytag: member="csTiledCoverageBuffer::StateTest" ref="a25" args="()" -->
virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiString.html">iString</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a25">StateTest</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a26"></a><!-- doxytag: member="csTiledCoverageBuffer::Benchmark" ref="a26" args="(int num_iterations)" -->
virtual <a class="el" href="cstypes_8h.html#a26">csTicks</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a26">Benchmark</a> (int num_iterations)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a27"></a><!-- doxytag: member="csTiledCoverageBuffer::Dump" ref="a27" args="()" -->
virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiString.html">iString</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a27">Dump</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a28"></a><!-- doxytag: member="csTiledCoverageBuffer::Dump" ref="a28" args="(iGraphics3D *g3d)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a28">Dump</a> (<a class="el" href="structiGraphics3D.html">iGraphics3D</a> *g3d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a29"></a><!-- doxytag: member="csTiledCoverageBuffer::DebugCommand" ref="a29" args="(const char *)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#a29">DebugCommand</a> (const char *)</td></tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="o0"></a><!-- doxytag: member="csTiledCoverageBuffer::bugplug" ref="o0" args="" -->
<a class="el" href="structiBugPlug.html">iBugPlug</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsTiledCoverageBuffer.html#o0">bugplug</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The tiled coverage Buffer. 
<p>
This is a black-and-white bitmap represented by 32-bit ints arranged in rows. For example, a 128x128 bitmap is represented by 4 rows of 128 ints. Every int represents a column of 32 pixels. In addition there is also a maximum depth value for every 8x8 pixels. The screen buffer is divided into tiles of 64x32 or 32x64 pixels.
<p>

<p>
Definition at line <a class="el" href="tcovbuf_8h-source.html#l00470">470</a> of file <a class="el" href="tcovbuf_8h-source.html">tcovbuf.h</a>.<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0"></a><!-- doxytag: member="csTiledCoverageBuffer::csTiledCoverageBuffer" ref="a0" args="(int w, int h)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">csTiledCoverageBuffer::csTiledCoverageBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new coverage buffer with the given dimensions. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1"></a><!-- doxytag: member="csTiledCoverageBuffer::~csTiledCoverageBuffer" ref="a1" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual csTiledCoverageBuffer::~csTiledCoverageBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy the coverage buffer. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a16"></a><!-- doxytag: member="csTiledCoverageBuffer::AddWriteQueueTest" ref="a16" args="(const csTestRectData &amp;maindata, const csTestRectData &amp;data, bool &amp;relevant)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int csTiledCoverageBuffer::AddWriteQueueTest           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>maindata</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>relevant</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a rectangle for a write queue test. 
<p>
This returns the number of tiles that were covered. If 'relevant' is set to false by this function then that means the rectangle couldn't affect the result because it only affects tiles that are already fully covering the object we are testing.    </td>
  </tr>
</table>
<a class="anchor" name="a14"></a><!-- doxytag: member="csTiledCoverageBuffer::CountNotCulledObjects" ref="a14" args="(const csBox2Int &amp;bbox)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int csTiledCoverageBuffer::CountNotCulledObjects           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsBox2Int.html">csBox2Int</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bbox</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Count the number of objects that were already culled away previously for the given rectangle. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a3"></a><!-- doxytag: member="csTiledCoverageBuffer::Initialize" ref="a3" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void csTiledCoverageBuffer::Initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the coverage buffer to empty. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a9"></a><!-- doxytag: member="csTiledCoverageBuffer::InsertOutline" ref="a9" args="(const csReversibleTransform &amp;trans, float fov, float sx, float sy, csVector3 *verts, size_t num_verts, bool *used_verts, int *edges, size_t num_edges, bool splat_outline, csBox2Int &amp;modified_bbox)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int csTiledCoverageBuffer::InsertOutline           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>fov</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>sy</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>num_verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool *&nbsp;</td>
          <td class="mdname" nowrap> <em>used_verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>edges</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>num_edges</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>splat_outline</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsBox2Int.html">csBox2Int</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>modified_bbox</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert an outline in the coverage buffer. 
<p>
It will update the screen buffer. 'bbox' will contain the screen space box that was modified by this function. Function returns false if outline was not visible (i.e. screen buffer was not modified). The given array of edges is an array of two integers (vertex indices) per edge. The 'used_verts' contains true for all vertices that are used. If 'splat_outline' is true then outline splatting is used. <p>
If this function returns the number of tiles that were modified.    </td>
  </tr>
</table>
<a class="anchor" name="a7"></a><!-- doxytag: member="csTiledCoverageBuffer::InsertPolygon" ref="a7" args="(csVector2 *verts, size_t num_verts, float max_depth, csBox2Int &amp;modified_bbox)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int csTiledCoverageBuffer::InsertPolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsVector2.html">csVector2</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>num_verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsBox2Int.html">csBox2Int</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>modified_bbox</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a polygon in the coverage buffer. 
<p>
This function will not do any backface culling and it will work perfectly in all orientations. Polygon has to be convex. It will update the screen buffer. 'modified_bbox' will be updated to contain the union of the previous contents of 'modified_bbox' and also the screen space box that was modified by this function. <p>
If this function returns the number of tiles that were modified.    </td>
  </tr>
</table>
<a class="anchor" name="a5"></a><!-- doxytag: member="csTiledCoverageBuffer::InsertPolygonInverted" ref="a5" args="(csVector2 *verts, size_t num_verts, float max_depth)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void csTiledCoverageBuffer::InsertPolygonInverted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsVector2.html">csVector2</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>num_verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>max_depth</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert an inverted polygon in the coverage buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a6"></a><!-- doxytag: member="csTiledCoverageBuffer::InsertPolygonInvertedNoDepth" ref="a6" args="(csVector2 *verts, size_t num_verts)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void csTiledCoverageBuffer::InsertPolygonInvertedNoDepth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsVector2.html">csVector2</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>num_verts</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert an inverted polygon in the coverage buffer. 
<p>
This function ignores depth in the depth buffer and should only be used if you don't plan to use depth information nor depend on it.    </td>
  </tr>
</table>
<a class="anchor" name="a8"></a><!-- doxytag: member="csTiledCoverageBuffer::InsertPolygonNoDepth" ref="a8" args="(csVector2 *verts, size_t num_verts)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int csTiledCoverageBuffer::InsertPolygonNoDepth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsVector2.html">csVector2</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>num_verts</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a polygon in the coverage buffer. 
<p>
This function will not do any backface culling and it will work perfectly in all orientations. Polygon has to be convex. It will update the screen buffer. <p>
If this function returns the number of tiles that were modified. <p>
This function ignores depth in the depth buffer and should only be used if you don't plan to use depth information nor depend on it.    </td>
  </tr>
</table>
<a class="anchor" name="a13"></a><!-- doxytag: member="csTiledCoverageBuffer::MarkCulledObject" ref="a13" args="(const csTestRectData &amp;data)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void csTiledCoverageBuffer::MarkCulledObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>data</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mark the given rectangle as being culled away. 
<p>
For every affected tile this will increase the objects_culled field.    </td>
  </tr>
</table>
<a class="anchor" name="a10"></a><!-- doxytag: member="csTiledCoverageBuffer::PrepareTestRectangle" ref="a10" args="(const csBox2 &amp;rect, csTestRectData &amp;data)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool csTiledCoverageBuffer::PrepareTestRectangle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsBox2.html">csBox2</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prepare data for TestRectangle. 
<p>
If this returns false you have an early exit since the rectangle cannot be visible regardless of depth and coverage buffer contents.    </td>
  </tr>
</table>
<a class="anchor" name="a15"></a><!-- doxytag: member="csTiledCoverageBuffer::PrepareWriteQueueTest" ref="a15" args="(const csTestRectData &amp;data, float min_depth)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int csTiledCoverageBuffer::PrepareWriteQueueTest           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>min_depth</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prepare a write queue test for the given rectangle. 
<p>
This returns the number of uncovered tiles. Use <a class="el" href="classcsTiledCoverageBuffer.html#a16">AddWriteQueueTest()</a> to add additional rectangles.    </td>
  </tr>
</table>
<a class="anchor" name="a12"></a><!-- doxytag: member="csTiledCoverageBuffer::QuickTestRectangle" ref="a12" args="(const csTestRectData &amp;data, float min_depth)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool csTiledCoverageBuffer::QuickTestRectangle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>min_depth</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Quickly test a rectangle with the coverage buffer. 
<p>
This is only a very rough test but it is faster then <a class="el" href="classcsTiledCoverageBuffer.html#a11">TestRectangle()</a>. If this function returns false then the rectangle is not visible. If this function returns true it is possible that the rectangle is visible.    </td>
  </tr>
</table>
<a class="anchor" name="a2"></a><!-- doxytag: member="csTiledCoverageBuffer::Setup" ref="a2" args="(int w, int h)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void csTiledCoverageBuffer::Setup           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setup coverage buffer for given size. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a18"></a><!-- doxytag: member="csTiledCoverageBuffer::StatusNoDepth" ref="a18" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int csTiledCoverageBuffer::StatusNoDepth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return status of coverage buffer (ignoring depth information). 
<p>
If this returns 1 the buffer is full. If it returns -1 the buffer is empty. If it returns 0 the buffer is partially full.    </td>
  </tr>
</table>
<a class="anchor" name="a17"></a><!-- doxytag: member="csTiledCoverageBuffer::TestPoint" ref="a17" args="(const csVector2 &amp;point, float min_depth)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool csTiledCoverageBuffer::TestPoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector2.html">csVector2</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>min_depth</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test a point with the coverage buffer. 
<p>
Function returns false if point was not visible (i.e. screen buffer would not have been modified).    </td>
  </tr>
</table>
<a class="anchor" name="a4"></a><!-- doxytag: member="csTiledCoverageBuffer::TestPolygon" ref="a4" args="(csVector2 *verts, size_t num_verts, float min_depth)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool csTiledCoverageBuffer::TestPolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsVector2.html">csVector2</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>num_verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>min_depth</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test if a polygon would modify the coverage buffer if it was inserted. 
<p>
This function will not do any backface culling and it will work perfectly in all orientations. Polygon has to be convex. It will NOT update the screen buffer. Function returns false if polygon was not visible (i.e. screen buffer was not modified).    </td>
  </tr>
</table>
<a class="anchor" name="a11"></a><!-- doxytag: member="csTiledCoverageBuffer::TestRectangle" ref="a11" args="(const csTestRectData &amp;data, float min_depth)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool csTiledCoverageBuffer::TestRectangle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structcsTestRectData.html">csTestRectData</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>min_depth</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test a rectangle with the coverage buffer. 
<p>
Function returns false if rectangle was not visible (i.e. screen buffer would not have been modified). Call <a class="el" href="classcsTiledCoverageBuffer.html#a10">PrepareTestRectangle()</a> to fill in <a class="el" href="structcsTestRectData.html">csTestRectData</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>csgeom/<a class="el" href="tcovbuf_8h-source.html">tcovbuf.h</a></ul>
<hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.4 
</small></address> </div></body> </html>
