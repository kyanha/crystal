<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>iVisibilityCuller struct Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>iVisibilityCuller Struct Reference<br>
<small>
[<a class="el" href="group__engine3d__vis.html">Visibility</a>]</small>
</h1>This interface represents a visibility culling system.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="viscull_8h-source.html">viscull.h</a>&gt;</code>
<p>
<p>Inheritance diagram for iVisibilityCuller:
<p><center><img src="structiVisibilityCuller.png" usemap="#iVisibilityCuller_map" border="0" alt=""></center>
<map name="iVisibilityCuller_map">
<area href="structiBase.html" alt="iBase" shape="rect" coords="0,0,96,24">
</map>
<a href="structiVisibilityCuller-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a0">Setup</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup all data for this visibility culler. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a1">RegisterVisObject</a> (<a class="el" href="structiVisibilityObject.html">iVisibilityObject</a> *visobj)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a visibility object with this culler. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a2">UnregisterVisObject</a> (<a class="el" href="structiVisibilityObject.html">iVisibilityObject</a> *visobj)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister a visibility object with this culler. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a3">VisTest</a> (<a class="el" href="structiRenderView.html">iRenderView</a> *irview, <a class="el" href="structiVisibilityCullerListener.html">iVisibilityCullerListener</a> *viscallback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do the visibility test from a given viewpoint. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a4">PrecacheCulling</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Precache visibility culling. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiVisibilityObjectIterator.html">iVisibilityObjectIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a5">VisTest</a> (const <a class="el" href="classcsBox3.html">csBox3</a> &amp;box)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark all objects as visible that intersect with the given bounding box. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiVisibilityObjectIterator.html">iVisibilityObjectIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a6">VisTest</a> (const <a class="el" href="classcsSphere.html">csSphere</a> &amp;sphere)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark all objects as visible that intersect with the given bounding sphere. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a7">VisTest</a> (const <a class="el" href="classcsSphere.html">csSphere</a> &amp;sphere, <a class="el" href="structiVisibilityCullerListener.html">iVisibilityCullerListener</a> *viscallback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify the visibility callback of all objects that intersect with the given bounding sphere. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiVisibilityObjectIterator.html">iVisibilityObjectIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a8">VisTest</a> (<a class="el" href="classcsPlane3.html">csPlane3</a> *plane, int num_planes)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark all objects as visible that are in the volume formed by the set of planes. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a9">VisTest</a> (<a class="el" href="classcsPlane3.html">csPlane3</a> *plane, int num_planes, <a class="el" href="structiVisibilityCullerListener.html">iVisibilityCullerListener</a> *viscallback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify the visibility callback of all objects that are in the volume formed by the set of planes. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiVisibilityObjectIterator.html">iVisibilityObjectIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a10">IntersectSegmentSloppy</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersect a segment with all objects in the visibility culler and return them all in an iterator. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiVisibilityObjectIterator.html">iVisibilityObjectIterator</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a11">IntersectSegment</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, bool accurate=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersect a segment with all objects in the visibility culler and return them all in an iterator. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a12">IntersectSegment</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr=0, <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> **p_mesh=0, int *poly_idx=0, bool accurate=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersect a beam using this culler and return the intersection point, the mesh and optional polygon index. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structiVisibilityCuller.html#a13">CastShadows</a> (<a class="el" href="structiFrustumView.html">iFrustumView</a> *fview)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start casting shadows from a given point in space. </em> <a href="#a13"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This interface represents a visibility culling system. 
<p>
To use it you first register visibility objects (which are all the objects for which you want to test visibility) to this culler. A visibility culler can usually also support shadow calculation. <p>
Main creators of instances implementing this interface: <ul>
<li>
Dynavis culler plugin (crystalspace.culling.dynavis) </li>
<li>
Frustvis culler plugin (crystalspace.culling.frustvis) </li>
</ul>
Main ways to get pointers to this interface: <ul>
<li>
<a class="el" href="group__scf.html#a70">CS_QUERY_REGISTRY()</a> </li>
<li>
<a class="el" href="group__scf.html#a73">CS_LOAD_PLUGIN()</a> </li>
<li>
<a class="el" href="structiSector.html#a16">iSector::GetVisibilityCuller()</a> </li>
</ul>
Main users of this interface: <ul>
<li>
<a class="el" href="structiEngine.html">iEngine</a> </li>
</ul>

<p>

<p>
Definition at line <a class="el" href="viscull_8h-source.html#l00105">105</a> of file <a class="el" href="viscull_8h-source.html">viscull.h</a>.<hr><h2>Member Function Documentation</h2>
<a name="a13" doxytag="iVisibilityCuller::CastShadows"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iVisibilityCuller::CastShadows </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiFrustumView.html">iFrustumView</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>fview</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start casting shadows from a given point in space. 
<p>
What this will do is traverse all objects registered to the visibility culler. If some object implements <a class="el" href="structiShadowCaster.html">iShadowCaster</a> then this function will use the shadows casted by that object and put them in the frustum view. This function will then also call the object function which is assigned to <a class="el" href="structiFrustumView.html">iFrustumView</a>. That object function will (for example) call iShadowReceiver-&gt;<a class="el" href="structiVisibilityCuller.html#a13">CastShadows()</a> to cast the collected shadows on the shadow receiver.     </td>
  </tr>
</table>
<a name="a12" doxytag="iVisibilityCuller::IntersectSegment"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool iVisibilityCuller::IntersectSegment </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>isect</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap> <em>pr</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>p_mesh</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>poly_idx</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>accurate</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Intersect a beam using this culler and return the intersection point, the mesh and optional polygon index. 
<p>
If the returned mesh is 0 then this means that the object belonging to the culler itself was hit. Some meshes don't support returning polygon indices in which case that field will always be -1. If accurate is false then a less accurate (and faster) method is used. In that case the polygon index will never be filled.     </td>
  </tr>
</table>
<a name="a11" doxytag="iVisibilityCuller::IntersectSegment"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiVisibilityObjectIterator.html">iVisibilityObjectIterator</a>&gt; iVisibilityCuller::IntersectSegment </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>accurate</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Intersect a segment with all objects in the visibility culler and return them all in an iterator. 
<p>
If accurate is true then a more accurate (and slower) method is used.     </td>
  </tr>
</table>
<a name="a10" doxytag="iVisibilityCuller::IntersectSegmentSloppy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiVisibilityObjectIterator.html">iVisibilityObjectIterator</a>&gt; iVisibilityCuller::IntersectSegmentSloppy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Intersect a segment with all objects in the visibility culler and return them all in an iterator. 
<p>
This function is less accurate then <a class="el" href="structiVisibilityCuller.html#a11">IntersectSegment()</a> because it might also return objects that are not even hit by the beam but just close to it.     </td>
  </tr>
</table>
<a name="a4" doxytag="iVisibilityCuller::PrecacheCulling"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iVisibilityCuller::PrecacheCulling </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Precache visibility culling. 
<p>
This can be useful in case you want to ensure that render speed doesn't get any hickups as soon as a portal to this sector becomes visible. iEngine-&gt;PrecacheDraw() will call this function.     </td>
  </tr>
</table>
<a name="a1" doxytag="iVisibilityCuller::RegisterVisObject"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iVisibilityCuller::RegisterVisObject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiVisibilityObject.html">iVisibilityObject</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>visobj</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a visibility object with this culler. 
<p>
If this visibility object also supports <a class="el" href="structiShadowCaster.html">iShadowCaster</a> and this visibility culler supports shadow casting then it will automatically get registered as a shadow caster as well. Same for <a class="el" href="structiShadowReceiver.html">iShadowReceiver</a>.     </td>
  </tr>
</table>
<a name="a0" doxytag="iVisibilityCuller::Setup"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iVisibilityCuller::Setup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setup all data for this visibility culler. 
<p>
This needs to be called before the culler is used for the first time. The given name will be used to cache the data.     </td>
  </tr>
</table>
<a name="a2" doxytag="iVisibilityCuller::UnregisterVisObject"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iVisibilityCuller::UnregisterVisObject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiVisibilityObject.html">iVisibilityObject</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>visobj</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unregister a visibility object with this culler. 
<p>
    </td>
  </tr>
</table>
<a name="a9" doxytag="iVisibilityCuller::VisTest"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iVisibilityCuller::VisTest </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsPlane3.html">csPlane3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>plane</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_planes</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structiVisibilityCullerListener.html">iVisibilityCullerListener</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>viscallback</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Notify the visibility callback of all objects that are in the volume formed by the set of planes. 
<p>
Can be used for frustum intersection, box intersection, .... <dl compact><dt><b>Remarks:</b></dt><dd>Warning! This function can only use up to 32 planes. </dd></dl>
    </td>
  </tr>
</table>
<a name="a8" doxytag="iVisibilityCuller::VisTest"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiVisibilityObjectIterator.html">iVisibilityObjectIterator</a>&gt; iVisibilityCuller::VisTest </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsPlane3.html">csPlane3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>plane</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_planes</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mark all objects as visible that are in the volume formed by the set of planes. 
<p>
Can be used for frustum intersection, box intersection, .... Warning! This function can only use up to 32 planes.     </td>
  </tr>
</table>
<a name="a7" doxytag="iVisibilityCuller::VisTest"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iVisibilityCuller::VisTest </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsSphere.html">csSphere</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>sphere</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structiVisibilityCullerListener.html">iVisibilityCullerListener</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>viscallback</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Notify the visibility callback of all objects that intersect with the given bounding sphere. 
<p>
    </td>
  </tr>
</table>
<a name="a6" doxytag="iVisibilityCuller::VisTest"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiVisibilityObjectIterator.html">iVisibilityObjectIterator</a>&gt; iVisibilityCuller::VisTest </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsSphere.html">csSphere</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sphere</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mark all objects as visible that intersect with the given bounding sphere. 
<p>
    </td>
  </tr>
</table>
<a name="a5" doxytag="iVisibilityCuller::VisTest"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiVisibilityObjectIterator.html">iVisibilityObjectIterator</a>&gt; iVisibilityCuller::VisTest </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsBox3.html">csBox3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>box</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mark all objects as visible that intersect with the given bounding box. 
<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="iVisibilityCuller::VisTest"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool iVisibilityCuller::VisTest </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRenderView.html">iRenderView</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>irview</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structiVisibilityCullerListener.html">iVisibilityCullerListener</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>viscallback</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do the visibility test from a given viewpoint. 
<p>
This will first clear the visible flag on all registered objects and then it will mark all visible objects. If this function returns false then all objects are visible.     </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>iengine/<a class="el" href="viscull_8h-source.html">viscull.h</a></ul>
<hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.3 
</small></address> </div></body> </html>
