<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: iEventQueue Struct Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>iEventQueue Struct Reference<br>
<small>
[<a class="el" href="group__event__handling.html">Event handling</a>]</small>
</h1><!-- doxytag: class="iEventQueue" --><!-- doxytag: inherits="iBase" -->This interface represents a general event queue.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="eventq_8h-source.html">iutil/eventq.h</a>&gt;</code>
<p>
Inheritance diagram for iEventQueue:<p><center><img src="structiEventQueue__inherit__graph.png" border="0" usemap="#iEventQueue__inherit__map" alt="Inheritance graph"></center>
<map name="iEventQueue__inherit__map">
<area href="classscfImplementation1.html" shape="rect" coords="7,158,341,182" alt="">
<area href="structiBase.html" shape="rect" coords="146,9,202,33" alt="">
<area href="classcsEventQueue.html" shape="rect" coords="119,233,229,257" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="structiEventQueue-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a0">ChangeListenerTrigger</a> (<a class="el" href="structiEventHandler.html">iEventHandler</a> *, unsigned int trigger)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a listener's trigger.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a1">Clear</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear event queue.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiEvent.html">iEvent</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a2">CreateEvent</a> (<a class="el" href="cstypes_8h.html#a9">uint8</a> type)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an event, from the pool if there are any free events available.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiEventOutlet.html">iEventOutlet</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a3">CreateEventOutlet</a> (<a class="el" href="structiEventPlug.html">iEventPlug</a> *)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register an event plug and return a new outlet.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a4">Dispatch</a> (<a class="el" href="structiEvent.html">iEvent</a> &amp;)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dispatch a single event from the queue.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiEvent.html">iEvent</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a5">Get</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get next event from queue; returns a null reference if no events are present.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiEventCord.html">iEventCord</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a6">GetEventCord</a> (int Category, int Subcategory)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the event cord for a given category and subcategory.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiEventOutlet.html">iEventOutlet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a7">GetEventOutlet</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a public event outlet for posting just an event.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a8">IsEmpty</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query if queue is empty.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a9">Post</a> (<a class="el" href="structiEvent.html">iEvent</a> *)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Place an event into queue.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a10">Process</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process the event queue.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a11">RegisterListener</a> (<a class="el" href="structiEventHandler.html">iEventHandler</a> *, unsigned int trigger)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a listener for specific events.  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a12">RemoveAllListeners</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister all listeners.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiEventQueue.html#a13">RemoveListener</a> (<a class="el" href="structiEventHandler.html">iEventHandler</a> *)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister a listener.  <a href="#a13"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This interface represents a general event queue. 
<p>
Events may be posted to the queue by various sources. Listeners (implementing <a class="el" href="structiEventHandler.html">iEventHandler</a>) can register to receive notification when various events are processed. Typically, one instance of this object is available from the shared-object registry (<a class="el" href="structiObjectRegistry.html">iObjectRegistry</a>).<p>
Main creators of instances implementing this interface:<ul>
<li><a class="el" href="classcsInitializer.html#e3">csInitializer::CreateEnvironment()</a></li><li><a class="el" href="classcsInitializer.html#e4">csInitializer::CreateEventQueue()</a></li></ul>
<p>
Main ways to get pointers to this interface:<ul>
<li><a class="el" href="iutil_2objreg_8h.html#a3">csQueryRegistry()</a></li></ul>

<p>

<p>
Definition at line <a class="el" href="eventq_8h-source.html#l00053">53</a> of file <a class="el" href="eventq_8h-source.html">eventq.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a0"></a><!-- doxytag: member="iEventQueue::ChangeListenerTrigger" ref="a0" args="(iEventHandler *, unsigned int trigger)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventQueue::ChangeListenerTrigger           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiEventHandler.html">iEventHandler</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>trigger</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change a listener's trigger. 
<p>
See <a class="el" href="structiEventQueue.html#a11">RegisterListener()</a> for a discussion of the trigger.
<p>
Implemented in <a class="el" href="classcsEventQueue.html#a0">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1"></a><!-- doxytag: member="iEventQueue::Clear" ref="a1" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventQueue::Clear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear event queue. 
<p>

<p>
Implemented in <a class="el" href="classcsEventQueue.html#a1">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2"></a><!-- doxytag: member="iEventQueue::CreateEvent" ref="a2" args="(uint8 type)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiEvent.html">iEvent</a>&gt; iEventQueue::CreateEvent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="cstypes_8h.html#a9">uint8</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an event, from the pool if there are any free events available. 
<p>
Else create a new event in the pool and use it.
<p>
Implemented in <a class="el" href="classcsEventQueue.html#a3">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3"></a><!-- doxytag: member="iEventQueue::CreateEventOutlet" ref="a3" args="(iEventPlug *)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiEventOutlet.html">iEventOutlet</a>&gt; iEventQueue::CreateEventOutlet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiEventPlug.html">iEventPlug</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register an event plug and return a new outlet. 
<p>
Any module which generates events should consider using this interface for posting those events to the queue. The module should implement the <a class="el" href="structiEventPlug.html">iEventPlug</a> interface and register that interface with this method. In return, an <a class="el" href="structiEventOutlet.html">iEventOutlet</a> object will be created which can be used to actually post events to the queue. It is the caller's responsibility to send a <a class="el" href="structiBase.html#a1">DecRef()</a> message to the returned event outlet when it is no longer needed.
<p>
Implemented in <a class="el" href="classcsEventQueue.html#a4">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4"></a><!-- doxytag: member="iEventQueue::Dispatch" ref="a4" args="(iEvent &amp;)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventQueue::Dispatch           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiEvent.html">iEvent</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dispatch a single event from the queue. 
<p>
This is normally called by <a class="el" href="structiEventQueue.html#a10">Process()</a> once for each event in the queue. Events are dispatched to the appropriate listeners (implementors of <a class="el" href="structiEventHandler.html">iEventHandler</a>) which have been registered via <a class="el" href="structiEventQueue.html#a11">RegisterListener()</a>.
<p>
Implemented in <a class="el" href="classcsEventQueue.html#a6">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5"></a><!-- doxytag: member="iEventQueue::Get" ref="a5" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiEvent.html">iEvent</a>&gt; iEventQueue::Get           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get next event from queue; returns a null reference if no events are present. 
<p>
There is rarely any need to manually retrieve events from the queue. Instead, normal event processing via <a class="el" href="structiEventQueue.html#a10">Process()</a> takes care of this responsibility. iEventQueue gives up ownership of the returned <a class="el" href="structiEvent.html">iEvent</a>.
<p>
Implemented in <a class="el" href="classcsEventQueue.html#a7">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6"></a><!-- doxytag: member="iEventQueue::GetEventCord" ref="a6" args="(int Category, int Subcategory)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiEventCord.html">iEventCord</a>* iEventQueue::GetEventCord           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>Category</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Subcategory</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the event cord for a given category and subcategory. 
<p>
This allows events to be delivered immediately, bypassing the normal event queue, to a chain of plugins that register with the implementation of <a class="el" href="structiEventCord.html">iEventCord</a> returned by this function. The category and subcategory are matched against the category and subcategory of each actual <a class="el" href="structiEvent.html">iEvent</a>.
<p>
Implemented in <a class="el" href="classcsEventQueue.html#a8">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7"></a><!-- doxytag: member="iEventQueue::GetEventOutlet" ref="a7" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiEventOutlet.html">iEventOutlet</a>* iEventQueue::GetEventOutlet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a public event outlet for posting just an event. 
<p>
In general most modules should create their own private outlet via <a class="el" href="structiEventQueue.html#a3">CreateEventOutlet()</a> and register as a normal event plug. However, there are cases when you just need to post one event from time to time; in these cases it is easier to post it without the bulk of creating a new <a class="el" href="structiEventPlug.html">iEventPlug</a> interface. In these cases, you can post the event by obtaining the shared event outlet from <a class="el" href="structiEventQueue.html#a7">GetEventOutlet()</a>, and use it to post an event instead.
<p>
Implemented in <a class="el" href="classcsEventQueue.html#a9">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8"></a><!-- doxytag: member="iEventQueue::IsEmpty" ref="a8" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iEventQueue::IsEmpty           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Query if queue is empty. 
<p>

<p>
Implemented in <a class="el" href="classcsEventQueue.html#a10">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a9"></a><!-- doxytag: member="iEventQueue::Post" ref="a9" args="(iEvent *)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventQueue::Post           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiEvent.html">iEvent</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Place an event into queue. 
<p>
In general, clients should post events to the queue via an <a class="el" href="structiEventOutlet.html">iEventOutlet</a> rather than directly via <a class="el" href="structiEventQueue.html#a9">Post()</a>, however there may be certain circumanstances where posting directly to the queue is preferred. <dl compact><dt><b>Remarks:</b></dt><dd><a class="el" href="structiEventQueue.html#a9">Post()</a> takes ownership of the event. That means that you MUST NOT <a class="el" href="structiBase.html#a1">DecRef()</a> the event after passing it to <a class="el" href="structiEventQueue.html#a9">Post()</a>. Instead, if you want to keep it, <a class="el" href="structiBase.html#a3">IncRef()</a> it.</dd></dl>

<p>
Implemented in <a class="el" href="classcsEventQueue.html#a11">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10"></a><!-- doxytag: member="iEventQueue::Process" ref="a10" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventQueue::Process           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Process the event queue. 
<p>
Calls <a class="el" href="structiEventQueue.html#a4">Dispatch()</a> once for each event in the queue in order to actually dispatch the event. Typically, this method is invoked by the host application on a periodic basis (often from the host's own event loop) in order to give Crystal Space modules a chance to run and respond to events.
<p>
Implemented in <a class="el" href="classcsEventQueue.html#a12">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a11"></a><!-- doxytag: member="iEventQueue::RegisterListener" ref="a11" args="(iEventHandler *, unsigned int trigger)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventQueue::RegisterListener           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiEventHandler.html">iEventHandler</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>trigger</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a listener for specific events. 
<p>
If the listener is already registered, then this method merely changes the listener's `trigger'. The `trigger' argument is a combination of the CSMASK_XXX event triggers defined in iutil/evdefs.h. Multiple triggers may be specified by combining them with the bitwise "or" operator (`|'). The CSMASK_Nothing event trigger is special. If registered with this trigger, the listener will be called in just before <a class="el" href="structiEventQueue.html#a10">Process()</a> iterates over the event queue, and then it will be called with 3 different csevBroadcast events after has been dispatched the last event. In this case, the listener will be sent an csevBroadcast event with the Event.Retrieve("cmdCode") equal to cscmdPreProcess before events dispatching, and after events dispatching the listener will receive three csevBroadcast events, in 3 successive phases, following this ordering: the first broadcasted event has the Event.Retrieve("cmdCode") equal to cscmdProcess, then the second broadcasted event has a value of cscmdPostProcess and finally the last event broadcasted has the cscmdFinalProcess value .
<p>
Implemented in <a class="el" href="classcsEventQueue.html#a13">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a12"></a><!-- doxytag: member="iEventQueue::RemoveAllListeners" ref="a12" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventQueue::RemoveAllListeners           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unregister all listeners. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>This function is used to clear all listeners from the event queue stack. You should only call this function at the end of your program after the event queue processing has terminated. </dd></dl>
<dl compact><dt><b></b></dt><dd>If you make use of <a class="el" href="classcsInitializer.html#e11">csInitializer::DestroyApplication()</a>, this is done for you by that call.</dd></dl>

<p>
Implemented in <a class="el" href="classcsEventQueue.html#a14">csEventQueue</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a13"></a><!-- doxytag: member="iEventQueue::RemoveListener" ref="a13" args="(iEventHandler *)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iEventQueue::RemoveListener           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiEventHandler.html">iEventHandler</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unregister a listener. 
<p>
It is important to call <a class="el" href="structiEventQueue.html#a13">RemoveListener()</a> before deleting your event handler!
<p>
Implemented in <a class="el" href="classcsEventQueue.html#a15">csEventQueue</a>.    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>iutil/<a class="el" href="eventq_8h-source.html">eventq.h</a></ul>
<hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.4 
</small></address> </div></body> </html>
