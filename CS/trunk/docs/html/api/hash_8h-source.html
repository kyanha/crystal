<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/hash.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000022.html">csutil</a></div>
<h1>hash.h</h1><a href="hash_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2003 by Mat Sutcliffe &lt;oktal@gmx.co.uk&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_UTIL_HASH_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_UTIL_HASH_H__</span>
00021 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include "csextern.h"</span>
00027 <span class="preprocessor">#include "<a class="code" href="array_8h.html">array.h</a>"</span>
00028 <span class="preprocessor">#include "<a class="code" href="comparator_8h.html">comparator.h</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="ref_8h.html">ref.h</a>"</span>
00030 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00031 
00041 CS_CRYSTALSPACE_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__util__containers.html#ga1">csHashCompute</a> (<span class="keywordtype">char</span> <span class="keyword">const</span>*);
00042 
00049 CS_CRYSTALSPACE_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__util__containers.html#ga1">csHashCompute</a> (<span class="keywordtype">char</span> <span class="keyword">const</span>*, size_t length);
00050 
00055 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00056"></a><a class="code" href="classcsHashComputer.html">00056</a> <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>
00057 {
00058 <span class="keyword">public</span>:
<a name="l00060"></a><a class="code" href="classcsHashComputer.html#e0">00060</a>   <span class="keyword">static</span> <a class="code" href="group__util.html#ga18">uint</a> <a class="code" href="classcsHashComputer.html#e0">ComputeHash</a> (<span class="keyword">const</span> T&amp; key)
00061   {
00062     <span class="keywordflow">return</span> key.GetHash();
00063   }
00064 };
00065 
00070 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00071"></a><a class="code" href="classcsHashComputerIntegral.html">00071</a> <span class="keyword">class </span><a class="code" href="classcsHashComputerIntegral.html">csHashComputerIntegral</a>
00072 {
00073 <span class="keyword">public</span>:
<a name="l00075"></a><a class="code" href="classcsHashComputerIntegral.html#e0">00075</a>   <span class="keyword">static</span> <a class="code" href="group__util.html#ga18">uint</a> <a class="code" href="classcsHashComputerIntegral.html#e0">ComputeHash</a> (<span class="keyword">const</span> T&amp; key)
00076   {
00077     <span class="keywordflow">return</span> (<a class="code" href="group__util.html#ga9">uintptr_t</a>)key;
00078   }
00079 };
00080 
00082 
00085 CS_SPECIALIZE_TEMPLATE
<a name="l00086"></a><a class="code" href="classcsHashComputer_3_01void_01_5_01_4.html">00086</a> <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;void*&gt; : <span class="keyword">public</span> <a class="code" href="classcsHashComputerIntegral.html">csHashComputerIntegral&lt;void*&gt;</a> {};
00087 CS_SPECIALIZE_TEMPLATE
00088 <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;int&gt; : <span class="keyword">public</span> <a class="code" href="classcsHashComputerIntegral.html">csHashComputerIntegral</a>&lt;int&gt; {}; 
00089 CS_SPECIALIZE_TEMPLATE
00090 <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;unsigned int&gt; : 
00091   <span class="keyword">public</span> <a class="code" href="classcsHashComputerIntegral.html">csHashComputerIntegral</a>&lt;unsigned int&gt; {}; 
00092 CS_SPECIALIZE_TEMPLATE
00093 <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;long&gt; : <span class="keyword">public</span> <a class="code" href="classcsHashComputerIntegral.html">csHashComputerIntegral</a>&lt;long&gt; {}; 
00094 CS_SPECIALIZE_TEMPLATE
00095 <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;unsigned long&gt; : 
00096   <span class="keyword">public</span> <a class="code" href="classcsHashComputerIntegral.html">csHashComputerIntegral</a>&lt;unsigned long&gt; {}; 
00097 CS_SPECIALIZE_TEMPLATE
00098 <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;float&gt;
00099 {
00100 <span class="keyword">public</span>:
00102   <span class="keyword">static</span> <a class="code" href="group__util.html#ga18">uint</a> <a class="code" href="classcsHashComputer.html#e0">ComputeHash</a> (<span class="keywordtype">float</span> key)
00103   {
00104     <span class="keyword">union</span>
00105 <span class="keyword">    </span>{
00106       <span class="keywordtype">float</span> f;
00107       <a class="code" href="group__util.html#ga18">uint</a> u;
00108     } float2uint;
00109     float2uint.f = key;
00110     <span class="keywordflow">return</span> float2uint.u;
00111   }
00112 };
00113 CS_SPECIALIZE_TEMPLATE
00114 <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;double&gt;
00115 {
00116 <span class="keyword">public</span>:
00118   <span class="keyword">static</span> <a class="code" href="group__util.html#ga18">uint</a> <a class="code" href="classcsHashComputer.html#e0">ComputeHash</a> (<span class="keywordtype">double</span> key)
00119   {
00120     <span class="keyword">union</span>
00121 <span class="keyword">    </span>{
00122       <span class="keywordtype">double</span> f;
00123       <a class="code" href="group__util.html#ga18">uint</a> u;
00124     } double2uint;
00125     double2uint.f = key;
00126     <span class="keywordflow">return</span> double2uint.u;
00127   }
00128 };
00130 
00134 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00135"></a><a class="code" href="classcsPtrKey.html">00135</a> <span class="keyword">class </span><a class="code" href="classcsPtrKey.html">csPtrKey</a>
00136 {
00137   T* ptr;
00138 <span class="keyword">public</span>:
00139   <a class="code" href="classcsPtrKey.html">csPtrKey</a> () : ptr(0) {}
00140   <a class="code" href="classcsPtrKey.html">csPtrKey</a> (T* ptr) : ptr(ptr) {}
00141   <a class="code" href="classcsPtrKey.html">csPtrKey</a> (<a class="code" href="classcsPtrKey.html">csPtrKey</a> <span class="keyword">const</span>&amp; other) : ptr (other.<a class="code" href="classcsPtrKey.html#r0">ptr</a>) {}
00142 
00143   <a class="code" href="group__util.html#ga18">uint</a> GetHash ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<a class="code" href="group__util.html#ga9">uintptr_t</a>)ptr; }
00144   <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> <a class="code" href="classcsPtrKey.html">csPtrKey</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classcsPtrKey.html">csPtrKey</a>&amp; r2)
00145   { <span class="keywordflow">return</span> r1.ptr &lt; r2.<a class="code" href="classcsPtrKey.html#r0">ptr</a>; }
00146   operator T* ()<span class="keyword"> const</span>
00147 <span class="keyword">  </span>{ <span class="keywordflow">return</span> ptr; }
00148   T* operator -&gt; ()<span class="keyword"> const</span>
00149 <span class="keyword">  </span>{ <span class="keywordflow">return</span> ptr; }
00150   <a class="code" href="classcsPtrKey.html">csPtrKey</a>&amp; operator = (<a class="code" href="classcsPtrKey.html">csPtrKey</a> <span class="keyword">const</span>&amp; other)
00151   { ptr = other.<a class="code" href="classcsPtrKey.html#r0">ptr</a>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
00152 };
00153 
00163 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00164"></a><a class="code" href="classcsHashComputerString.html">00164</a> <span class="keyword">class </span><a class="code" href="classcsHashComputerString.html">csHashComputerString</a>
00165 {
00166 <span class="keyword">public</span>:
00167   <span class="keyword">static</span> <a class="code" href="group__util.html#ga18">uint</a> ComputeHash (<span class="keyword">const</span> T&amp; key)
00168   {
00169     <span class="keywordflow">return</span> <a class="code" href="group__util__containers.html#ga1">csHashCompute</a> ((<span class="keyword">const</span> <span class="keywordtype">char</span>*)key);
00170   }
00171 };
00172 
00176 CS_SPECIALIZE_TEMPLATE
<a name="l00177"></a><a class="code" href="classcsHashComputer_3_01const_01char_01_5_01_4.html">00177</a> <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;const char*&gt; : <span class="keyword">public</span> <a class="code" href="classcsHashComputerString.html">csHashComputerString&lt;const char*&gt;</a> {};
00178 
00188 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00189"></a><a class="code" href="classcsHashComputerStruct.html">00189</a> <span class="keyword">class </span><a class="code" href="classcsHashComputerStruct.html">csHashComputerStruct</a>
00190 {
00191 <span class="keyword">public</span>:
00192   <span class="keyword">static</span> <a class="code" href="group__util.html#ga18">uint</a> ComputeHash (<span class="keyword">const</span> T&amp; key)
00193   {
00194     <span class="keywordflow">return</span> <a class="code" href="group__util__containers.html#ga1">csHashCompute</a> ((<span class="keywordtype">char</span>*)&amp;key, <span class="keyword">sizeof</span> (T));
00195   }
00196 };
00197 
<a name="l00202"></a><a class="code" href="classcsStrKey.html">00202</a> <span class="keyword">class </span><a class="code" href="classcsStrKey.html">csStrKey</a>
00203 {
00204 <span class="keyword">private</span>:
00205   <span class="keywordtype">char</span>* str;
00206 
00207 <span class="keyword">public</span>:
00208   <a class="code" href="classcsStrKey.html">csStrKey</a> () { str = 0; }
00209   <a class="code" href="classcsStrKey.html">csStrKey</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* s) { str = <a class="code" href="group__util.html#ga98">csStrNew</a> (s); }
00210   <a class="code" href="classcsStrKey.html">csStrKey</a> (<span class="keyword">const</span> <a class="code" href="classcsStrKey.html">csStrKey</a>&amp; c) { str = <a class="code" href="group__util.html#ga98">csStrNew</a> (c.<a class="code" href="classcsStrKey.html#r0">str</a>); }
00211   ~<a class="code" href="classcsStrKey.html">csStrKey</a> () { <span class="keyword">delete</span>[] str; }
00212   <a class="code" href="classcsStrKey.html">csStrKey</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classcsStrKey.html">csStrKey</a>&amp; o)
00213   {
00214     <span class="keyword">delete</span>[] str; str = <a class="code" href="group__util.html#ga98">csStrNew</a> (o.<a class="code" href="classcsStrKey.html#r0">str</a>);
00215     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00216   }
00217   operator const char* ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> str; }
00218   <a class="code" href="group__util.html#ga18">uint</a> GetHash()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="group__util__containers.html#ga1">csHashCompute</a> (str); }
00219 };
00220 
00224 CS_SPECIALIZE_TEMPLATE
<a name="l00225"></a><a class="code" href="classcsComparator_3_01csStrKey_00_01csStrKey_01_4.html">00225</a> <span class="keyword">class </span><a class="code" href="classcsComparator.html">csComparator</a>&lt;csStrKey, csStrKey&gt; : <span class="keyword">public</span> <a class="code" href="classcsComparatorString.html">csComparatorString</a>&lt;csStrKey&gt; {};
00226 
00236 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> K = <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt; 
<a name="l00237"></a><a class="code" href="classcsHash.html">00237</a> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>
00238 {
00239 <span class="keyword">protected</span>:
00240   <span class="keyword">struct </span>Element
00241   {
00242     <span class="keyword">const</span> K key;
00243     T value;
00244 
00245     Element (<span class="keyword">const</span> K&amp; key0, <span class="keyword">const</span> T &amp;value0) : key (key0), value (value0) {}
00246     Element (<span class="keyword">const</span> Element &amp;other) : key (other.key), value (other.value) {}
00247   };
00248   <a class="code" href="classcsArray.html">csArray&lt; csArray&lt;Element&gt;</a> &gt; Elements;
00249 
00250   size_t Modulo;
00251 
00252 <span class="keyword">private</span>:
00253   size_t InitModulo;
00254   size_t GrowRate;
00255   size_t MaxSize;
00256   size_t Size;
00257 
00258   <span class="keywordtype">void</span> Grow ()
00259   {
00260     <span class="keyword">static</span> <span class="keyword">const</span> size_t Primes[] =
00261     {
00262       53,         97,         193,       389,       769, 
00263       1543,       3079,       6151,      12289,     24593,
00264       49157,      98317,      196613,    393241,    786433,
00265       1572869,    3145739,    6291469,   12582917,  25165843,
00266       50331653,   100663319,  201326611, 402653189, 805306457,
00267       1610612741, 0
00268     };
00269 
00270     <span class="keyword">const</span> size_t *p;
00271     size_t elen = Elements.<a class="code" href="classcsArray.html#a5">Length</a> ();
00272     <span class="keywordflow">for</span> (p = Primes; *p &amp;&amp; *p &lt;= elen; p++) ;
00273     Modulo = *p;
00274     CS_ASSERT (Modulo);
00275 
00276     Elements.<a class="code" href="classcsArray.html#a10">SetLength</a>(Modulo, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>(0, MIN(Modulo / GrowRate, 8)));
00277 
00278     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00279     {
00280       <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; src = Elements[i];
00281       size_t slen = src.<a class="code" href="classcsArray.html#a5">Length</a> ();
00282       <span class="keywordflow">for</span> (size_t j = slen; j &gt; 0; j--)
00283       {
00284         <span class="keyword">const</span> Element&amp; srcElem = src[j - 1];
00285         <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; dst = 
00286           Elements.<a class="code" href="classcsArray.html#a12">Get</a> (<a class="code" href="classcsHashComputer.html">csHashComputer&lt;K&gt;</a>::ComputeHash (srcElem.key) % Modulo);
00287         <span class="keywordflow">if</span> (&amp;src != &amp;dst)
00288         {
00289           dst.<a class="code" href="classcsArray.html#a19">Push</a> (srcElem);
00290           src.<a class="code" href="classcsArray.html#a38">DeleteIndex</a> (j - 1);
00291         }
00292       }
00293     }
00294   }
00295 
00296 <span class="keyword">public</span>:
<a name="l00311"></a><a class="code" href="classcsHash.html#a0">00311</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (size_t size = 23, size_t grow_rate = 5, size_t max_size = 20000)
00312     : Elements (size), Modulo (size), InitModulo (size),
00313       GrowRate (MIN (grow_rate, size)), MaxSize (max_size), Size (0)
00314   {
00315     Elements.<a class="code" href="classcsArray.html#a10">SetLength</a> (size, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> (0, MIN (size / GrowRate, 8)));
00316   }
00317 
<a name="l00319"></a><a class="code" href="classcsHash.html#a1">00319</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T&gt;</a> &amp;o) : Elements (o.Elements),
00320     Modulo (o.Modulo), InitModulo (o.InitModulo),
00321     GrowRate (o.GrowRate), MaxSize (o.MaxSize), Size (o.Size) {}
00322 
<a name="l00330"></a><a class="code" href="classcsHash.html#a2">00330</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a2">Put</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00331   {
00332     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00333       Elements[<a class="code" href="classcsHashComputer.html#e0">csHashComputer&lt;K&gt;::ComputeHash</a> (key) % Modulo];
00334     values.<a class="code" href="classcsArray.html#a19">Push</a> (Element (key, value));
00335     Size++;
00336     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a5">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a5">Length</a> () / GrowRate
00337      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a5">Length</a> () &lt; MaxSize) Grow ();
00338   }
00339 
<a name="l00341"></a><a class="code" href="classcsHash.html#a3">00341</a>   <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> <a class="code" href="classcsHash.html#a3">GetAll</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00342 <span class="keyword">  </span>{
00343     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00344       Elements[<a class="code" href="classcsHashComputer.html#e0">csHashComputer&lt;K&gt;::ComputeHash</a> (key) % Modulo];
00345     <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> ret (values.<a class="code" href="classcsArray.html#a5">Length</a> () / 2);
00346     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00347     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00348     {
00349       <span class="keyword">const</span> Element&amp; v = values[i];
00350       <span class="keywordflow">if</span> (<a class="code" href="classcsComparator.html">csComparator&lt;K, K&gt;</a>::Compare (v.key, key) == 0) 
00351         ret.<a class="code" href="classcsArray.html#a19">Push</a> (v.value);
00352     }
00353     <span class="keywordflow">return</span> ret;
00354   }
00355 
<a name="l00357"></a><a class="code" href="classcsHash.html#a4">00357</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a4">PutUnique</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00358   {
00359     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00360       Elements[<a class="code" href="classcsHashComputer.html#e0">csHashComputer&lt;K&gt;::ComputeHash</a> (key) % Modulo];
00361     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00362     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00363     {
00364       Element&amp; v = values[i];
00365       <span class="keywordflow">if</span> (<a class="code" href="classcsComparator.html">csComparator&lt;K, K&gt;</a>::Compare (v.key, key) == 0)
00366       {
00367         v.value = value;
00368         <span class="keywordflow">return</span>;
00369       }
00370     }
00371 
00372     values.<a class="code" href="classcsArray.html#a19">Push</a> (Element (key, value));
00373     Size++;
00374     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a5">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a5">Length</a> () / GrowRate
00375      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a5">Length</a> () &lt; MaxSize) Grow ();
00376   }
00377 
<a name="l00382"></a><a class="code" href="classcsHash.html#a5">00382</a>   CS_DEPRECATED_METHOD <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a5">PutFirst</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00383   {
00384     <a class="code" href="classcsHash.html#a4">PutUnique</a>(key, value);
00385   }
00386 
<a name="l00388"></a><a class="code" href="classcsHash.html#a6">00388</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a6">Contains</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00389 <span class="keyword">  </span>{
00390     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00391       Elements[<a class="code" href="classcsHashComputer.html#e0">csHashComputer&lt;K&gt;::ComputeHash</a> (key) % Modulo];
00392     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00393     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00394       <span class="keywordflow">if</span> (<a class="code" href="classcsComparator.html">csComparator&lt;K, K&gt;</a>::Compare (values[i].key, key) == 0) 
00395         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00396     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00397   }
00398 
<a name="l00404"></a><a class="code" href="classcsHash.html#a7">00404</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a7">In</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00405 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classcsHash.html#a6">Contains</a>(key); }
00406 
<a name="l00411"></a><a class="code" href="classcsHash.html#a8">00411</a>   <span class="keyword">const</span> T* <a class="code" href="classcsHash.html#a8">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00412 <span class="keyword">  </span>{
00413     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00414       Elements[<a class="code" href="classcsHashComputer.html#e0">csHashComputer&lt;K&gt;::ComputeHash</a> (key) % Modulo];
00415     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00416     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00417     {
00418       <span class="keyword">const</span> Element&amp; v = values[i];
00419       <span class="keywordflow">if</span> (<a class="code" href="classcsComparator.html">csComparator&lt;K, K&gt;</a>::Compare (v.key, key) == 0)
00420         <span class="keywordflow">return</span> &amp;v.value;
00421     }
00422 
00423     <span class="keywordflow">return</span> 0;
00424   }
00425 
<a name="l00430"></a><a class="code" href="classcsHash.html#a9">00430</a>   T* <a class="code" href="classcsHash.html#a8">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)
00431   {
00432     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00433       Elements[<a class="code" href="classcsHashComputer.html#e0">csHashComputer&lt;K&gt;::ComputeHash</a> (key) % Modulo];
00434     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00435     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00436     {
00437       Element&amp; v = values[i];
00438       <span class="keywordflow">if</span> (<a class="code" href="classcsComparator.html">csComparator&lt;K, K&gt;</a>::Compare (v.key, key) == 0)
00439         <span class="keywordflow">return</span> &amp;v.value;
00440     }
00441 
00442     <span class="keywordflow">return</span> 0;
00443   }
00444 
<a name="l00449"></a><a class="code" href="classcsHash.html#a10">00449</a>   <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash.html#a10">Get</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T&amp; fallback)<span class="keyword"> const</span>
00450 <span class="keyword">  </span>{
00451     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00452       Elements[<a class="code" href="classcsHashComputer.html#e0">csHashComputer&lt;K&gt;::ComputeHash</a> (key) % Modulo];
00453     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00454     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00455     {
00456       <span class="keyword">const</span> Element&amp; v = values[i];
00457       <span class="keywordflow">if</span> (<a class="code" href="classcsComparator.html">csComparator&lt;K, K&gt;</a>::Compare (v.key, key) == 0)
00458         <span class="keywordflow">return</span> v.value;
00459     }
00460 
00461     <span class="keywordflow">return</span> fallback;
00462   }
00463 
<a name="l00468"></a><a class="code" href="classcsHash.html#a11">00468</a>   T&amp; <a class="code" href="classcsHash.html#a10">Get</a> (<span class="keyword">const</span> K&amp; key, T&amp; fallback)
00469   {
00470     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00471       Elements[<a class="code" href="classcsHashComputer.html#e0">csHashComputer&lt;K&gt;::ComputeHash</a> (key) % Modulo];
00472     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00473     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00474     {
00475       Element&amp; v = values[i];
00476       <span class="keywordflow">if</span> (<a class="code" href="classcsComparator.html">csComparator&lt;K, K&gt;</a>::Compare (v.key, key) == 0)
00477         <span class="keywordflow">return</span> v.value;
00478     }
00479 
00480     <span class="keywordflow">return</span> fallback;
00481   }
00482 
<a name="l00484"></a><a class="code" href="classcsHash.html#a12">00484</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a12">DeleteAll</a> ()
00485   {
00486     Elements.<a class="code" href="classcsArray.html#a10">SetLength</a> (Modulo = InitModulo);
00487     size_t elen = Elements.<a class="code" href="classcsArray.html#a5">Length</a> ();
00488     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00489       Elements[i].<a class="code" href="classcsArray.html#a34">Empty</a> ();
00490     Size = 0;
00491   }
00492 
<a name="l00494"></a><a class="code" href="classcsHash.html#a13">00494</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a13">Empty</a>() { <a class="code" href="classcsHash.html#a12">DeleteAll</a>(); }
00495 
<a name="l00497"></a><a class="code" href="classcsHash.html#a14">00497</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a12">DeleteAll</a> (<span class="keyword">const</span> K&amp; key)
00498   {
00499     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00500     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00501       Elements[<a class="code" href="classcsHashComputer.html#e0">csHashComputer&lt;K&gt;::ComputeHash</a> (key) % Modulo];
00502     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a5">Length</a> (); i &gt; 0; i--)
00503     {
00504       <span class="keyword">const</span> size_t idx = i - 1;
00505       <span class="keywordflow">if</span> (<a class="code" href="classcsComparator.html">csComparator&lt;K, K&gt;</a>::Compare (values[idx].key, key) == 0)
00506       {
00507         values.<a class="code" href="classcsArray.html#a39">DeleteIndexFast</a> (idx);
00508         ret = <span class="keyword">true</span>;
00509         Size--;
00510       }
00511     }
00512     <span class="keywordflow">return</span> ret;
00513   }
00514   
<a name="l00516"></a><a class="code" href="classcsHash.html#a15">00516</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a15">Delete</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00517   {
00518     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00519     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00520       Elements[<a class="code" href="classcsHashComputer.html#e0">csHashComputer&lt;K&gt;::ComputeHash</a> (key) % Modulo];
00521     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a5">Length</a> (); i &gt; 0; i--)
00522     {
00523       <span class="keyword">const</span> size_t idx = i - 1;
00524       <span class="keywordflow">if</span> ((<a class="code" href="classcsComparator.html">csComparator&lt;K, K&gt;</a>::Compare (values[idx].key, key) == 0) &amp;&amp; 
00525         (values[idx].value == value))
00526       {
00527         values.<a class="code" href="classcsArray.html#a39">DeleteIndexFast</a> (idx);
00528         ret = <span class="keyword">true</span>;
00529         Size--;
00530       }
00531     }
00532     <span class="keywordflow">return</span> ret;
00533   }
00534 
<a name="l00536"></a><a class="code" href="classcsHash.html#a16">00536</a>   size_t <a class="code" href="classcsHash.html#a16">GetSize</a> ()<span class="keyword"> const</span>
00537 <span class="keyword">  </span>{
00538     <span class="keywordflow">return</span> Size;
00539   }
00540 
<a name="l00546"></a><a class="code" href="classcsHash.html#a17">00546</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a17">IsEmpty</a>()<span class="keyword"> const</span>
00547 <span class="keyword">  </span>{
00548     <span class="keywordflow">return</span> <a class="code" href="classcsHash.html#a16">GetSize</a>() == 0;
00549   }
00550 
<a name="l00552"></a><a class="code" href="classcsHash_1_1Iterator.html">00552</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>
00553   {
00554   <span class="keyword">private</span>:
00555     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K&gt;</a>* hash;
00556     <span class="keyword">const</span> K key;
00557     size_t bucket, size, element;
00558 
00559     <span class="keywordtype">void</span> Seek ()
00560     {
00561       <span class="keywordflow">while</span> ((element &lt; size) &amp;&amp; 
00562         (<a class="code" href="classcsComparator.html">csComparator&lt;K, K&gt;</a>::Compare (hash-&gt;Elements[bucket][element].key, 
00563         key) != 0))
00564           element++;
00565     }
00566 
00567   <span class="keyword">protected</span>:
00568     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K&gt;</a>* hash0, <span class="keyword">const</span> K&amp; key0) :
00569       hash(hash0),
00570       key(key0), 
00571       bucket(<a class="code" href="classcsHashComputer.html">csHashComputer&lt;K&gt;</a>::ComputeHash (key) % hash-&gt;Modulo),
00572       size(hash-&gt;Elements[bucket].Length ())
00573       { <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> (); }
00574 
00575     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>&lt;T, K&gt;;
00576   <span class="keyword">public</span>:
<a name="l00578"></a><a class="code" href="classcsHash_1_1Iterator.html#a0">00578</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00579       hash (o.hash),
00580       key(o.key),
00581       bucket(o.bucket),
00582       size(o.size),
00583       element(o.element) {}
00584 
<a name="l00586"></a><a class="code" href="classcsHash_1_1Iterator.html#a1">00586</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; <a class="code" href="classcsHash_1_1Iterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; o)
00587     {
00588       hash = o.<a class="code" href="classcsHash_1_1Iterator.html#r0">hash</a>;
00589       key = o.<a class="code" href="classcsHash_1_1Iterator.html#r1">key</a>;
00590       bucket = o.<a class="code" href="classcsHash_1_1Iterator.html#r2">bucket</a>;
00591       size = o.<a class="code" href="classcsHash_1_1Iterator.html#r3">size</a>;
00592       element = o.<a class="code" href="classcsHash_1_1Iterator.html#r4">element</a>;
00593       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00594     }
00595 
<a name="l00597"></a><a class="code" href="classcsHash_1_1Iterator.html#a2">00597</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1Iterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00598 <span class="keyword">    </span>{
00599       <span class="keywordflow">return</span> element &lt; size;
00600     }
00601 
<a name="l00603"></a><a class="code" href="classcsHash_1_1Iterator.html#a3">00603</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1Iterator.html#a3">Next</a> ()
00604     {
00605       <span class="keyword">const</span> T &amp;ret = hash-&gt;Elements[bucket][element].value;
00606       element++;
00607       Seek ();
00608       <span class="keywordflow">return</span> ret;
00609     }
00610 
<a name="l00612"></a><a class="code" href="classcsHash_1_1Iterator.html#a4">00612</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> () { element = 0; Seek (); }
00613   };
00614   <span class="keyword">friend</span> <span class="keyword">class </span>Iterator;
00615 
<a name="l00617"></a><a class="code" href="classcsHash_1_1GlobalIterator.html">00617</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>
00618   {
00619   <span class="keyword">private</span>:
00620     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K&gt;</a> *hash;
00621     size_t bucket, size, element;
00622 
00623     <span class="keywordtype">void</span> Zero () { bucket = element = 0; }
00624     <span class="keywordtype">void</span> Init () { size = hash-&gt;Elements[bucket].Length (); }
00625 
00626     <span class="keywordtype">void</span> FindItem ()
00627     {
00628       <span class="keywordflow">if</span> (element &gt;= size)
00629       {
00630         <span class="keywordflow">while</span> (++bucket &lt; hash-&gt;Elements.Length ())
00631         {
00632           Init ();
00633           <span class="keywordflow">if</span> (size != 0)
00634           {
00635             element = 0;
00636             <span class="keywordflow">break</span>;
00637           }
00638         }
00639       }
00640     }
00641 
00642   <span class="keyword">protected</span>:
00643     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K&gt;</a> *hash0) : hash (hash0) 
00644     { 
00645       Zero (); 
00646       Init (); 
00647       FindItem ();
00648     }
00649 
00650     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>&lt;T, K&gt;;
00651   <span class="keyword">public</span>:
<a name="l00653"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a0">00653</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00654       hash (o.hash),
00655       bucket (o.bucket),
00656       size (o.size),
00657       element (o.element) {}
00658 
<a name="l00660"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a1">00660</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; o)
00661     {
00662       hash = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r0">hash</a>;
00663       bucket = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r1">bucket</a>;
00664       size = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r2">size</a>;
00665       element = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r3">element</a>;
00666       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00667     }
00668 
<a name="l00670"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a2">00670</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00671 <span class="keyword">    </span>{
00672       <span class="keywordflow">if</span> (hash-&gt;Elements.Length () == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00673       <span class="keywordflow">return</span> element &lt; size || bucket &lt; hash-&gt;Elements.Length ();
00674     }
00675 
<a name="l00677"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a3">00677</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ()
00678     {
00679       element++;
00680       FindItem ();
00681     }
00682 
<a name="l00684"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a4">00684</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ()
00685     {
00686       <span class="keywordflow">return</span> hash-&gt;Elements[bucket][element].value;
00687     }
00688 
<a name="l00690"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a5">00690</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ()
00691     {
00692       <span class="keyword">const</span> T &amp;ret = <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00693       <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ();
00694       <span class="keywordflow">return</span> ret;
00695     }
00696 
<a name="l00698"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a6">00698</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> (K &amp;key)
00699     {
00700       key = hash-&gt;Elements[bucket][element].key;
00701       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00702     }
00703 
<a name="l00705"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a7">00705</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> (K &amp;key)
00706     {
00707       key = hash-&gt;Elements[bucket][element].key;
00708       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ();
00709     }
00710 
<a name="l00712"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a8">00712</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a8">Reset</a> () { Zero (); Init (); FindItem (); }
00713   };
00714   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00715 
<a name="l00718"></a><a class="code" href="classcsHash.html#a18">00718</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a18">DeleteElement</a> (GlobalIterator&amp; iterator)
00719   {
00720     Elements[iterator.bucket].<a class="code" href="classcsArray.html#a38">DeleteIndex</a>(iterator.element);
00721     Size--;
00722     iterator.size--;
00723     iterator.FindItem ();
00724   }
00725 
<a name="l00732"></a><a class="code" href="classcsHash.html#a19">00732</a>   Iterator <a class="code" href="classcsHash.html#a20">GetIterator</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00733 <span class="keyword">  </span>{
00734     <span class="keywordflow">return</span> Iterator (<span class="keyword">this</span>, key);
00735   }
00736 
<a name="l00742"></a><a class="code" href="classcsHash.html#a20">00742</a>   GlobalIterator <a class="code" href="classcsHash.html#a20">GetIterator</a> ()<span class="keyword"> const</span>
00743 <span class="keyword">  </span>{
00744     <span class="keywordflow">return</span> GlobalIterator (<span class="keyword">this</span>);
00745   }
00746 };
00747 
00750 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.2 
</small></address> </div></body> </html>
