<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/hash.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>csutil/hash.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2003 by Mat Sutcliffe &lt;oktal@gmx.co.uk&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_UTIL_HASH_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_UTIL_HASH_H__</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include "csextern.h"</span>
00023 <span class="preprocessor">#include "array.h"</span>
00024 
00031 CS_CSUTIL_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> csHashCompute (<span class="keywordtype">char</span> <span class="keyword">const</span>*);
00032 
00039 CS_CSUTIL_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> csHashCompute (<span class="keywordtype">char</span> <span class="keyword">const</span>*, size_t length);
00040 
00044 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00045"></a><a class="code" href="classcsIntegralHashKeyHandler.html">00045</a> <span class="keyword">class </span><a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler</a>
00046 {
00047 <span class="keyword">public</span>:
00048   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ComputeHash (<span class="keyword">const</span> T&amp; key)
00049   {
00050 <span class="preprocessor">#if (_MSC_VER &gt;= 1300)</span>
00051 <span class="preprocessor"></span>    <span class="comment">/*</span>
00052 <span class="comment">      VC7 with 64bit warnings complains about a pointer truncation when T is</span>
00053 <span class="comment">      a pointer. This isn't serious (as csHash&lt;&gt; does not rely on the hash of</span>
00054 <span class="comment">      a key alone to retrieve a value). The __w64 causes VC7 to not emit that</span>
00055 <span class="comment">      warning (on 32bit compilers at least).</span>
00056 <span class="comment">     */</span>
00057     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __w64)key;  
00058 <span class="preprocessor">#else</span>
00059 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)key;  
00060 <span class="preprocessor">#endif</span>
00061 <span class="preprocessor"></span>  }
00062 
00063   <span class="keyword">static</span> <span class="keywordtype">bool</span> CompareKeys (<span class="keyword">const</span> T&amp; key1, <span class="keyword">const</span> T&amp; key2)
00064   {
00065     <span class="keywordflow">return</span> (key1 == key2);
00066   }
00067 };
00068 
00073 <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>K = <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, 
00074   <span class="keyword">class </span>KeyHandler = <a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler&lt;K&gt;</a> &gt; 
<a name="l00075"></a><a class="code" href="classcsHash.html">00075</a> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>
00076 {
00077 <span class="keyword">protected</span>:
00078   <span class="keyword">struct </span>Element
00079   {
00080     <span class="keyword">const</span> K key;
00081     T value;
00082 
00083     Element (<span class="keyword">const</span> K&amp; key0, <span class="keyword">const</span> T &amp;value0) : key (key0), value (value0) {}
00084     Element (<span class="keyword">const</span> Element &amp;other) : key (other.key), value (other.value) {}
00085   };
00086   <a class="code" href="classcsArray.html">csArray&lt; csArray&lt;Element&gt;</a> &gt; Elements;
00087 
00088   size_t Modulo;
00089 
00090 <span class="keyword">private</span>:
00091   size_t InitModulo;
00092   size_t GrowRate;
00093   size_t MaxSize;
00094   size_t Size;
00095 
00096   <span class="keywordtype">void</span> Grow ()
00097   {
00098     <span class="keyword">static</span> <span class="keyword">const</span> size_t Primes[] =
00099     {
00100       53,         97,         193,       389,       769, 
00101       1543,       3079,       6151,      12289,     24593,
00102       49157,      98317,      196613,    393241,    786433,
00103       1572869,    3145739,    6291469,   12582917,  25165843,
00104       50331653,   100663319,  201326611, 402653189, 805306457,
00105       1610612741, 0
00106     };
00107 
00108     <span class="keyword">const</span> size_t *p;
00109     size_t elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00110     <span class="keywordflow">for</span> (p = Primes; *p &amp;&amp; *p &lt;= elen; p++) ;
00111     Modulo = *p;
00112     CS_ASSERT (Modulo);
00113 
00114     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo);
00115 
00116     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00117     {
00118       <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; src = Elements[i];
00119       size_t slen = src.<a class="code" href="classcsArray.html#a4">Length</a> ();
00120       <span class="keywordflow">for</span> (size_t j = slen; j &gt; 0; j--)
00121       {
00122         <span class="keyword">const</span> Element&amp; srcElem = src[j - 1];
00123         <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; dst = 
00124           Elements.<a class="code" href="classcsArray.html#a9">Get</a> (KeyHandler::ComputeHash (srcElem.key) % Modulo);
00125         <span class="keywordflow">if</span> (&amp;src != &amp;dst)
00126         {
00127           dst.Push (srcElem);
00128           src.DeleteIndex (j - 1);
00129         }
00130       }
00131     }
00132   }
00133 
00134 <span class="keyword">public</span>:
<a name="l00148"></a><a class="code" href="classcsHash.html#a0">00148</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keywordtype">int</span> size = 257, <span class="keywordtype">int</span> grow_rate = 64, <span class="keywordtype">int</span> max_size = 20000)
00149     : Elements (size), Modulo (size), InitModulo (size),
00150       GrowRate (grow_rate), MaxSize (max_size), Size (0)
00151   {
00152     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (size, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> (0, 8));
00153   }
00154 
<a name="l00156"></a><a class="code" href="classcsHash.html#a1">00156</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T&gt;</a> &amp;o) : Elements (o.Elements),
00157     Modulo (o.Modulo), InitModulo (o.InitModulo),
00158     GrowRate (o.GrowRate), MaxSize (o.MaxSize), Size (o.Size) {}
00159 
<a name="l00161"></a><a class="code" href="classcsHash.html#a2">00161</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a2">Put</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00162   {
00163     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00164       Elements[KeyHandler::ComputeHash (key) % Modulo];
00165     values.Push (Element (key, value));
00166     Size++;
00167     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00168      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00169   }
00170 
<a name="l00172"></a><a class="code" href="classcsHash.html#a3">00172</a>   <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> <a class="code" href="classcsHash.html#a3">GetAll</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00173 <span class="keyword">  </span>{
00174     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00175       Elements[KeyHandler::ComputeHash (key) % Modulo];
00176     <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> ret (values.<a class="code" href="classcsArray.html#a4">Length</a> () / 2);
00177     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00178     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00179     {
00180       <span class="keyword">const</span> Element&amp; v = values[i];
00181       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key)) 
00182         ret.Push (v.value);
00183     }
00184     <span class="keywordflow">return</span> ret;
00185   }
00186 
<a name="l00188"></a><a class="code" href="classcsHash.html#a4">00188</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a4">PutFirst</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00189   {
00190     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00191       Elements[KeyHandler::ComputeHash (key) % Modulo];
00192     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00193     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00194     {
00195       Element&amp; v = values[i];
00196       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00197       {
00198         v.value = value;
00199         <span class="keywordflow">return</span>;
00200       }
00201     }
00202 
00203     values.Push (Element (key, value));
00204     Size++;
00205     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00206      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00207   }
00208 
<a name="l00210"></a><a class="code" href="classcsHash.html#a5">00210</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a5">In</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00211 <span class="keyword">  </span>{
00212     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00213       Elements[KeyHandler::ComputeHash (key) % Modulo];
00214     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00215     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00216       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key)) 
00217         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00218 
00219     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00220   }
00221 
<a name="l00226"></a><a class="code" href="classcsHash.html#a6">00226</a>   <span class="keyword">const</span> T* <a class="code" href="classcsHash.html#a6">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00227 <span class="keyword">  </span>{
00228     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00229       Elements[KeyHandler::ComputeHash (key) % Modulo];
00230     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00231     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00232     {
00233       <span class="keyword">const</span> Element&amp; v = values[i];
00234       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00235         <span class="keywordflow">return</span> &amp;v.value;
00236     }
00237 
00238     <span class="keywordflow">return</span> 0;
00239   }
00240 
<a name="l00245"></a><a class="code" href="classcsHash.html#a7">00245</a>   T* <a class="code" href="classcsHash.html#a6">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)
00246   {
00247     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00248       Elements[KeyHandler::ComputeHash (key) % Modulo];
00249     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00250     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00251     {
00252       Element&amp; v = values[i];
00253       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00254         <span class="keywordflow">return</span> &amp;v.value;
00255     }
00256 
00257     <span class="keywordflow">return</span> 0;
00258   }
00259 
<a name="l00264"></a><a class="code" href="classcsHash.html#a8">00264</a>   <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash.html#a8">Get</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T&amp; fallback)<span class="keyword"> const</span>
00265 <span class="keyword">  </span>{
00266     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00267       Elements[KeyHandler::ComputeHash (key) % Modulo];
00268     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00269     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00270     {
00271       <span class="keyword">const</span> Element&amp; v = values[i];
00272       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00273         <span class="keywordflow">return</span> v.value;
00274     }
00275 
00276     <span class="keywordflow">return</span> fallback;
00277   }
00278 
<a name="l00283"></a><a class="code" href="classcsHash.html#a9">00283</a>   T&amp; <a class="code" href="classcsHash.html#a8">Get</a> (<span class="keyword">const</span> K&amp; key, T&amp; fallback)
00284   {
00285     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00286       Elements[KeyHandler::ComputeHash (key) % Modulo];
00287     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00288     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00289     {
00290       Element&amp; v = values[i];
00291       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00292         <span class="keywordflow">return</span> v.value;
00293     }
00294 
00295     <span class="keywordflow">return</span> fallback;
00296   }
00297 
<a name="l00299"></a><a class="code" href="classcsHash.html#a10">00299</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a10">DeleteAll</a> ()
00300   {
00301     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo = InitModulo);
00302     size_t elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00303     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00304       Elements[i].Empty ();
00305     Size = 0;
00306   }
00307 
<a name="l00309"></a><a class="code" href="classcsHash.html#a11">00309</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a10">DeleteAll</a> (<span class="keyword">const</span> K&amp; key)
00310   {
00311     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00312     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00313       Elements[KeyHandler::ComputeHash (key) % Modulo];
00314     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a4">Length</a> (); i &gt; 0; i--)
00315     {
00316       <span class="keyword">const</span> size_t idx = i - 1;
00317       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[idx].key, key))
00318       {
00319         values.DeleteIndex (idx);
00320         ret = <span class="keyword">true</span>;
00321         Size--;
00322       }
00323     }
00324     <span class="keywordflow">return</span> ret;
00325   }
00326   
<a name="l00328"></a><a class="code" href="classcsHash.html#a12">00328</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a12">Delete</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00329   {
00330     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00331     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00332       Elements[KeyHandler::ComputeHash (key) % Modulo];
00333     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a4">Length</a> (); i &gt; 0; i--)
00334     {
00335       <span class="keyword">const</span> size_t idx = i - 1;
00336       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[idx].key, key) &amp;&amp; 
00337         (values[idx].value == value))
00338       {
00339         values.DeleteIndex (idx);
00340         ret = <span class="keyword">true</span>;
00341         Size--;
00342       }
00343     }
00344     <span class="keywordflow">return</span> ret;
00345   }
00346 
<a name="l00348"></a><a class="code" href="classcsHash.html#a13">00348</a>   size_t <a class="code" href="classcsHash.html#a13">GetSize</a> ()<span class="keyword"> const</span>
00349 <span class="keyword">  </span>{
00350     <span class="keywordflow">return</span> Size;
00351   }
00352 
<a name="l00354"></a><a class="code" href="classcsHash_1_1Iterator.html">00354</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>
00355   {
00356   <span class="keyword">private</span>:
00357     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash;
00358     <span class="keyword">const</span> K key;
00359     <span class="keywordtype">int</span> bucket, size, element;
00360 
00361     <span class="keywordtype">void</span> Seek ()
00362     {
00363       <span class="keywordflow">while</span> ((element &lt; size) &amp;&amp; 
00364         ! KeyHandler::CompareKeys (hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key, key))
00365           element++;
00366     }
00367 
00368   <span class="keyword">protected</span>:
00369     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash0, <span class="keyword">const</span> K&amp; key0) :
00370       hash(hash0),
00371       key(key0), 
00372       bucket(KeyHandler::ComputeHash(key) % hash-&gt;<a class="code" href="classcsHash.html#n1">Modulo</a>),
00373       size(hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket].Length ())
00374       { <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> (); }
00375 
00376     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>;
00377   <span class="keyword">public</span>:
<a name="l00379"></a><a class="code" href="classcsHash_1_1Iterator.html#a0">00379</a>     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00380       hash (o.hash),
00381       key(o.key),
00382       bucket(o.bucket),
00383       size(o.size),
00384       element(o.element) {}
00385 
<a name="l00387"></a><a class="code" href="classcsHash_1_1Iterator.html#a1">00387</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; <a class="code" href="classcsHash_1_1Iterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; o)
00388     {
00389       hash = o.<a class="code" href="classcsHash_1_1Iterator.html#o0">hash</a>;
00390       key = o.<a class="code" href="classcsHash_1_1Iterator.html#o1">key</a>;
00391       bucket = o.<a class="code" href="classcsHash_1_1Iterator.html#o2">bucket</a>;
00392       size = o.<a class="code" href="classcsHash_1_1Iterator.html#o3">size</a>;
00393       element = o.<a class="code" href="classcsHash_1_1Iterator.html#o4">element</a>;
00394       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00395     }
00396 
<a name="l00398"></a><a class="code" href="classcsHash_1_1Iterator.html#a2">00398</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1Iterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00399 <span class="keyword">    </span>{
00400       <span class="keywordflow">return</span> element &lt; size;
00401     }
00402 
<a name="l00404"></a><a class="code" href="classcsHash_1_1Iterator.html#a3">00404</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1Iterator.html#a3">Next</a> ()
00405     {
00406       <span class="keyword">const</span> T &amp;ret = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].value;
00407       element++;
00408       Seek ();
00409       <span class="keywordflow">return</span> ret;
00410     }
00411 
<a name="l00413"></a><a class="code" href="classcsHash_1_1Iterator.html#a4">00413</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> () { element = 0; Seek (); }
00414   };
00415   <span class="keyword">friend</span> <span class="keyword">class </span>Iterator;
00416 
<a name="l00418"></a><a class="code" href="classcsHash_1_1GlobalIterator.html">00418</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>
00419   {
00420   <span class="keyword">private</span>:
00421     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash;
00422     size_t bucket, size, element;
00423 
00424     <span class="keywordtype">void</span> Zero () { bucket = element = 0; }
00425     <span class="keywordtype">void</span> Init () { size = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket].Length (); }
00426 
00427     <span class="keywordtype">void</span> FindItem ()
00428     {
00429       <span class="keywordflow">if</span> (element &gt;= size)
00430       {
00431         <span class="keywordflow">while</span> (++bucket &lt; hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> ())
00432         {
00433           Init ();
00434           <span class="keywordflow">if</span> (size != 0)
00435           {
00436             element = 0;
00437             <span class="keywordflow">break</span>;
00438           }
00439         }
00440       }
00441     }
00442 
00443   <span class="keyword">protected</span>:
00444     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash0) : hash (hash0) 
00445     { 
00446       Zero (); 
00447       Init (); 
00448       FindItem ();
00449     }
00450 
00451     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>;
00452   <span class="keyword">public</span>:
<a name="l00454"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a0">00454</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00455       hash (o.hash),
00456       bucket (o.bucket),
00457       size (o.size),
00458       element (o.element) {}
00459 
<a name="l00461"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a1">00461</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; o)
00462     {
00463       hash = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o0">hash</a>;
00464       bucket = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o1">bucket</a>;
00465       size = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o2">size</a>;
00466       element = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o3">element</a>;
00467       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00468     }
00469 
<a name="l00471"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a2">00471</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00472 <span class="keyword">    </span>{
00473       <span class="keywordflow">if</span> (hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> () == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00474       <span class="keywordflow">return</span> element &lt; size || bucket &lt; hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> ();
00475     }
00476 
<a name="l00478"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a3">00478</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ()
00479     {
00480       element++;
00481       FindItem ();
00482     }
00483 
<a name="l00485"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a4">00485</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ()
00486     {
00487       <span class="keywordflow">return</span> hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].value;
00488     }
00489 
<a name="l00491"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a5">00491</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ()
00492     {
00493       <span class="keyword">const</span> T &amp;ret = <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00494       <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ();
00495       <span class="keywordflow">return</span> ret;
00496     }
00497 
00498     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> (K &amp;key)
00499     {
00500       key = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key;
00501       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00502     }
00503 
<a name="l00505"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a7">00505</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> (K &amp;key)
00506     {
00507       key = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key;
00508       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ();
00509     }
00510 
<a name="l00512"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a8">00512</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a8">Reset</a> () { Zero (); Init (); FindItem (); }
00513   };
00514   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00515 
<a name="l00518"></a><a class="code" href="classcsHash.html#a14">00518</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a14">DeleteElement</a> (GlobalIterator iterator)
00519   {
00520     Elements[iterator.bucket].DeleteIndex(iterator.element);
00521     Size--;
00522     iterator.size--;
00523     iterator.FindItem ();
00524   }
00525 
<a name="l00532"></a><a class="code" href="classcsHash.html#a15">00532</a>   Iterator <a class="code" href="classcsHash.html#a16">GetIterator</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00533 <span class="keyword">  </span>{
00534     <span class="keywordflow">return</span> Iterator (<span class="keyword">this</span>, key);
00535   }
00536 
<a name="l00542"></a><a class="code" href="classcsHash.html#a16">00542</a>   GlobalIterator <a class="code" href="classcsHash.html#a16">GetIterator</a> ()<span class="keyword"> const</span>
00543 <span class="keyword">  </span>{
00544     <span class="keywordflow">return</span> GlobalIterator (<span class="keyword">this</span>);
00545   }
00546 };
00547 
00553 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> KeyHandler = csIntegralHashKeyHandler&lt;T&gt; &gt; 
<a name="l00554"></a><a class="code" href="classcsSet.html">00554</a> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>
00555 {
00556 <span class="keyword">private</span>:
00557   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a> map;
00558 
00559 <span class="keyword">public</span>:
<a name="l00561"></a><a class="code" href="classcsSet_1_1Iterator.html">00561</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1Iterator.html">Iterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1Iterator.html">Iterator</a>
00562   {
00563   <span class="keyword">protected</span>:
00564     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> () {}
00565   <span class="keyword">public</span>:
00566   };
<a name="l00568"></a><a class="code" href="classcsSet_1_1GlobalIterator.html">00568</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>
00569   {
00570   <span class="keyword">protected</span>:
00571     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> () {}
00572     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsSet.html">csSet&lt;T, KeyHandler&gt;</a> *set0) : 
00573       <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;::GlobalIterator</a>(&amp;set0-&gt;map)
00574     { }
00575 
00576   <span class="keyword">public</span>:
00577     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>;
00578   };
00579   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00580 
<a name="l00585"></a><a class="code" href="classcsSet.html#a0">00585</a>   <a class="code" href="classcsSet.html#a0">csSet</a> (<span class="keywordtype">int</span> size = 257, <span class="keywordtype">int</span> grow_rate = 64, <span class="keywordtype">int</span> max_size = 20000)
00586         : map (size, grow_rate, max_size)
00587   {
00588   }
00589 
<a name="l00594"></a><a class="code" href="classcsSet.html#a1">00594</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a1">Add</a> (<span class="keyword">const</span> T&amp; object)
00595   {
00596     <span class="keywordflow">if</span> (<a class="code" href="classcsSet.html#a3">In</a> (object)) <span class="keywordflow">return</span>;
00597     <a class="code" href="classcsSet.html#a2">AddNoTest</a> (object);
00598   }
00599 
<a name="l00606"></a><a class="code" href="classcsSet.html#a2">00606</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a2">AddNoTest</a> (<span class="keyword">const</span> T&amp; object)
00607   {
00608     map.<a class="code" href="classcsHash.html#a2">Put</a> (object, object);
00609   }
00610 
<a name="l00614"></a><a class="code" href="classcsSet.html#a3">00614</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a3">In</a> (<span class="keyword">const</span> T&amp; object)<span class="keyword"> const</span>
00615 <span class="keyword">  </span>{
00616     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a5">In</a> (object);
00617   }
00618 
<a name="l00622"></a><a class="code" href="classcsSet.html#a4">00622</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a4">DeleteAll</a> ()
00623   {
00624     map.<a class="code" href="classcsHash.html#a10">DeleteAll</a> ();
00625   }
00626 
<a name="l00632"></a><a class="code" href="classcsSet.html#a5">00632</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a5">Delete</a> (<span class="keyword">const</span> T&amp; object)
00633   {
00634     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a12">Delete</a> (object, object);
00635   }
00636 
<a name="l00638"></a><a class="code" href="classcsSet.html#a6">00638</a>   size_t <a class="code" href="classcsSet.html#a6">GetSize</a> ()<span class="keyword"> const</span>
00639 <span class="keyword">  </span>{
00640     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a13">GetSize</a> ();
00641   }
00642 
<a name="l00644"></a><a class="code" href="classcsSet.html#a7">00644</a>   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a>* <a class="code" href="classcsSet.html#a7">GetHash</a> () { <span class="keywordflow">return</span> &amp;map; }
00645 
<a name="l00651"></a><a class="code" href="classcsSet.html#a8">00651</a>   <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> <a class="code" href="classcsSet.html#a8">GetIterator</a> ()<span class="keyword"> const</span>
00652 <span class="keyword">  </span>{
00653     <span class="keywordflow">return</span> <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>(<span class="keyword">this</span>);
00654   }
00655 };
00656 
00657 
00658 <span class="preprocessor">#endif</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
