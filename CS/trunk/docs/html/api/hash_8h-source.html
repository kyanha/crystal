<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/hash.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>csutil/hash.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2003 by Mat Sutcliffe &lt;oktal@gmx.co.uk&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_UTIL_HASH_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_UTIL_HASH_H__</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include "csextern.h"</span>
00023 <span class="preprocessor">#include "array.h"</span>
00024 
00031 CS_CSUTIL_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> csHashCompute (<span class="keywordtype">char</span> <span class="keyword">const</span>*);
00032 
00039 CS_CSUTIL_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> csHashCompute (<span class="keywordtype">char</span> <span class="keyword">const</span>*, size_t length);
00040 
00044 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00045"></a><a class="code" href="classcsIntegralHashKeyHandler.html">00045</a> <span class="keyword">class </span><a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler</a>
00046 {
00047 <span class="keyword">public</span>:
00048   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ComputeHash (<span class="keyword">const</span> T&amp; key)
00049   {
00050 <span class="preprocessor">#if (_MSC_VER &gt;= 1300)</span>
00051 <span class="preprocessor"></span>    <span class="comment">/*</span>
00052 <span class="comment">      VC7 with 64bit warnings complains about a pointer truncation when T is</span>
00053 <span class="comment">      a pointer. This isn't serious (as csHash&lt;&gt; does not rely on the hash of</span>
00054 <span class="comment">      a key alone to retrieve a value). The __w64 causes VC7 to not emit that</span>
00055 <span class="comment">      warning (on 32bit compilers at least).</span>
00056 <span class="comment">     */</span>
00057     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __w64)key;  
00058 <span class="preprocessor">#else</span>
00059 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)key;  
00060 <span class="preprocessor">#endif</span>
00061 <span class="preprocessor"></span>  }
00062 
00063   <span class="keyword">static</span> <span class="keywordtype">bool</span> CompareKeys (<span class="keyword">const</span> T&amp; key1, <span class="keyword">const</span> T&amp; key2)
00064   {
00065     <span class="keywordflow">return</span> (key1 == key2);
00066   }
00067 };
00068 
00073 <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>K = <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, 
00074   <span class="keyword">class </span>KeyHandler = <a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler&lt;K&gt;</a> &gt; 
<a name="l00075"></a><a class="code" href="classcsHash.html">00075</a> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>
00076 {
00077 <span class="keyword">protected</span>:
00078   <span class="keyword">struct </span>Element
00079   {
00080     <span class="keyword">const</span> K key;
00081     T value;
00082 
00083     Element (<span class="keyword">const</span> K&amp; key0, <span class="keyword">const</span> T &amp;value0) : key (key0), value (value0) {}
00084     Element (<span class="keyword">const</span> Element &amp;other) : key (other.key), value (other.value) {}
00085   };
00086   <a class="code" href="classcsArray.html">csArray&lt; csArray&lt;Element&gt;</a> &gt; Elements;
00087 
00088   <span class="keywordtype">int</span> Modulo;
00089 
00090 <span class="keyword">private</span>:
00091   <span class="keywordtype">int</span> InitModulo;
00092   <span class="keywordtype">int</span> GrowRate;
00093   <span class="keywordtype">int</span> MaxSize;
00094   <span class="keywordtype">int</span> Size;
00095 
00096   <span class="keywordtype">void</span> Grow ()
00097   {
00098     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> Primes[] =
00099     {
00100       53,         97,         193,       389,       769, 
00101       1543,       3079,       6151,      12289,     24593,
00102       49157,      98317,      196613,    393241,    786433,
00103       1572869,    3145739,    6291469,   12582917,  25165843,
00104       50331653,   100663319,  201326611, 402653189, 805306457,
00105       1610612741, 0
00106     };
00107 
00108     <span class="keyword">const</span> <span class="keywordtype">int</span> *p;
00109     <span class="keywordtype">int</span> elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00110     <span class="keywordflow">for</span> (p = Primes; *p &amp;&amp; *p &lt;= elen; p++) ;
00111     Modulo = *p;
00112     CS_ASSERT (Modulo);
00113 
00114     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo);
00115 
00116     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; elen; i++)
00117     {
00118       <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; src = Elements[i];
00119       <span class="keywordtype">int</span> slen = src.<a class="code" href="classcsArray.html#a4">Length</a> ();
00120       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = slen - 1; j &gt;= 0; j--)
00121       {
00122         <span class="keyword">const</span> Element&amp; srcElem = src[j];
00123         <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; dst = 
00124           Elements.<a class="code" href="classcsArray.html#a9">Get</a> (KeyHandler::ComputeHash (srcElem.key) % Modulo);
00125         <span class="keywordflow">if</span> (&amp;src != &amp;dst)
00126         {
00127           dst.Push (srcElem);
00128           src.DeleteIndex (j);
00129         }
00130       }
00131     }
00132   }
00133 
00134 <span class="keyword">public</span>:
<a name="l00148"></a><a class="code" href="classcsHash.html#a0">00148</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keywordtype">int</span> size = 257, <span class="keywordtype">int</span> grow_rate = 64, <span class="keywordtype">int</span> max_size = 20000)
00149     : Elements (size), Modulo (size), InitModulo (size),
00150       GrowRate (grow_rate), MaxSize (max_size), Size (0)
00151   {
00152     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (size, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> (0, 8));
00153   }
00154 
<a name="l00156"></a><a class="code" href="classcsHash.html#a1">00156</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T&gt;</a> &amp;o) : Elements (o.Elements),
00157     Modulo (o.Modulo), InitModulo (o.InitModulo),
00158     GrowRate (o.GrowRate), MaxSize (o.MaxSize), Size (o.Size) {}
00159 
<a name="l00161"></a><a class="code" href="classcsHash.html#a2">00161</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a2">Put</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00162   {
00163     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00164       Elements[KeyHandler::ComputeHash (key) % Modulo];
00165     values.Push (Element (key, value));
00166     Size++;
00167     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00168      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00169   }
00170 
<a name="l00172"></a><a class="code" href="classcsHash.html#a3">00172</a>   <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> <a class="code" href="classcsHash.html#a3">GetAll</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00173 <span class="keyword">  </span>{
00174     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00175       Elements[KeyHandler::ComputeHash (key) % Modulo];
00176     <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> ret (values.<a class="code" href="classcsArray.html#a4">Length</a> () / 2);
00177     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00178     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00179     {
00180       <span class="keyword">const</span> Element&amp; v = values[i];
00181       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key)) 
00182         ret.Push (v.value);
00183     }
00184     <span class="keywordflow">return</span> ret;
00185   }
00186 
<a name="l00188"></a><a class="code" href="classcsHash.html#a4">00188</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a4">PutFirst</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00189   {
00190     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00191       Elements[KeyHandler::ComputeHash (key) % Modulo];
00192     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00193     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00194     {
00195       Element&amp; v = values[i];
00196       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00197       {
00198         v.value = value;
00199         <span class="keywordflow">return</span>;
00200       }
00201     }
00202 
00203     values.Push (Element (key, value));
00204     Size++;
00205     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00206      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00207   }
00208 
<a name="l00210"></a><a class="code" href="classcsHash.html#a5">00210</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a5">In</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00211 <span class="keyword">  </span>{
00212     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00213       Elements[KeyHandler::ComputeHash (key) % Modulo];
00214     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00215     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00216       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key)) 
00217         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00218 
00219     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00220   }
00221 
<a name="l00226"></a><a class="code" href="classcsHash.html#a6">00226</a>   <span class="keyword">const</span> T* <a class="code" href="classcsHash.html#a6">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00227 <span class="keyword">  </span>{
00228     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00229       Elements[KeyHandler::ComputeHash (key) % Modulo];
00230     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00231     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00232     {
00233       <span class="keyword">const</span> Element&amp; v = values[i];
00234       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00235         <span class="keywordflow">return</span> &amp;v.value;
00236     }
00237 
00238     <span class="keywordflow">return</span> 0;
00239   }
00240 
<a name="l00245"></a><a class="code" href="classcsHash.html#a7">00245</a>   T* <a class="code" href="classcsHash.html#a6">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)
00246   {
00247     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00248       Elements[KeyHandler::ComputeHash (key) % Modulo];
00249     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00250     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00251     {
00252       Element&amp; v = values[i];
00253       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00254         <span class="keywordflow">return</span> &amp;v.value;
00255     }
00256 
00257     <span class="keywordflow">return</span> 0;
00258   }
00259 
<a name="l00264"></a><a class="code" href="classcsHash.html#a8">00264</a>   <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash.html#a8">Get</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T&amp; fallback)<span class="keyword"> const</span>
00265 <span class="keyword">  </span>{
00266     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00267       Elements[KeyHandler::ComputeHash (key) % Modulo];
00268     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00269     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00270     {
00271       <span class="keyword">const</span> Element&amp; v = values[i];
00272       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00273         <span class="keywordflow">return</span> v.value;
00274     }
00275 
00276     <span class="keywordflow">return</span> fallback;
00277   }
00278 
<a name="l00283"></a><a class="code" href="classcsHash.html#a9">00283</a>   T&amp; <a class="code" href="classcsHash.html#a8">Get</a> (<span class="keyword">const</span> K&amp; key, T&amp; fallback)
00284   {
00285     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00286       Elements[KeyHandler::ComputeHash (key) % Modulo];
00287     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00288     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00289     {
00290       Element&amp; v = values[i];
00291       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00292         <span class="keywordflow">return</span> v.value;
00293     }
00294 
00295     <span class="keywordflow">return</span> fallback;
00296   }
00297 
<a name="l00299"></a><a class="code" href="classcsHash.html#a10">00299</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a10">DeleteAll</a> ()
00300   {
00301     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo = InitModulo);
00302     <span class="keywordtype">int</span> elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00303     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; elen; i++)
00304       Elements[i].Empty ();
00305     Size = 0;
00306   }
00307 
<a name="l00309"></a><a class="code" href="classcsHash.html#a11">00309</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a10">DeleteAll</a> (<span class="keyword">const</span> K&amp; key)
00310   {
00311     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00312     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00313       Elements[KeyHandler::ComputeHash (key) % Modulo];
00314     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = values.<a class="code" href="classcsArray.html#a4">Length</a> () - 1; i &gt;= 0; i--)
00315       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key))
00316       {
00317         values.DeleteIndex (i);
00318         ret = <span class="keyword">true</span>;
00319         Size--;
00320       }
00321     <span class="keywordflow">return</span> ret;
00322   }
00323   
<a name="l00325"></a><a class="code" href="classcsHash.html#a12">00325</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a12">Delete</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00326   {
00327     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00328     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00329       Elements[KeyHandler::ComputeHash (key) % Modulo];
00330     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = values.<a class="code" href="classcsArray.html#a4">Length</a> () - 1; i &gt;= 0; i--)
00331       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key) &amp;&amp; 
00332         (values[i].value == value))
00333       {
00334         values.DeleteIndex (i);
00335         ret = <span class="keyword">true</span>;
00336         Size--;
00337       }
00338     <span class="keywordflow">return</span> ret;
00339   }
00340 
<a name="l00342"></a><a class="code" href="classcsHash.html#a13">00342</a>   <span class="keywordtype">int</span> <a class="code" href="classcsHash.html#a13">GetSize</a> ()<span class="keyword"> const</span>
00343 <span class="keyword">  </span>{
00344     <span class="keywordflow">return</span> Size;
00345   }
00346 
<a name="l00348"></a><a class="code" href="classcsHash_1_1Iterator.html">00348</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>
00349   {
00350   <span class="keyword">private</span>:
00351     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash;
00352     <span class="keyword">const</span> K key;
00353     <span class="keywordtype">int</span> bucket, size, element;
00354 
00355     <span class="keywordtype">void</span> Seek ()
00356     {
00357       <span class="keywordflow">while</span> ((element &lt; size) &amp;&amp; 
00358         ! KeyHandler::CompareKeys (hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key, key))
00359           element++;
00360     }
00361 
00362   <span class="keyword">protected</span>:
00363     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash0, <span class="keyword">const</span> K&amp; key0) :
00364       hash(hash0),
00365       key(key0), 
00366       bucket(KeyHandler::ComputeHash(key) % hash-&gt;<a class="code" href="classcsHash.html#n1">Modulo</a>),
00367       size(hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket].Length ())
00368       { <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> (); }
00369 
00370     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>;
00371   <span class="keyword">public</span>:
<a name="l00373"></a><a class="code" href="classcsHash_1_1Iterator.html#a0">00373</a>     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00374       hash (o.hash),
00375       key(o.key),
00376       bucket(o.bucket),
00377       size(o.size),
00378       element(o.element) {}
00379 
<a name="l00381"></a><a class="code" href="classcsHash_1_1Iterator.html#a1">00381</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; <a class="code" href="classcsHash_1_1Iterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; o)
00382     {
00383       hash = o.<a class="code" href="classcsHash_1_1Iterator.html#o0">hash</a>;
00384       key = o.<a class="code" href="classcsHash_1_1Iterator.html#o1">key</a>;
00385       bucket = o.<a class="code" href="classcsHash_1_1Iterator.html#o2">bucket</a>;
00386       size = o.<a class="code" href="classcsHash_1_1Iterator.html#o3">size</a>;
00387       element = o.<a class="code" href="classcsHash_1_1Iterator.html#o4">element</a>;
00388       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00389     }
00390 
<a name="l00392"></a><a class="code" href="classcsHash_1_1Iterator.html#a2">00392</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1Iterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00393 <span class="keyword">    </span>{
00394       <span class="keywordflow">return</span> element &lt; size;
00395     }
00396 
<a name="l00398"></a><a class="code" href="classcsHash_1_1Iterator.html#a3">00398</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1Iterator.html#a3">Next</a> ()
00399     {
00400       <span class="keyword">const</span> T &amp;ret = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].value;
00401       element++;
00402       Seek ();
00403       <span class="keywordflow">return</span> ret;
00404     }
00405 
<a name="l00407"></a><a class="code" href="classcsHash_1_1Iterator.html#a4">00407</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> () { element = 0; Seek (); }
00408   };
00409   <span class="keyword">friend</span> <span class="keyword">class </span>Iterator;
00410 
<a name="l00412"></a><a class="code" href="classcsHash_1_1GlobalIterator.html">00412</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>
00413   {
00414   <span class="keyword">private</span>:
00415     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash;
00416     <span class="keywordtype">int</span> bucket, size, element;
00417 
00418     <span class="keywordtype">void</span> Zero () { bucket = element = 0; }
00419     <span class="keywordtype">void</span> Init () { size = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket].Length (); }
00420 
00421     <span class="keywordtype">void</span> FindItem ()
00422     {
00423       <span class="keywordflow">if</span> (element &gt;= size)
00424       {
00425         <span class="keywordflow">while</span> (++bucket &lt; hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> ())
00426         {
00427           Init ();
00428           <span class="keywordflow">if</span> (size != 0)
00429           {
00430             element = 0;
00431             <span class="keywordflow">break</span>;
00432           }
00433         }
00434       }
00435     }
00436 
00437   <span class="keyword">protected</span>:
00438     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash0) : hash (hash0) 
00439     { 
00440       Zero (); 
00441       Init (); 
00442       FindItem ();
00443     }
00444 
00445     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>;
00446   <span class="keyword">public</span>:
<a name="l00448"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a0">00448</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00449       hash (o.hash),
00450       bucket (o.bucket),
00451       size (o.size),
00452       element (o.element) {}
00453 
<a name="l00455"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a1">00455</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; o)
00456     {
00457       hash = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o0">hash</a>;
00458       bucket = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o1">bucket</a>;
00459       size = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o2">size</a>;
00460       element = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o3">element</a>;
00461       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00462     }
00463 
<a name="l00465"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a2">00465</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00466 <span class="keyword">    </span>{
00467       <span class="keywordflow">if</span> (hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> () == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00468       <span class="keywordflow">return</span> element &lt; size || bucket &lt; hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> ();
00469     }
00470 
<a name="l00472"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a3">00472</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ()
00473     {
00474       element++;
00475       FindItem ();
00476     }
00477 
<a name="l00479"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a4">00479</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ()
00480     {
00481       <span class="keywordflow">return</span> hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].value;
00482     }
00483 
<a name="l00485"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a5">00485</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ()
00486     {
00487       <span class="keyword">const</span> T &amp;ret = <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00488       <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ();
00489       <span class="keywordflow">return</span> ret;
00490     }
00491 
00492     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> (K &amp;key)
00493     {
00494       key = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key;
00495       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00496     }
00497 
<a name="l00499"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a7">00499</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> (K &amp;key)
00500     {
00501       key = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key;
00502       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ();
00503     }
00504 
<a name="l00506"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a8">00506</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a8">Reset</a> () { Zero (); Init (); FindItem (); }
00507   };
00508   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00509 
<a name="l00512"></a><a class="code" href="classcsHash.html#a14">00512</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a14">DeleteElement</a> (GlobalIterator iterator)
00513   {
00514     Elements[iterator.bucket].DeleteIndex(iterator.element);
00515     Size--;
00516     iterator.size--;
00517     iterator.FindItem ();
00518   }
00519 
<a name="l00526"></a><a class="code" href="classcsHash.html#a15">00526</a>   Iterator <a class="code" href="classcsHash.html#a16">GetIterator</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00527 <span class="keyword">  </span>{
00528     <span class="keywordflow">return</span> Iterator (<span class="keyword">this</span>, key);
00529   }
00530 
<a name="l00536"></a><a class="code" href="classcsHash.html#a16">00536</a>   GlobalIterator <a class="code" href="classcsHash.html#a16">GetIterator</a> ()<span class="keyword"> const</span>
00537 <span class="keyword">  </span>{
00538     <span class="keywordflow">return</span> GlobalIterator (<span class="keyword">this</span>);
00539   }
00540 };
00541 
00547 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> KeyHandler = csIntegralHashKeyHandler&lt;T&gt; &gt; 
<a name="l00548"></a><a class="code" href="classcsSet.html">00548</a> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>
00549 {
00550 <span class="keyword">private</span>:
00551   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a> map;
00552 
00553 <span class="keyword">public</span>:
<a name="l00555"></a><a class="code" href="classcsSet_1_1Iterator.html">00555</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1Iterator.html">Iterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1Iterator.html">Iterator</a>
00556   {
00557   <span class="keyword">protected</span>:
00558     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> () {}
00559   <span class="keyword">public</span>:
00560   };
<a name="l00562"></a><a class="code" href="classcsSet_1_1GlobalIterator.html">00562</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>
00563   {
00564   <span class="keyword">protected</span>:
00565     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> () {}
00566     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsSet.html">csSet&lt;T, KeyHandler&gt;</a> *set0) : 
00567       <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;::GlobalIterator</a>(&amp;set0-&gt;map)
00568     { }
00569 
00570   <span class="keyword">public</span>:
00571     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>;
00572   };
00573   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00574 
<a name="l00579"></a><a class="code" href="classcsSet.html#a0">00579</a>   <a class="code" href="classcsSet.html#a0">csSet</a> (<span class="keywordtype">int</span> size = 257, <span class="keywordtype">int</span> grow_rate = 64, <span class="keywordtype">int</span> max_size = 20000)
00580         : map (size, grow_rate, max_size)
00581   {
00582   }
00583 
<a name="l00588"></a><a class="code" href="classcsSet.html#a1">00588</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a1">Add</a> (<span class="keyword">const</span> T&amp; object)
00589   {
00590     <span class="keywordflow">if</span> (<a class="code" href="classcsSet.html#a3">In</a> (object)) <span class="keywordflow">return</span>;
00591     <a class="code" href="classcsSet.html#a2">AddNoTest</a> (object);
00592   }
00593 
<a name="l00600"></a><a class="code" href="classcsSet.html#a2">00600</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a2">AddNoTest</a> (<span class="keyword">const</span> T&amp; object)
00601   {
00602     map.<a class="code" href="classcsHash.html#a2">Put</a> (object, object);
00603   }
00604 
<a name="l00608"></a><a class="code" href="classcsSet.html#a3">00608</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a3">In</a> (<span class="keyword">const</span> T&amp; object)<span class="keyword"> const</span>
00609 <span class="keyword">  </span>{
00610     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a5">In</a> (object);
00611   }
00612 
<a name="l00616"></a><a class="code" href="classcsSet.html#a4">00616</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a4">DeleteAll</a> ()
00617   {
00618     map.<a class="code" href="classcsHash.html#a10">DeleteAll</a> ();
00619   }
00620 
<a name="l00626"></a><a class="code" href="classcsSet.html#a5">00626</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a5">Delete</a> (<span class="keyword">const</span> T&amp; object)
00627   {
00628     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a12">Delete</a> (object, object);
00629   }
00630 
<a name="l00632"></a><a class="code" href="classcsSet.html#a6">00632</a>   <span class="keywordtype">int</span> <a class="code" href="classcsSet.html#a6">GetSize</a> ()<span class="keyword"> const</span>
00633 <span class="keyword">  </span>{
00634     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a13">GetSize</a> ();
00635   }
00636 
<a name="l00638"></a><a class="code" href="classcsSet.html#a7">00638</a>   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a>* <a class="code" href="classcsSet.html#a7">GetHash</a> () { <span class="keywordflow">return</span> &amp;map; }
00639 
<a name="l00645"></a><a class="code" href="classcsSet.html#a8">00645</a>   <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> <a class="code" href="classcsSet.html#a8">GetIterator</a> ()<span class="keyword"> const</span>
00646 <span class="keyword">  </span>{
00647     <span class="keywordflow">return</span> <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>(<span class="keyword">this</span>);
00648   }
00649 };
00650 
00651 
00652 <span class="preprocessor">#endif</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
