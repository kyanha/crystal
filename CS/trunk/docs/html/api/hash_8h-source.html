<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/hash.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000022.html">csutil</a></div>
<h1>hash.h</h1><a href="hash_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2003 by Mat Sutcliffe &lt;oktal@gmx.co.uk&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_UTIL_HASH_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_UTIL_HASH_H__</span>
00021 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include "csextern.h"</span>
00027 <span class="preprocessor">#include "<a class="code" href="array_8h.html">array.h</a>"</span>
00028 
00035 CS_CRYSTALSPACE_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="hash_8h.html#a0">csHashCompute</a> (<span class="keywordtype">char</span> <span class="keyword">const</span>*);
00036 
00043 CS_CRYSTALSPACE_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="hash_8h.html#a0">csHashCompute</a> (<span class="keywordtype">char</span> <span class="keyword">const</span>*, size_t length);
00044 
00048 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00049"></a><a class="code" href="classcsIntegralHashKeyHandler.html">00049</a> <span class="keyword">class </span><a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler</a>
00050 {
00051 <span class="keyword">public</span>:
00052   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ComputeHash (<span class="keyword">const</span> T&amp; key)
00053   {
00054 <span class="preprocessor">#if (CS_PROCESSOR_SIZE == 32)</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#if (_MSC_VER &gt;= 1300)</span>
00056 <span class="preprocessor"></span>    <span class="comment">/*</span>
00057 <span class="comment">      VC7 with 64bit warnings complains about a pointer truncation when T is</span>
00058 <span class="comment">      a pointer. This isn't serious (as csHash&lt;&gt; does not rely on the hash of</span>
00059 <span class="comment">      a key alone to retrieve a value). The __w64 causes VC7 to not emit that</span>
00060 <span class="comment">      warning (on 32bit compilers at least).</span>
00061 <span class="comment">     */</span>
00062     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __w64)key;  
00063 <span class="preprocessor">#else</span>
00064 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)key;  
00065 <span class="preprocessor">#endif</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00067 <span class="preprocessor"></span>    <span class="comment">// Cast to uint64 first to avoid compiler warnings about truncation.</span>
00068     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((<a class="code" href="group__util.html#ga6">uint64</a>)key);
00069 <span class="preprocessor">#endif</span>
00070 <span class="preprocessor"></span>  }
00071 
00072   <span class="keyword">static</span> <span class="keywordtype">bool</span> CompareKeys (<span class="keyword">const</span> T&amp; key1, <span class="keyword">const</span> T&amp; key2)
00073   {
00074     <span class="keywordflow">return</span> (key1 == key2);
00075   }
00076 };
00077 
00082 <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>K = <span class="keywordtype">unsigned</span> int, 
00083   <span class="keyword">class </span>KeyHandler = <a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler&lt;K&gt;</a> &gt; 
<a name="l00084"></a><a class="code" href="classcsHash.html">00084</a> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>
00085 {
00086 <span class="keyword">protected</span>:
00087   <span class="keyword">struct </span>Element
00088   {
00089     <span class="keyword">const</span> K key;
00090     T value;
00091 
00092     Element (<span class="keyword">const</span> K&amp; key0, <span class="keyword">const</span> T &amp;value0) : key (key0), value (value0) {}
00093     Element (<span class="keyword">const</span> Element &amp;other) : key (other.key), value (other.value) {}
00094   };
00095   <a class="code" href="classcsArray.html">csArray&lt; csArray&lt;Element&gt;</a> &gt; Elements;
00096 
00097   size_t Modulo;
00098 
00099 <span class="keyword">private</span>:
00100   size_t InitModulo;
00101   size_t GrowRate;
00102   size_t MaxSize;
00103   size_t Size;
00104 
00105   <span class="keywordtype">void</span> Grow ()
00106   {
00107     <span class="keyword">static</span> <span class="keyword">const</span> size_t Primes[] =
00108     {
00109       53,         97,         193,       389,       769, 
00110       1543,       3079,       6151,      12289,     24593,
00111       49157,      98317,      196613,    393241,    786433,
00112       1572869,    3145739,    6291469,   12582917,  25165843,
00113       50331653,   100663319,  201326611, 402653189, 805306457,
00114       1610612741, 0
00115     };
00116 
00117     <span class="keyword">const</span> size_t *p;
00118     size_t elen = Elements.<a class="code" href="classcsArray.html#a5">Length</a> ();
00119     <span class="keywordflow">for</span> (p = Primes; *p &amp;&amp; *p &lt;= elen; p++) ;
00120     Modulo = *p;
00121     CS_ASSERT (Modulo);
00122 
00123     Elements.<a class="code" href="classcsArray.html#a10">SetLength</a>(Modulo, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>(0, MIN(Modulo / GrowRate, 8)));
00124 
00125     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00126     {
00127       <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; src = Elements[i];
00128       size_t slen = src.<a class="code" href="classcsArray.html#a5">Length</a> ();
00129       <span class="keywordflow">for</span> (size_t j = slen; j &gt; 0; j--)
00130       {
00131         <span class="keyword">const</span> Element&amp; srcElem = src[j - 1];
00132         <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; dst = 
00133           Elements.<a class="code" href="classcsArray.html#a12">Get</a> (KeyHandler::ComputeHash (srcElem.key) % Modulo);
00134         <span class="keywordflow">if</span> (&amp;src != &amp;dst)
00135         {
00136           dst.<a class="code" href="classcsArray.html#a19">Push</a> (srcElem);
00137           src.<a class="code" href="classcsArray.html#a38">DeleteIndex</a> (j - 1);
00138         }
00139       }
00140     }
00141   }
00142 
00143 <span class="keyword">public</span>:
<a name="l00158"></a><a class="code" href="classcsHash.html#a0">00158</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (size_t size = 23, size_t grow_rate = 5, size_t max_size = 20000)
00159     : Elements (size), Modulo (size), InitModulo (size),
00160       GrowRate (MIN (grow_rate, size)), MaxSize (max_size), Size (0)
00161   {
00162     Elements.<a class="code" href="classcsArray.html#a10">SetLength</a> (size, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> (0, MIN (size / GrowRate, 8)));
00163   }
00164 
<a name="l00166"></a><a class="code" href="classcsHash.html#a1">00166</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T&gt;</a> &amp;o) : Elements (o.Elements),
00167     Modulo (o.Modulo), InitModulo (o.InitModulo),
00168     GrowRate (o.GrowRate), MaxSize (o.MaxSize), Size (o.Size) {}
00169 
<a name="l00177"></a><a class="code" href="classcsHash.html#a2">00177</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a2">Put</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00178   {
00179     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00180       Elements[KeyHandler::ComputeHash (key) % Modulo];
00181     values.<a class="code" href="classcsArray.html#a19">Push</a> (Element (key, value));
00182     Size++;
00183     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a5">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a5">Length</a> () / GrowRate
00184      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a5">Length</a> () &lt; MaxSize) Grow ();
00185   }
00186 
<a name="l00188"></a><a class="code" href="classcsHash.html#a3">00188</a>   <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> <a class="code" href="classcsHash.html#a3">GetAll</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00189 <span class="keyword">  </span>{
00190     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00191       Elements[KeyHandler::ComputeHash (key) % Modulo];
00192     <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> ret (values.<a class="code" href="classcsArray.html#a5">Length</a> () / 2);
00193     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00194     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00195     {
00196       <span class="keyword">const</span> Element&amp; v = values[i];
00197       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key)) 
00198         ret.<a class="code" href="classcsArray.html#a19">Push</a> (v.value);
00199     }
00200     <span class="keywordflow">return</span> ret;
00201   }
00202 
<a name="l00204"></a><a class="code" href="classcsHash.html#a4">00204</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a4">PutUnique</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00205   {
00206     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00207       Elements[KeyHandler::ComputeHash (key) % Modulo];
00208     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00209     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00210     {
00211       Element&amp; v = values[i];
00212       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00213       {
00214         v.value = value;
00215         <span class="keywordflow">return</span>;
00216       }
00217     }
00218 
00219     values.<a class="code" href="classcsArray.html#a19">Push</a> (Element (key, value));
00220     Size++;
00221     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a5">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a5">Length</a> () / GrowRate
00222      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a5">Length</a> () &lt; MaxSize) Grow ();
00223   }
00224 
<a name="l00229"></a><a class="code" href="classcsHash.html#a5">00229</a>   <a class="code" href="cssysdef_8h.html#a40">CS_DEPRECATED_METHOD</a> <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a5">PutFirst</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00230   {
00231     <a class="code" href="classcsHash.html#a4">PutUnique</a>(key, value);
00232   }
00233 
<a name="l00235"></a><a class="code" href="classcsHash.html#a6">00235</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a6">Contains</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00236 <span class="keyword">  </span>{
00237     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00238       Elements[KeyHandler::ComputeHash (key) % Modulo];
00239     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00240     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00241       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key)) 
00242         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00243     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00244   }
00245 
<a name="l00251"></a><a class="code" href="classcsHash.html#a7">00251</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a7">In</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00252 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classcsHash.html#a6">Contains</a>(key); }
00253 
<a name="l00258"></a><a class="code" href="classcsHash.html#a8">00258</a>   <span class="keyword">const</span> T* <a class="code" href="classcsHash.html#a8">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00259 <span class="keyword">  </span>{
00260     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00261       Elements[KeyHandler::ComputeHash (key) % Modulo];
00262     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00263     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00264     {
00265       <span class="keyword">const</span> Element&amp; v = values[i];
00266       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00267         <span class="keywordflow">return</span> &amp;v.value;
00268     }
00269 
00270     <span class="keywordflow">return</span> 0;
00271   }
00272 
<a name="l00277"></a><a class="code" href="classcsHash.html#a9">00277</a>   T* <a class="code" href="classcsHash.html#a8">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)
00278   {
00279     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00280       Elements[KeyHandler::ComputeHash (key) % Modulo];
00281     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00282     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00283     {
00284       Element&amp; v = values[i];
00285       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00286         <span class="keywordflow">return</span> &amp;v.value;
00287     }
00288 
00289     <span class="keywordflow">return</span> 0;
00290   }
00291 
<a name="l00296"></a><a class="code" href="classcsHash.html#a10">00296</a>   <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash.html#a10">Get</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T&amp; fallback)<span class="keyword"> const</span>
00297 <span class="keyword">  </span>{
00298     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00299       Elements[KeyHandler::ComputeHash (key) % Modulo];
00300     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00301     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00302     {
00303       <span class="keyword">const</span> Element&amp; v = values[i];
00304       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00305         <span class="keywordflow">return</span> v.value;
00306     }
00307 
00308     <span class="keywordflow">return</span> fallback;
00309   }
00310 
<a name="l00315"></a><a class="code" href="classcsHash.html#a11">00315</a>   T&amp; <a class="code" href="classcsHash.html#a10">Get</a> (<span class="keyword">const</span> K&amp; key, T&amp; fallback)
00316   {
00317     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00318       Elements[KeyHandler::ComputeHash (key) % Modulo];
00319     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a5">Length</a> ();
00320     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00321     {
00322       Element&amp; v = values[i];
00323       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00324         <span class="keywordflow">return</span> v.value;
00325     }
00326 
00327     <span class="keywordflow">return</span> fallback;
00328   }
00329 
<a name="l00331"></a><a class="code" href="classcsHash.html#a12">00331</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a12">DeleteAll</a> ()
00332   {
00333     Elements.<a class="code" href="classcsArray.html#a10">SetLength</a> (Modulo = InitModulo);
00334     size_t elen = Elements.<a class="code" href="classcsArray.html#a5">Length</a> ();
00335     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00336       Elements[i].<a class="code" href="classcsArray.html#a34">Empty</a> ();
00337     Size = 0;
00338   }
00339 
<a name="l00341"></a><a class="code" href="classcsHash.html#a13">00341</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a13">Empty</a>() { <a class="code" href="classcsHash.html#a12">DeleteAll</a>(); }
00342 
<a name="l00344"></a><a class="code" href="classcsHash.html#a14">00344</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a12">DeleteAll</a> (<span class="keyword">const</span> K&amp; key)
00345   {
00346     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00347     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00348       Elements[KeyHandler::ComputeHash (key) % Modulo];
00349     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a5">Length</a> (); i &gt; 0; i--)
00350     {
00351       <span class="keyword">const</span> size_t idx = i - 1;
00352       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[idx].key, key))
00353       {
00354         values.<a class="code" href="classcsArray.html#a39">DeleteIndexFast</a> (idx);
00355         ret = <span class="keyword">true</span>;
00356         Size--;
00357       }
00358     }
00359     <span class="keywordflow">return</span> ret;
00360   }
00361   
<a name="l00363"></a><a class="code" href="classcsHash.html#a15">00363</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a15">Delete</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00364   {
00365     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00366     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00367       Elements[KeyHandler::ComputeHash (key) % Modulo];
00368     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a5">Length</a> (); i &gt; 0; i--)
00369     {
00370       <span class="keyword">const</span> size_t idx = i - 1;
00371       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[idx].key, key) &amp;&amp; 
00372         (values[idx].value == value))
00373       {
00374         values.<a class="code" href="classcsArray.html#a39">DeleteIndexFast</a> (idx);
00375         ret = <span class="keyword">true</span>;
00376         Size--;
00377       }
00378     }
00379     <span class="keywordflow">return</span> ret;
00380   }
00381 
<a name="l00383"></a><a class="code" href="classcsHash.html#a16">00383</a>   size_t <a class="code" href="classcsHash.html#a16">GetSize</a> ()<span class="keyword"> const</span>
00384 <span class="keyword">  </span>{
00385     <span class="keywordflow">return</span> Size;
00386   }
00387 
<a name="l00393"></a><a class="code" href="classcsHash.html#a17">00393</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a17">IsEmpty</a>()<span class="keyword"> const</span>
00394 <span class="keyword">  </span>{
00395     <span class="keywordflow">return</span> <a class="code" href="classcsHash.html#a16">GetSize</a>() == 0;
00396   }
00397 
<a name="l00399"></a><a class="code" href="classcsHash_1_1Iterator.html">00399</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>
00400   {
00401   <span class="keyword">private</span>:
00402     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash;
00403     <span class="keyword">const</span> K key;
00404     size_t bucket, size, element;
00405 
00406     <span class="keywordtype">void</span> Seek ()
00407     {
00408       <span class="keywordflow">while</span> ((element &lt; size) &amp;&amp; 
00409         ! KeyHandler::CompareKeys (hash-&gt;Elements[bucket][element].key, key))
00410           element++;
00411     }
00412 
00413   <span class="keyword">protected</span>:
00414     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash0, <span class="keyword">const</span> K&amp; key0) :
00415       hash(hash0),
00416       key(key0), 
00417       bucket(KeyHandler::ComputeHash(key) % hash-&gt;Modulo),
00418       size(hash-&gt;Elements[bucket].Length ())
00419       { <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> (); }
00420 
00421     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>&lt;T, K, KeyHandler&gt;;
00422   <span class="keyword">public</span>:
<a name="l00424"></a><a class="code" href="classcsHash_1_1Iterator.html#a0">00424</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00425       hash (o.hash),
00426       key(o.key),
00427       bucket(o.bucket),
00428       size(o.size),
00429       element(o.element) {}
00430 
<a name="l00432"></a><a class="code" href="classcsHash_1_1Iterator.html#a1">00432</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; <a class="code" href="classcsHash_1_1Iterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; o)
00433     {
00434       hash = o.<a class="code" href="classcsHash_1_1Iterator.html#r0">hash</a>;
00435       key = o.<a class="code" href="classcsHash_1_1Iterator.html#r1">key</a>;
00436       bucket = o.<a class="code" href="classcsHash_1_1Iterator.html#r2">bucket</a>;
00437       size = o.<a class="code" href="classcsHash_1_1Iterator.html#r3">size</a>;
00438       element = o.<a class="code" href="classcsHash_1_1Iterator.html#r4">element</a>;
00439       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00440     }
00441 
<a name="l00443"></a><a class="code" href="classcsHash_1_1Iterator.html#a2">00443</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1Iterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00444 <span class="keyword">    </span>{
00445       <span class="keywordflow">return</span> element &lt; size;
00446     }
00447 
<a name="l00449"></a><a class="code" href="classcsHash_1_1Iterator.html#a3">00449</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1Iterator.html#a3">Next</a> ()
00450     {
00451       <span class="keyword">const</span> T &amp;ret = hash-&gt;Elements[bucket][element].value;
00452       element++;
00453       Seek ();
00454       <span class="keywordflow">return</span> ret;
00455     }
00456 
<a name="l00458"></a><a class="code" href="classcsHash_1_1Iterator.html#a4">00458</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> () { element = 0; Seek (); }
00459   };
00460   <span class="keyword">friend</span> <span class="keyword">class </span>Iterator;
00461 
<a name="l00463"></a><a class="code" href="classcsHash_1_1GlobalIterator.html">00463</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>
00464   {
00465   <span class="keyword">private</span>:
00466     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash;
00467     size_t bucket, size, element;
00468 
00469     <span class="keywordtype">void</span> Zero () { bucket = element = 0; }
00470     <span class="keywordtype">void</span> Init () { size = hash-&gt;Elements[bucket].Length (); }
00471 
00472     <span class="keywordtype">void</span> FindItem ()
00473     {
00474       <span class="keywordflow">if</span> (element &gt;= size)
00475       {
00476         <span class="keywordflow">while</span> (++bucket &lt; hash-&gt;Elements.Length ())
00477         {
00478           Init ();
00479           <span class="keywordflow">if</span> (size != 0)
00480           {
00481             element = 0;
00482             <span class="keywordflow">break</span>;
00483           }
00484         }
00485       }
00486     }
00487 
00488   <span class="keyword">protected</span>:
00489     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash0) : hash (hash0) 
00490     { 
00491       Zero (); 
00492       Init (); 
00493       FindItem ();
00494     }
00495 
00496     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>&lt;T, K, KeyHandler&gt;;
00497   <span class="keyword">public</span>:
<a name="l00499"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a0">00499</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00500       hash (o.hash),
00501       bucket (o.bucket),
00502       size (o.size),
00503       element (o.element) {}
00504 
<a name="l00506"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a1">00506</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; o)
00507     {
00508       hash = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r0">hash</a>;
00509       bucket = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r1">bucket</a>;
00510       size = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r2">size</a>;
00511       element = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#r3">element</a>;
00512       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00513     }
00514 
<a name="l00516"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a2">00516</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00517 <span class="keyword">    </span>{
00518       <span class="keywordflow">if</span> (hash-&gt;Elements.Length () == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00519       <span class="keywordflow">return</span> element &lt; size || bucket &lt; hash-&gt;Elements.Length ();
00520     }
00521 
<a name="l00523"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a3">00523</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ()
00524     {
00525       element++;
00526       FindItem ();
00527     }
00528 
<a name="l00530"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a4">00530</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ()
00531     {
00532       <span class="keywordflow">return</span> hash-&gt;Elements[bucket][element].value;
00533     }
00534 
<a name="l00536"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a5">00536</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ()
00537     {
00538       <span class="keyword">const</span> T &amp;ret = <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00539       <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ();
00540       <span class="keywordflow">return</span> ret;
00541     }
00542 
<a name="l00544"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a6">00544</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> (K &amp;key)
00545     {
00546       key = hash-&gt;Elements[bucket][element].key;
00547       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00548     }
00549 
<a name="l00551"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a7">00551</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> (K &amp;key)
00552     {
00553       key = hash-&gt;Elements[bucket][element].key;
00554       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ();
00555     }
00556 
<a name="l00558"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a8">00558</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a8">Reset</a> () { Zero (); Init (); FindItem (); }
00559   };
00560   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00561 
<a name="l00564"></a><a class="code" href="classcsHash.html#a18">00564</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a18">DeleteElement</a> (GlobalIterator&amp; iterator)
00565   {
00566     Elements[iterator.bucket].<a class="code" href="classcsArray.html#a38">DeleteIndex</a>(iterator.element);
00567     Size--;
00568     iterator.size--;
00569     iterator.FindItem ();
00570   }
00571 
<a name="l00578"></a><a class="code" href="classcsHash.html#a19">00578</a>   Iterator <a class="code" href="classcsHash.html#a20">GetIterator</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00579 <span class="keyword">  </span>{
00580     <span class="keywordflow">return</span> Iterator (<span class="keyword">this</span>, key);
00581   }
00582 
<a name="l00588"></a><a class="code" href="classcsHash.html#a20">00588</a>   GlobalIterator <a class="code" href="classcsHash.html#a20">GetIterator</a> ()<span class="keyword"> const</span>
00589 <span class="keyword">  </span>{
00590     <span class="keywordflow">return</span> GlobalIterator (<span class="keyword">this</span>);
00591   }
00592 };
00593 
00599 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> KeyHandler = csIntegralHashKeyHandler&lt;T&gt; &gt; 
<a name="l00600"></a><a class="code" href="classcsSet.html">00600</a> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>
00601 {
00602 <span class="keyword">public</span>:
00603   <span class="keyword">typedef</span> <a class="code" href="classcsHash.html">csHash&lt;bool, T, KeyHandler&gt;</a> <a class="code" href="classcsHash.html">HashType</a>;
00604 
00605 <span class="keyword">private</span>:
00606   <span class="keyword">typedef</span> typename_qualifier HashType::GlobalIterator ParentIter;
00607   <a class="code" href="classcsHash.html">HashType</a> map;
00608 
00609 <span class="keyword">public</span>:
00610   <span class="comment">/* Unfortunately, MSVC6 barfs if we derive this from ParentIter. */</span>
<a name="l00612"></a><a class="code" href="classcsSet_1_1GlobalIterator.html">00612</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>
00613   {
00614   <span class="keyword">protected</span>:
00615     ParentIter iter;
00616     <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> () {}
00617     <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsSet.html">csSet&lt;T, KeyHandler&gt;</a>* s) :
00618       iter(s-&gt;<a class="code" href="classcsSet.html#r0">map</a>.<a class="code" href="classcsHash.html#a19">GetIterator</a>()) {}
00619 
00620   <span class="keyword">public</span>:
00621     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>&lt;T, KeyHandler&gt;;
00622 
00623     <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>&amp; o) : iter(o.<a class="code" href="classcsSet_1_1GlobalIterator.html#p0">iter</a>) {}
00624     GlobalIterator&amp; operator=(<span class="keyword">const</span> GlobalIterator&amp; o)
00625     { iter = o.<a class="code" href="classcsSet_1_1GlobalIterator.html#p0">iter</a>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
00626 
<a name="l00628"></a><a class="code" href="classcsSet_1_1GlobalIterator.html#a2">00628</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsSet_1_1GlobalIterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00629 <span class="keyword">    </span>{ <span class="keywordflow">return</span> iter.HasNext(); }
00630 
<a name="l00632"></a><a class="code" href="classcsSet_1_1GlobalIterator.html#a3">00632</a>     T <a class="code" href="classcsSet_1_1GlobalIterator.html#a3">Next</a>()
00633     {
00634       T key;
00635       iter.Next(key);
00636       <span class="keywordflow">return</span> key;
00637     }
00638   };
00639   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00640 
<a name="l00645"></a><a class="code" href="classcsSet.html#a0">00645</a>   <a class="code" href="classcsSet.html#a0">csSet</a> (<span class="keywordtype">int</span> size = 23, <span class="keywordtype">int</span> grow_rate = 5, <span class="keywordtype">int</span> max_size = 20000)
00646         : map (size, grow_rate, max_size)
00647   {
00648   }
00649 
<a name="l00654"></a><a class="code" href="classcsSet.html#a1">00654</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a1">Add</a> (<span class="keyword">const</span> T&amp; object)
00655   {
00656     <span class="keywordflow">if</span> (!<a class="code" href="classcsSet.html#a3">Contains</a> (object))
00657       <a class="code" href="classcsSet.html#a2">AddNoTest</a> (object);
00658   }
00659 
<a name="l00666"></a><a class="code" href="classcsSet.html#a2">00666</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a2">AddNoTest</a> (<span class="keyword">const</span> T&amp; object)
00667   {
00668     map.<a class="code" href="classcsHash.html#a2">Put</a> (object, <span class="keyword">true</span>);
00669   }
00670 
<a name="l00674"></a><a class="code" href="classcsSet.html#a3">00674</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a3">Contains</a> (<span class="keyword">const</span> T&amp; object)<span class="keyword"> const</span>
00675 <span class="keyword">  </span>{
00676     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a6">Contains</a> (object);
00677   }
00678 
<a name="l00684"></a><a class="code" href="classcsSet.html#a4">00684</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a4">In</a> (<span class="keyword">const</span> T&amp; object)<span class="keyword"> const</span>
00685 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classcsSet.html#a3">Contains</a>(object); }
00686 
<a name="l00690"></a><a class="code" href="classcsSet.html#a5">00690</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a5">DeleteAll</a> ()
00691   {
00692     map.<a class="code" href="classcsHash.html#a12">DeleteAll</a> ();
00693   }
00694 
<a name="l00696"></a><a class="code" href="classcsSet.html#a6">00696</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a6">Empty</a>() { <a class="code" href="classcsSet.html#a5">DeleteAll</a>(); }
00697 
<a name="l00703"></a><a class="code" href="classcsSet.html#a7">00703</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a7">Delete</a> (<span class="keyword">const</span> T&amp; object)
00704   {
00705     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a15">Delete</a> (object, object);
00706   }
00707 
<a name="l00709"></a><a class="code" href="classcsSet.html#a8">00709</a>   size_t <a class="code" href="classcsSet.html#a8">GetSize</a> ()<span class="keyword"> const</span>
00710 <span class="keyword">  </span>{
00711     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a16">GetSize</a> ();
00712   }
00713 
<a name="l00719"></a><a class="code" href="classcsSet.html#a9">00719</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a9">IsEmpty</a>()<span class="keyword"> const</span>
00720 <span class="keyword">  </span>{
00721     <span class="keywordflow">return</span> <a class="code" href="classcsSet.html#a8">GetSize</a>() == 0;
00722   }
00723 
<a name="l00725"></a><a class="code" href="classcsSet.html#a10">00725</a>   <a class="code" href="classcsHash.html">HashType</a>* <a class="code" href="classcsSet.html#a10">GetHash</a> () { <span class="keywordflow">return</span> &amp;map; }
00726 
<a name="l00732"></a><a class="code" href="classcsSet.html#a11">00732</a>   GlobalIterator <a class="code" href="classcsSet.html#a11">GetIterator</a> ()<span class="keyword"> const</span>
00733 <span class="keyword">  </span>{
00734     <span class="keywordflow">return</span> GlobalIterator(<span class="keyword">this</span>);
00735   }
00736 };
00737 
00738 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.2 
</small></address> </div></body> </html>
