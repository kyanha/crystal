<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/hash.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>csutil/hash.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2003 by Mat Sutcliffe &lt;oktal@gmx.co.uk&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_UTIL_HASH_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_UTIL_HASH_H__</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include "csextern.h"</span>
00023 <span class="preprocessor">#include "array.h"</span>
00024 
00031 CS_CSUTIL_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> csHashCompute (<span class="keywordtype">char</span> <span class="keyword">const</span>*);
00032 
00039 CS_CSUTIL_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> csHashCompute (<span class="keywordtype">char</span> <span class="keyword">const</span>*, size_t length);
00040 
00044 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00045"></a><a class="code" href="classcsIntegralHashKeyHandler.html">00045</a> <span class="keyword">class </span><a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler</a>
00046 {
00047 <span class="keyword">public</span>:
00048   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ComputeHash (<span class="keyword">const</span> T&amp; key)
00049   {
00050 <span class="preprocessor">#ifndef CS_PLATFORM_IS_64BITS</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#if (_MSC_VER &gt;= 1300)</span>
00052 <span class="preprocessor"></span>    <span class="comment">/*</span>
00053 <span class="comment">      VC7 with 64bit warnings complains about a pointer truncation when T is</span>
00054 <span class="comment">      a pointer. This isn't serious (as csHash&lt;&gt; does not rely on the hash of</span>
00055 <span class="comment">      a key alone to retrieve a value). The __w64 causes VC7 to not emit that</span>
00056 <span class="comment">      warning (on 32bit compilers at least).</span>
00057 <span class="comment">     */</span>
00058     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __w64)key;  
00059 <span class="preprocessor">#else</span>
00060 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)key;  
00061 <span class="preprocessor">#endif</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00063 <span class="preprocessor"></span>    <span class="comment">// Cast to uint64 first to avoid compiler warnings about truncation.</span>
00064     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((uint64)key);
00065 <span class="preprocessor">#endif</span>
00066 <span class="preprocessor"></span>  }
00067 
00068   <span class="keyword">static</span> <span class="keywordtype">bool</span> CompareKeys (<span class="keyword">const</span> T&amp; key1, <span class="keyword">const</span> T&amp; key2)
00069   {
00070     <span class="keywordflow">return</span> (key1 == key2);
00071   }
00072 };
00073 
00078 <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>K = <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, 
00079   <span class="keyword">class </span>KeyHandler = <a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler&lt;K&gt;</a> &gt; 
<a name="l00080"></a><a class="code" href="classcsHash.html">00080</a> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>
00081 {
00082 <span class="keyword">protected</span>:
00083   <span class="keyword">struct </span>Element
00084   {
00085     <span class="keyword">const</span> K key;
00086     T value;
00087 
00088     Element (<span class="keyword">const</span> K&amp; key0, <span class="keyword">const</span> T &amp;value0) : key (key0), value (value0) {}
00089     Element (<span class="keyword">const</span> Element &amp;other) : key (other.key), value (other.value) {}
00090   };
00091   <a class="code" href="classcsArray.html">csArray&lt; csArray&lt;Element&gt;</a> &gt; Elements;
00092 
00093   size_t Modulo;
00094 
00095 <span class="keyword">private</span>:
00096   size_t InitModulo;
00097   size_t GrowRate;
00098   size_t MaxSize;
00099   size_t Size;
00100 
00101   <span class="keywordtype">void</span> Grow ()
00102   {
00103     <span class="keyword">static</span> <span class="keyword">const</span> size_t Primes[] =
00104     {
00105       53,         97,         193,       389,       769, 
00106       1543,       3079,       6151,      12289,     24593,
00107       49157,      98317,      196613,    393241,    786433,
00108       1572869,    3145739,    6291469,   12582917,  25165843,
00109       50331653,   100663319,  201326611, 402653189, 805306457,
00110       1610612741, 0
00111     };
00112 
00113     <span class="keyword">const</span> size_t *p;
00114     size_t elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00115     <span class="keywordflow">for</span> (p = Primes; *p &amp;&amp; *p &lt;= elen; p++) ;
00116     Modulo = *p;
00117     CS_ASSERT (Modulo);
00118 
00119     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo);
00120 
00121     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00122     {
00123       <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; src = Elements[i];
00124       size_t slen = src.<a class="code" href="classcsArray.html#a4">Length</a> ();
00125       <span class="keywordflow">for</span> (size_t j = slen; j &gt; 0; j--)
00126       {
00127         <span class="keyword">const</span> Element&amp; srcElem = src[j - 1];
00128         <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; dst = 
00129           Elements.<a class="code" href="classcsArray.html#a9">Get</a> (KeyHandler::ComputeHash (srcElem.key) % Modulo);
00130         <span class="keywordflow">if</span> (&amp;src != &amp;dst)
00131         {
00132           dst.Push (srcElem);
00133           src.DeleteIndex (j - 1);
00134         }
00135       }
00136     }
00137   }
00138 
00139 <span class="keyword">public</span>:
<a name="l00153"></a><a class="code" href="classcsHash.html#a0">00153</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keywordtype">int</span> size = 257, <span class="keywordtype">int</span> grow_rate = 64, <span class="keywordtype">int</span> max_size = 20000)
00154     : Elements (size), Modulo (size), InitModulo (size),
00155       GrowRate (grow_rate), MaxSize (max_size), Size (0)
00156   {
00157     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (size, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> (0, 8));
00158   }
00159 
<a name="l00161"></a><a class="code" href="classcsHash.html#a1">00161</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T&gt;</a> &amp;o) : Elements (o.Elements),
00162     Modulo (o.Modulo), InitModulo (o.InitModulo),
00163     GrowRate (o.GrowRate), MaxSize (o.MaxSize), Size (o.Size) {}
00164 
<a name="l00166"></a><a class="code" href="classcsHash.html#a2">00166</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a2">Put</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00167   {
00168     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00169       Elements[KeyHandler::ComputeHash (key) % Modulo];
00170     values.Push (Element (key, value));
00171     Size++;
00172     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00173      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00174   }
00175 
<a name="l00177"></a><a class="code" href="classcsHash.html#a3">00177</a>   <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> <a class="code" href="classcsHash.html#a3">GetAll</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00178 <span class="keyword">  </span>{
00179     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00180       Elements[KeyHandler::ComputeHash (key) % Modulo];
00181     <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> ret (values.<a class="code" href="classcsArray.html#a4">Length</a> () / 2);
00182     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00183     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00184     {
00185       <span class="keyword">const</span> Element&amp; v = values[i];
00186       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key)) 
00187         ret.Push (v.value);
00188     }
00189     <span class="keywordflow">return</span> ret;
00190   }
00191 
<a name="l00193"></a><a class="code" href="classcsHash.html#a4">00193</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a4">PutFirst</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00194   {
00195     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00196       Elements[KeyHandler::ComputeHash (key) % Modulo];
00197     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00198     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00199     {
00200       Element&amp; v = values[i];
00201       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00202       {
00203         v.value = value;
00204         <span class="keywordflow">return</span>;
00205       }
00206     }
00207 
00208     values.Push (Element (key, value));
00209     Size++;
00210     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00211      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00212   }
00213 
<a name="l00215"></a><a class="code" href="classcsHash.html#a5">00215</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a5">In</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00216 <span class="keyword">  </span>{
00217     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00218       Elements[KeyHandler::ComputeHash (key) % Modulo];
00219     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00220     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00221       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key)) 
00222         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00223 
00224     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00225   }
00226 
<a name="l00231"></a><a class="code" href="classcsHash.html#a6">00231</a>   <span class="keyword">const</span> T* <a class="code" href="classcsHash.html#a6">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00232 <span class="keyword">  </span>{
00233     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00234       Elements[KeyHandler::ComputeHash (key) % Modulo];
00235     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00236     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00237     {
00238       <span class="keyword">const</span> Element&amp; v = values[i];
00239       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00240         <span class="keywordflow">return</span> &amp;v.value;
00241     }
00242 
00243     <span class="keywordflow">return</span> 0;
00244   }
00245 
<a name="l00250"></a><a class="code" href="classcsHash.html#a7">00250</a>   T* <a class="code" href="classcsHash.html#a6">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)
00251   {
00252     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00253       Elements[KeyHandler::ComputeHash (key) % Modulo];
00254     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00255     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00256     {
00257       Element&amp; v = values[i];
00258       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00259         <span class="keywordflow">return</span> &amp;v.value;
00260     }
00261 
00262     <span class="keywordflow">return</span> 0;
00263   }
00264 
<a name="l00269"></a><a class="code" href="classcsHash.html#a8">00269</a>   <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash.html#a8">Get</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T&amp; fallback)<span class="keyword"> const</span>
00270 <span class="keyword">  </span>{
00271     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00272       Elements[KeyHandler::ComputeHash (key) % Modulo];
00273     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00274     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00275     {
00276       <span class="keyword">const</span> Element&amp; v = values[i];
00277       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00278         <span class="keywordflow">return</span> v.value;
00279     }
00280 
00281     <span class="keywordflow">return</span> fallback;
00282   }
00283 
<a name="l00288"></a><a class="code" href="classcsHash.html#a9">00288</a>   T&amp; <a class="code" href="classcsHash.html#a8">Get</a> (<span class="keyword">const</span> K&amp; key, T&amp; fallback)
00289   {
00290     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00291       Elements[KeyHandler::ComputeHash (key) % Modulo];
00292     <span class="keyword">const</span> size_t len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00293     <span class="keywordflow">for</span> (size_t i = 0; i &lt; len; ++i)
00294     {
00295       Element&amp; v = values[i];
00296       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00297         <span class="keywordflow">return</span> v.value;
00298     }
00299 
00300     <span class="keywordflow">return</span> fallback;
00301   }
00302 
<a name="l00304"></a><a class="code" href="classcsHash.html#a10">00304</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a10">DeleteAll</a> ()
00305   {
00306     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo = InitModulo);
00307     size_t elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00308     <span class="keywordflow">for</span> (size_t i = 0; i &lt; elen; i++)
00309       Elements[i].Empty ();
00310     Size = 0;
00311   }
00312 
<a name="l00314"></a><a class="code" href="classcsHash.html#a11">00314</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a10">DeleteAll</a> (<span class="keyword">const</span> K&amp; key)
00315   {
00316     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00317     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00318       Elements[KeyHandler::ComputeHash (key) % Modulo];
00319     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a4">Length</a> (); i &gt; 0; i--)
00320     {
00321       <span class="keyword">const</span> size_t idx = i - 1;
00322       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[idx].key, key))
00323       {
00324         values.DeleteIndex (idx);
00325         ret = <span class="keyword">true</span>;
00326         Size--;
00327       }
00328     }
00329     <span class="keywordflow">return</span> ret;
00330   }
00331   
<a name="l00333"></a><a class="code" href="classcsHash.html#a12">00333</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a12">Delete</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00334   {
00335     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00336     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00337       Elements[KeyHandler::ComputeHash (key) % Modulo];
00338     <span class="keywordflow">for</span> (size_t i = values.<a class="code" href="classcsArray.html#a4">Length</a> (); i &gt; 0; i--)
00339     {
00340       <span class="keyword">const</span> size_t idx = i - 1;
00341       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[idx].key, key) &amp;&amp; 
00342         (values[idx].value == value))
00343       {
00344         values.DeleteIndex (idx);
00345         ret = <span class="keyword">true</span>;
00346         Size--;
00347       }
00348     }
00349     <span class="keywordflow">return</span> ret;
00350   }
00351 
<a name="l00353"></a><a class="code" href="classcsHash.html#a13">00353</a>   size_t <a class="code" href="classcsHash.html#a13">GetSize</a> ()<span class="keyword"> const</span>
00354 <span class="keyword">  </span>{
00355     <span class="keywordflow">return</span> Size;
00356   }
00357 
<a name="l00359"></a><a class="code" href="classcsHash_1_1Iterator.html">00359</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>
00360   {
00361   <span class="keyword">private</span>:
00362     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash;
00363     <span class="keyword">const</span> K key;
00364     size_t bucket, size, element;
00365 
00366     <span class="keywordtype">void</span> Seek ()
00367     {
00368       <span class="keywordflow">while</span> ((element &lt; size) &amp;&amp; 
00369         ! KeyHandler::CompareKeys (hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key, key))
00370           element++;
00371     }
00372 
00373   <span class="keyword">protected</span>:
00374     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash0, <span class="keyword">const</span> K&amp; key0) :
00375       hash(hash0),
00376       key(key0), 
00377       bucket(KeyHandler::ComputeHash(key) % hash-&gt;<a class="code" href="classcsHash.html#n1">Modulo</a>),
00378       size(hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket].Length ())
00379       { <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> (); }
00380 
00381     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>;
00382   <span class="keyword">public</span>:
<a name="l00384"></a><a class="code" href="classcsHash_1_1Iterator.html#a0">00384</a>     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00385       hash (o.hash),
00386       key(o.key),
00387       bucket(o.bucket),
00388       size(o.size),
00389       element(o.element) {}
00390 
<a name="l00392"></a><a class="code" href="classcsHash_1_1Iterator.html#a1">00392</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; <a class="code" href="classcsHash_1_1Iterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; o)
00393     {
00394       hash = o.<a class="code" href="classcsHash_1_1Iterator.html#o0">hash</a>;
00395       key = o.<a class="code" href="classcsHash_1_1Iterator.html#o1">key</a>;
00396       bucket = o.<a class="code" href="classcsHash_1_1Iterator.html#o2">bucket</a>;
00397       size = o.<a class="code" href="classcsHash_1_1Iterator.html#o3">size</a>;
00398       element = o.<a class="code" href="classcsHash_1_1Iterator.html#o4">element</a>;
00399       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00400     }
00401 
<a name="l00403"></a><a class="code" href="classcsHash_1_1Iterator.html#a2">00403</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1Iterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00404 <span class="keyword">    </span>{
00405       <span class="keywordflow">return</span> element &lt; size;
00406     }
00407 
<a name="l00409"></a><a class="code" href="classcsHash_1_1Iterator.html#a3">00409</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1Iterator.html#a3">Next</a> ()
00410     {
00411       <span class="keyword">const</span> T &amp;ret = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].value;
00412       element++;
00413       Seek ();
00414       <span class="keywordflow">return</span> ret;
00415     }
00416 
<a name="l00418"></a><a class="code" href="classcsHash_1_1Iterator.html#a4">00418</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> () { element = 0; Seek (); }
00419   };
00420   <span class="keyword">friend</span> <span class="keyword">class </span>Iterator;
00421 
<a name="l00423"></a><a class="code" href="classcsHash_1_1GlobalIterator.html">00423</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>
00424   {
00425   <span class="keyword">private</span>:
00426     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash;
00427     size_t bucket, size, element;
00428 
00429     <span class="keywordtype">void</span> Zero () { bucket = element = 0; }
00430     <span class="keywordtype">void</span> Init () { size = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket].Length (); }
00431 
00432     <span class="keywordtype">void</span> FindItem ()
00433     {
00434       <span class="keywordflow">if</span> (element &gt;= size)
00435       {
00436         <span class="keywordflow">while</span> (++bucket &lt; hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> ())
00437         {
00438           Init ();
00439           <span class="keywordflow">if</span> (size != 0)
00440           {
00441             element = 0;
00442             <span class="keywordflow">break</span>;
00443           }
00444         }
00445       }
00446     }
00447 
00448   <span class="keyword">protected</span>:
00449     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash0) : hash (hash0) 
00450     { 
00451       Zero (); 
00452       Init (); 
00453       FindItem ();
00454     }
00455 
00456     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>;
00457   <span class="keyword">public</span>:
<a name="l00459"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a0">00459</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00460       hash (o.hash),
00461       bucket (o.bucket),
00462       size (o.size),
00463       element (o.element) {}
00464 
<a name="l00466"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a1">00466</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; o)
00467     {
00468       hash = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o0">hash</a>;
00469       bucket = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o1">bucket</a>;
00470       size = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o2">size</a>;
00471       element = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o3">element</a>;
00472       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00473     }
00474 
<a name="l00476"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a2">00476</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00477 <span class="keyword">    </span>{
00478       <span class="keywordflow">if</span> (hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> () == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00479       <span class="keywordflow">return</span> element &lt; size || bucket &lt; hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> ();
00480     }
00481 
<a name="l00483"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a3">00483</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ()
00484     {
00485       element++;
00486       FindItem ();
00487     }
00488 
<a name="l00490"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a4">00490</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ()
00491     {
00492       <span class="keywordflow">return</span> hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].value;
00493     }
00494 
<a name="l00496"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a5">00496</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ()
00497     {
00498       <span class="keyword">const</span> T &amp;ret = <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00499       <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Advance</a> ();
00500       <span class="keywordflow">return</span> ret;
00501     }
00502 
00503     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> (K &amp;key)
00504     {
00505       key = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key;
00506       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a4">NextNoAdvance</a> ();
00507     }
00508 
<a name="l00510"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a7">00510</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> (K &amp;key)
00511     {
00512       key = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key;
00513       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Next</a> ();
00514     }
00515 
<a name="l00517"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a8">00517</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a8">Reset</a> () { Zero (); Init (); FindItem (); }
00518   };
00519   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00520 
<a name="l00523"></a><a class="code" href="classcsHash.html#a14">00523</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a14">DeleteElement</a> (GlobalIterator iterator)
00524   {
00525     Elements[iterator.bucket].DeleteIndex(iterator.element);
00526     Size--;
00527     iterator.size--;
00528     iterator.FindItem ();
00529   }
00530 
<a name="l00537"></a><a class="code" href="classcsHash.html#a15">00537</a>   Iterator <a class="code" href="classcsHash.html#a16">GetIterator</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00538 <span class="keyword">  </span>{
00539     <span class="keywordflow">return</span> Iterator (<span class="keyword">this</span>, key);
00540   }
00541 
<a name="l00547"></a><a class="code" href="classcsHash.html#a16">00547</a>   GlobalIterator <a class="code" href="classcsHash.html#a16">GetIterator</a> ()<span class="keyword"> const</span>
00548 <span class="keyword">  </span>{
00549     <span class="keywordflow">return</span> GlobalIterator (<span class="keyword">this</span>);
00550   }
00551 };
00552 
00558 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> KeyHandler = csIntegralHashKeyHandler&lt;T&gt; &gt; 
<a name="l00559"></a><a class="code" href="classcsSet.html">00559</a> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>
00560 {
00561 <span class="keyword">private</span>:
00562   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a> map;
00563 
00564 <span class="keyword">public</span>:
<a name="l00566"></a><a class="code" href="classcsSet_1_1Iterator.html">00566</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1Iterator.html">Iterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1Iterator.html">Iterator</a>
00567   {
00568   <span class="keyword">protected</span>:
00569     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> () {}
00570   <span class="keyword">public</span>:
00571   };
<a name="l00573"></a><a class="code" href="classcsSet_1_1GlobalIterator.html">00573</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>
00574   {
00575   <span class="keyword">protected</span>:
00576     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> () {}
00577     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsSet.html">csSet&lt;T, KeyHandler&gt;</a> *set0) : 
00578       <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;::GlobalIterator</a>(&amp;set0-&gt;map)
00579     { }
00580 
00581   <span class="keyword">public</span>:
00582     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>;
00583   };
00584   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00585 
<a name="l00590"></a><a class="code" href="classcsSet.html#a0">00590</a>   <a class="code" href="classcsSet.html#a0">csSet</a> (<span class="keywordtype">int</span> size = 257, <span class="keywordtype">int</span> grow_rate = 64, <span class="keywordtype">int</span> max_size = 20000)
00591         : map (size, grow_rate, max_size)
00592   {
00593   }
00594 
<a name="l00599"></a><a class="code" href="classcsSet.html#a1">00599</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a1">Add</a> (<span class="keyword">const</span> T&amp; object)
00600   {
00601     <span class="keywordflow">if</span> (<a class="code" href="classcsSet.html#a3">In</a> (object)) <span class="keywordflow">return</span>;
00602     <a class="code" href="classcsSet.html#a2">AddNoTest</a> (object);
00603   }
00604 
<a name="l00611"></a><a class="code" href="classcsSet.html#a2">00611</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a2">AddNoTest</a> (<span class="keyword">const</span> T&amp; object)
00612   {
00613     map.<a class="code" href="classcsHash.html#a2">Put</a> (object, object);
00614   }
00615 
<a name="l00619"></a><a class="code" href="classcsSet.html#a3">00619</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a3">In</a> (<span class="keyword">const</span> T&amp; object)<span class="keyword"> const</span>
00620 <span class="keyword">  </span>{
00621     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a5">In</a> (object);
00622   }
00623 
<a name="l00627"></a><a class="code" href="classcsSet.html#a4">00627</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a4">DeleteAll</a> ()
00628   {
00629     map.<a class="code" href="classcsHash.html#a10">DeleteAll</a> ();
00630   }
00631 
<a name="l00637"></a><a class="code" href="classcsSet.html#a5">00637</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a5">Delete</a> (<span class="keyword">const</span> T&amp; object)
00638   {
00639     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a12">Delete</a> (object, object);
00640   }
00641 
<a name="l00643"></a><a class="code" href="classcsSet.html#a6">00643</a>   size_t <a class="code" href="classcsSet.html#a6">GetSize</a> ()<span class="keyword"> const</span>
00644 <span class="keyword">  </span>{
00645     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a13">GetSize</a> ();
00646   }
00647 
<a name="l00649"></a><a class="code" href="classcsSet.html#a7">00649</a>   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a>* <a class="code" href="classcsSet.html#a7">GetHash</a> () { <span class="keywordflow">return</span> &amp;map; }
00650 
<a name="l00656"></a><a class="code" href="classcsSet.html#a8">00656</a>   <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> <a class="code" href="classcsSet.html#a8">GetIterator</a> ()<span class="keyword"> const</span>
00657 <span class="keyword">  </span>{
00658     <span class="keywordflow">return</span> <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>(<span class="keyword">this</span>);
00659   }
00660 };
00661 
00662 
00663 <span class="preprocessor">#endif</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
