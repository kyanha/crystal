<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/hash.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>csutil/hash.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2003 by Mat Sutcliffe &lt;oktal@gmx.co.uk&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_UTIL_HASH_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_UTIL_HASH_H__</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include "csextern.h"</span>
00023 <span class="preprocessor">#include "array.h"</span>
00024 
00031 CS_CSUTIL_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> csHashCompute (<span class="keywordtype">char</span> <span class="keyword">const</span>*);
00032 
00039 CS_CSUTIL_EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> csHashCompute (<span class="keywordtype">char</span> <span class="keyword">const</span>*, <span class="keywordtype">int</span> length);
00040 
00044 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00045"></a><a class="code" href="classcsIntegralHashKeyHandler.html">00045</a> <span class="keyword">class </span><a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler</a>
00046 {
00047 <span class="keyword">public</span>:
00048   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ComputeHash (<span class="keyword">const</span> T&amp; key)
00049   {
00050     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)key;
00051   }
00052 
00053   <span class="keyword">static</span> <span class="keywordtype">bool</span> CompareKeys (<span class="keyword">const</span> T&amp; key1, <span class="keyword">const</span> T&amp; key2)
00054   {
00055     <span class="keywordflow">return</span> (key1 == key2);
00056   }
00057 };
00058 
00063 <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>K = <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, 
00064   <span class="keyword">class </span>KeyHandler = <a class="code" href="classcsIntegralHashKeyHandler.html">csIntegralHashKeyHandler&lt;K&gt;</a> &gt; 
<a name="l00065"></a><a class="code" href="classcsHash.html">00065</a> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>
00066 {
00067 <span class="keyword">protected</span>:
00068   <span class="keyword">struct </span>Element
00069   {
00070     <span class="keyword">const</span> K key;
00071     T value;
00072 
00073     Element (<span class="keyword">const</span> K&amp; key0, <span class="keyword">const</span> T &amp;value0) : key (key0), value (value0) {}
00074     Element (<span class="keyword">const</span> Element &amp;other) : key (other.key), value (other.value) {}
00075   };
00076   <a class="code" href="classcsArray.html">csArray&lt; csArray&lt;Element&gt;</a> &gt; Elements;
00077 
00078   <span class="keywordtype">int</span> Modulo;
00079 
00080 <span class="keyword">private</span>:
00081   <span class="keywordtype">int</span> InitModulo;
00082   <span class="keywordtype">int</span> GrowRate;
00083   <span class="keywordtype">int</span> MaxSize;
00084   <span class="keywordtype">int</span> Size;
00085 
00086   <span class="keywordtype">void</span> Grow ()
00087   {
00088     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> Primes[] =
00089     {
00090       53,         97,         193,       389,       769, 
00091       1543,       3079,       6151,      12289,     24593,
00092       49157,      98317,      196613,    393241,    786433,
00093       1572869,    3145739,    6291469,   12582917,  25165843,
00094       50331653,   100663319,  201326611, 402653189, 805306457,
00095       1610612741, 0
00096     };
00097 
00098     <span class="keyword">const</span> <span class="keywordtype">int</span> *p;
00099     <span class="keywordtype">int</span> elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00100     <span class="keywordflow">for</span> (p = Primes; *p &amp;&amp; *p &lt;= elen; p++) ;
00101     Modulo = *p;
00102     CS_ASSERT (Modulo);
00103 
00104     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo);
00105 
00106     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; elen; i++)
00107     {
00108       <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; src = Elements[i];
00109       <span class="keywordtype">int</span> slen = src.<a class="code" href="classcsArray.html#a4">Length</a> ();
00110       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = slen - 1; j &gt;= 0; j--)
00111       {
00112         <span class="keyword">const</span> Element&amp; srcElem = src[j];
00113         <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a>&amp; dst = 
00114           Elements.<a class="code" href="classcsArray.html#a9">Get</a> (KeyHandler::ComputeHash (srcElem.key) % Modulo);
00115         <span class="keywordflow">if</span> (&amp;src != &amp;dst)
00116         {
00117           dst.Push (srcElem);
00118           src.DeleteIndex (j);
00119         }
00120       }
00121     }
00122   }
00123 
00124 <span class="keyword">public</span>:
<a name="l00138"></a><a class="code" href="classcsHash.html#a0">00138</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keywordtype">int</span> size = 257, <span class="keywordtype">int</span> grow_rate = 64, <span class="keywordtype">int</span> max_size = 20000)
00139     : Elements (size), Modulo (size), InitModulo (size),
00140       GrowRate (grow_rate), MaxSize (max_size), Size (0)
00141   {
00142     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (size, <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> (0, 8));
00143   }
00144 
<a name="l00146"></a><a class="code" href="classcsHash.html#a1">00146</a>   <a class="code" href="classcsHash.html#a0">csHash</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T&gt;</a> &amp;o) : Elements (o.Elements),
00147     Modulo (o.Modulo), InitModulo (o.InitModulo),
00148     GrowRate (o.GrowRate), MaxSize (o.MaxSize), Size (o.Size) {}
00149 
<a name="l00151"></a><a class="code" href="classcsHash.html#a2">00151</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a2">Put</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00152   {
00153     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00154       Elements[KeyHandler::ComputeHash (key) % Modulo];
00155     values.Push (Element (key, value));
00156     Size++;
00157     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00158      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00159   }
00160 
<a name="l00162"></a><a class="code" href="classcsHash.html#a3">00162</a>   <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> <a class="code" href="classcsHash.html#a3">GetAll</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00163 <span class="keyword">  </span>{
00164     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00165       Elements[KeyHandler::ComputeHash (key) % Modulo];
00166     <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> ret (values.<a class="code" href="classcsArray.html#a4">Length</a> () / 2);
00167     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00168     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00169     {
00170       <span class="keyword">const</span> Element&amp; v = values[i];
00171       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key)) 
00172         ret.Push (v.value);
00173     }
00174     <span class="keywordflow">return</span> ret;
00175   }
00176 
<a name="l00178"></a><a class="code" href="classcsHash.html#a4">00178</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a4">PutFirst</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00179   {
00180     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00181       Elements[KeyHandler::ComputeHash (key) % Modulo];
00182     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00183     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00184     {
00185       Element&amp; v = values[i];
00186       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00187       {
00188         v.value = value;
00189         <span class="keywordflow">return</span>;
00190       }
00191     }
00192 
00193     values.Push (Element (key, value));
00194     Size++;
00195     <span class="keywordflow">if</span> (values.<a class="code" href="classcsArray.html#a4">Length</a> () &gt; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () / GrowRate
00196      &amp;&amp; Elements.<a class="code" href="classcsArray.html#a4">Length</a> () &lt; MaxSize) Grow ();
00197   }
00198 
<a name="l00200"></a><a class="code" href="classcsHash.html#a5">00200</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a5">In</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00201 <span class="keyword">  </span>{
00202     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00203       Elements[KeyHandler::ComputeHash (key) % Modulo];
00204     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00205     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00206       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key)) 
00207         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00208 
00209     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00210   }
00211 
<a name="l00216"></a><a class="code" href="classcsHash.html#a6">00216</a>   <span class="keyword">const</span> T* <a class="code" href="classcsHash.html#a6">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00217 <span class="keyword">  </span>{
00218     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00219       Elements[KeyHandler::ComputeHash (key) % Modulo];
00220     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00221     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00222     {
00223       <span class="keyword">const</span> Element&amp; v = values[i];
00224       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00225         <span class="keywordflow">return</span> &amp;v.value;
00226     }
00227 
00228     <span class="keywordflow">return</span> 0;
00229   }
00230 
<a name="l00235"></a><a class="code" href="classcsHash.html#a7">00235</a>   T* <a class="code" href="classcsHash.html#a6">GetElementPointer</a> (<span class="keyword">const</span> K&amp; key)
00236   {
00237     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00238       Elements[KeyHandler::ComputeHash (key) % Modulo];
00239     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00240     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00241     {
00242       Element&amp; v = values[i];
00243       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00244         <span class="keywordflow">return</span> &amp;v.value;
00245     }
00246 
00247     <span class="keywordflow">return</span> 0;
00248   }
00249 
<a name="l00254"></a><a class="code" href="classcsHash.html#a8">00254</a>   <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash.html#a8">Get</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T&amp; fallback)<span class="keyword"> const</span>
00255 <span class="keyword">  </span>{
00256     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00257       Elements[KeyHandler::ComputeHash (key) % Modulo];
00258     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00259     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00260     {
00261       <span class="keyword">const</span> Element&amp; v = values[i];
00262       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00263         <span class="keywordflow">return</span> v.value;
00264     }
00265 
00266     <span class="keywordflow">return</span> fallback;
00267   }
00268 
<a name="l00273"></a><a class="code" href="classcsHash.html#a9">00273</a>   T&amp; <a class="code" href="classcsHash.html#a8">Get</a> (<span class="keyword">const</span> K&amp; key, T&amp; fallback)
00274   {
00275     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00276       Elements[KeyHandler::ComputeHash (key) % Modulo];
00277     <span class="keyword">const</span> <span class="keywordtype">int</span> len = values.<a class="code" href="classcsArray.html#a4">Length</a> ();
00278     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
00279     {
00280       Element&amp; v = values[i];
00281       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (v.key, key))
00282         <span class="keywordflow">return</span> v.value;
00283     }
00284 
00285     <span class="keywordflow">return</span> fallback;
00286   }
00287 
<a name="l00289"></a><a class="code" href="classcsHash.html#a10">00289</a>   <span class="keywordtype">void</span> <a class="code" href="classcsHash.html#a10">DeleteAll</a> ()
00290   {
00291     Elements.<a class="code" href="classcsArray.html#a7">SetLength</a> (Modulo = InitModulo);
00292     <span class="keywordtype">int</span> elen = Elements.<a class="code" href="classcsArray.html#a4">Length</a> ();
00293     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; elen; i++)
00294       Elements[i].Empty ();
00295     Size = 0;
00296   }
00297 
<a name="l00299"></a><a class="code" href="classcsHash.html#a11">00299</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a10">DeleteAll</a> (<span class="keyword">const</span> K&amp; key)
00300   {
00301     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00302     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00303       Elements[KeyHandler::ComputeHash (key) % Modulo];
00304     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = values.<a class="code" href="classcsArray.html#a4">Length</a> () - 1; i &gt;= 0; i--)
00305       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key))
00306       {
00307         values.DeleteIndex (i);
00308         ret = <span class="keyword">true</span>;
00309         Size--;
00310       }
00311     <span class="keywordflow">return</span> ret;
00312   }
00313   
<a name="l00315"></a><a class="code" href="classcsHash.html#a12">00315</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsHash.html#a12">Delete</a> (<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> T &amp;value)
00316   {
00317     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
00318     <a class="code" href="classcsArray.html">csArray&lt;Element&gt;</a> &amp;values = 
00319       Elements[KeyHandler::ComputeHash (key) % Modulo];
00320     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = values.<a class="code" href="classcsArray.html#a4">Length</a> () - 1; i &gt;= 0; i--)
00321       <span class="keywordflow">if</span> (KeyHandler::CompareKeys (values[i].key, key) &amp;&amp; 
00322         (values[i].value == value))
00323       {
00324         values.DeleteIndex (i);
00325         ret = <span class="keyword">true</span>;
00326         Size--;
00327       }
00328     <span class="keywordflow">return</span> ret;
00329   }
00330 
<a name="l00332"></a><a class="code" href="classcsHash.html#a13">00332</a>   <span class="keywordtype">int</span> <a class="code" href="classcsHash.html#a13">GetSize</a> ()<span class="keyword"> const</span>
00333 <span class="keyword">  </span>{
00334     <span class="keywordflow">return</span> Size;
00335   }
00336 
<a name="l00338"></a><a class="code" href="classcsHash_1_1Iterator.html">00338</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>
00339   {
00340   <span class="keyword">private</span>:
00341     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash;
00342     <span class="keyword">const</span> K key;
00343     <span class="keywordtype">int</span> bucket, size, element;
00344 
00345     <span class="keywordtype">void</span> Seek ()
00346     {
00347       <span class="keywordflow">while</span> ((element &lt; size) &amp;&amp; 
00348         ! KeyHandler::CompareKeys (hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key, key))
00349           element++;
00350     }
00351 
00352   <span class="keyword">protected</span>:
00353     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a>* hash0, <span class="keyword">const</span> K&amp; key0) :
00354       hash(hash0),
00355       key(key0), 
00356       bucket(KeyHandler::ComputeHash(key) % hash-&gt;<a class="code" href="classcsHash.html#n1">Modulo</a>),
00357       size(hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket].Length ())
00358       { <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> (); }
00359 
00360     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>;
00361   <span class="keyword">public</span>:
<a name="l00363"></a><a class="code" href="classcsHash_1_1Iterator.html#a0">00363</a>     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00364       hash (o.hash),
00365       key(o.key),
00366       bucket(o.bucket),
00367       size(o.size),
00368       element(o.element) {}
00369 
<a name="l00371"></a><a class="code" href="classcsHash_1_1Iterator.html#a1">00371</a>     <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; <a class="code" href="classcsHash_1_1Iterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a>&amp; o)
00372     {
00373       hash = o.<a class="code" href="classcsHash_1_1Iterator.html#o0">hash</a>;
00374       key = o.<a class="code" href="classcsHash_1_1Iterator.html#o1">key</a>;
00375       bucket = o.<a class="code" href="classcsHash_1_1Iterator.html#o2">bucket</a>;
00376       size = o.<a class="code" href="classcsHash_1_1Iterator.html#o3">size</a>;
00377       element = o.<a class="code" href="classcsHash_1_1Iterator.html#o4">element</a>;
00378       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00379     }
00380 
<a name="l00382"></a><a class="code" href="classcsHash_1_1Iterator.html#a2">00382</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1Iterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00383 <span class="keyword">    </span>{
00384       <span class="keywordflow">return</span> element &lt; size;
00385     }
00386 
<a name="l00388"></a><a class="code" href="classcsHash_1_1Iterator.html#a3">00388</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1Iterator.html#a3">Next</a> ()
00389     {
00390       <span class="keyword">const</span> T &amp;ret = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].value;
00391       element++;
00392       Seek ();
00393       <span class="keywordflow">return</span> ret;
00394     }
00395 
<a name="l00397"></a><a class="code" href="classcsHash_1_1Iterator.html#a4">00397</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1Iterator.html#a4">Reset</a> () { element = 0; Seek (); }
00398   };
00399   <span class="keyword">friend</span> <span class="keyword">class </span>Iterator;
00400 
<a name="l00402"></a><a class="code" href="classcsHash_1_1GlobalIterator.html">00402</a>   <span class="keyword">class </span><a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>
00403   {
00404   <span class="keyword">private</span>:
00405     <span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash;
00406     <span class="keywordtype">int</span> bucket, size, element;
00407 
00408     <span class="keywordtype">void</span> Zero () { bucket = element = 0; }
00409     <span class="keywordtype">void</span> Init () { size = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket].Length (); }
00410 
00411     <span class="keywordtype">void</span> FindItem ()
00412     {
00413       <span class="keywordflow">if</span> (element &gt;= size)
00414       {
00415         <span class="keywordflow">while</span> (++bucket &lt; hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> ())
00416         {
00417           Init ();
00418           <span class="keywordflow">if</span> (size != 0)
00419           {
00420             element = 0;
00421             <span class="keywordflow">break</span>;
00422           }
00423         }
00424       }
00425     }
00426 
00427   <span class="keyword">protected</span>:
00428     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash.html">csHash&lt;T, K, KeyHandler&gt;</a> *hash0) : hash (hash0) 
00429     { 
00430       Zero (); 
00431       Init (); 
00432       FindItem ();
00433     }
00434 
00435     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHash.html">csHash</a>;
00436   <span class="keyword">public</span>:
<a name="l00438"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a0">00438</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsHash_1_1Iterator.html">Iterator</a> &amp;o) :
00439       hash (o.hash),
00440       bucket (o.bucket),
00441       size (o.size),
00442       element (o.element) {}
00443 
<a name="l00445"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a1">00445</a>     <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a1">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcsHash_1_1GlobalIterator.html">GlobalIterator</a>&amp; o)
00446     {
00447       hash = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o0">hash</a>;
00448       bucket = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o1">bucket</a>;
00449       size = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o2">size</a>;
00450       element = o.<a class="code" href="classcsHash_1_1GlobalIterator.html#o3">element</a>;
00451       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00452     }
00453 
<a name="l00455"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a2">00455</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a2">HasNext</a> ()<span class="keyword"> const</span>
00456 <span class="keyword">    </span>{
00457       <span class="keywordflow">if</span> (hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> () == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00458       <span class="keywordflow">return</span> element &lt; size || bucket &lt; hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>.<a class="code" href="classcsArray.html#a4">Length</a> ();
00459     }
00460 
<a name="l00462"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a3">00462</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Next</a> ()
00463     {
00464       <span class="keyword">const</span> T &amp;ret = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].value;
00465       element++;
00466       FindItem ();
00467       <span class="keywordflow">return</span> ret;
00468     }
00469 
<a name="l00471"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a4">00471</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Next</a> (K &amp;key)
00472     {
00473       key = hash-&gt;<a class="code" href="classcsHash.html#n0">Elements</a>[bucket][element].key;
00474       <span class="keywordflow">return</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a3">Next</a> ();
00475     }
00476 
<a name="l00478"></a><a class="code" href="classcsHash_1_1GlobalIterator.html#a5">00478</a>     <span class="keywordtype">void</span> <a class="code" href="classcsHash_1_1GlobalIterator.html#a5">Reset</a> () { Zero (); Init (); FindItem (); }
00479   };
00480   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00481 
<a name="l00488"></a><a class="code" href="classcsHash.html#a14">00488</a>   Iterator <a class="code" href="classcsHash.html#a15">GetIterator</a> (<span class="keyword">const</span> K&amp; key)<span class="keyword"> const</span>
00489 <span class="keyword">  </span>{
00490     <span class="keywordflow">return</span> Iterator (<span class="keyword">this</span>, key);
00491   }
00492 
<a name="l00498"></a><a class="code" href="classcsHash.html#a15">00498</a>   GlobalIterator <a class="code" href="classcsHash.html#a15">GetIterator</a> ()<span class="keyword"> const</span>
00499 <span class="keyword">  </span>{
00500     <span class="keywordflow">return</span> GlobalIterator (<span class="keyword">this</span>);
00501   }
00502 };
00503 
00509 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> KeyHandler = csIntegralHashKeyHandler&lt;T&gt; &gt; 
<a name="l00510"></a><a class="code" href="classcsSet.html">00510</a> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>
00511 {
00512 <span class="keyword">private</span>:
00513   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a> map;
00514 
00515 <span class="keyword">public</span>:
<a name="l00517"></a><a class="code" href="classcsSet_1_1Iterator.html">00517</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1Iterator.html">Iterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1Iterator.html">Iterator</a>
00518   {
00519   <span class="keyword">protected</span>:
00520     <a class="code" href="classcsHash_1_1Iterator.html#a0">Iterator</a> () {}
00521   <span class="keyword">public</span>:
00522   };
<a name="l00524"></a><a class="code" href="classcsSet_1_1GlobalIterator.html">00524</a>   <span class="keyword">class </span><a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> : <span class="keyword">public</span> <a class="code" href="classcsHash.html">csHash</a>&lt;T, T, KeyHandler&gt;::<a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>
00525   {
00526   <span class="keyword">protected</span>:
00527     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> () {}
00528     <a class="code" href="classcsHash_1_1GlobalIterator.html#a0">GlobalIterator</a> (<span class="keyword">const</span> <a class="code" href="classcsSet.html">csSet&lt;T, KeyHandler&gt;</a> *set0) : 
00529       <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;::GlobalIterator</a>(&amp;set0-&gt;map)
00530     { }
00531 
00532   <span class="keyword">public</span>:
00533     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsSet.html">csSet</a>;
00534   };
00535   <span class="keyword">friend</span> <span class="keyword">class </span>GlobalIterator;
00536 
<a name="l00541"></a><a class="code" href="classcsSet.html#a0">00541</a>   <a class="code" href="classcsSet.html#a0">csSet</a> (<span class="keywordtype">int</span> size = 257, <span class="keywordtype">int</span> grow_rate = 64, <span class="keywordtype">int</span> max_size = 20000)
00542         : map (size, grow_rate, max_size)
00543   {
00544   }
00545 
<a name="l00550"></a><a class="code" href="classcsSet.html#a1">00550</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a1">Add</a> (<span class="keyword">const</span> T&amp; object)
00551   {
00552     <span class="keywordflow">if</span> (<a class="code" href="classcsSet.html#a3">In</a> (object)) <span class="keywordflow">return</span>;
00553     <a class="code" href="classcsSet.html#a2">AddNoTest</a> (object);
00554   }
00555 
<a name="l00562"></a><a class="code" href="classcsSet.html#a2">00562</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a2">AddNoTest</a> (<span class="keyword">const</span> T&amp; object)
00563   {
00564     map.<a class="code" href="classcsHash.html#a2">Put</a> (object, object);
00565   }
00566 
<a name="l00570"></a><a class="code" href="classcsSet.html#a3">00570</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a3">In</a> (<span class="keyword">const</span> T&amp; object)<span class="keyword"> const</span>
00571 <span class="keyword">  </span>{
00572     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a5">In</a> (object);
00573   }
00574 
<a name="l00578"></a><a class="code" href="classcsSet.html#a4">00578</a>   <span class="keywordtype">void</span> <a class="code" href="classcsSet.html#a4">DeleteAll</a> ()
00579   {
00580     map.<a class="code" href="classcsHash.html#a10">DeleteAll</a> ();
00581   }
00582 
<a name="l00588"></a><a class="code" href="classcsSet.html#a5">00588</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsSet.html#a5">Delete</a> (<span class="keyword">const</span> T&amp; object)
00589   {
00590     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a12">Delete</a> (object, object);
00591   }
00592 
<a name="l00594"></a><a class="code" href="classcsSet.html#a6">00594</a>   <span class="keywordtype">int</span> <a class="code" href="classcsSet.html#a6">GetSize</a> ()<span class="keyword"> const</span>
00595 <span class="keyword">  </span>{
00596     <span class="keywordflow">return</span> map.<a class="code" href="classcsHash.html#a13">GetSize</a> ();
00597   }
00598 
<a name="l00600"></a><a class="code" href="classcsSet.html#a7">00600</a>   <a class="code" href="classcsHash.html">csHash&lt;T, T, KeyHandler&gt;</a>* <a class="code" href="classcsSet.html#a7">GetHash</a> () { <span class="keywordflow">return</span> &amp;map; }
00601 
<a name="l00607"></a><a class="code" href="classcsSet.html#a8">00607</a>   <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a> <a class="code" href="classcsSet.html#a8">GetIterator</a> ()<span class="keyword"> const</span>
00608 <span class="keyword">  </span>{
00609     <span class="keywordflow">return</span> <a class="code" href="classcsSet_1_1GlobalIterator.html">GlobalIterator</a>(<span class="keyword">this</span>);
00610   }
00611 };
00612 
00613 <span class="preprocessor">#endif</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
