<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>iCollideSystem struct Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>iCollideSystem Struct Reference</h1>This is the Collide plug-in. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="ivaria_2collider_8h-source.html">collider.h</a>&gt;</code>
<p>
<p>Inheritance diagram for iCollideSystem:
<p><center><img src="structiCollideSystem.png" usemap="#iCollideSystem_map" border="0" alt=""></center>
<map name="iCollideSystem_map">
<area href="structiBase.html" alt="iBase" shape="rect" coords="0,0,94,24">
</map>
<a href="structiCollideSystem-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiCollider.html">iCollider</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="structiCollideSystem.html#a0">CreateCollider</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *mesh)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a <a class="el" href="structiCollider.html">iCollider</a> for the given mesh geometry.</em> <a href="#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="structiCollideSystem.html#a1">Collide</a> (<a class="el" href="structiCollider.html">iCollider</a> *collider1, const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *trans1, <a class="el" href="structiCollider.html">iCollider</a> *collider2, const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *trans2)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Test collision between two colliders.</em> <a href="#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="structcsCollisionPair.html">csCollisionPair</a> *&nbsp;</td><td valign=bottom><a class="el" href="structiCollideSystem.html#a2">GetCollisionPairs</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get pointer to current array of collision pairs.</em> <a href="#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="structiCollideSystem.html#a3">GetCollisionPairCount</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get number of collision pairs in array.</em> <a href="#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiCollideSystem.html#a4">ResetCollisionPairs</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Reset the array with collision pairs.</em> <a href="#a4"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="structiCollideSystem.html#a5">SetOneHitOnly</a> (bool o)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Indicate if we are interested only in the first hit that is found.</em> <a href="#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="structiCollideSystem.html#a6">GetOneHitOnly</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return true if this CD system will only return the first hit that is found.</em> <a href="#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="structiCollideSystem.html#a7">CollidePath</a> (<a class="el" href="structiCollider.html">iCollider</a> *collider, const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *trans, <a class="el" href="classcsVector3.html">csVector3</a> &amp;newpos, int num_colliders, <a class="el" href="structiCollider.html">iCollider</a> **colliders, <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> **transforms)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Test if an object can move to a new position.</em> <a href="#a7"></a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This is the Collide plug-in.
<p>
This plugin is a factory for creating <a class="el" href="structiCollider.html">iCollider</a> entities. A collider represents an entity in the collision detection world. It uses the geometry data as given by <a class="el" href="structiPolygonMesh.html">iPolygonMesh</a>. 
<p>
 Main creators of instances implementing this interface: <ul>
<li>RAPID plugin (crystalspace.collisiondetection.rapid) <li>OPCODE plugin (crystalspace.collisiondetection.opcode) </ul>
Main ways to get pointers to this interface: <ul>
<li><a class="el" href="group__scf.html#a59">CS_QUERY_REGISTRY()</a> </ul>
Main users of this interface: <ul>
<li><a class="el" href="classcsColliderWrapper.html">csColliderWrapper</a> <li><a class="el" href="classcsColliderHelper.html">csColliderHelper</a> </ul>

<p>

<p>
Definition at line <a class="el" href="ivaria_2collider_8h-source.html#l00085">85</a> of file <a class="el" href="ivaria_2collider_8h-source.html">collider.h</a>.<hr><h2>Member Function Documentation</h2>
<a name="a1" doxytag="iCollideSystem::Collide"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool iCollideSystem::Collide </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiCollider.html">iCollider</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>collider1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>trans1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structiCollider.html">iCollider</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>collider2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>trans2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test collision between two colliders.
<p>
This is only supported for <a class="el" href="structiCollider.html">iCollider</a> objects created by this plugin. Returns false if no collision or else true. The collisions will be added to the collision pair array that you can query with GetCollisionPairs and reset/clear with ResetCollisionPairs (very important! Do not forget this). Every call to Collide will add to that array.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>collider1</em>&nbsp;</td><td>
is the first collider as created by this same collide system (never pass in a collider created by another collide system). </td></tr>
<tr><td valign=top><em>trans1</em>&nbsp;</td><td>
is the transform for the object represented by the first collider. If the collider belongs to a mesh object then you can get the transform by calling mesh-&gt;GetMovable ()-&gt;GetFullTransform(). </td></tr>
<tr><td valign=top><em>collider2</em>&nbsp;</td><td>
is the second collider. </td></tr>
<tr><td valign=top><em>trans2</em>&nbsp;</td><td>
is the second transform. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
true if there are triangles that intersect. The array with collision pairs will be updated. </dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="iCollideSystem::CollidePath"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int iCollideSystem::CollidePath </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiCollider.html">iCollider</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>collider</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>trans</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>newpos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>num_colliders</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structiCollider.html">iCollider</a> **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>colliders</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>transforms</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test if an object can move to a new position.
<p>
The new position vector will be modified to reflect the maximum new position that the object could move to without colliding with something. This function will return: <ul>
<li>-1 if the object could not move at all (i.e. stuck at start position). <li>0 if the object could not move fully to the desired position. <li>1 if the object can move unhindered to the end position. </ul>

<p>
 This function will reset the collision pair array. If there was a collision along the way the array will contain the information for the first collision preventing movement. 
<p>
 The given transform should be the transform of the object corresponding with the old position. 'colliders' and 'transforms' should be arrays with 'num_colliders' elements for all the objects that we should test against. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>collider</em>&nbsp;</td><td>
is the collider of the object that we are going to move along the path. </td></tr>
<tr><td valign=top><em>trans</em>&nbsp;</td><td>
is the transform of that object (see <a class="el" href="structiCollideSystem.html#a1">Collide()</a>). </td></tr>
<tr><td valign=top><em>newpos</em>&nbsp;</td><td>
is the new position of that object. </td></tr>
<tr><td valign=top><em>num_colliders</em>&nbsp;</td><td>
is the number of colliders that we are going to use to collide with. </td></tr>
<tr><td valign=top><em>colliders</em>&nbsp;</td><td>
is an array of colliders. Typically you can obtain such a list by doing <a class="el" href="structiEngine.html">iEngine</a>-&gt;GetNearbyMeshes() and then getting the colliders from all meshes you get (possibly using <a class="el" href="classcsColliderWrapper.html">csColliderWrapper</a>). </td></tr>
<tr><td valign=top><em>transforms</em>&nbsp;</td><td>
is an array of transforms that belong with the array of colliders. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a0" doxytag="iCollideSystem::CreateCollider"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiCollider.html">iCollider</a>&gt; iCollideSystem::CreateCollider </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>mesh</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a <a class="el" href="structiCollider.html">iCollider</a> for the given mesh geometry.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>mesh</em>&nbsp;</td><td>
is a structure describing the geometry from which the collider will be made. You can get such a mesh either by making your own subclass of <a class="el" href="structiPolygonMesh.html">iPolygonMesh</a>, by getting a mesh from <a class="el" href="structiMeshObject.html">iMeshObject</a>-&gt;GetObjectModel()-&gt;GetPolygonMeshColldet(), or else by using <a class="el" href="classcsPolygonMesh.html">csPolygonMesh</a>, or <a class="el" href="classcsPolygonMeshBox.html">csPolygonMeshBox</a>. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
a reference to a collider that you have to store. </dl>    </td>
  </tr>
</table>
<a name="a3" doxytag="iCollideSystem::GetCollisionPairCount"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int iCollideSystem::GetCollisionPairCount </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get number of collision pairs in array.
<p>
<dl compact><dt><b>Returns: </b></dt><dd>
the number of collision pairs. </dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="iCollideSystem::GetCollisionPairs"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="structcsCollisionPair.html">csCollisionPair</a>* iCollideSystem::GetCollisionPairs </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get pointer to current array of collision pairs.
<p>
This array will grow with every call to Collide until you clear it using 'ResetCollisionPairs'. Note that the triangles are in object space and not world space! <dl compact><dt><b>Returns: </b></dt><dd>
an array of collision pairs for all <a class="el" href="structiCollideSystem.html#a1">Collide()</a> calls that occured between now and the call to <a class="el" href="structiCollideSystem.html#a4">ResetCollisionPairs()</a>. </dl>    </td>
  </tr>
</table>
<a name="a6" doxytag="iCollideSystem::GetOneHitOnly"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool iCollideSystem::GetOneHitOnly </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true if this CD system will only return the first hit that is found.
<p>
For CD systems that support multiple hits this will return the value set by the <a class="el" href="structiCollideSystem.html#a5">SetOneHitOnly()</a> function. For CD systems that support one hit only this will always return true. <dl compact><dt><b>Returns: </b></dt><dd>
true if there is only one hit recorder for every call to <a class="el" href="structiCollideSystem.html#a1">Collide()</a>. </dl>    </td>
  </tr>
</table>
<a name="a4" doxytag="iCollideSystem::ResetCollisionPairs"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iCollideSystem::ResetCollisionPairs </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset the array with collision pairs.
<p>
It is very important to call this before collision detection. Otherwise the internal table of collision pairs will grow forever.     </td>
  </tr>
</table>
<a name="a5" doxytag="iCollideSystem::SetOneHitOnly"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void iCollideSystem::SetOneHitOnly </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>o</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Indicate if we are interested only in the first hit that is found.
<p>
This is only valid for CD algorithms that actually allow the detection of multiple CD hit points. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>o</em>&nbsp;</td><td>
is true if you are only interested in one colliding triangle per call to Collide. By default this is 'false' unless the CD system only supports single hits. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>ivaria/<a class="el" href="ivaria_2collider_8h-source.html">collider.h</a></ul>
<hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
