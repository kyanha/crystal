<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/blockallocator.h Source File (Crystal Space Public API Reference)</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr height="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr height="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>csutil/blockallocator.h</h1><a href="blockallocator_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">  Crystal Space Generic Object Block Allocator</span>
<a name="l00003"></a>00003 <span class="comment">  Copyright (C)2005 by Eric sunshine &lt;sunshine@sunshineco.com&gt;</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">  This library is free software; you can redistribute it and/or</span>
<a name="l00006"></a>00006 <span class="comment">  modify it under the terms of the GNU Library General Public</span>
<a name="l00007"></a>00007 <span class="comment">  License as published by the Free Software Foundation; either</span>
<a name="l00008"></a>00008 <span class="comment">  version 2 of the License, or (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">  This library is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment">  Library General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">  You should have received a copy of the GNU Library General Public</span>
<a name="l00016"></a>00016 <span class="comment">  License along with this library; if not, write to the Free</span>
<a name="l00017"></a>00017 <span class="comment">  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<a name="l00018"></a>00018 <span class="comment">*/</span>
<a name="l00019"></a>00019 <span class="preprocessor">#ifndef __CSUTIL_BLOCK_ALLOCATOR_H__</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define __CSUTIL_BLOCK_ALLOCATOR_H__</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00026"></a>00026 <span class="preprocessor">#include "csextern.h"</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include "<a class="code" href="array_8h.html">csutil/array.h</a>"</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include "<a class="code" href="bitarray_8h.html">csutil/bitarray.h</a>"</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include "<a class="code" href="sysfunc_8h.html">csutil/sysfunc.h</a>"</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="comment">// hack: work around problems caused by #defining 'new'</span>
<a name="l00032"></a>00032 <span class="preprocessor">#if defined(CS_EXTENSIVE_MEMDEBUG) || defined(CS_MEMORY_TRACKER)</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor"># undef new</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#include &lt;new&gt;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="csutil_2memdebug_8h.html">csutil/memdebug.h</a>"</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;typeinfo&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include "<a class="code" href="csstring_8h.html">csstring.h</a>"</span>
<a name="l00041"></a>00041 <span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00047"></a><a class="code" href="classcsBlockAllocatorNormalBlockPolicy.html">00047</a> <span class="keyword">class </span><a class="code" href="classcsBlockAllocatorNormalBlockPolicy.html">csBlockAllocatorNormalBlockPolicy</a>
<a name="l00048"></a>00048 {
<a name="l00049"></a>00049 <span class="keyword">public</span>:
<a name="l00053"></a><a class="code" href="classcsBlockAllocatorNormalBlockPolicy.html#c7a243ef09615782dec797dc350463da">00053</a>   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* <a class="code" href="classcsBlockAllocatorNormalBlockPolicy.html#c7a243ef09615782dec797dc350463da">AllocBlock</a> (size_t blocksize) 
<a name="l00054"></a>00054   {
<a name="l00055"></a>00055     <span class="keywordflow">return</span> (<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>*)malloc(blocksize);
<a name="l00056"></a>00056   }
<a name="l00057"></a>00057 
<a name="l00062"></a><a class="code" href="classcsBlockAllocatorNormalBlockPolicy.html#4889d893d2c197b77eb43b9f4714296d">00062</a>   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classcsBlockAllocatorNormalBlockPolicy.html#4889d893d2c197b77eb43b9f4714296d">FreeBlock</a>(<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* p)
<a name="l00063"></a>00063   {
<a name="l00064"></a>00064     free (p);
<a name="l00065"></a>00065   }
<a name="l00066"></a>00066 };
<a name="l00067"></a>00067 
<a name="l00073"></a>00073 <span class="keyword">template</span> &lt;size_t A = 1&gt;
<a name="l00074"></a><a class="code" href="classcsBlockAllocatorAlignPolicy.html">00074</a> <span class="keyword">class </span><a class="code" href="classcsBlockAllocatorAlignPolicy.html">csBlockAllocatorAlignPolicy</a>
<a name="l00075"></a>00075 {
<a name="l00076"></a>00076 <span class="keyword">public</span>:
<a name="l00080"></a><a class="code" href="classcsBlockAllocatorAlignPolicy.html#d4a1ce09586f50a2af355b95dab1237c">00080</a>   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* <a class="code" href="classcsBlockAllocatorAlignPolicy.html#d4a1ce09586f50a2af355b95dab1237c">AllocBlock</a>(size_t blocksize) 
<a name="l00081"></a>00081   {
<a name="l00082"></a>00082     <span class="keywordflow">return</span> (<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>*)<a class="code" href="cssysdef_8h.html#ffed40c02197af3e3b65b44810504bef">csAlignedMalloc</a> (blocksize, A);
<a name="l00083"></a>00083   }
<a name="l00084"></a>00084 
<a name="l00089"></a><a class="code" href="classcsBlockAllocatorAlignPolicy.html#5f78b1ab91a755471e7a9df1917b510e">00089</a>   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classcsBlockAllocatorAlignPolicy.html#5f78b1ab91a755471e7a9df1917b510e">FreeBlock</a>(<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* p)
<a name="l00090"></a>00090   {
<a name="l00091"></a>00091     <a class="code" href="cssysdef_8h.html#b3ebafb0431aa2c78a086fa75812e117">csAlignedFree</a> (p);
<a name="l00092"></a>00092   }
<a name="l00093"></a>00093 };
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>
<a name="l00101"></a>00101 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00102"></a>00102 <span class="keyword">class </span>csBlockAllocatorMTBlockPolicy
<a name="l00103"></a>00103 {
<a name="l00104"></a>00104 <span class="keyword">public</span>:
<a name="l00108"></a>00108   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* AllocBlock (size_t blocksize)
<a name="l00109"></a>00109   {
<a name="l00110"></a>00110     <a class="code" href="classcsString.html">csString</a> buf;
<a name="l00111"></a>00111     buf.<a class="code" href="classcsStringBase.html#f6b05c0f5327d0ef2d7965da77a0857d">AppendFmt</a> (<span class="stringliteral">"csBlockAllocator&lt;%s &gt;"</span>, <span class="keyword">typeid</span> (T).name());
<a name="l00112"></a>00112     <a class="code" href="group__util.html#g728e973c799f206f0151c8a3bd1e5699">uintptr_t</a>* ptr = (<a class="code" href="group__util.html#g728e973c799f206f0151c8a3bd1e5699">uintptr_t</a>*)malloc (blocksize + <span class="keyword">sizeof</span> (<a class="code" href="group__util.html#g728e973c799f206f0151c8a3bd1e5699">uintptr_t</a>)*2);
<a name="l00113"></a>00113     *ptr++ = (uintptr_t)mtiRegisterAlloc (blocksize, (<span class="keywordtype">void</span>*)buf.<a class="code" href="classcsStringFast.html#ae377ba228b98ff910c5508f320c0d75">GetData</a>());
<a name="l00114"></a>00114     *ptr++ = blocksize;
<a name="l00115"></a>00115     <span class="keywordflow">return</span> (<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>*)ptr;
<a name="l00116"></a>00116   }
<a name="l00117"></a>00117 
<a name="l00122"></a>00122   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> FreeBlock(<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* p)
<a name="l00123"></a>00123   {
<a name="l00124"></a>00124     uintptr_t* ptr = ((uintptr_t*)p)-2;
<a name="l00125"></a>00125     mtiRegisterFree ((csMemTrackerInfo*)*ptr, (size_t)ptr[1]);
<a name="l00126"></a>00126     free (ptr);
<a name="l00127"></a>00127   }
<a name="l00128"></a>00128 };
<a name="l00129"></a>00129 <span class="preprocessor">#endif</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span>
<a name="l00151"></a>00151 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BlockPolicy = csBlockAllocatorMTBlockPolicy&lt;T&gt; &gt;
<a name="l00153"></a>00153 <span class="preprocessor">#else</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BlockPolicy = csBlockAllocatorNormalBlockPolicy&gt;
<a name="l00155"></a>00155 <span class="preprocessor">#endif</span>
<a name="l00156"></a><a class="code" href="classcsBlockAllocator.html">00156</a> <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classcsBlockAllocator.html">csBlockAllocator</a>
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158 <span class="keyword">protected</span>: <span class="comment">// 'protected' allows access by test-suite.</span>
<a name="l00159"></a><a class="code" href="structcsBlockAllocator_1_1FreeNode.html">00159</a>   <span class="keyword">struct </span><a class="code" href="structcsBlockAllocator_1_1FreeNode.html">FreeNode</a>
<a name="l00160"></a>00160   {
<a name="l00161"></a><a class="code" href="structcsBlockAllocator_1_1FreeNode.html#f00a788b2fd4feba9935dd611de96be0">00161</a>     <a class="code" href="structcsBlockAllocator_1_1FreeNode.html">FreeNode</a>* <a class="code" href="structcsBlockAllocator_1_1FreeNode.html#f00a788b2fd4feba9935dd611de96be0">next</a>;
<a name="l00162"></a>00162   };
<a name="l00163"></a>00163 
<a name="l00164"></a><a class="code" href="structcsBlockAllocator_1_1BlockKey.html">00164</a>   <span class="keyword">struct </span><a class="code" href="structcsBlockAllocator_1_1BlockKey.html">BlockKey</a>
<a name="l00165"></a>00165   {
<a name="l00166"></a><a class="code" href="structcsBlockAllocator_1_1BlockKey.html#d7bf2946f9427ef3f1f5afa90fc015db">00166</a>     <a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a> <span class="keyword">const</span>* <a class="code" href="structcsBlockAllocator_1_1BlockKey.html#d7bf2946f9427ef3f1f5afa90fc015db">addr</a>;
<a name="l00167"></a><a class="code" href="structcsBlockAllocator_1_1BlockKey.html#47c42c065a8d80d9f12eb5ab4efd0d6e">00167</a>     size_t blocksize;
<a name="l00168"></a><a class="code" href="structcsBlockAllocator_1_1BlockKey.html#0fdcbe2331bfb46fb1004196ab3c1ba0">00168</a>     <a class="code" href="structcsBlockAllocator_1_1BlockKey.html#0fdcbe2331bfb46fb1004196ab3c1ba0">BlockKey</a>(<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a> <span class="keyword">const</span>* p, size_t n) : <a class="code" href="structcsBlockAllocator_1_1BlockKey.html#d7bf2946f9427ef3f1f5afa90fc015db">addr</a>(p), blocksize(n) {}
<a name="l00169"></a>00169   };
<a name="l00170"></a>00170 
<a name="l00172"></a><a class="code" href="classcsBlockAllocator.html#4fe56299179746b6174b8d0c011d46f4">00172</a>   <a class="code" href="classcsArray.html">csArray&lt;uint8*&gt;</a> <a class="code" href="classcsBlockAllocator.html#4fe56299179746b6174b8d0c011d46f4">blocks</a>;
<a name="l00174"></a><a class="code" href="classcsBlockAllocator.html#81c20ae6c29b6ab741dc36cdaa287cb0">00174</a>   size_t <a class="code" href="classcsBlockAllocator.html#81c20ae6c29b6ab741dc36cdaa287cb0">size</a>;
<a name="l00176"></a><a class="code" href="classcsBlockAllocator.html#652d6e3a91721a28c1bdd262a111ce35">00176</a>   size_t <a class="code" href="classcsBlockAllocator.html#652d6e3a91721a28c1bdd262a111ce35">elsize</a>;
<a name="l00178"></a><a class="code" href="classcsBlockAllocator.html#612cb2095c8d4e90ef03ed9ad3abffa7">00178</a>   size_t blocksize;
<a name="l00180"></a><a class="code" href="classcsBlockAllocator.html#b36d241ddb23ed047d4197657c9e368b">00180</a>   FreeNode* <a class="code" href="classcsBlockAllocator.html#b36d241ddb23ed047d4197657c9e368b">freenode</a>;
<a name="l00182"></a><a class="code" href="classcsBlockAllocator.html#e906e27a3d46db3046942064389f21ec">00182</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsBlockAllocator.html#e906e27a3d46db3046942064389f21ec">pedantic</a>;
<a name="l00188"></a><a class="code" href="classcsBlockAllocator.html#56ac94fd364707157738c33bff5c3b52">00188</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsBlockAllocator.html#56ac94fd364707157738c33bff5c3b52">insideDisposeAll</a>;
<a name="l00189"></a>00189 
<a name="l00196"></a><a class="code" href="classcsBlockAllocator.html#0d532ca0608aa37df465c9646b13afb5">00196</a>   <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsBlockAllocator.html#0d532ca0608aa37df465c9646b13afb5">FuzzyCmp</a>(<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* <span class="keyword">const</span>&amp; block, BlockKey <span class="keyword">const</span>&amp; k)
<a name="l00197"></a>00197   {
<a name="l00198"></a>00198     <span class="keywordflow">return</span> (block + k.blocksize &lt;= k.addr ? -1 : (block &gt; k.addr ? 1 : 0));
<a name="l00199"></a>00199   }
<a name="l00200"></a>00200 
<a name="l00204"></a><a class="code" href="classcsBlockAllocator.html#176ffa7038d7dd8350bdabb2bf25b769">00204</a>   size_t <a class="code" href="classcsBlockAllocator.html#176ffa7038d7dd8350bdabb2bf25b769">FindBlock</a>(<span class="keywordtype">void</span> <span class="keyword">const</span>* m)<span class="keyword"> const</span>
<a name="l00205"></a>00205 <span class="keyword">  </span>{
<a name="l00206"></a>00206     <span class="keywordflow">return</span> <a class="code" href="classcsBlockAllocator.html#4fe56299179746b6174b8d0c011d46f4">blocks</a>.<a class="code" href="classcsArray.html#eb23011335b0d46ead40440ecd53d59b">FindSortedKey</a>(
<a name="l00207"></a>00207       <a class="code" href="classcsArrayCmp.html">csArrayCmp&lt;uint8*,BlockKey&gt;</a>(BlockKey((<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>*)m, blocksize), <a class="code" href="classcsBlockAllocator.html#0d532ca0608aa37df465c9646b13afb5">FuzzyCmp</a>));
<a name="l00208"></a>00208   }
<a name="l00209"></a>00209 
<a name="l00215"></a><a class="code" href="classcsBlockAllocator.html#efc74abf9d4941adfee2cac56b053ebb">00215</a>   <a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* <a class="code" href="classcsBlockAllocator.html#efc74abf9d4941adfee2cac56b053ebb">AllocBlock</a>()<span class="keyword"> const</span>
<a name="l00216"></a>00216 <span class="keyword">  </span>{
<a name="l00217"></a>00217     <a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* block = BlockPolicy::AllocBlock(blocksize);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219     <span class="comment">// Build the free-node chain (all nodes are free in the new block).</span>
<a name="l00220"></a>00220     FreeNode* nextfree = 0;
<a name="l00221"></a>00221     <a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* node = block + (<a class="code" href="classcsBlockAllocator.html#81c20ae6c29b6ab741dc36cdaa287cb0">size</a> - 1) * <a class="code" href="classcsBlockAllocator.html#652d6e3a91721a28c1bdd262a111ce35">elsize</a>;
<a name="l00222"></a>00222     <span class="keywordflow">for</span> ( ; node &gt;= block; node -= <a class="code" href="classcsBlockAllocator.html#652d6e3a91721a28c1bdd262a111ce35">elsize</a>)
<a name="l00223"></a>00223     {
<a name="l00224"></a>00224       FreeNode* slot = (FreeNode*)node;
<a name="l00225"></a>00225       slot-&gt;next = nextfree;
<a name="l00226"></a>00226       nextfree = slot;
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228     <a class="code" href="cssysdef_8h.html#c380bd47888ecfe73e7b7a40b6f827a1">CS_ASSERT</a>((<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>*)nextfree == block);
<a name="l00229"></a>00229     <span class="keywordflow">return</span> block;
<a name="l00230"></a>00230   }
<a name="l00231"></a>00231 
<a name="l00235"></a><a class="code" href="classcsBlockAllocator.html#adac51c587275fcc2c1eb2d3e6d073b3">00235</a>   <span class="keywordtype">void</span> FreeBlock(<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* p)<span class="keyword"> const</span>
<a name="l00236"></a>00236 <span class="keyword">  </span>{
<a name="l00237"></a>00237     BlockPolicy::FreeBlock(p);
<a name="l00238"></a>00238   }
<a name="l00239"></a>00239 
<a name="l00243"></a><a class="code" href="classcsBlockAllocator.html#09e4e42aa17d7e33a7c1344950788e40">00243</a>   <span class="keywordtype">void</span> DestroyObject (T* p, <span class="keywordtype">bool</span> warn, <span class="keywordtype">bool</span> invokeDtor = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l00244"></a>00244 <span class="keyword">  </span>{
<a name="l00245"></a>00245     <span class="keywordflow">if</span> (invokeDtor) p-&gt;~T();
<a name="l00246"></a>00246     <span class="keywordflow">if</span> (warn)
<a name="l00247"></a>00247     {
<a name="l00248"></a>00248 <span class="preprocessor">#ifdef CS_DEBUG</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span>      <a class="code" href="group__util.html#g9bd60492f7f494e915605a6cbc42a54b">csPrintfErr</a>(<span class="stringliteral">"NOTIFY: csBlockAllocator(%p) destroying potentially leaked "</span>
<a name="l00250"></a>00250                   <span class="stringliteral">"object at %p.\n"</span>, (<span class="keywordtype">void</span>*)<span class="keyword">this</span>, (<span class="keywordtype">void</span>*)p);
<a name="l00251"></a>00251 <span class="preprocessor">#endif</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span>    }
<a name="l00253"></a>00253 <span class="preprocessor">#ifdef CS_BLOCKALLOC_DEBUG</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span>    memset (p, 0xfb, elsize);
<a name="l00255"></a>00255 <span class="preprocessor">#endif</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span>  }
<a name="l00257"></a>00257 
<a name="l00262"></a><a class="code" href="classcsBlockAllocator.html#4cc76697f41295e7f394e4c0ca1e5b2f">00262</a>   <a class="code" href="classcsBitArray.html">csBitArray</a> GetAllocationMap()<span class="keyword"> const</span>
<a name="l00263"></a>00263 <span class="keyword">  </span>{
<a name="l00264"></a>00264     <a class="code" href="classcsBitArray.html">csBitArray</a> mask(size * blocks.GetSize());
<a name="l00265"></a>00265     mask.FlipAllBits();
<a name="l00266"></a>00266     <span class="keywordflow">for</span> (FreeNode* p = freenode; p != 0; p = p-&gt;next)
<a name="l00267"></a>00267     {
<a name="l00268"></a>00268       size_t <span class="keyword">const</span> n = FindBlock(p);
<a name="l00269"></a>00269       <a class="code" href="cssysdef_8h.html#c380bd47888ecfe73e7b7a40b6f827a1">CS_ASSERT</a>(n != <a class="code" href="group__util__containers.html#g7477ed9887527029069ab5d5c79e2f70">csArrayItemNotFound</a>);
<a name="l00270"></a>00270       size_t <span class="keyword">const</span> slot = ((<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>*)p - blocks[n]) / elsize; <span class="comment">// Slot in block.</span>
<a name="l00271"></a>00271       mask.ClearBit(n * size + slot);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273     <span class="keywordflow">return</span> mask;
<a name="l00274"></a>00274   }
<a name="l00275"></a>00275 
<a name="l00281"></a><a class="code" href="classcsBlockAllocator.html#0c423b2841c8509a854a6616faab9a5b">00281</a>   <span class="keywordtype">void</span> DisposeAll(<span class="keywordtype">bool</span> warn_unfreed)
<a name="l00282"></a>00282   {
<a name="l00283"></a>00283     insideDisposeAll = <span class="keyword">true</span>;
<a name="l00284"></a>00284     <a class="code" href="classcsBitArray.html">csBitArray</a> <span class="keyword">const</span> mask(GetAllocationMap());
<a name="l00285"></a>00285     size_t node = 0;
<a name="l00286"></a>00286     <span class="keywordflow">for</span> (size_t b = 0, bN = blocks.GetSize(); b &lt; bN; b++)
<a name="l00287"></a>00287     {
<a name="l00288"></a>00288       <span class="keywordflow">for</span> (<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a> *p = blocks[b], *pN = p + blocksize; p &lt; pN; p += elsize)
<a name="l00289"></a>00289           <span class="keywordflow">if</span> (mask.<a class="code" href="classcsBitArrayTweakable.html#19e077803aeb46a70b7fe038b7d596c5">IsBitSet</a>(node++))
<a name="l00290"></a>00290             DestroyObject((T*)p, warn_unfreed);
<a name="l00291"></a>00291       FreeBlock(blocks[b]);
<a name="l00292"></a>00292     }
<a name="l00293"></a>00293     blocks.DeleteAll();
<a name="l00294"></a>00294     freenode = 0;
<a name="l00295"></a>00295     insideDisposeAll = <span class="keyword">false</span>;
<a name="l00296"></a>00296   }
<a name="l00297"></a>00297 
<a name="l00299"></a><a class="code" href="classcsBlockAllocator.html#18b9075ab900fdbded3e72a3b9422706">00299</a>   <span class="keywordtype">void</span>* AllocCommon ()
<a name="l00300"></a>00300   {
<a name="l00301"></a>00301     <span class="keywordflow">if</span> (insideDisposeAll)
<a name="l00302"></a>00302     {
<a name="l00303"></a>00303       <a class="code" href="group__util.html#g9bd60492f7f494e915605a6cbc42a54b">csPrintfErr</a>(<span class="stringliteral">"ERROR: csBlockAllocator(%p) tried to allocate memory "</span>
<a name="l00304"></a>00304         <span class="stringliteral">"while inside DisposeAll()"</span>, (<span class="keywordtype">void</span>*)<span class="keyword">this</span>);
<a name="l00305"></a>00305       <a class="code" href="cssysdef_8h.html#c380bd47888ecfe73e7b7a40b6f827a1">CS_ASSERT</a>(<span class="keyword">false</span>);
<a name="l00306"></a>00306     }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     <span class="keywordflow">if</span> (freenode == 0)
<a name="l00309"></a>00309     {
<a name="l00310"></a>00310       <a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* p = AllocBlock();
<a name="l00311"></a>00311       blocks.InsertSorted(p);
<a name="l00312"></a>00312       freenode = (FreeNode*)p;
<a name="l00313"></a>00313     }
<a name="l00314"></a>00314     <span class="keywordtype">void</span>* <span class="keyword">const</span> node = freenode;
<a name="l00315"></a>00315     freenode = freenode-&gt;next;
<a name="l00316"></a>00316     <span class="keywordflow">return</span> node;
<a name="l00317"></a>00317   }
<a name="l00318"></a>00318 <span class="keyword">public</span>:
<a name="l00340"></a><a class="code" href="classcsBlockAllocator.html#5012d76fbb58ec110356165046733c94">00340</a>   <a class="code" href="classcsBlockAllocator.html">csBlockAllocator</a>(size_t nelem = 32, <span class="keywordtype">bool</span> warn_unfreed = <span class="keyword">false</span>) :
<a name="l00341"></a>00341     size(nelem), elsize(sizeof(T)), freenode(0), pedantic(warn_unfreed),
<a name="l00342"></a>00342     insideDisposeAll(false)
<a name="l00343"></a>00343   {
<a name="l00344"></a>00344     <span class="keywordflow">if</span> (elsize &lt; <span class="keyword">sizeof</span> (FreeNode))
<a name="l00345"></a>00345       elsize = <span class="keyword">sizeof</span> (FreeNode);
<a name="l00346"></a>00346     blocksize = elsize * size;
<a name="l00347"></a>00347   }
<a name="l00348"></a>00348 
<a name="l00352"></a><a class="code" href="classcsBlockAllocator.html#0c81963ee85398e04514209114839e8b">00352</a>   ~<a class="code" href="classcsBlockAllocator.html">csBlockAllocator</a>()
<a name="l00353"></a>00353   {
<a name="l00354"></a>00354     DisposeAll(pedantic);
<a name="l00355"></a>00355   }
<a name="l00356"></a>00356 
<a name="l00362"></a><a class="code" href="classcsBlockAllocator.html#4267f7c7254b9cc0b6950df2d14a46dc">00362</a>   <span class="keywordtype">void</span> Empty()
<a name="l00363"></a>00363   {
<a name="l00364"></a>00364     DisposeAll(<span class="keyword">false</span>);
<a name="l00365"></a>00365   }
<a name="l00366"></a>00366 
<a name="l00371"></a><a class="code" href="classcsBlockAllocator.html#7ae146cf6b08e8784f225bc622862cf4">00371</a>   <span class="keywordtype">void</span> Compact()
<a name="l00372"></a>00372   {
<a name="l00373"></a>00373     <span class="keywordflow">if</span> (insideDisposeAll) <span class="keywordflow">return</span>;
<a name="l00374"></a>00374 
<a name="l00375"></a>00375     <span class="keywordtype">bool</span> compacted = <span class="keyword">false</span>;
<a name="l00376"></a>00376     <a class="code" href="classcsBitArray.html">csBitArray</a> mask(GetAllocationMap());
<a name="l00377"></a>00377     <span class="keywordflow">for</span> (size_t b = blocks.GetSize(); b-- &gt; 0; )
<a name="l00378"></a>00378     {
<a name="l00379"></a>00379       size_t <span class="keyword">const</span> node = b * size;
<a name="l00380"></a>00380       <span class="keywordflow">if</span> (!mask.<a class="code" href="classcsBitArrayTweakable.html#404f5ba789cecf357bc9003f796aa853">AreSomeBitsSet</a>(node, size))
<a name="l00381"></a>00381       {
<a name="l00382"></a>00382         FreeBlock(blocks[b]);
<a name="l00383"></a>00383         blocks.DeleteIndex(b);
<a name="l00384"></a>00384         mask.<a class="code" href="classcsBitArrayTweakable.html#fd7ee919a37d5bac355d5034dbe52605">Delete</a>(node, size);
<a name="l00385"></a>00385         compacted = <span class="keyword">true</span>;
<a name="l00386"></a>00386       }
<a name="l00387"></a>00387     }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389     <span class="comment">// If blocks were deleted, then free-node chain broke, so rebuild it.</span>
<a name="l00390"></a>00390     <span class="keywordflow">if</span> (compacted)
<a name="l00391"></a>00391     {
<a name="l00392"></a>00392       FreeNode* nextfree = 0;
<a name="l00393"></a>00393       size_t <span class="keyword">const</span> bN = blocks.GetSize();
<a name="l00394"></a>00394       size_t node = bN * size;
<a name="l00395"></a>00395       <span class="keywordflow">for</span> (size_t b = bN; b-- &gt; 0; )
<a name="l00396"></a>00396       {
<a name="l00397"></a>00397         <a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* <span class="keyword">const</span> p0 = blocks[b];
<a name="l00398"></a>00398         <span class="keywordflow">for</span> (<a class="code" href="group__util.html#gdde6aaee8457bee49c2a92621fe22b79">uint8</a>* p = p0 + (size - 1) * elsize; p &gt;= p0; p -= elsize)
<a name="l00399"></a>00399         {
<a name="l00400"></a>00400           <span class="keywordflow">if</span> (!mask.IsBitSet(--node))
<a name="l00401"></a>00401           {
<a name="l00402"></a>00402             FreeNode* slot = (FreeNode*)p;
<a name="l00403"></a>00403             slot-&gt;next = nextfree;
<a name="l00404"></a>00404             nextfree = slot;
<a name="l00405"></a>00405           }
<a name="l00406"></a>00406         }
<a name="l00407"></a>00407       }
<a name="l00408"></a>00408       freenode = nextfree;
<a name="l00409"></a>00409     }
<a name="l00410"></a>00410   }
<a name="l00411"></a>00411 
<a name="l00416"></a><a class="code" href="classcsBlockAllocator.html#cd9df327cc94324f0aac67475289a9b7">00416</a>   T* Alloc ()
<a name="l00417"></a>00417   {
<a name="l00418"></a>00418     <span class="keywordflow">return</span> <span class="keyword">new</span> (AllocCommon()) T;
<a name="l00419"></a>00419   }
<a name="l00420"></a>00420 
<a name="l00429"></a><a class="code" href="classcsBlockAllocator.html#ecc5b522426eeb0c95fe3ae93ab91cce">00429</a>   <span class="keywordtype">void</span>* AllocUninit ()
<a name="l00430"></a>00430   {
<a name="l00431"></a>00431     <span class="keywordflow">return</span> AllocCommon();
<a name="l00432"></a>00432   }
<a name="l00433"></a>00433 
<a name="l00440"></a><a class="code" href="classcsBlockAllocator.html#ce5ad2caf93871ee1ead8e2148875773">00440</a>   <span class="keywordtype">void</span> Free (T* p, <span class="keywordtype">bool</span> invokeDtor = <span class="keyword">true</span>)
<a name="l00441"></a>00441   {
<a name="l00442"></a>00442     <span class="keywordflow">if</span> (p != 0 &amp;&amp; !insideDisposeAll)
<a name="l00443"></a>00443     {
<a name="l00444"></a>00444       <a class="code" href="cssysdef_8h.html#c380bd47888ecfe73e7b7a40b6f827a1">CS_ASSERT</a>(FindBlock(p) != <a class="code" href="group__util__containers.html#g7477ed9887527029069ab5d5c79e2f70">csArrayItemNotFound</a>);
<a name="l00445"></a>00445       DestroyObject(p, <span class="keyword">false</span>, invokeDtor);
<a name="l00446"></a>00446       FreeNode* f = (FreeNode*)p;
<a name="l00447"></a>00447       f-&gt;next = freenode;
<a name="l00448"></a>00448       freenode = f;
<a name="l00449"></a>00449     }
<a name="l00450"></a>00450   }
<a name="l00456"></a><a class="code" href="classcsBlockAllocator.html#6be99e7e4fe78e958687403dc6440b39">00456</a>   <span class="keywordtype">bool</span> TryFree (T* p, <span class="keywordtype">bool</span> invokeDtor = <span class="keyword">true</span>)
<a name="l00457"></a>00457   {
<a name="l00458"></a>00458     <span class="keywordflow">if</span> (p != 0 &amp;&amp; !insideDisposeAll)
<a name="l00459"></a>00459     {
<a name="l00460"></a>00460       <span class="keywordflow">if</span> (FindBlock(p) == <a class="code" href="group__util__containers.html#g7477ed9887527029069ab5d5c79e2f70">csArrayItemNotFound</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00461"></a>00461       DestroyObject(p, <span class="keyword">false</span>, invokeDtor);
<a name="l00462"></a>00462       FreeNode* f = (FreeNode*)p;
<a name="l00463"></a>00463       f-&gt;next = freenode;
<a name="l00464"></a>00464       freenode = f;
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00467"></a>00467   }
<a name="l00469"></a><a class="code" href="classcsBlockAllocator.html#9f1a5aa0b6bf5dfadb38a1bdca1e14e8">00469</a>   size_t GetBlockElements()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size; }
<a name="l00470"></a>00470 };
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="preprocessor">#if defined(CS_EXTENSIVE_MEMDEBUG) || defined(CS_MEMORY_TRACKER)</span>
<a name="l00473"></a>00473 <span class="preprocessor"></span><span class="preprocessor"># define new CS_EXTENSIVE_MEMDEBUG_NEW</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00475"></a>00475 <span class="preprocessor"></span>
<a name="l00476"></a>00476 <span class="preprocessor">#endif // __CSUTIL_BLOCK_ALLOCATOR_H__</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.6 
</small></address> </div></body> </html>
