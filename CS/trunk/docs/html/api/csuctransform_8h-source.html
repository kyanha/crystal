<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/csuctransform.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>csutil/csuctransform.h</h1><a href="csuctransform_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2003 by Frank Richter</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_CSUCTRANSFORM_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_CSUCTRANSFORM_H__</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include "<a class="code" href="csunicode_8h.html">csunicode.h</a>"</span>
00023 
00031 
<a name="l00032"></a><a class="code" href="group__util.html#a96">00032</a> <span class="preprocessor">#define CS_UC_MAX_UTF8_ENCODED          6</span>
00033 <span class="preprocessor"></span>
<a name="l00034"></a><a class="code" href="group__util.html#a97">00034</a> <span class="preprocessor">#define CS_UC_MAX_UTF16_ENCODED         2</span>
00035 <span class="preprocessor"></span>
<a name="l00036"></a><a class="code" href="group__util.html#a98">00036</a> <span class="preprocessor">#define CS_UC_MAX_UTF32_ENCODED         1</span>
00037 <span class="preprocessor"></span> 
<a name="l00041"></a><a class="code" href="classcsUnicodeTransform.html">00041</a> <span class="keyword">class </span><a class="code" href="classcsUnicodeTransform.html">csUnicodeTransform</a>
00042 {
00043 <span class="keyword">public</span>:
00044 <span class="preprocessor">#define FAIL(ret)                               \</span>
00045 <span class="preprocessor">  {                                             \</span>
00046 <span class="preprocessor">    if (isValid) *isValid = false;              \</span>
00047 <span class="preprocessor">    ch = CS_UC_CHAR_REPLACER;                   \</span>
00048 <span class="preprocessor">    return ret;                                 \</span>
00049 <span class="preprocessor">  }</span>
00050 <span class="preprocessor"></span>
00051 <span class="preprocessor">#define SUCCEED                                 \</span>
00052 <span class="preprocessor">    if (isValid) *isValid = true;               \</span>
00053 <span class="preprocessor">    return chUsed;</span>
00054 <span class="preprocessor"></span>  
00055 <span class="preprocessor">#define GET_NEXT(next)  \</span>
00056 <span class="preprocessor">  if ((size_t)chUsed == strlen)                 \</span>
00057 <span class="preprocessor">  {                                             \</span>
00058 <span class="preprocessor">    FAIL(chUsed);                               \</span>
00059 <span class="preprocessor">  }                                             \</span>
00060 <span class="preprocessor">  next = *str++;                                \</span>
00061 <span class="preprocessor">  if (next == 0)                                \</span>
00062 <span class="preprocessor">  {                                             \</span>
00063 <span class="preprocessor">    FAIL(chUsed);                               \</span>
00064 <span class="preprocessor">  }                                             \</span>
00065 <span class="preprocessor">  chUsed++;                                     </span>
00066 <span class="preprocessor"></span>  
<a name="l00082"></a><a class="code" href="classcsUnicodeTransform.html#z109_0">00082</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z109_0">UTF8Decode</a> (<span class="keyword">const</span> utf8_char* str, size_t strlen, 
00083     utf32_char&amp; ch, <span class="keywordtype">bool</span>* isValid = 0)
00084   {
00085     <span class="keywordflow">if</span> (str == 0)
00086     {
00087       FAIL(0);
00088     }
00089     <span class="keywordtype">int</span> chUsed = 0;
00090     
00091     <a class="code" href="group__util.html#a15">utf8_char</a> curCh;
00092     GET_NEXT(curCh);
00093     <span class="keywordflow">if</span> ((curCh &amp; 0x80) == 0)
00094     {
00095       <span class="comment">// easy case</span>
00096       ch = curCh;
00097       SUCCEED;
00098     }
00099     <span class="keywordflow">else</span>
00100     {
00101       <span class="comment">// Count with how many bytes this char is encoded.</span>
00102       <span class="keywordtype">int</span> n = 0;
00103       <span class="keywordflow">while</span> ((n &lt; 7) &amp;&amp; ((curCh &amp; (1 &lt;&lt; (7 - n))) != 0)) { n++; }
00104 
00105       <span class="keywordflow">if</span> ((n &lt; 2) || (n &gt; 6))
00106       {
00107         <span class="comment">// Invalid code: first char of a "sequence" must have</span>
00108         <span class="comment">// at least two and at most six MSBs set</span>
00109         FAIL(1);
00110       }
00111 
00112       ch = (curCh &amp; ((1 &lt;&lt; (8 - n)) - 1));
00113       
00114       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; n; i++)
00115       {
00116         GET_NEXT(curCh);
00117         <span class="keywordflow">if</span> ((curCh &amp; 0xc0) != 0x80)
00118         {
00119           FAIL(chUsed);
00120         }
00121         <span class="keywordflow">else</span>
00122         {
00123           ch &lt;&lt;= 6;
00124           ch |= (curCh &amp; 0x3f);
00125         }
00126       }
00127       
00128       <span class="comment">// Check for "overlong" codes.</span>
00129       <span class="keywordflow">if</span> ((ch &lt; 0x80) &amp;&amp; (n &gt; 0))
00130       {
00131         FAIL(chUsed);
00132       }
00133       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ch &lt; 0x800) &amp;&amp; (n &gt; 2))
00134       {
00135         FAIL(chUsed);
00136       }
00137       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ch &lt; 0x10000) &amp;&amp; (n &gt; 3))
00138       {
00139         FAIL(chUsed);
00140       }
00141       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ch &lt; 0x200000) &amp;&amp; (n &gt; 4))
00142       {
00143         FAIL(chUsed);
00144       }
00145       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ch &lt; 0x4000000) &amp;&amp; (n &gt; 5))
00146       {
00147         FAIL(chUsed);
00148       }
00149       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ch &lt; 0x80000000) &amp;&amp; (n &gt; 6))
00150       {
00151         FAIL(chUsed);
00152       }
00153       
00154       <span class="keywordflow">if</span> (<a class="code" href="group__util.html#a105">CS_UC_IS_INVALID</a>(ch) || <a class="code" href="group__util.html#a102">CS_UC_IS_SURROGATE</a>(ch))
00155         FAIL(chUsed);
00156       SUCCEED;
00157     }
00158   }
00159   
<a name="l00164"></a><a class="code" href="classcsUnicodeTransform.html#z109_1">00164</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z109_1">UTF16Decode</a> (<span class="keyword">const</span> utf16_char* str, size_t strlen, 
00165     utf32_char&amp; ch, <span class="keywordtype">bool</span>* isValid = 0)
00166   {
00167     <span class="keywordflow">if</span> (str == 0)
00168     {
00169       FAIL(0);
00170     }
00171     <span class="keywordtype">int</span> chUsed = 0;
00172     
00173     <a class="code" href="group__util.html#a16">utf16_char</a> curCh;
00174     GET_NEXT(curCh);
00175     <span class="comment">// Decode surrogate</span>
00176     <span class="keywordflow">if</span> (<a class="code" href="group__util.html#a102">CS_UC_IS_SURROGATE</a> (curCh))
00177     {
00178       <span class="comment">// Invalid code</span>
00179       <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#a103">CS_UC_IS_HIGH_SURROGATE</a> (curCh))
00180       {
00181         FAIL(chUsed);
00182       }
00183       ch = (curCh &amp; 0x03ff) &lt;&lt; 10;
00184       GET_NEXT(curCh);
00185       <span class="comment">// Invalid code</span>
00186       <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#a104">CS_UC_IS_LOW_SURROGATE</a> (curCh))
00187       {
00188         <span class="comment">// Fail with 1 so the char is handled upon the next Decode.</span>
00189         FAIL(1);
00190       }
00191       ch |= (curCh &amp; 0x3ff);
00192       <span class="comment">// Check for "overlong" codes</span>
00193       <span class="keywordflow">if</span> ((ch == 0) || (ch &lt; 0x10000))
00194         FAIL(chUsed);
00195     }
00196     <span class="keywordflow">else</span>
00197     {
00198       ch = curCh;
00199     }
00200     <span class="keywordflow">if</span> (<a class="code" href="group__util.html#a105">CS_UC_IS_INVALID</a>(ch))
00201       FAIL(chUsed);
00202     SUCCEED;
00203   }
00204   
<a name="l00209"></a><a class="code" href="classcsUnicodeTransform.html#z109_2">00209</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z109_2">UTF32Decode</a> (<span class="keyword">const</span> utf32_char* str, size_t strlen, 
00210     utf32_char&amp; ch, <span class="keywordtype">bool</span>* isValid = 0)
00211   {
00212     <span class="keywordflow">if</span> (str == 0)
00213     {
00214       FAIL(0);
00215     }
00216     <span class="keywordtype">int</span> chUsed = 0;
00217     
00218     GET_NEXT(ch);
00219     <span class="keywordflow">if</span> (<a class="code" href="group__util.html#a105">CS_UC_IS_INVALID</a>(ch))
00220       FAIL(chUsed);
00221     SUCCEED;
00222   }
00224 <span class="preprocessor">#undef FAIL</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#undef SUCCEED</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#undef GET_NEXT</span>
00227 <span class="preprocessor"></span>
00228 <span class="preprocessor">#define _OUTPUT_CHAR(buf, chr)                          \</span>
00229 <span class="preprocessor">  if (bufRemaining &gt; 0)                                 \</span>
00230 <span class="preprocessor">  {                                                     \</span>
00231 <span class="preprocessor">    if(buf) *buf++ = chr;                               \</span>
00232 <span class="preprocessor">    bufRemaining--;                                     \</span>
00233 <span class="preprocessor">  }                                                     \</span>
00234 <span class="preprocessor">  encodedLen++;</span>
00235 <span class="preprocessor"></span>
00236 <span class="preprocessor">#define OUTPUT_CHAR(chr) _OUTPUT_CHAR(buf, chr)</span>
00237 <span class="preprocessor"></span>  
<a name="l00250"></a><a class="code" href="classcsUnicodeTransform.html#z110_0">00250</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z110_0">EncodeUTF8</a> (<span class="keyword">const</span> utf32_char ch, utf8_char* buf, 
00251     size_t bufsize)
00252   {
00253     <span class="keywordflow">if</span> ((<a class="code" href="group__util.html#a105">CS_UC_IS_INVALID</a>(ch)) || (<a class="code" href="group__util.html#a102">CS_UC_IS_SURROGATE</a>(ch))) 
00254       <span class="keywordflow">return</span> 0;
00255     size_t bufRemaining = bufsize;
00256     <span class="keywordtype">int</span> encodedLen = 0;
00257     
00258     <span class="keywordflow">if</span> (ch &lt; 0x80)
00259     {
00260       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)ch);
00261     }
00262     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &lt; 0x800)
00263     {
00264       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0xc0 | (ch &gt;&gt; 6)));
00265       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | (ch &amp; 0x3f)));
00266     }
00267     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &lt; 0x10000)
00268     {
00269       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0xe0 | (ch &gt;&gt; 12)));
00270       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | ((ch &gt;&gt; 6) &amp; 0x3f)));
00271       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | (ch &amp; 0x3f)));
00272     }
00273     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &lt; 0x200000)
00274     {
00275       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0xf0 | (ch &gt;&gt; 18)));
00276       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | ((ch &gt;&gt; 12) &amp; 0x3f)));
00277       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | ((ch &gt;&gt; 6) &amp; 0x3f)));
00278       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | (ch &amp; 0x3f)));
00279     }
00280     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &lt; 0x4000000)
00281     {
00282       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0xf8 | (ch &gt;&gt; 24)));
00283       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | ((ch &gt;&gt; 18) &amp; 0x3f)));
00284       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | ((ch &gt;&gt; 12) &amp; 0x3f)));
00285       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | ((ch &gt;&gt; 6) &amp; 0x3f)));
00286       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | (ch &amp; 0x3f)));
00287     }
00288     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &lt; 0x80000000)
00289     {
00290       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0xfc | (ch &gt;&gt; 30)));
00291       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | ((ch &gt;&gt; 24) &amp; 0x3f)));
00292       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | ((ch &gt;&gt; 18) &amp; 0x3f)));
00293       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | ((ch &gt;&gt; 12) &amp; 0x3f)));
00294       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | ((ch &gt;&gt; 6) &amp; 0x3f)));
00295       OUTPUT_CHAR ((<a class="code" href="group__util.html#a15">utf8_char</a>)(0x80 | (ch &amp; 0x3f)));
00296     }
00297     <span class="keywordflow">return</span> encodedLen;
00298   }
00299     
<a name="l00304"></a><a class="code" href="classcsUnicodeTransform.html#z110_1">00304</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z110_1">EncodeUTF16</a> (<span class="keyword">const</span> utf32_char ch, utf16_char* buf, 
00305     size_t bufsize)
00306   {
00307     <span class="keywordflow">if</span> ((<a class="code" href="group__util.html#a105">CS_UC_IS_INVALID</a>(ch)) || (<a class="code" href="group__util.html#a102">CS_UC_IS_SURROGATE</a>(ch))) 
00308       <span class="keywordflow">return</span> 0;
00309     size_t bufRemaining = bufsize;
00310     <span class="keywordtype">int</span> encodedLen = 0;
00311     
00312     <span class="keywordflow">if</span> (ch &lt; 0x10000)
00313     {
00314       OUTPUT_CHAR((<a class="code" href="group__util.html#a16">utf16_char</a>)ch);
00315     }
00316     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &lt; 0x100000)
00317     {
00318       OUTPUT_CHAR((<a class="code" href="group__util.html#a16">utf16_char</a>)((ch &gt;&gt; 10) | <a class="code" href="group__util.html#a106">CS_UC_CHAR_HIGH_SURROGATE_FIRST</a>));
00319       OUTPUT_CHAR((<a class="code" href="group__util.html#a16">utf16_char</a>)((ch &amp; 0x3ff) | <a class="code" href="group__util.html#a108">CS_UC_CHAR_LOW_SURROGATE_FIRST</a>));
00320     }
00321     <span class="keywordflow">else</span>
00322       <span class="keywordflow">return</span> 0;
00323     
00324     <span class="keywordflow">return</span> encodedLen;
00325   }
00326 
<a name="l00331"></a><a class="code" href="classcsUnicodeTransform.html#z110_2">00331</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z110_2">EncodeUTF32</a> (<span class="keyword">const</span> utf32_char ch, utf32_char* buf, 
00332     size_t bufsize)
00333   {
00334     <span class="keywordflow">if</span> ((<a class="code" href="group__util.html#a105">CS_UC_IS_INVALID</a>(ch)) || (<a class="code" href="group__util.html#a102">CS_UC_IS_SURROGATE</a>(ch))) 
00335       <span class="keywordflow">return</span> 0;
00336     size_t bufRemaining = bufsize;
00337     <span class="keywordtype">int</span> encodedLen = 0;
00338     
00339     OUTPUT_CHAR(ch);
00340     
00341     <span class="keywordflow">return</span> encodedLen;
00342   }
00344 <span class="preprocessor">#undef OUTPUT_CHAR</span>
00345 <span class="preprocessor"></span>  
00346 <span class="preprocessor">#define OUTPUT_CHAR(chr) _OUTPUT_CHAR(dest, chr)</span>
00347 <span class="preprocessor"></span>  
00348 <span class="preprocessor">#define UCTF_CONVERTER(funcName, fromType, decoder, toType, encoder)    \</span>
00349 <span class="preprocessor">  inline static size_t funcName (toType* dest, size_t destSize,         \</span>
00350 <span class="preprocessor">    const fromType* source, size_t srcSize = (size_t)-1)                \</span>
00351 <span class="preprocessor">  {                                                                     \</span>
00352 <span class="preprocessor">    if ((srcSize == 0) || (source == 0))                                \</span>
00353 <span class="preprocessor">      return 0;                                                         \</span>
00354 <span class="preprocessor">                                                                        \</span>
00355 <span class="preprocessor">    size_t bufRemaining = (destSize &gt; 0) ? destSize - 1 : 0;            \</span>
00356 <span class="preprocessor">    size_t encodedLen = 0;                                              \</span>
00357 <span class="preprocessor">                                                                        \</span>
00358 <span class="preprocessor">    size_t srcChars = srcSize;                                          \</span>
00359 <span class="preprocessor">                                                                        \</span>
00360 <span class="preprocessor">    if (srcSize == (size_t)-1)                                          \</span>
00361 <span class="preprocessor">    {                                                                   \</span>
00362 <span class="preprocessor">      srcChars = 0;                                                     \</span>
00363 <span class="preprocessor">      const fromType* sptr = source;                                    \</span>
00364 <span class="preprocessor">      while (*sptr++ != 0) srcChars++;                                  \</span>
00365 <span class="preprocessor">    }                                                                   \</span>
00366 <span class="preprocessor">                                                                        \</span>
00367 <span class="preprocessor">    while (srcChars &gt; 0)                                                \</span>
00368 <span class="preprocessor">    {                                                                   \</span>
00369 <span class="preprocessor">      utf32_char ch;                                                    \</span>
00370 <span class="preprocessor">      int scnt = decoder (source, srcChars, ch, 0);                     \</span>
00371 <span class="preprocessor">      if (scnt == 0) break;                                             \</span>
00372 <span class="preprocessor">      int dcnt = encoder (ch, dest, bufRemaining);                      \</span>
00373 <span class="preprocessor">      if (dcnt == 0)                                                    \</span>
00374 <span class="preprocessor">      {                                                                 \</span>
00375 <span class="preprocessor">        dcnt = encoder (CS_UC_CHAR_REPLACER, dest, bufRemaining);       \</span>
00376 <span class="preprocessor">      }                                                                 \</span>
00377 <span class="preprocessor">                                                                        \</span>
00378 <span class="preprocessor">      if ((size_t)dcnt &gt;= bufRemaining)                                 \</span>
00379 <span class="preprocessor">      {                                                                 \</span>
00380 <span class="preprocessor">        if (dest &amp;&amp; (destSize &gt; 0)) dest += bufRemaining;               \</span>
00381 <span class="preprocessor">        bufRemaining = 0;                                               \</span>
00382 <span class="preprocessor">      }                                                                 \</span>
00383 <span class="preprocessor">      else                                                              \</span>
00384 <span class="preprocessor">      {                                                                 \</span>
00385 <span class="preprocessor">        bufRemaining -= dcnt;                                           \</span>
00386 <span class="preprocessor">        if (dest &amp;&amp; (destSize &gt; 0)) dest += dcnt;                       \</span>
00387 <span class="preprocessor">      }                                                                 \</span>
00388 <span class="preprocessor">      encodedLen += dcnt;                                               \</span>
00389 <span class="preprocessor">      if ((size_t)scnt &gt;= srcChars) break;                              \</span>
00390 <span class="preprocessor">      srcChars -= scnt;                                                 \</span>
00391 <span class="preprocessor">      source += scnt;                                                   \</span>
00392 <span class="preprocessor">    }                                                                   \</span>
00393 <span class="preprocessor">                                                                        \</span>
00394 <span class="preprocessor">    if (dest) *dest = 0;                                                \</span>
00395 <span class="preprocessor">                                                                        \</span>
00396 <span class="preprocessor">    return encodedLen + 1;                                              \</span>
00397 <span class="preprocessor">  }</span>
00398 <span class="preprocessor"></span>
<a name="l00416"></a><a class="code" href="classcsUnicodeTransform.html#z111_0">00416</a>   UCTF_CONVERTER (UTF8to16, utf8_char, UTF8Decode, utf16_char, EncodeUTF16);
<a name="l00421"></a><a class="code" href="classcsUnicodeTransform.html#z111_1">00421</a>   UCTF_CONVERTER (UTF8to32, utf8_char, UTF8Decode, utf32_char, EncodeUTF32);
00422 
<a name="l00427"></a><a class="code" href="classcsUnicodeTransform.html#z111_2">00427</a>   UCTF_CONVERTER (UTF16to8, utf16_char, UTF16Decode, utf8_char, EncodeUTF8);
<a name="l00432"></a><a class="code" href="classcsUnicodeTransform.html#z111_3">00432</a>   UCTF_CONVERTER (UTF16to32, utf16_char, UTF16Decode, utf32_char, EncodeUTF32);
00433   
<a name="l00438"></a><a class="code" href="classcsUnicodeTransform.html#z111_4">00438</a>   UCTF_CONVERTER (UTF32to8, utf32_char, UTF32Decode, utf8_char, EncodeUTF8);
<a name="l00443"></a><a class="code" href="classcsUnicodeTransform.html#z111_5">00443</a>   UCTF_CONVERTER (UTF32to16, utf32_char, UTF32Decode, utf16_char, EncodeUTF16);
00446 <span class="preprocessor">#undef UCTF_CONVERTER</span>
00447 <span class="preprocessor"></span><span class="preprocessor">#undef OUTPUT_CHAR</span>
00448 <span class="preprocessor"></span>
00449 <span class="preprocessor">#if (CS_WCHAR_T_SIZE == 1)</span>
00450 <span class="preprocessor"></span>  <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_0">UTF8toWC</a> (<span class="keywordtype">wchar_t</span>* dest, size_t destSize, 
00451     <span class="keyword">const</span> utf8_char* source, size_t srcSize)
00452   {
00453     size_t srcChars = srcSize;                                          
00454     <span class="keywordflow">if</span> (srcSize == (size_t)-1)                                          
00455     {                                                                   
00456       srcChars = 0;                                                     
00457       <span class="keyword">const</span> <a class="code" href="group__util.html#a15">utf8_char</a>* sptr = source;                                   
00458       <span class="keywordflow">while</span> (*sptr++ != 0) srcChars++;                                  
00459     }                           
00460     <span class="keywordflow">if</span> ((dest != 0) &amp;&amp; (destSize != 0))
00461     {
00462       size_t len = MIN (destSize - 1, srcChars);
00463       memcpy (dest, source, size * <span class="keyword">sizeof</span> (<span class="keywordtype">wchar_t</span>));
00464       *(dest + len) = 0;
00465     }
00466     <span class="keywordflow">return</span> srcChars + 1;
00467   };
00468 
00469   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_1">UTF16toWC</a> (<span class="keywordtype">wchar_t</span>* dest, size_t destSize, 
00470     <span class="keyword">const</span> utf16_char* source, size_t srcSize)
00471   {
00472     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_2">UTF16to8</a> ((utf8_char*)dest, destSize, source, srcSize);
00473   };
00474 
00475   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_2">UTF32toWC</a> (<span class="keywordtype">wchar_t</span>* dest, size_t destSize, 
00476     <span class="keyword">const</span> utf32_char* source, size_t srcSize)
00477   {
00478     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_4">UTF32to8</a> ((utf8_char*)dest, destSize, source, srcSize);
00479   };
00480   
00481   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_3">WCtoUTF8</a> (utf8_char* dest, size_t destSize, 
00482     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* source, size_t srcSize)
00483   {
00484     size_t srcChars = srcSize;                                          
00485     <span class="keywordflow">if</span> (srcSize == (size_t)-1)                                          
00486     {                                                                   
00487       srcChars = 0;                                                     
00488       <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* sptr = source;                                     
00489       <span class="keywordflow">while</span> (*sptr++ != 0) srcChars++;                                  
00490     }                           
00491     <span class="keywordflow">if</span> ((dest != 0) &amp;&amp; (destSize != 0))
00492     {
00493       size_t len = MIN (destSize - 1, srcChars);
00494       memcpy (dest, source, len * <span class="keyword">sizeof</span> (<span class="keywordtype">wchar_t</span>));
00495       *(dest + len) = 0;
00496     }
00497     <span class="keywordflow">return</span> srcChars + 1;
00498   };
00499 
00500   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_4">WCtoUTF16</a> (utf16_char* dest, size_t destSize, 
00501     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* source, size_t srcSize)
00502   {
00503     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_0">UTF8to16</a> (dest, destSize, source, srcSize);
00504   };
00505 
00506   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_5">WCtoUTF32</a> (utf32_char* dest, size_t destSize, 
00507     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* source, size_t srcSize)
00508   {
00509     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_1">UTF8to32</a> (dest, destSize, source, srcSize);
00510   };
00511 <span class="preprocessor">#elif (CS_WCHAR_T_SIZE == 2)</span>
00512 <span class="preprocessor"></span>  <span class="comment">// Methods below for doxygen documentation are here as the size '2' is </span>
00513   <span class="comment">// default.</span>
00514   
<a name="l00521"></a><a class="code" href="classcsUnicodeTransform.html#z112_0">00521</a>   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_0">UTF8toWC</a> (<span class="keywordtype">wchar_t</span>* dest, size_t destSize, 
00522     <span class="keyword">const</span> utf8_char* source, size_t srcSize)
00523   {
00524     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_0">UTF8to16</a> ((<a class="code" href="group__util.html#a16">utf16_char</a>*)dest, destSize, source, srcSize);
00525   };
00526 
<a name="l00531"></a><a class="code" href="classcsUnicodeTransform.html#z112_1">00531</a>   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_1">UTF16toWC</a> (<span class="keywordtype">wchar_t</span>* dest, size_t destSize, 
00532     <span class="keyword">const</span> utf16_char* source, size_t srcSize)
00533   {
00534     size_t srcChars = srcSize;                                          
00535     <span class="keywordflow">if</span> (srcSize == (size_t)-1)                                          
00536     {                                                                   
00537       srcChars = 0;                                                     
00538       <span class="keyword">const</span> <a class="code" href="group__util.html#a16">utf16_char</a>* sptr = source;                                  
00539       <span class="keywordflow">while</span> (*sptr++ != 0) srcChars++;                                  
00540     }                           
00541     <span class="keywordflow">if</span> ((dest != 0) &amp;&amp; (destSize != 0))
00542     {
00543       size_t len = MIN (destSize - 1, srcChars);
00544       memcpy (dest, source, len * <span class="keyword">sizeof</span> (<span class="keywordtype">wchar_t</span>));
00545       *(dest + len) = 0;
00546     }
00547     <span class="keywordflow">return</span> srcChars + 1;
00548   };
00549 
<a name="l00554"></a><a class="code" href="classcsUnicodeTransform.html#z112_2">00554</a>   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_2">UTF32toWC</a> (<span class="keywordtype">wchar_t</span>* dest, size_t destSize, 
00555     <span class="keyword">const</span> utf32_char* source, size_t srcSize)
00556   {
00557     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_5">UTF32to16</a> ((<a class="code" href="group__util.html#a16">utf16_char</a>*)dest, destSize, source, srcSize);
00558   };
00559   
<a name="l00564"></a><a class="code" href="classcsUnicodeTransform.html#z112_3">00564</a>   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_3">WCtoUTF8</a> (utf8_char* dest, size_t destSize, 
00565     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* source, size_t srcSize)
00566   {
00567     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_2">UTF16to8</a> (dest, destSize, (<a class="code" href="group__util.html#a16">utf16_char</a>*)source, srcSize);
00568   };
00569 
<a name="l00574"></a><a class="code" href="classcsUnicodeTransform.html#z112_4">00574</a>   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_4">WCtoUTF16</a> (utf16_char* dest, size_t destSize, 
00575     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* source, size_t srcSize)
00576   {
00577     size_t srcChars = srcSize;                                          
00578     <span class="keywordflow">if</span> (srcSize == (size_t)-1)                                          
00579     {                                                                   
00580       srcChars = 0;                                                     
00581       <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* sptr = source;                                     
00582       <span class="keywordflow">while</span> (*sptr++ != 0) srcChars++;                                  
00583     }                           
00584     <span class="keywordflow">if</span> ((dest != 0) &amp;&amp; (destSize != 0))
00585     {
00586       size_t len = MIN (destSize - 1, srcChars);
00587       memcpy (dest, source, len * <span class="keyword">sizeof</span> (<span class="keywordtype">wchar_t</span>));
00588       *(dest + len) = 0;
00589     }
00590     <span class="keywordflow">return</span> srcChars + 1;
00591   };
00592 
<a name="l00597"></a><a class="code" href="classcsUnicodeTransform.html#z112_5">00597</a>   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_5">WCtoUTF32</a> (utf32_char* dest, size_t destSize, 
00598     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* source, size_t srcSize)
00599   {
00600     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_3">UTF16to32</a> (dest, destSize, (<a class="code" href="group__util.html#a16">utf16_char</a>*)source, srcSize);
00601   };
00603 <span class="preprocessor">#elif (CS_WCHAR_T_SIZE == 4)</span>
00604 <span class="preprocessor"></span>  <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_0">UTF8toWC</a> (<span class="keywordtype">wchar_t</span>* dest, size_t destSize, 
00605     <span class="keyword">const</span> utf8_char* source, size_t srcSize)
00606   {
00607     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_1">UTF8to32</a> ((utf32_char*)dest, destSize, source, srcSize);
00608   };
00609 
00610   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_1">UTF16toWC</a> (<span class="keywordtype">wchar_t</span>* dest, size_t destSize, 
00611     <span class="keyword">const</span> utf16_char* source, size_t srcSize)
00612   {
00613     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_3">UTF16to32</a> ((utf32_char*)dest, destSize, source, srcSize);
00614   };
00615 
00616   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_2">UTF32toWC</a> (<span class="keywordtype">wchar_t</span>* dest, size_t destSize, 
00617     <span class="keyword">const</span> utf32_char* source,  size_t srcSize)
00618   {
00619     size_t srcChars = srcSize;                                          
00620     <span class="keywordflow">if</span> (srcSize == (size_t)-1)                                          
00621     {                                                                   
00622       srcChars = 0;                                                     
00623       <span class="keyword">const</span> <a class="code" href="group__util.html#a17">utf32_char</a>* sptr = source;                                  
00624       <span class="keywordflow">while</span> (*sptr++ != 0) srcChars++;                                  
00625     }                           
00626     <span class="keywordflow">if</span> ((dest != 0) &amp;&amp; (destSize != 0))
00627     {
00628       size_t len = MIN (destSize - 1, srcChars);
00629       memcpy (dest, source, len * <span class="keyword">sizeof</span> (<span class="keywordtype">wchar_t</span>));
00630       *(dest + len) = 0;
00631     }
00632     <span class="keywordflow">return</span> srcChars + 1;
00633   };
00634   
00635   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_3">WCtoUTF8</a> (utf8_char* dest, size_t destSize, 
00636     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* source, size_t srcSize)
00637   {
00638     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_4">UTF32to8</a> (dest, destSize, (utf32_char*)source, srcSize);
00639   };
00640 
00641   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_4">WCtoUTF16</a> (utf16_char* dest, size_t destSize, 
00642     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* source, size_t srcSize)
00643   {
00644     <span class="keywordflow">return</span> <a class="code" href="classcsUnicodeTransform.html#z111_5">UTF32to16</a> (dest, destSize, (utf32_char*)source, srcSize);
00645   };
00646 
00647   <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="classcsUnicodeTransform.html#z112_5">WCtoUTF32</a> (utf32_char* dest, size_t destSize, 
00648     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* source, size_t srcSize)
00649   {
00650     size_t srcChars = srcSize;                                          
00651     <span class="keywordflow">if</span> (srcSize == (size_t)-1)                                          
00652     {                                                                   
00653       srcChars = 0;                                                     
00654       <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* sptr = source;                                     
00655       <span class="keywordflow">while</span> (*sptr++ != 0) srcChars++;                                  
00656     }                           
00657     <span class="keywordflow">if</span> ((dest != 0) &amp;&amp; (destSize != 0))
00658     {
00659       size_t len = MIN (destSize - 1, srcChars);
00660       memcpy (dest, source, len * <span class="keyword">sizeof</span> (<span class="keywordtype">wchar_t</span>));
00661       *(dest + len) = 0;
00662     }
00663     <span class="keywordflow">return</span> srcChars + 1;
00664   };
00665 <span class="preprocessor">#else</span>
00666 <span class="preprocessor"></span><span class="preprocessor">  #error Odd-sized, unsupported wchar_t!</span>
00667 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00668 <span class="preprocessor"></span>
<a name="l00681"></a><a class="code" href="classcsUnicodeTransform.html#z113_0">00681</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z113_0">UTF8Skip</a> (<span class="keyword">const</span> utf8_char* str, size_t maxSkip)
00682   {
00683     <span class="keywordflow">if</span> (maxSkip &lt; 1) <span class="keywordflow">return</span> 0;
00684   
00685     <span class="keywordflow">if</span> ((*str &amp; 0x80) == 0)
00686     {
00687       <span class="keywordflow">return</span> 1;
00688     }
00689     <span class="keywordflow">else</span>
00690     {
00691       <span class="keywordtype">int</span> n = 0;
00692       <span class="keywordflow">while</span> ((n &lt; 7) &amp;&amp; ((*str &amp; (1 &lt;&lt; (7 - n))) != 0)) { n++; }
00693 
00694       <span class="keywordflow">if</span> ((n &lt; 2) || (n &gt; 6))
00695       {
00696         <span class="keywordflow">return</span> 1;
00697       }
00698 
00699       <span class="keywordtype">int</span> skip = 1;
00700       
00701       <span class="keywordflow">for</span> (; skip &lt; n; skip++)
00702       {
00703         <span class="keywordflow">if</span> (((str[skip] &amp; 0xc0) != 0x80) || ((size_t)skip &gt; maxSkip))
00704         {
00705           <span class="keywordflow">break</span>;
00706         }
00707       }
00708       <span class="keywordflow">return</span> skip;
00709     }
00710   }
00711   
<a name="l00722"></a><a class="code" href="classcsUnicodeTransform.html#z113_1">00722</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z113_1">UTF8Rewind</a> (<span class="keyword">const</span> utf8_char* str, size_t maxRew)
00723   {
00724     <span class="keywordflow">if</span> (maxRew &lt; 1) <span class="keywordflow">return</span> 0;
00725     
00726     <span class="keyword">const</span> <a class="code" href="group__util.html#a15">utf8_char</a>* pos = str - 1;
00727     
00728     <span class="keywordflow">if</span> ((*pos &amp; 0x80) == 0)
00729     {
00730       <span class="keywordflow">return</span> 1;
00731     }
00732     
00733     <span class="comment">// Skip backward to the first byte of the sequence.</span>
00734     <span class="keywordtype">int</span> skip = 1;
00735     <span class="keywordflow">while</span> (((*pos &amp; 0xc0) == 0x80) &amp;&amp; ((size_t)skip &lt; maxRew))
00736     {
00737       skip++;
00738       pos--;
00739     }
00740     
00741     <span class="keywordflow">return</span> skip;
00742   }
00743   
<a name="l00749"></a><a class="code" href="classcsUnicodeTransform.html#z113_2">00749</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z113_2">UTF16Skip</a> (<span class="keyword">const</span> utf16_char* str, size_t maxSkip)
00750   {
00751     <span class="keywordflow">if</span> (<a class="code" href="group__util.html#a103">CS_UC_IS_HIGH_SURROGATE</a> (*str))
00752       <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(MIN(maxSkip, 2));
00753     <span class="keywordflow">else</span>
00754       <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(MIN(maxSkip, 1));
00755   }
00756   
<a name="l00762"></a><a class="code" href="classcsUnicodeTransform.html#z113_3">00762</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z113_3">UTF16Rewind</a> (<span class="keyword">const</span> utf16_char* str, size_t maxRew)
00763   {
00764     <span class="keywordflow">if</span> (maxRew &lt; 1) <span class="keywordflow">return</span> 0;
00765     
00766     <span class="keyword">const</span> <a class="code" href="group__util.html#a16">utf16_char</a>* pos = str - 1;
00767     <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#a102">CS_UC_IS_SURROGATE</a>(*pos)) 
00768       <span class="keywordflow">return</span> 1;
00769     <span class="keywordflow">else</span>
00770     {
00771       <span class="keywordflow">if</span> ((maxRew &gt; 1) &amp;&amp; (<a class="code" href="group__util.html#a103">CS_UC_IS_HIGH_SURROGATE</a>(*(pos - 1))))
00772         <span class="keywordflow">return</span> 2;
00773       <span class="keywordflow">else</span>
00774         <span class="keywordflow">return</span> 1;
00775     }
00776   }
00777   
<a name="l00783"></a><a class="code" href="classcsUnicodeTransform.html#z113_4">00783</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z113_4">UTF32Skip</a> (<span class="keyword">const</span> utf32_char* str, size_t maxSkip)
00784   {
00785     <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(MIN(maxSkip, 1));
00786   }
00787 
<a name="l00793"></a><a class="code" href="classcsUnicodeTransform.html#z113_5">00793</a>   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsUnicodeTransform.html#z113_5">UTF32Rewind</a> (<span class="keyword">const</span> utf32_char* str, size_t maxRew)
00794   {
00795     <span class="keywordflow">if</span> (maxRew &lt; 1) <span class="keywordflow">return</span> 0;
00796     <span class="keywordflow">return</span> 1;
00797   }
00799 };
00800 
00803 <span class="preprocessor">#endif</span>
00804 <span class="preprocessor"></span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.3 
</small></address> </div></body> </html>
