<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/formatter.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000022.html">csutil</a></div>
<h1>formatter.h</h1><a href="formatter_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2005 by Frank Richter</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_CSUTIL_FORMATTER_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_CSUTIL_FORMATTER_H__</span>
00021 <span class="preprocessor"></span>
00027 <span class="preprocessor">#include "<a class="code" href="cssysdef_8h.html">cssysdef.h</a>"</span>
00028 <span class="preprocessor">#include "<a class="code" href="csuctransform_8h.html">csutil/csuctransform.h</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="dirtyaccessarray_8h.html">csutil/dirtyaccessarray.h</a>"</span>
00030 <span class="preprocessor">#include "<a class="code" href="util_8h.html">csutil/util.h</a>"</span>
00031 <span class="preprocessor">#include "<a class="code" href="math_8h.html">csgeom/math.h</a>"</span>
00032 
00033 <span class="comment">// MinGW uses MS CRT, but it can't grok long double.  VC doesn't have long</span>
00034 <span class="comment">// double and CRT printf() doesn't know %Lf, %Lg, or %Le.</span>
00035 <span class="preprocessor">#if defined(__MINGW32__) || defined(CS_COMPILER_MSVC)</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define CS_FORMATTER_NO_LONG_DOUBLE_FORMAT</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00038 <span class="preprocessor"></span>
00039 <span class="comment">// MSVC 7.1 requires us to use a `typename' qualifier on the declaration of</span>
00040 <span class="comment">// `mantissa' in csPrintfFormatter. Although this is accepted by most other</span>
00041 <span class="comment">// compilers, it breaks on gcc 3.4.x, which complains (apparently incorrectly?)</span>
00042 <span class="comment">// that IEEEFloatMantissa is not a templated type.</span>
00043 <span class="preprocessor">#if defined(CS_COMPILER_MSVC) &amp;&amp; (_MSC_VER &gt;= 1300)</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define CS_FORMATTER_TYPENAME_QUALIFIER typename_qualifier</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define CS_FORMATTER_TYPENAME_QUALIFIER</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00048 <span class="preprocessor"></span>
00057 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00058"></a><a class="code" href="classcsFmtDefaultReader.html">00058</a> <span class="keyword">class </span><a class="code" href="classcsFmtDefaultReader.html">csFmtDefaultReader</a>
00059 {
00060   <span class="keyword">const</span> T* str;
00061   <span class="keyword">const</span> T* <span class="keyword">const</span> startStr;
00062   size_t len;
00063   <span class="keyword">const</span> size_t startLen;
00064 <span class="keyword">public</span>:
<a name="l00066"></a><a class="code" href="classcsFmtDefaultReader.html#a0">00066</a>   <a class="code" href="classcsFmtDefaultReader.html">csFmtDefaultReader</a> (<span class="keyword">const</span> T* string, size_t length) : startStr (string), 
00067     startLen (length) { Reset(); }
<a name="l00069"></a><a class="code" href="classcsFmtDefaultReader.html#a1">00069</a>   <span class="keywordtype">bool</span> GetNext (utf32_char&amp; ch) 
00070   {
00071     <span class="keywordtype">int</span> n = <a class="code" href="classcsUnicodeTransform.html#z541_3">csUnicodeTransform::Decode</a> (str, len, ch);
00072     <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00073     str += (size_t)n;
00074     len -= (size_t)n;
00075     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00076   }
<a name="l00078"></a><a class="code" href="classcsFmtDefaultReader.html#a2">00078</a>   <span class="keywordtype">void</span> Reset() { str = startStr; len = startLen; }
<a name="l00080"></a><a class="code" href="classcsFmtDefaultReader.html#a3">00080</a>   size_t GetPosition()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> str - startStr; }
00081 };
00082 
00083 
00089 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00090"></a><a class="code" href="classcsFmtDefaultWriter.html">00090</a> <span class="keyword">class </span><a class="code" href="classcsFmtDefaultWriter.html">csFmtDefaultWriter</a>
00091 {
00092   T* dest;
00093   size_t size;
00094   size_t total;
00095 <span class="keyword">public</span>:
<a name="l00097"></a><a class="code" href="classcsFmtDefaultWriter.html#a0">00097</a>   <a class="code" href="classcsFmtDefaultWriter.html">csFmtDefaultWriter</a> (T* dest, size_t size) : dest (dest), size (size), 
00098     total (0) {}
<a name="l00100"></a><a class="code" href="classcsFmtDefaultWriter.html#a1">00100</a>   <span class="keywordtype">void</span> Put (utf32_char ch) 
00101   { 
00102     size_t n = (size_t)<a class="code" href="classcsUnicodeTransform.html#z542_3">csUnicodeTransform::Encode</a> (ch, dest, size);
00103     total += n;
00104     n = <a class="code" href="group__geom__utils.html#ga6">csMin</a> (size, n);
00105     dest += n;
00106     size -= n;
00107   }
<a name="l00112"></a><a class="code" href="classcsFmtDefaultWriter.html#a2">00112</a>   size_t GetTotal()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> total; }
00113 };
00114 
00119 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Twriter, <span class="keyword">class</span> Treader&gt;
<a name="l00120"></a><a class="code" href="classcsPrintfFormatter.html">00120</a> <span class="keyword">class </span><a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter</a>
00121 {
00122   <span class="keyword">class </span>Scratch : <span class="keyword">public</span> <a class="code" href="classcsDirtyAccessArray.html">csDirtyAccessArray</a>&lt;utf32_char&gt;
00123   {
00124   <span class="keyword">public</span>:
00125     <span class="keywordtype">void</span> WriteTo (Twriter&amp; writer, size_t offset = 0, size_t len = (size_t)~0)
00126     {
00127       <span class="keyword">const</span> size_t n = MIN (len, <a class="code" href="classcsArray.html#a4">Length</a>());
00128       <span class="keywordflow">for</span> (size_t i = offset; i &lt; n; i++) writer.Put (Get (i));
00129     }
00130   };
00131   Scratch scratch;
00132 
00134   <span class="keyword">struct </span>FmtParam
00135   {
00136     <span class="keyword">union</span>
00137 <span class="keyword">    </span>{
00138       <span class="keywordtype">int</span> vInt;
00139       <span class="keywordtype">void</span>* vPtr;
00140       <span class="keywordtype">long</span> vLong;
00141       <a class="code" href="group__util.html#ga15">longlong</a> vLL;
00142       <span class="keywordtype">double</span> vDbl;
00143       <span class="keywordtype">long</span> <span class="keywordtype">double</span> vLongDbl;
00144       size_t vSzT;
00145       <a class="code" href="group__util.html#ga10">ptrdiff_t</a> vPDT;
00146       <a class="code" href="group__util.html#ga11">intmax_t</a> vIMT;
00147     };
00148   };
00149   <span class="keyword">enum</span> Conversion
00150   {
00151     convBogus = 0,
00152     convNone,
00153     convInt,
00154     convOctal,
00155     convUint,
00156     convHex,
00157     convFloatFix,
00158     convFloatExp,
00159     convFloatGeneral,
00160     convFloatHex,
00161     convChar,
00162     convStr,
00163     convPtr,
00164     convGetNum,
00165     convErrno
00166   };
00167   <span class="keyword">enum</span> Type
00168   {
00169     typeNone = 0,
00170     typeChar,
00171     typeShort,
00172     typeIntmax,
00173     typeLong,
00174     typeLongLong,
00175     typePtrDiffT,
00176     typeSizeT
00177   };
00179   <span class="keyword">struct </span>FormatSpec
00180   {
00181     size_t copyRun;
00182     size_t fmtSkip;
00183 
00184     <span class="keywordtype">int</span> paramIdx;
00185     <span class="keywordtype">bool</span> leftJustify;
00186     <span class="keywordtype">bool</span> plusSign;
00187     <span class="keywordtype">bool</span> spacePrefix;
00188     <span class="keywordtype">bool</span> basePrefix;
00189     <span class="keywordtype">bool</span> padZero;
00190     <span class="keywordtype">int</span> width;
00191     <span class="keywordtype">int</span> precision;
00192     Conversion conversion;
00193     <span class="keywordtype">bool</span> uppercase;
00194     Type type;
00195 
00196     FormatSpec() { Reset(); }
00197     <span class="keywordtype">void</span> Reset () 
00198     { 
00199       memset (<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span> (*<span class="keyword">this</span>)); 
00200       precision = -1;
00201     }
00202   };
00203   <a class="code" href="classcsArray.html">csArray&lt;FormatSpec&gt;</a> formatSpecs;
00204   <a class="code" href="classcsArray.html">csArray&lt;FmtParam&gt;</a> params;
00205   Treader&amp; reader;
00206 
00207   <span class="keyword">struct </span>SpecParseState
00208   {
00209     <a class="code" href="group__util.html#ga22">utf32_char</a> ch;
00210     FormatSpec currentFormat;
00211     size_t charRun;
00212     <span class="keywordtype">int</span> paramIdx;
00213     size_t fmtBegin;
00214 
00215     SpecParseState() : paramIdx(0) {}
00216     <span class="keywordtype">void</span> Reset()
00217     {
00218       charRun = 0;
00219       currentFormat.Reset();
00220     }
00221   };
00222 
00223   <span class="keywordtype">bool</span> ParseFlag (SpecParseState&amp; state)
00224   {
00225     <span class="keywordflow">switch</span> (state.ch)
00226     {
00227       <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
00228         {
00229           state.currentFormat.leftJustify = <span class="keyword">true</span>;
00230           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00231         }
00232       <span class="keywordflow">case</span> <span class="charliteral">'+'</span>:
00233         {
00234           state.currentFormat.plusSign = <span class="keyword">true</span>;
00235           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00236         }
00237       <span class="keywordflow">case</span> <span class="charliteral">' '</span>:
00238         {
00239           state.currentFormat.spacePrefix = <span class="keyword">true</span>;
00240           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00241         }
00242       <span class="keywordflow">case</span> <span class="charliteral">'#'</span>:
00243         {
00244           state.currentFormat.basePrefix = <span class="keyword">true</span>;
00245           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00246         }
00247       <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
00248         {
00249           state.currentFormat.padZero = <span class="keyword">true</span>;
00250           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00251         }
00252       <span class="keywordflow">case</span> <span class="charliteral">'\''</span>:
00253         {
00254           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00255         }
00256     }
00257     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00258   }
00259   
00260   <span class="keywordtype">bool</span> ParseType (SpecParseState&amp; state)
00261   {
00262     <span class="keywordflow">switch</span> (state.ch)
00263     {
00264       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
00265         {
00266           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00267             state.currentFormat.type = typeShort;
00268           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.currentFormat.type == typeShort)
00269             state.currentFormat.type = typeChar;
00270           <span class="keywordflow">else</span>
00271             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00272           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00273         }
00274       <span class="keywordflow">case</span> <span class="charliteral">'j'</span>:
00275         {
00276           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00277             state.currentFormat.type = typeIntmax;
00278           <span class="keywordflow">else</span>
00279             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00280           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00281         }
00282       <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
00283         {
00284           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00285             state.currentFormat.type = typeLong;
00286           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.currentFormat.type == typeLong)
00287             state.currentFormat.type = typeLongLong;
00288           <span class="keywordflow">else</span>
00289             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00290           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00291         }
00292       <span class="keywordflow">case</span> <span class="charliteral">'L'</span>:
00293       <span class="keywordflow">case</span> <span class="charliteral">'q'</span>:
00294         {
00295           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00296             state.currentFormat.type = typeLongLong;
00297           <span class="keywordflow">else</span>
00298             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00299           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00300         }
00301       <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
00302         {
00303           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00304             state.currentFormat.type = typePtrDiffT;
00305           <span class="keywordflow">else</span>
00306             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00307           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00308         }
00309       <span class="keywordflow">case</span> <span class="charliteral">'z'</span>:
00310         {
00311           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00312             state.currentFormat.type = typeSizeT;
00313           <span class="keywordflow">else</span>
00314             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00315           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00316         }
00317     }
00318     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00319   }
00320 
00321   <span class="keywordtype">bool</span> ParseConversion (SpecParseState&amp; state)
00322   {
00323     <span class="keywordflow">switch</span> (state.ch)
00324     {
00325       <span class="keywordflow">case</span> <span class="charliteral">'%'</span>:
00326         {
00327           <span class="keyword">const</span> size_t fmtLen = (reader.GetPosition() - 1) - state.fmtBegin;
00328           <span class="keywordflow">if</span> (fmtLen == 1)
00329           {
00330             state.currentFormat.conversion = convNone;
00331             state.fmtBegin++;
00332             state.currentFormat.copyRun++;
00333             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00334           }
00335           <span class="keywordflow">break</span>;
00336         }
00337       <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00338       <span class="keywordflow">case</span> <span class="charliteral">'i'</span>:
00339         {
00340           state.currentFormat.conversion = convInt;
00341           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00342         }
00343       <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
00344         {
00345           state.currentFormat.conversion = convOctal;
00346           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00347         }
00348       <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
00349         {
00350           state.currentFormat.conversion = convUint;
00351           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00352         }
00353       <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
00354       <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
00355         {
00356           state.currentFormat.conversion = convHex;
00357           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'X'</span>);
00358           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00359         }
00360       <span class="keywordflow">case</span> <span class="charliteral">'f'</span>:
00361         {
00362           state.currentFormat.conversion = convFloatFix;
00363           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00364         }
00365       <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
00366       <span class="keywordflow">case</span> <span class="charliteral">'E'</span>:
00367         {
00368           state.currentFormat.conversion = convFloatExp;
00369           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'E'</span>);
00370           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00371         }
00372       <span class="keywordflow">case</span> <span class="charliteral">'g'</span>:
00373       <span class="keywordflow">case</span> <span class="charliteral">'G'</span>:
00374         {
00375           state.currentFormat.conversion = convFloatGeneral;
00376           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'G'</span>);
00377           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00378         }
00379       <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
00380       <span class="keywordflow">case</span> <span class="charliteral">'A'</span>:
00381         {
00382           state.currentFormat.conversion = convFloatHex;
00383           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'A'</span>);
00384           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00385         }
00386       <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
00387         {
00388           state.currentFormat.conversion = convChar;
00389           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00390         }
00391       <span class="keywordflow">case</span> <span class="charliteral">'C'</span>:
00392         {
00393           state.currentFormat.conversion = convChar;
00394           state.currentFormat.type = typeLong;
00395           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00396         }
00397       <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
00398         {
00399           state.currentFormat.conversion = convStr;
00400           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00401         }
00402       <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
00403         {
00404           state.currentFormat.conversion = convStr;
00405           state.currentFormat.type = typeLong;
00406           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00407         }
00408       <span class="keywordflow">case</span> <span class="charliteral">'p'</span>:
00409         {
00410           state.currentFormat.conversion = convPtr;
00411           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00412         }
00413       <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
00414         {
00415           state.currentFormat.conversion = convGetNum;
00416           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00417         }
00418       <span class="keywordflow">case</span> <span class="charliteral">'m'</span>:
00419         {
00420           state.currentFormat.conversion = convErrno;
00421           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00422         }
00423     }
00424     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00425   }
00426 
00427   <span class="keywordtype">void</span> ParseSpec ()
00428   {
00429     <span class="keyword">enum</span> {
00430       scanFormat,
00431       formatParamFlagsWidthPrecTypeConversion,
00432       formatFlagsWidthPrecTypeConversion,
00433       formatParamWidth,
00434       formatDotPrecTypeConversion,
00435       formatPrecTypeConversion,
00436       formatTypeConversion
00437     } parseState = scanFormat;
00438 
00439     <span class="comment">// Collect positions of state specifiers from format string</span>
00440     SpecParseState state;
00441     state.Reset();
00442     <span class="keywordflow">while</span> (reader.GetNext (state.ch))
00443     {
00444       <span class="keywordflow">switch</span> (parseState)
00445       {
00446         <span class="comment">// Note: all falling through in this switch() is intentional.</span>
00447         <span class="keywordflow">case</span> scanFormat:
00448           {
00449             <span class="comment">// Check for a % sign</span>
00450             <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'%'</span>)
00451             {
00452               parseState = formatParamFlagsWidthPrecTypeConversion;
00453               state.fmtBegin = reader.GetPosition() - 1;
00454               state.currentFormat.copyRun = state.charRun;
00455             }
00456             <span class="keywordflow">else</span>
00457               state.charRun++;
00458           }
00459           <span class="keywordflow">break</span>;
00460         <span class="keywordflow">case</span> formatParamFlagsWidthPrecTypeConversion:
00461           <span class="comment">// Check for start of width or param index</span>
00462           <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'1'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00463           {
00464             state.currentFormat.width = state.ch - <span class="charliteral">'0'</span>;
00465             parseState = formatParamWidth;
00466             <span class="keywordflow">break</span>;
00467           }
00468           <span class="comment">// Check for '*' (fetch width from args)</span>
00469           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'*'</span>)
00470           {
00471             state.currentFormat.width = -2;
00472             parseState = formatDotPrecTypeConversion;
00473             <span class="keywordflow">break</span>;
00474           }
00475           <span class="comment">// Param delimiter</span>
00476           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'$'</span>)
00477           {
00478             <span class="comment">// @@@ Hmm. Empty param...</span>
00479             parseState = formatFlagsWidthPrecTypeConversion;
00480             <span class="keywordflow">break</span>;
00481           }
00482         <span class="keywordflow">case</span> formatParamWidth:
00483           <span class="keywordflow">if</span> (parseState == formatParamWidth) <span class="comment">// != can occur due fallthrough</span>
00484           {
00485             <span class="comment">// Subsequent digits width or param index</span>
00486             <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'0'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00487             {
00488               state.currentFormat.width *= 10;
00489               state.currentFormat.width += state.ch - <span class="charliteral">'0'</span>;
00490               <span class="keywordflow">break</span>;
00491             }
00492             <span class="comment">// Param delimiter</span>
00493             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'$'</span>)
00494             {
00495               state.paramIdx = state.currentFormat.width - 1;
00496               state.currentFormat.width = 0;
00497               parseState = formatFlagsWidthPrecTypeConversion;
00498               <span class="keywordflow">break</span>;
00499             }
00500           }
00501         <span class="keywordflow">case</span> formatFlagsWidthPrecTypeConversion:
00502           <span class="comment">// Check for start of width</span>
00503           <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'1'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00504           {
00505             state.currentFormat.width *= 10;
00506             state.currentFormat.width += state.ch - <span class="charliteral">'0'</span>;
00507             parseState = formatParamWidth;
00508             <span class="keywordflow">break</span>;
00509           }
00510           <span class="comment">// Check for '*' (fetch width from args)</span>
00511           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'*'</span>)
00512           {
00513             state.currentFormat.width = -2;
00514             parseState = formatDotPrecTypeConversion;
00515             <span class="keywordflow">break</span>;
00516           }
00517           <span class="comment">// Check for flags (0, -, ...)</span>
00518           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ParseFlag (state))
00519           {
00520             parseState = formatFlagsWidthPrecTypeConversion;
00521             <span class="keywordflow">break</span>;
00522           }
00523         <span class="keywordflow">case</span> formatDotPrecTypeConversion:
00524           <span class="comment">// Check for precision delimiter</span>
00525           <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'.'</span>)
00526           {
00527             parseState = formatPrecTypeConversion;
00528             state.currentFormat.precision = 0;
00529             <span class="keywordflow">break</span>;
00530           }
00531         <span class="keywordflow">case</span> formatPrecTypeConversion:
00532           <span class="comment">// Precision digits</span>
00533           <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'0'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00534           {
00535             state.currentFormat.precision *= 10;
00536             state.currentFormat.precision += state.ch - <span class="charliteral">'0'</span>;
00537             <span class="keywordflow">break</span>;
00538           }
00539           <span class="comment">// Check for '*' (fetch precision from args)</span>
00540           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'*'</span>)
00541           {
00542             state.currentFormat.precision = -2;
00543             parseState = formatTypeConversion;
00544             <span class="keywordflow">break</span>;
00545           }
00546           <span class="comment">// Check for param type modifier (l, h, ...)</span>
00547           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ParseType (state))
00548           {
00549             parseState = formatPrecTypeConversion;
00550             <span class="keywordflow">break</span>;
00551           }
00552         <span class="keywordflow">case</span> formatTypeConversion:
00553           <span class="comment">// Check actual conversion (s, d, ...)</span>
00554           <span class="keywordflow">if</span> (ParseConversion (state))
00555           {
00556             state.currentFormat.fmtSkip =
00557               reader.GetPosition() - state.fmtBegin;
00558             <span class="keywordflow">if</span> (state.currentFormat.conversion != convNone)
00559               state.currentFormat.paramIdx = state.paramIdx++;
00560             formatSpecs.<a class="code" href="classcsArray.html#a16">Push</a> (state.currentFormat);
00561 
00562             state.Reset();
00563           }
00564           <span class="keywordflow">else</span>
00565           {
00566             state.charRun += reader.GetPosition() - state.fmtBegin;
00567             state.currentFormat.Reset();
00568           }
00569           parseState = scanFormat;
00570           <span class="keywordflow">break</span>;
00571       }
00572     }
00573   }
00574 
00576   <span class="keywordtype">void</span> FetchArgs (va_list args)
00577   {
00578     size_t i;
00579     <span class="comment">// Determine order of params</span>
00580     <a class="code" href="classcsArray.html">csArray&lt;FormatSpec*&gt;</a> paramOrder;
00581     paramOrder.<a class="code" href="classcsArray.html#a31">SetCapacity</a> (formatSpecs.<a class="code" href="classcsArray.html#a4">Length</a>());
00582     <span class="keywordflow">for</span> (i = 0; i &lt; formatSpecs.<a class="code" href="classcsArray.html#a4">Length</a>(); i++)
00583     {
00584       FormatSpec&amp; currentFormat = formatSpecs[i];
00585       <span class="keywordflow">if</span> (currentFormat.conversion == convNone) <span class="keywordflow">continue</span>;
00586       <span class="keywordflow">if</span> (paramOrder.<a class="code" href="classcsArray.html#a4">Length</a>() &lt;= (size_t)currentFormat.paramIdx)
00587         paramOrder.<a class="code" href="classcsArray.html#a7">SetLength</a> (currentFormat.paramIdx + 1, 0);
00588       paramOrder[currentFormat.paramIdx] = &amp;currentFormat;
00589     }
00590     <span class="comment">// Fetch params from stack in order, store at correct place in params array</span>
00591     <span class="keywordflow">for</span> (i = 0; i &lt; paramOrder.<a class="code" href="classcsArray.html#a4">Length</a>(); i++)
00592     {
00593       FmtParam&amp; param = params.<a class="code" href="classcsArray.html#a11">GetExtend</a> (i);
00594       FormatSpec* fmtPtr = paramOrder[i];
00595       <span class="keywordflow">if</span> (fmtPtr == 0) 
00596       {
00597         <span class="comment">// Can just guess here...</span>
00598         param.vInt = va_arg (args, <span class="keywordtype">int</span>);
00599         <span class="keywordflow">continue</span>;
00600       }
00601       FormatSpec&amp; currentFormat = *fmtPtr;
00602 
00603       <span class="keywordflow">if</span> (currentFormat.width == -2)
00604       {
00605         currentFormat.width = va_arg (args, <span class="keywordtype">int</span>);
00606         <span class="keywordflow">if</span> (currentFormat.width &lt; 0)
00607         {
00608           currentFormat.width = -currentFormat.width;
00609           currentFormat.leftJustify = <span class="keyword">true</span>;
00610         }
00611       }
00612       <span class="keywordflow">if</span> (currentFormat.precision == -2)
00613       {
00614         <span class="keywordtype">int</span> v = va_arg (args, <span class="keywordtype">int</span>);
00615         <span class="keywordflow">if</span> (v &gt;= 0) 
00616           currentFormat.precision = v;
00617         <span class="keywordflow">else</span>
00618           currentFormat.precision = -1;
00619       }
00620       <span class="keywordflow">switch</span> (currentFormat.conversion)
00621       {
00622         <span class="keywordflow">case</span> convInt:
00623         <span class="keywordflow">case</span> convOctal:
00624         <span class="keywordflow">case</span> convUint:
00625         <span class="keywordflow">case</span> convHex:
00626         <span class="keywordflow">default</span>:
00627           {
00628             <span class="keywordflow">switch</span> (currentFormat.type)
00629             {
00630               <span class="keywordflow">case</span> typeIntmax:
00631                 param.vIMT = va_arg (args, <a class="code" href="group__util.html#ga11">intmax_t</a>);
00632                 <span class="keywordflow">break</span>;
00633               <span class="keywordflow">case</span> typeLong:
00634                 param.vLong = va_arg (args, <span class="keywordtype">long</span>);
00635                 <span class="keywordflow">break</span>;
00636               <span class="keywordflow">case</span> typeLongLong:
00637                 param.vLL = va_arg (args, <a class="code" href="group__util.html#ga15">longlong</a>);
00638                 <span class="keywordflow">break</span>;
00639               <span class="keywordflow">case</span> typePtrDiffT:
00640                 param.vPDT = va_arg (args, <a class="code" href="group__util.html#ga10">ptrdiff_t</a>);
00641                 <span class="keywordflow">break</span>;
00642               <span class="keywordflow">case</span> typeSizeT:
00643                 param.vSzT = va_arg (args, size_t);
00644                 <span class="keywordflow">break</span>;
00645               <span class="keywordflow">case</span> typeShort:
00646                 param.vInt = (short)(va_arg (args, <span class="keywordtype">int</span>));
00647                 <span class="keywordflow">break</span>;
00648               <span class="keywordflow">case</span> typeChar:
00649                 param.vInt = (char)(va_arg (args, <span class="keywordtype">int</span>));
00650                 <span class="keywordflow">break</span>;
00651               <span class="keywordflow">default</span>:
00652                 param.vInt = va_arg (args, <span class="keywordtype">int</span>);
00653                 <span class="keywordflow">break</span>;
00654             }
00655           }
00656           <span class="keywordflow">break</span>;
00657         <span class="keywordflow">case</span> convErrno:
00658           param.vInt = errno;
00659           <span class="keywordflow">break</span>;
00660         <span class="keywordflow">case</span> convChar:
00661           <span class="keywordflow">if</span> (currentFormat.type == typeLong)
00662           {
00663             param.vInt = (wint_t)(va_arg (args, <span class="keywordtype">int</span>));
00664           }
00665           <span class="keywordflow">else</span>
00666           {
00667             param.vInt = (<span class="keywordtype">unsigned</span> char)(va_arg (args, <span class="keywordtype">int</span>));
00668           }
00669           <span class="keywordflow">break</span>;
00670         <span class="keywordflow">case</span> convFloatFix:
00671         <span class="keywordflow">case</span> convFloatExp:
00672         <span class="keywordflow">case</span> convFloatGeneral:
00673         <span class="keywordflow">case</span> convFloatHex:
00674           <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
00675           {
00676             param.vLongDbl = va_arg (args, <span class="keywordtype">long</span> <span class="keywordtype">double</span>);
00677           }
00678           <span class="keywordflow">else</span>
00679           {
00680             param.vDbl = va_arg (args, <span class="keywordtype">double</span>);
00681           }
00682           <span class="keywordflow">break</span>;
00683         <span class="keywordflow">case</span> convStr:
00684         <span class="keywordflow">case</span> convPtr:
00685         <span class="keywordflow">case</span> convGetNum:
00686           param.vPtr = va_arg (args, <span class="keywordtype">void</span>*);
00687           <span class="keywordflow">break</span>;
00688         <span class="keywordflow">case</span> convNone:
00689           <span class="keywordflow">break</span>;
00690       }
00691     }
00692   }
00693 
00694   <span class="keywordtype">void</span> Init (va_list args)
00695   {
00696     ParseSpec ();
00697     FetchArgs (args);
00698   }
00699 
00701   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00702   <span class="keywordtype">void</span> OutputString (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00703     <span class="keyword">const</span> T* stringPtr)
00704   {
00705     <span class="keywordflow">if</span> (stringPtr == 0)
00706     {
00707       OutputString (writer, currentFormat, (<a class="code" href="group__util.html#ga20">utf8_char</a>*)<span class="stringliteral">"(nil)"</span>);
00708       <span class="keywordflow">return</span>;
00709     }
00710 
00711     size_t scratchOffs = scratch.Length();
00712     size_t len = 0;
00713     {
00714       <span class="keyword">const</span> T* ptr = stringPtr;
00715       <span class="keywordflow">while</span> (*ptr++ != 0) len++;
00716     }
00717     <span class="keywordflow">while</span> (len &gt; 0)
00718     {
00719       <a class="code" href="group__util.html#ga22">utf32_char</a> ch;
00720       <span class="keywordtype">int</span> n = <a class="code" href="classcsUnicodeTransform.html#z541_3">csUnicodeTransform::Decode</a> (stringPtr, len, ch);
00721       scratch.Push (ch);
00722       stringPtr += n;
00723       len -= (size_t)n;
00724     }
00725     <span class="keywordflow">if</span> (!currentFormat.leftJustify 
00726       &amp;&amp; ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs)))
00727     {
00728       size_t d = (size_t)currentFormat.width - scratch.Length() + scratchOffs;
00729       <span class="keywordflow">while</span> (d-- &gt; 0) writer.Put (<span class="charliteral">' '</span>);
00730     }
00731     scratch.WriteTo (writer, scratchOffs);
00732     <span class="keywordflow">if</span> (currentFormat.leftJustify 
00733       &amp;&amp; ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs)))
00734     {
00735       size_t d = (size_t)currentFormat.width - scratch.Length() + scratchOffs;
00736       <span class="keywordflow">while</span> (d-- &gt; 0) writer.Put (<span class="charliteral">' '</span>);
00737     }
00738     scratch.Truncate (scratchOffs);
00739   }
00740 
00742   <span class="keywordtype">void</span> DoPadding (<span class="keyword">const</span> FormatSpec&amp; currentFormat, <span class="keyword">const</span> size_t scratchOffs,
00743     <span class="keyword">const</span> size_t insert0offs)
00744   {
00745     <span class="keywordflow">if</span> (currentFormat.leftJustify)
00746     {
00747       <span class="keywordflow">while</span> ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs))
00748       {
00749         scratch.Push (<span class="charliteral">' '</span>);
00750       }
00751     }
00752     <span class="keywordflow">else</span>
00753     {
00754       <span class="keywordflow">if</span> (currentFormat.padZero)
00755       {
00756         <span class="keywordflow">while</span> ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs))
00757         {
00758           scratch.Insert (insert0offs, <span class="charliteral">'0'</span>);
00759         }
00760       }
00761       <span class="keywordflow">else</span>
00762       {
00763         <span class="keywordflow">while</span> ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs))
00764         {
00765           scratch.Insert (scratchOffs, <span class="charliteral">' '</span>);
00766         }
00767       }
00768     }
00769   }
00770 
00772   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00773   <span class="keywordtype">void</span> OutputInt (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat, T value)
00774   {
00775     <span class="keyword">const</span> size_t scratchOffs = scratch.Length();
00776     size_t insertOffs = scratchOffs;
00777 
00778     <span class="keywordflow">if</span> (value &lt; 0)
00779     {
00780       scratch.Push (<span class="charliteral">'-'</span>);
00781       insertOffs++;
00782       value = -value;
00783     }
00784     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.plusSign)
00785     {
00786       scratch.Push (<span class="charliteral">'+'</span>);
00787       insertOffs++;
00788     }
00789     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.spacePrefix)
00790     {
00791       scratch.Push (<span class="charliteral">' '</span>);
00792       insertOffs++;
00793     }
00794 
00795     <span class="keywordtype">int</span> width = 0;
00796     <span class="keywordtype">int</span> numDigits = currentFormat.precision;
00797     <span class="keywordflow">if</span> (!((value == 0) &amp;&amp; (numDigits == 0)))
00798     {
00799       <span class="keywordflow">do</span>
00800       {
00801         <span class="keywordtype">int</span> d = value % 10;
00802         scratch.Insert (insertOffs, d + <span class="charliteral">'0'</span>);
00803         width++;
00804         value = value / 10;
00805       }
00806       <span class="keywordflow">while</span> ((value != 0) || (width &lt; numDigits));
00807     }
00808     DoPadding (currentFormat, scratchOffs, insertOffs);
00809     scratch.WriteTo (writer, scratchOffs);
00810     scratch.Truncate (scratchOffs);
00811   }
00812 
00814   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00815   <span class="keywordtype">void</span> OutputUint (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00816     T value, <a class="code" href="group__util.html#ga18">uint</a> radix, <span class="keyword">const</span> <span class="keywordtype">char</span>* prefix = 0)
00817   {
00818     <span class="keyword">const</span> <a class="code" href="group__util.html#ga22">utf32_char</a> letterFirst = currentFormat.uppercase ? <span class="charliteral">'A'</span> : <span class="charliteral">'a'</span>;
00819     <span class="keyword">const</span> size_t scratchOffs = scratch.Length();
00820     size_t insertOffs = scratchOffs;
00821 
00822     <span class="keywordflow">if</span> (prefix != 0)
00823     {
00824       <span class="keywordflow">while</span> (*prefix != 0)
00825       {
00826         <a class="code" href="group__util.html#ga22">utf32_char</a> ch = (value != 0) ? *prefix : <span class="charliteral">' '</span>;
00827         scratch.Push (ch);
00828         insertOffs++;
00829         prefix++;
00830       }
00831     }
00832 
00833     <span class="keywordtype">int</span> width = 0;
00834     <span class="keywordtype">int</span> numDigits = currentFormat.precision;
00835     <span class="keywordflow">if</span> (!((value == 0) &amp;&amp; (numDigits == 0)))
00836     {
00837       <span class="keywordflow">do</span>
00838       {
00839         <a class="code" href="group__util.html#ga18">uint</a> d = value % radix;
00840         <a class="code" href="group__util.html#ga22">utf32_char</a> ch;
00841         <span class="keywordflow">if</span> (d &lt;= 9)
00842           ch = d + <span class="charliteral">'0'</span>;
00843         <span class="keywordflow">else</span>
00844           ch = d - 10 + letterFirst;
00845         scratch.Insert (insertOffs, ch);
00846         width++;
00847         value = value / radix;
00848       }
00849       <span class="keywordflow">while</span> ((value != 0) || (width &lt; numDigits));
00850     }
00851     DoPadding (currentFormat, scratchOffs, insertOffs);
00852     scratch.WriteTo (writer, scratchOffs);
00853     scratch.Truncate (scratchOffs);
00854   }
00855 
00857   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00858   <span class="keywordtype">void</span> OutputFloat (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00859     <span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> <span class="keywordtype">char</span>* type)
00860   {
00861     <span class="keywordtype">char</span> flags[5] = <span class="stringliteral">""</span>;
00862     <span class="keywordflow">if</span> (currentFormat.plusSign)
00863       strcat (flags, <span class="stringliteral">"+"</span>);
00864     <span class="keywordflow">if</span> (currentFormat.spacePrefix)
00865       strcat (flags, <span class="stringliteral">" "</span>);
00866     <span class="keywordflow">if</span> (currentFormat.basePrefix)
00867       strcat (flags, <span class="stringliteral">"#"</span>);
00868     <span class="keywordflow">if</span> (currentFormat.padZero)
00869       strcat (flags, <span class="stringliteral">"0"</span>);
00870     <a class="code" href="cssysdef_8h.html#a4">CS_ALLOC_STACK_ARRAY</a>(<span class="keywordtype">char</span>, precStr, 
00871       (<span class="keyword">sizeof</span>(currentFormat.precision) * 24) / 10 + 3);
00872     <span class="keywordflow">if</span> (currentFormat.precision &gt;= 0)
00873       sprintf (precStr, <span class="stringliteral">".%d"</span>, currentFormat.precision);
00874     <span class="keywordflow">else</span>
00875       precStr[0] = 0;
00876     <a class="code" href="cssysdef_8h.html#a4">CS_ALLOC_STACK_ARRAY</a>(<span class="keywordtype">char</span>, formatStr, 1 + strlen (flags)
00877       + (<span class="keyword">sizeof</span>(currentFormat.width) * 24) / 10 + 2 + strlen (precStr) + 2);
00878     sprintf (formatStr, <span class="stringliteral">"%%%s%d%s%s"</span>, flags, currentFormat.width, precStr,
00879       type);
00880     <span class="keywordtype">char</span> formattedStr[64];
00881     sprintf (formattedStr, formatStr, value);
00882 
00883     <span class="keywordtype">char</span>* p = formattedStr;
00884     <span class="keywordflow">while</span> (*p != 0)
00885       writer.Put (*p++);
00886   }
00887 
00891   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Tbase&gt;
00892   <span class="keyword">struct </span>IEEEFloatMantissa
00893   {
00894     Tbase mantissa[<span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase)];
00895 
00896     Tbase&amp; operator[] (<span class="keywordtype">int</span> index)
00897     { <span class="keywordflow">return</span> mantissa[index]; }
00898     <span class="keywordtype">bool</span> Eq0 ()
00899     {
00900       <span class="keywordflow">for</span> (<a class="code" href="group__util.html#ga18">uint</a> n = 0; n &lt; <span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase); n++)
00901       {
00902         <span class="keywordflow">if</span> (mantissa[n] != 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00903       }
00904       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00905     }
00906     <span class="keyword">const</span> Tbase operator&amp; (Tbase other)<span class="keyword"> const</span>
00907 <span class="keyword">    </span>{ <span class="keywordflow">return</span> mantissa[0] &amp; other; }
00908     IEEEFloatMantissa&amp; operator&lt;&lt;= (<span class="keywordtype">int</span> shift)
00909     { 
00910       <span class="keyword">const</span> <span class="keywordtype">int</span> ovShift = <span class="keyword">sizeof</span>(Tbase) * 8 - shift;
00911       Tbase overflow = 0;
00912       <span class="keywordflow">for</span> (<a class="code" href="group__util.html#ga18">uint</a> n = 0; n &lt; <span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase); n++)
00913       {
00914         Tbase newOverflow = mantissa[n] &gt;&gt; ovShift;
00915         mantissa[n] = (mantissa[n] &lt;&lt; shift) | overflow;
00916         overflow = newOverflow;
00917       }
00918       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00919     }
00920     Tbase&amp; Leftmost ()
00921     { <span class="keywordflow">return</span> mantissa[<span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase)-1]; }
00922   };
00923 
00925   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Tbase&gt;
00926   <span class="keyword">struct </span>IEEEFloatSplitter
00927   {
00928     <span class="keywordtype">bool</span> sign;
00929     Tbase exp;
00930 
00931     CS_FORMATTER_TYPENAME_QUALIFIER
00932     <a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter&lt;Twriter,Treader&gt;</a>::IEEEFloatMantissa&lt;T, Tbase&gt; mantissa;
00933 
00934     IEEEFloatSplitter (<span class="keyword">const</span> T&amp; val, <span class="keyword">const</span> <span class="keywordtype">int</span> mantissaBits,
00935       <span class="keyword">const</span> <span class="keywordtype">int</span> expBits) 
00936     {
00937       <span class="keyword">const</span> <span class="keywordtype">int</span> baseBits = <span class="keyword">sizeof</span>(Tbase) * 8;
00938       <span class="keyword">const</span> <span class="keywordtype">int</span> signBit = mantissaBits + expBits;
00939 
00940       <span class="keyword">union</span>
00941 <span class="keyword">      </span>{
00942         T v;
00943         Tbase vB[<span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase)];
00944       } toBase;
00945       toBase.v = val;
00946 <span class="preprocessor">  #ifdef CS_LITTLE_ENDIAN</span>
00947 <span class="preprocessor"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> hi = (<span class="keyword">sizeof</span> (T) / <span class="keyword">sizeof</span> (Tbase)) - 1;
00948       <span class="keyword">const</span> <span class="keywordtype">int</span> lo = 0;
00949       <span class="keyword">const</span> <span class="keywordtype">int</span> d = 1;
00950 <span class="preprocessor">  #else</span>
00951 <span class="preprocessor"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> hi = 0;
00952       <span class="keyword">const</span> <span class="keywordtype">int</span> lo = (<span class="keyword">sizeof</span> (T) / <span class="keyword">sizeof</span> (Tbase)) - 1;
00953       <span class="keyword">const</span> <span class="keywordtype">int</span> d = -1;
00954 <span class="preprocessor">  #endif</span>
00955 <span class="preprocessor"></span>      sign = toBase.vB[lo + (signBit / baseBits) * d]
00956         &amp; (1 &lt;&lt; (signBit % baseBits));
00957       exp = (toBase.vB[hi] &gt;&gt; (mantissaBits % (baseBits)))
00958         &amp; ((1 &lt;&lt; expBits) - 1);
00959       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = lo, p = 0; n != hi + d; n += d, p++)
00960       {
00961         <span class="keyword">const</span> <span class="keywordtype">int</span> bit = p * baseBits;
00962         <span class="keyword">const</span> Tbase mask = ((bit + baseBits) &lt;= mantissaBits) ? ~0 
00963           : ((1 &lt;&lt; (mantissaBits % baseBits)) - 1);
00964         mantissa[p] = toBase.vB[n] &amp; mask;
00965       }
00966     }
00967   };
00969   <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00970   <span class="keywordtype">void</span> OutputFloatHex (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00971     <span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> <span class="keywordtype">int</span> vMantissaBits, <span class="keyword">const</span> <span class="keywordtype">int</span> expBits, <span class="keyword">const</span> <span class="keywordtype">int</span> bias)
00972   {
00973 <span class="preprocessor">#ifdef CS_IEEE_DOUBLE_FORMAT</span>
00974 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="group__util.html#ga22">utf32_char</a> letterFirst = currentFormat.uppercase ? <span class="charliteral">'A'</span> : <span class="charliteral">'a'</span>;
00975 
00976 <span class="preprocessor">#ifdef CS_PROCESSOR_X86</span>
00977 <span class="preprocessor"></span>    <span class="comment">// @@@ x86 long double uses explicit mantissa MSB</span>
00978     <span class="keyword">const</span> <span class="keywordtype">bool</span> hiddenBit = !(vMantissaBits &gt;= 63);
00979 <span class="preprocessor">#else</span>
00980 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> hiddenBit = <span class="keyword">false</span>;
00981 <span class="preprocessor">#endif</span>
00982 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> mantissaBits = vMantissaBits - (hiddenBit ? 1 : 0);
00983     IEEEFloatSplitter&lt;T, uint&gt; vSplit (value, mantissaBits, expBits);
00984     <span class="keyword">const</span> <a class="code" href="group__util.html#ga18">uint</a> expMax = (1 &lt;&lt; (<span class="keyword">sizeof</span>(T) * 8 - mantissaBits - 1)) - 1;
00985 
00986     <span class="keywordflow">if</span> ((vSplit.exp == expMax) &amp;&amp; vSplit.mantissa.Eq0())
00987     {
00988       <span class="keywordtype">char</span> infStr[5];
00989       <span class="keywordflow">if</span> (vSplit.sign)
00990       {
00991         strcpy (infStr, <span class="stringliteral">"-"</span>);
00992       }
00993       <span class="keywordflow">else</span>
00994       {
00995         <span class="keywordflow">if</span> (currentFormat.plusSign)
00996           strcpy (infStr, <span class="stringliteral">"+"</span>);
00997         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.spacePrefix)
00998           strcpy (infStr, <span class="stringliteral">" "</span>);
00999         <span class="keywordflow">else</span>
01000           strcpy (infStr, <span class="stringliteral">""</span>);
01001       }
01002       strcat (infStr, currentFormat.uppercase ? <span class="stringliteral">"INF"</span> : <span class="stringliteral">"inf"</span>);
01003       OutputString (writer, currentFormat, 
01004         (<a class="code" href="group__util.html#ga20">utf8_char</a>*)infStr);
01005       <span class="keywordflow">return</span>;
01006     }
01007     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((vSplit.exp == expMax) &amp;&amp; !vSplit.mantissa.Eq0())
01008     {
01009       <span class="keywordtype">char</span> nanStr[5];
01010       <span class="keywordflow">if</span> (vSplit.sign)
01011       {
01012         strcpy (nanStr, <span class="stringliteral">"-"</span>);
01013       }
01014       <span class="keywordflow">else</span>
01015       {
01016         <span class="keywordflow">if</span> (currentFormat.plusSign)
01017           strcpy (nanStr, <span class="stringliteral">"+"</span>);
01018         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.spacePrefix)
01019           strcpy (nanStr, <span class="stringliteral">" "</span>);
01020         <span class="keywordflow">else</span>
01021           strcpy (nanStr, <span class="stringliteral">""</span>);
01022       }
01023       strcat (nanStr, currentFormat.uppercase ? <span class="stringliteral">"NAN"</span> : <span class="stringliteral">"nan"</span>);
01024       OutputString (writer, currentFormat, 
01025         (<a class="code" href="group__util.html#ga20">utf8_char</a>*)nanStr);
01026       <span class="keywordflow">return</span>;
01027     }
01028 
01029     <span class="keyword">const</span> size_t scratchOffs = scratch.Length();
01030     <span class="keywordflow">if</span> (vSplit.sign)
01031     {
01032       scratch.Push (<span class="charliteral">'-'</span>);
01033     }
01034     scratch.Push (<span class="charliteral">'0'</span>);
01035     scratch.Push (currentFormat.uppercase ? <span class="charliteral">'X'</span> : <span class="charliteral">'x'</span>);
01036     <span class="keywordflow">if</span> (hiddenBit)
01037     {
01038       <span class="keywordflow">if</span> (vSplit.exp == 0)
01039         scratch.Push (<span class="charliteral">'0'</span>);
01040       <span class="keywordflow">else</span>
01041         scratch.Push (<span class="charliteral">'1'</span>);
01042     }
01043     <span class="keywordflow">else</span>
01044     {
01045       <span class="keyword">const</span> <span class="keywordtype">int</span> bitNum = mantissaBits - 1;
01046       <span class="keyword">const</span> <span class="keywordtype">int</span> baseBits = <span class="keyword">sizeof</span> (uint) * 8;
01047       <span class="keyword">const</span> <span class="keywordtype">int</span> bitIndex = bitNum / baseBits;
01048       scratch.Push (<span class="charliteral">'0'</span> + ((vSplit.mantissa[bitIndex] 
01049         &gt;&gt; (bitNum % baseBits)) &amp; 1));
01050       vSplit.mantissa &lt;&lt;= 1;
01051     }
01052     <span class="keywordflow">if</span> ((currentFormat.precision &gt; 0) || (!vSplit.mantissa.Eq0()))
01053     {
01054       scratch.Push (<span class="charliteral">'.'</span>);
01055       
01056       IEEEFloatMantissa&lt;T, uint&gt; m (vSplit.mantissa);
01057       m &lt;&lt;= <span class="keyword">sizeof</span>(T)*8 - mantissaBits;
01058       <span class="keywordtype">int</span> w = 0;
01059       <span class="keywordflow">do</span>
01060       {
01061         <a class="code" href="group__util.html#ga18">uint</a> d = m.Leftmost() &gt;&gt; ((<span class="keyword">sizeof</span>(uint)*8)-4);
01062         <a class="code" href="group__util.html#ga22">utf32_char</a> ch;
01063         <span class="keywordflow">if</span> (d &lt;= 9)
01064           ch = d + <span class="charliteral">'0'</span>;
01065         <span class="keywordflow">else</span>
01066           ch = d - 10 + letterFirst;
01067         scratch.Push (ch);
01068         m &lt;&lt;= 4;
01069         w++;
01070       }
01071       <span class="keywordflow">while</span> ((w &lt; currentFormat.precision) 
01072         || ((currentFormat.precision &lt;= 0) &amp;&amp; !m.Eq0()));
01073     }
01074     scratch.Push (currentFormat.uppercase ? <span class="charliteral">'P'</span> : <span class="charliteral">'p'</span>);
01075     <span class="keywordtype">int</span> e;
01076     <span class="keywordflow">if</span> ((vSplit.exp == 0) &amp;&amp; vSplit.mantissa.Eq0())
01077       e = 0;
01078     <span class="keywordflow">else</span>
01079       e = (int)vSplit.exp + bias;
01080     <span class="keywordflow">if</span> (e &lt; 0)
01081     {
01082       scratch.Push (<span class="charliteral">'-'</span>);
01083       e = -e;
01084     }
01085     <span class="keywordflow">else</span>
01086       scratch.Push (<span class="charliteral">'+'</span>);
01087     <span class="keyword">const</span> size_t insertOffs = scratch.Length();;
01088     <span class="keywordflow">do</span>
01089     {
01090       <a class="code" href="group__util.html#ga18">uint</a> d = e % 10;
01091       scratch.Insert (insertOffs, d + <span class="charliteral">'0'</span>);
01092       e = e / 10;
01093     }
01094     <span class="keywordflow">while</span> (e != 0);
01095 
01096     DoPadding (currentFormat, scratchOffs, 
01097       vSplit.sign ? scratchOffs + 1 : scratchOffs);
01098     scratch.WriteTo (writer, scratchOffs);
01099     scratch.Truncate (scratchOffs);
01100 <span class="preprocessor">#else</span>
01101 <span class="preprocessor"></span><span class="preprocessor">  #warning Dont know how to hex-format floats for you</span>
01102 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01103 <span class="preprocessor"></span>  }
01104 <span class="keyword">public</span>:
<a name="l01106"></a><a class="code" href="classcsPrintfFormatter.html#a0">01106</a>   <a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter</a> (Treader* reader, va_list args) : reader (*reader)
01107   {
01108     Init (args);
01109   }
<a name="l01111"></a><a class="code" href="classcsPrintfFormatter.html#a1">01111</a>   <a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter</a> (Treader* reader, ...) : reader (*reader)
01112   {
01113     va_list ap;
01114     va_start(ap, reader);
01115     Init (ap);
01116     va_end(ap);
01117   }
<a name="l01119"></a><a class="code" href="classcsPrintfFormatter.html#a2">01119</a>   <span class="keywordtype">void</span> Format (Twriter&amp; writer)
01120   {
01121     reader.Reset();
01122     size_t i = 0;
01123     <a class="code" href="group__util.html#ga22">utf32_char</a> ch;
01124     <span class="keywordflow">while</span> (i &lt; formatSpecs.<a class="code" href="classcsArray.html#a4">Length</a>())
01125     {
01126       <span class="keyword">const</span> FormatSpec&amp; currentFormat = formatSpecs[i];
01127       size_t n;
01128       <span class="keywordflow">for</span> (n = 0; n &lt; currentFormat.copyRun; n++)
01129       {
01130         <span class="keywordflow">if</span> (!reader.GetNext (ch)) <span class="keywordflow">break</span>;
01131         writer.<a class="code" href="classcsArray.html#a14">Put</a> (ch);
01132       }
01133 
01134       <span class="keywordflow">switch</span> (currentFormat.conversion)
01135       {
01136         <span class="keywordflow">case</span> convStr:
01137           {
01138             <span class="keywordflow">if</span> (currentFormat.type == typeLong)
01139               OutputString (writer, currentFormat, 
01140               (<span class="keywordtype">wchar_t</span>*)(params[currentFormat.paramIdx].vPtr));
01141             <span class="keywordflow">else</span>
01142               OutputString (writer, currentFormat, 
01143               (<a class="code" href="group__util.html#ga20">utf8_char</a>*)(params[currentFormat.paramIdx].vPtr));
01144           }
01145           <span class="keywordflow">break</span>;
01146         <span class="keywordflow">case</span> convChar:
01147           {
01148             writer.<a class="code" href="classcsArray.html#a14">Put</a> (params[currentFormat.paramIdx].vInt);
01149           }
01150           <span class="keywordflow">break</span>;
01151         <span class="keywordflow">case</span> convInt:
01152           {
01153             <span class="keyword">const</span> FmtParam&amp; param = params[currentFormat.paramIdx];
01154             <span class="keywordflow">switch</span> (currentFormat.type)
01155             {
01156               <span class="keywordflow">case</span> typeIntmax:
01157                 {
01158                   <a class="code" href="group__util.html#ga11">intmax_t</a> v = param.vIMT;
01159                   OutputInt (writer, currentFormat, v);
01160                 }
01161                 <span class="keywordflow">break</span>;
01162               <span class="keywordflow">case</span> typeLong:
01163                 {
01164                   <span class="keywordtype">long</span> v = param.vLong;
01165                   OutputInt (writer, currentFormat, v);
01166                 }
01167                 <span class="keywordflow">break</span>;
01168               <span class="keywordflow">case</span> typeLongLong:
01169                 {
01170                   <a class="code" href="group__util.html#ga15">longlong</a> v = param.vLL;
01171                   OutputInt (writer, currentFormat, v);
01172                 }
01173                 <span class="keywordflow">break</span>;
01174               <span class="keywordflow">case</span> typePtrDiffT:
01175                 {
01176                   <a class="code" href="group__util.html#ga10">ptrdiff_t</a> v = param.vPDT;
01177                   OutputInt (writer, currentFormat, v);
01178                 }
01179                 <span class="keywordflow">break</span>;
01180               <span class="keywordflow">case</span> typeSizeT:
01181                 {
01182                   size_t v = param.vSzT;
01183                   OutputInt (writer, currentFormat, v);
01184                 }
01185                 <span class="keywordflow">break</span>;
01186               <span class="keywordflow">default</span>:
01187                 {
01188                   <span class="keywordtype">int</span> v = param.vInt;
01189                   OutputInt (writer, currentFormat, v);
01190                 }
01191                 <span class="keywordflow">break</span>;
01192             }
01193           }
01194           <span class="keywordflow">break</span>;
01195         <span class="keywordflow">case</span> convHex:
01196         <span class="keywordflow">case</span> convUint:
01197         <span class="keywordflow">case</span> convOctal:
01198           {
01199             <a class="code" href="group__util.html#ga18">uint</a> uiradix;
01200             <span class="keyword">const</span> <span class="keywordtype">char</span>* prefix;
01201             <span class="keywordflow">if</span> (currentFormat.conversion == convHex)
01202             {
01203               uiradix = 16;
01204               prefix = currentFormat.basePrefix 
01205                 ? (currentFormat.uppercase ? <span class="stringliteral">"0X"</span> : <span class="stringliteral">"0x"</span>) : 0;
01206             }
01207             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.conversion == convOctal)
01208             {
01209               uiradix = 8;
01210               prefix = currentFormat.basePrefix ? <span class="stringliteral">"0"</span> : 0;
01211             }
01212             <span class="keywordflow">else</span>
01213             {
01214               uiradix = 10;
01215               prefix = 0;
01216             }
01217             <span class="keyword">const</span> FmtParam&amp; param = params[currentFormat.paramIdx];
01218             <span class="keywordflow">switch</span> (currentFormat.type)
01219             {
01220               <span class="keywordflow">case</span> typeIntmax:
01221                 {
01222                   <a class="code" href="group__util.html#ga11">intmax_t</a> v = param.vIMT;
01223                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01224                 }
01225                 <span class="keywordflow">break</span>;
01226               <span class="keywordflow">case</span> typeLong:
01227                 {
01228                   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> v = param.vLong;
01229                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01230                 }
01231                 <span class="keywordflow">break</span>;
01232               <span class="keywordflow">case</span> typeLongLong:
01233                 {
01234                   <a class="code" href="group__util.html#ga16">ulonglong</a> v = param.vLL;
01235                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01236                 }
01237                 <span class="keywordflow">break</span>;
01238               <span class="keywordflow">case</span> typePtrDiffT:
01239                 {
01240                   <a class="code" href="group__util.html#ga10">ptrdiff_t</a> v = param.vPDT;
01241                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01242                 }
01243                 <span class="keywordflow">break</span>;
01244               <span class="keywordflow">case</span> typeSizeT:
01245                 {
01246                   size_t v = param.vSzT;
01247                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01248                 }
01249                 <span class="keywordflow">break</span>;
01250               <span class="keywordflow">default</span>:
01251                 {
01252                   <a class="code" href="group__util.html#ga18">uint</a> v = param.vInt;
01253                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01254                 }
01255                 <span class="keywordflow">break</span>;
01256             }
01257           }
01258           <span class="keywordflow">break</span>;
01259         <span class="keywordflow">case</span> convGetNum:
01260           *((<span class="keywordtype">int</span>*)(params[currentFormat.paramIdx].vPtr)) = writer.GetTotal();
01261           <span class="keywordflow">break</span>;
01262         <span class="keywordflow">case</span> convErrno:
01263           OutputString (writer, currentFormat, 
01264             (<a class="code" href="group__util.html#ga20">utf8_char</a>*)strerror (params[currentFormat.paramIdx].vInt));
01265           <span class="keywordflow">break</span>;
01266         <span class="keywordflow">case</span> convPtr:
01267           {
01268             FormatSpec fakeFormat;
01269             fakeFormat.leftJustify = currentFormat.leftJustify;
01270             fakeFormat.precision = <span class="keyword">sizeof</span> (uintptr_t) * 2;
01271             <span class="keywordflow">if</span> (params[currentFormat.paramIdx].vPtr == 0)
01272             {
01273               OutputString (writer, fakeFormat, (<a class="code" href="group__util.html#ga20">utf8_char</a>*)<span class="stringliteral">"(null)"</span>);
01274             }
01275             <span class="keywordflow">else</span>
01276             {
01277               OutputUint (writer, fakeFormat, 
01278                 (<a class="code" href="group__util.html#ga9">uintptr_t</a>)params[currentFormat.paramIdx].vPtr, 16, <span class="stringliteral">"0x"</span>);
01279             }
01280           }
01281           <span class="keywordflow">break</span>;
01282         <span class="keywordflow">case</span> convFloatFix:
01283           {
01284             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01285             {
01286 <span class="preprocessor">#ifdef CS_FORMATTER_NO_LONG_DOUBLE_FORMAT</span>
01287 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01288               (<span class="keywordtype">double</span>)params[currentFormat.paramIdx].vLongDbl, <span class="stringliteral">"f"</span>);
01289 <span class="preprocessor">#else</span>
01290 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01291               params[currentFormat.paramIdx].vLongDbl, <span class="stringliteral">"Lf"</span>);
01292 <span class="preprocessor">#endif</span>
01293 <span class="preprocessor"></span>            }
01294             <span class="keywordflow">else</span>
01295               OutputFloat (writer, currentFormat, 
01296               params[currentFormat.paramIdx].vDbl, <span class="stringliteral">"f"</span>);
01297           }
01298           <span class="keywordflow">break</span>;
01299         <span class="keywordflow">case</span> convFloatExp:
01300           {
01301             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01302             {
01303 <span class="preprocessor">#ifdef CS_FORMATTER_NO_LONG_DOUBLE_FORMAT</span>
01304 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01305               (<span class="keywordtype">double</span>)params[currentFormat.paramIdx].vLongDbl, 
01306               currentFormat.uppercase ? <span class="stringliteral">"E"</span> : <span class="stringliteral">"e"</span>);
01307 <span class="preprocessor">#else</span>
01308 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01309               params[currentFormat.paramIdx].vLongDbl, 
01310               currentFormat.uppercase ? <span class="stringliteral">"LE"</span> : <span class="stringliteral">"Le"</span>);
01311 <span class="preprocessor">#endif</span>
01312 <span class="preprocessor"></span>            }
01313             <span class="keywordflow">else</span>
01314               OutputFloat (writer, currentFormat, 
01315               params[currentFormat.paramIdx].vDbl, 
01316               currentFormat.uppercase ? <span class="stringliteral">"E"</span> : <span class="stringliteral">"e"</span>);
01317           }
01318           <span class="keywordflow">break</span>;
01319         <span class="keywordflow">case</span> convFloatGeneral:
01320           {
01321             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01322             {
01323 <span class="preprocessor">#ifdef CS_FORMATTER_NO_LONG_DOUBLE_FORMAT</span>
01324 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01325               (<span class="keywordtype">double</span>)params[currentFormat.paramIdx].vLongDbl, 
01326               currentFormat.uppercase ? <span class="stringliteral">"G"</span> : <span class="stringliteral">"g"</span>);
01327 <span class="preprocessor">#else</span>
01328 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01329               params[currentFormat.paramIdx].vLongDbl, 
01330               currentFormat.uppercase ? <span class="stringliteral">"LG"</span> : <span class="stringliteral">"Lg"</span>);
01331 <span class="preprocessor">#endif</span>
01332 <span class="preprocessor"></span>            }
01333             <span class="keywordflow">else</span>
01334               OutputFloat (writer, currentFormat, 
01335               params[currentFormat.paramIdx].vDbl, 
01336               currentFormat.uppercase ? <span class="stringliteral">"G"</span> : <span class="stringliteral">"g"</span>);
01337           }
01338           <span class="keywordflow">break</span>;
01339         <span class="keywordflow">case</span> convFloatHex:
01340           {
01341             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01342               OutputFloatHex (writer, currentFormat, 
01343               params[currentFormat.paramIdx].vLongDbl, LDBL_MANT_DIG, 
01344               csLog2 (LDBL_MAX_EXP) + 1, -(LDBL_MAX_EXP - 1));
01345             <span class="keywordflow">else</span>
01346               OutputFloatHex (writer, currentFormat, 
01347               params[currentFormat.paramIdx].vDbl, DBL_MANT_DIG, 
01348               csLog2 (DBL_MAX_EXP) + 1, -(DBL_MAX_EXP - 1));
01349           }
01350           <span class="keywordflow">break</span>;
01351         <span class="keywordflow">default</span>:
01352           <span class="keywordflow">break</span>;
01353       }
01354 
01355       <span class="keywordflow">for</span> (n = 0; n &lt; currentFormat.fmtSkip; n++)
01356       {
01357         <span class="keywordflow">if</span> (!reader.GetNext (ch)) <span class="keywordflow">break</span>;
01358       }
01359       i++;
01360     }
01361     <span class="keywordflow">while</span> (reader.GetNext (ch))
01362       writer.<a class="code" href="classcsArray.html#a14">Put</a> (ch);
01363     writer.<a class="code" href="classcsArray.html#a14">Put</a> (0);
01364   }
01365 };
01366 
01369 <span class="preprocessor">#endif // __CS_CSUTIL_FORMATTER_H__</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.9.1 
</small></address> </div></body> </html>
