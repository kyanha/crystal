<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/formatter.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000022.html">csutil</a></div>
<h1>formatter.h</h1><a href="formatter_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2005 by Jorrit Tyberghein</span>
00003 <span class="comment">              (C) 2005 by Frank Richter</span>
00004 <span class="comment"></span>
00005 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00006 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00007 <span class="comment">    License as published by the Free Software Foundation; either</span>
00008 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00009 <span class="comment"></span>
00010 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00011 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00012 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00013 <span class="comment">    Library General Public License for more details.</span>
00014 <span class="comment"></span>
00015 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00016 <span class="comment">    License along with this library; if not, write to the Free</span>
00017 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00018 <span class="comment">*/</span>
00019 
00020 <span class="preprocessor">#ifndef __CS_CSUTIL_FORMATTER_H__</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define __CS_CSUTIL_FORMATTER_H__</span>
00022 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include "<a class="code" href="csuctransform_8h.html">csutil/csuctransform.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="dirtyaccessarray_8h.html">csutil/dirtyaccessarray.h</a>"</span>
00028 <span class="preprocessor">#include "<a class="code" href="util_8h.html">csutil/util.h</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="math_8h.html">csgeom/math.h</a>"</span>
00030 
00039 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00040"></a><a class="code" href="classcsFmtDefaultReader.html">00040</a> <span class="keyword">class </span><a class="code" href="classcsFmtDefaultReader.html">csFmtDefaultReader</a>
00041 {
00042   <span class="keyword">const</span> T* str;
00043   <span class="keyword">const</span> T* <span class="keyword">const</span> startStr;
00044   size_t len;
00045   <span class="keyword">const</span> size_t startLen;
00046 <span class="keyword">public</span>:
<a name="l00048"></a><a class="code" href="classcsFmtDefaultReader.html#a0">00048</a>   <a class="code" href="classcsFmtDefaultReader.html">csFmtDefaultReader</a> (<span class="keyword">const</span> T* string, size_t length) : startStr (string), 
00049     startLen (length) { Reset(); }
<a name="l00051"></a><a class="code" href="classcsFmtDefaultReader.html#a1">00051</a>   <span class="keywordtype">bool</span> GetNext (utf32_char&amp; ch) 
00052   {
00053     <span class="keywordtype">int</span> n = <a class="code" href="classcsUnicodeTransform.html#z585_3">csUnicodeTransform::Decode</a> (str, len, ch);
00054     <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00055     str += (size_t)n;
00056     len -= (size_t)n;
00057     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00058   }
<a name="l00060"></a><a class="code" href="classcsFmtDefaultReader.html#a2">00060</a>   <span class="keywordtype">void</span> Reset() { str = startStr; len = startLen; }
<a name="l00062"></a><a class="code" href="classcsFmtDefaultReader.html#a3">00062</a>   size_t GetPosition()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> str - startStr; }
00063 };
00064 
00065 
00071 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00072"></a><a class="code" href="classcsFmtDefaultWriter.html">00072</a> <span class="keyword">class </span><a class="code" href="classcsFmtDefaultWriter.html">csFmtDefaultWriter</a>
00073 {
00074   T* dest;
00075   size_t size;
00076   size_t total;
00077 <span class="keyword">public</span>:
<a name="l00079"></a><a class="code" href="classcsFmtDefaultWriter.html#a0">00079</a>   <a class="code" href="classcsFmtDefaultWriter.html">csFmtDefaultWriter</a> (T* dest, size_t size) : dest (dest), size (size), 
00080     total (0) {}
<a name="l00082"></a><a class="code" href="classcsFmtDefaultWriter.html#a1">00082</a>   <span class="keywordtype">void</span> Put (utf32_char ch) 
00083   { 
00084     size_t n = (size_t)<a class="code" href="classcsUnicodeTransform.html#z586_3">csUnicodeTransform::Encode</a> (ch, dest, size);
00085     total += n;
00086     n = <a class="code" href="group__geom__utils.html#ga6">csMin</a> (size, n);
00087     dest += n;
00088     size -= n;
00089   }
<a name="l00094"></a><a class="code" href="classcsFmtDefaultWriter.html#a2">00094</a>   size_t GetTotal()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> total; }
00095 };
00096 
00101 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Twriter, <span class="keyword">class</span> Treader&gt;
<a name="l00102"></a><a class="code" href="classcsPrintfFormatter.html">00102</a> <span class="keyword">class </span><a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter</a>
00103 {
00104   <span class="keyword">class </span>Scratch : <span class="keyword">public</span> <a class="code" href="classcsDirtyAccessArray.html">csDirtyAccessArray</a>&lt;utf32_char&gt;
00105   {
00106   <span class="keyword">public</span>:
00107     <span class="keywordtype">void</span> WriteTo (Twriter&amp; writer, size_t offset = 0, size_t len = (size_t)~0)
00108     {
00109       <span class="keyword">const</span> size_t n = MIN (len, <a class="code" href="classcsArray.html#a4">Length</a>());
00110       <span class="keywordflow">for</span> (size_t i = offset; i &lt; n; i++) writer.Put (Get (i));
00111     }
00112   };
00113   Scratch scratch;
00114 
00116   <span class="keyword">struct </span>FmtParam
00117   {
00118     <span class="keyword">union</span>
00119 <span class="keyword">    </span>{
00120       <span class="keywordtype">int</span> vInt;
00121       <span class="keywordtype">void</span>* vPtr;
00122       <span class="keywordtype">long</span> vLong;
00123       <a class="code" href="group__util.html#ga13">longlong</a> vLL;
00124       <span class="keywordtype">double</span> vDbl;
00125       <span class="keywordtype">long</span> <span class="keywordtype">double</span> vLongDbl;
00126       size_t vSzT;
00127       <a class="code" href="group__util.html#ga10">ptrdiff_t</a> vPDT;
00128       <a class="code" href="group__util.html#ga11">intmax_t</a> vIMT;
00129     };
00130   };
00131   <span class="keyword">enum</span> Conversion
00132   {
00133     convBogus = 0,
00134     convNone,
00135     convInt,
00136     convOctal,
00137     convUint,
00138     convHex,
00139     convFloatFix,
00140     convFloatExp,
00141     convFloatGeneral,
00142     convFloatHex,
00143     convChar,
00144     convStr,
00145     convPtr,
00146     convGetNum,
00147     convErrno
00148   };
00149   <span class="keyword">enum</span> Type
00150   {
00151     typeNone = 0,
00152     typeChar,
00153     typeShort,
00154     typeIntmax,
00155     typeLong,
00156     typeLongLong,
00157     typePtrDiffT,
00158     typeSizeT
00159   };
00161   <span class="keyword">struct </span>FormatSpec
00162   {
00163     size_t copyRun;
00164     size_t fmtSkip;
00165 
00166     <span class="keywordtype">int</span> paramIdx;
00167     <span class="keywordtype">bool</span> leftJustify;
00168     <span class="keywordtype">bool</span> plusSign;
00169     <span class="keywordtype">bool</span> spacePrefix;
00170     <span class="keywordtype">bool</span> basePrefix;
00171     <span class="comment">//bool grouping;</span>
00172     <span class="keywordtype">bool</span> padZero;
00173     <span class="keywordtype">int</span> width;
00174     <span class="keywordtype">int</span> precision;
00175     Conversion conversion;
00176     <span class="keywordtype">bool</span> uppercase;
00177     Type type;
00178 
00179     FormatSpec() { Reset(); }
00180     <span class="keywordtype">void</span> Reset () 
00181     { 
00182       memset (<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span> (*<span class="keyword">this</span>)); 
00183       precision = -1;
00184     }
00185   };
00186   <a class="code" href="classcsArray.html">csArray&lt;FormatSpec&gt;</a> formatSpecs;
00187   <a class="code" href="classcsArray.html">csArray&lt;FmtParam&gt;</a> params;
00188   Treader&amp; reader;
00189 
00190   <span class="keyword">struct </span>SpecParseState
00191   {
00192     <a class="code" href="group__util.html#ga21">utf32_char</a> ch;
00193     FormatSpec currentFormat;
00194     size_t charRun;
00195     <span class="keywordtype">int</span> paramIdx;
00196     size_t fmtBegin;
00197 
00198     SpecParseState() : paramIdx(0) {}
00199     <span class="keywordtype">void</span> Reset()
00200     {
00201       charRun = 0;
00202       currentFormat.Reset();
00203     }
00204   };
00205 
00206   <span class="keywordtype">bool</span> ParseFlag (SpecParseState&amp; state)
00207   {
00208     <span class="keywordflow">switch</span> (state.ch)
00209     {
00210       <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
00211         {
00212           state.currentFormat.leftJustify = <span class="keyword">true</span>;
00213           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00214         }
00215       <span class="keywordflow">case</span> <span class="charliteral">'+'</span>:
00216         {
00217           state.currentFormat.plusSign = <span class="keyword">true</span>;
00218           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00219         }
00220       <span class="keywordflow">case</span> <span class="charliteral">' '</span>:
00221         {
00222           state.currentFormat.spacePrefix = <span class="keyword">true</span>;
00223           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00224         }
00225       <span class="keywordflow">case</span> <span class="charliteral">'#'</span>:
00226         {
00227           state.currentFormat.basePrefix = <span class="keyword">true</span>;
00228           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00229         }
00230       <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
00231         {
00232           state.currentFormat.padZero = <span class="keyword">true</span>;
00233           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00234         }
00235       <span class="keywordflow">case</span> <span class="charliteral">'\''</span>:
00236         {
00237           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00238         }
00239     }
00240     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00241   }
00242   
00243   <span class="keywordtype">bool</span> ParseType (SpecParseState&amp; state)
00244   {
00245     <span class="keywordflow">switch</span> (state.ch)
00246     {
00247       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
00248         {
00249           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00250             state.currentFormat.type = typeShort;
00251           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.currentFormat.type == typeShort)
00252             state.currentFormat.type = typeChar;
00253           <span class="keywordflow">else</span>
00254             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00255           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00256         }
00257       <span class="keywordflow">case</span> <span class="charliteral">'j'</span>:
00258         {
00259           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00260             state.currentFormat.type = typeIntmax;
00261           <span class="keywordflow">else</span>
00262             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00263           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00264         }
00265       <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
00266         {
00267           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00268             state.currentFormat.type = typeLong;
00269           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.currentFormat.type == typeLong)
00270             state.currentFormat.type = typeLongLong;
00271           <span class="keywordflow">else</span>
00272             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00273           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00274         }
00275       <span class="keywordflow">case</span> <span class="charliteral">'L'</span>:
00276       <span class="keywordflow">case</span> <span class="charliteral">'q'</span>:
00277         {
00278           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00279             state.currentFormat.type = typeLongLong;
00280           <span class="keywordflow">else</span>
00281             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00282           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00283         }
00284       <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
00285         {
00286           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00287             state.currentFormat.type = typePtrDiffT;
00288           <span class="keywordflow">else</span>
00289             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00290           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00291         }
00292       <span class="keywordflow">case</span> <span class="charliteral">'z'</span>:
00293         {
00294           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00295             state.currentFormat.type = typeSizeT;
00296           <span class="keywordflow">else</span>
00297             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00298           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00299         }
00300     }
00301     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00302   }
00303 
00304   <span class="keywordtype">bool</span> ParseConversion (SpecParseState&amp; state)
00305   {
00306     <span class="keywordflow">switch</span> (state.ch)
00307     {
00308       <span class="keywordflow">case</span> <span class="charliteral">'%'</span>:
00309         {
00310           <span class="keyword">const</span> size_t fmtLen = (reader.GetPosition() - 1) - state.fmtBegin;
00311           <span class="keywordflow">if</span> (fmtLen == 1)
00312           {
00313             state.currentFormat.conversion = convNone;
00314             state.fmtBegin++;
00315             state.currentFormat.copyRun++;
00316             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00317           }
00318           <span class="keywordflow">break</span>;
00319         }
00320       <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00321       <span class="keywordflow">case</span> <span class="charliteral">'i'</span>:
00322         {
00323           state.currentFormat.conversion = convInt;
00324           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00325         }
00326       <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
00327         {
00328           state.currentFormat.conversion = convOctal;
00329           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00330         }
00331       <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
00332         {
00333           state.currentFormat.conversion = convUint;
00334           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00335         }
00336       <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
00337       <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
00338         {
00339           state.currentFormat.conversion = convHex;
00340           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'X'</span>);
00341           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00342         }
00343       <span class="keywordflow">case</span> <span class="charliteral">'f'</span>:
00344         {
00345           state.currentFormat.conversion = convFloatFix;
00346           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00347         }
00348       <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
00349       <span class="keywordflow">case</span> <span class="charliteral">'E'</span>:
00350         {
00351           state.currentFormat.conversion = convFloatExp;
00352           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'E'</span>);
00353           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00354         }
00355       <span class="keywordflow">case</span> <span class="charliteral">'g'</span>:
00356       <span class="keywordflow">case</span> <span class="charliteral">'G'</span>:
00357         {
00358           state.currentFormat.conversion = convFloatGeneral;
00359           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'G'</span>);
00360           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00361         }
00362       <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
00363       <span class="keywordflow">case</span> <span class="charliteral">'A'</span>:
00364         {
00365           state.currentFormat.conversion = convFloatHex;
00366           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'A'</span>);
00367           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00368         }
00369       <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
00370         {
00371           state.currentFormat.conversion = convChar;
00372           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00373         }
00374       <span class="keywordflow">case</span> <span class="charliteral">'C'</span>:
00375         {
00376           state.currentFormat.conversion = convChar;
00377           state.currentFormat.type = typeLong;
00378           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00379         }
00380       <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
00381         {
00382           state.currentFormat.conversion = convStr;
00383           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00384         }
00385       <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
00386         {
00387           state.currentFormat.conversion = convStr;
00388           state.currentFormat.type = typeLong;
00389           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00390         }
00391       <span class="keywordflow">case</span> <span class="charliteral">'p'</span>:
00392         {
00393           state.currentFormat.conversion = convPtr;
00394           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00395         }
00396       <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
00397         {
00398           state.currentFormat.conversion = convGetNum;
00399           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00400         }
00401       <span class="keywordflow">case</span> <span class="charliteral">'m'</span>:
00402         {
00403           state.currentFormat.conversion = convErrno;
00404           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00405         }
00406     }
00407     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00408   }
00409 
00410   <span class="keywordtype">void</span> ParseSpec ()
00411   {
00412     <span class="keyword">enum</span> {
00413       scanFormat,
00414       formatParamFlagsWidthPrecTypeConversion,
00415       formatFlagsWidthPrecTypeConversion,
00416       formatParamWidth,
00417       formatPrecTypeConversion,
00418       formatTypeConversion
00419     } parseState = scanFormat;
00420 
00421     <span class="comment">// Collect positions of state specifiers from format string</span>
00422     SpecParseState state;
00423     state.Reset();
00424     <span class="keywordflow">while</span> (reader.GetNext (state.ch))
00425     {
00426       <span class="keywordflow">switch</span> (parseState)
00427       {
00428         <span class="keywordflow">case</span> scanFormat:
00429           {
00430             <span class="comment">// Check for a % sign</span>
00431             <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'%'</span>)
00432             {
00433               parseState = formatParamFlagsWidthPrecTypeConversion;
00434               state.fmtBegin = reader.GetPosition() - 1;
00435               state.currentFormat.copyRun = state.charRun;
00436             }
00437             <span class="keywordflow">else</span>
00438               state.charRun++;
00439           }
00440           <span class="keywordflow">break</span>;
00441         <span class="keywordflow">case</span> formatParamFlagsWidthPrecTypeConversion:
00442           <span class="comment">// Check for start of width or param index</span>
00443           <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'1'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00444           {
00445             state.currentFormat.width = state.ch - <span class="charliteral">'0'</span>;
00446             parseState = formatParamWidth;
00447             <span class="keywordflow">break</span>;
00448           }
00449           <span class="comment">// Param delimiter</span>
00450           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'$'</span>)
00451           {
00452             <span class="comment">// @@@ Hmm. Empty param...</span>
00453             parseState = formatFlagsWidthPrecTypeConversion;
00454             <span class="keywordflow">break</span>;
00455           }
00456         <span class="keywordflow">case</span> formatParamWidth:
00457           <span class="keywordflow">if</span> (parseState == formatParamWidth) <span class="comment">// != can occur due fallthrough</span>
00458           {
00459             <span class="comment">// Subsequent digits width or param index</span>
00460             <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'0'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00461             {
00462               state.currentFormat.width *= 10;
00463               state.currentFormat.width += state.ch - <span class="charliteral">'0'</span>;
00464               <span class="keywordflow">break</span>;
00465             }
00466             <span class="comment">// Param delimiter</span>
00467             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'$'</span>)
00468             {
00469               state.paramIdx = state.currentFormat.width - 1;
00470               state.currentFormat.width = 0;
00471               parseState = formatFlagsWidthPrecTypeConversion;
00472               <span class="keywordflow">break</span>;
00473             }
00474           }
00475         <span class="keywordflow">case</span> formatFlagsWidthPrecTypeConversion:
00476           <span class="comment">// Check for start of width</span>
00477           <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'1'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00478           {
00479             state.currentFormat.width *= 10;
00480             state.currentFormat.width += state.ch - <span class="charliteral">'0'</span>;
00481             parseState = formatParamWidth;
00482             <span class="keywordflow">break</span>;
00483           }
00484           <span class="comment">// Check for flags (0, -, ...)</span>
00485           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ParseFlag (state))
00486           {
00487             parseState = formatFlagsWidthPrecTypeConversion;
00488             <span class="keywordflow">break</span>;
00489           }
00490           <span class="comment">// Check for precision delimiter</span>
00491           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'.'</span>)
00492           {
00493             parseState = formatPrecTypeConversion;
00494             state.currentFormat.precision = 0;
00495             <span class="keywordflow">break</span>;
00496           }
00497         <span class="keywordflow">case</span> formatPrecTypeConversion:
00498           <span class="comment">// Precision digits</span>
00499           <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'0'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00500           {
00501             state.currentFormat.precision *= 10;
00502             state.currentFormat.precision += state.ch - <span class="charliteral">'0'</span>;
00503             <span class="keywordflow">break</span>;
00504           }
00505           <span class="comment">// Check for param type modifier (l, h, ...)</span>
00506           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ParseType (state))
00507           {
00508             parseState = formatPrecTypeConversion;
00509             <span class="keywordflow">break</span>;
00510           }
00511         <span class="keywordflow">case</span> formatTypeConversion:
00512           <span class="comment">// Check actual conversion (s, d, ...)</span>
00513           <span class="keywordflow">if</span> (ParseConversion (state))
00514           {
00515             state.currentFormat.fmtSkip = reader.GetPosition() - state.fmtBegin;
00516             <span class="keywordflow">if</span> (state.currentFormat.conversion != convNone)
00517               state.currentFormat.paramIdx = state.paramIdx++;
00518             formatSpecs.<a class="code" href="classcsArray.html#a16">Push</a> (state.currentFormat);
00519 
00520             state.Reset();
00521           }
00522           <span class="keywordflow">else</span>
00523           {
00524             state.charRun += reader.GetPosition() - state.fmtBegin;
00525             state.currentFormat.Reset();
00526           }
00527           parseState = scanFormat;
00528           <span class="keywordflow">break</span>;
00529        }
00530      }
00531    }
00532 
00533    <span class="keywordtype">void</span> FetchParams (va_list args)
00534    {
00535     <span class="comment">// Determine order of params</span>
00536     <span class="keywordflow">for</span> (size_t i = 0; i &lt; formatSpecs.<a class="code" href="classcsArray.html#a4">Length</a>(); i++)
00537     {
00538       <span class="keyword">const</span> FormatSpec&amp; currentFormat = formatSpecs[i];
00539       FmtParam&amp; param = params.<a class="code" href="classcsArray.html#a11">GetExtend</a> (currentFormat.paramIdx);
00540       <span class="keywordflow">switch</span> (currentFormat.conversion)
00541       {
00542         <span class="keywordflow">case</span> convInt:
00543         <span class="keywordflow">case</span> convOctal:
00544         <span class="keywordflow">case</span> convUint:
00545         <span class="keywordflow">case</span> convHex:
00546         <span class="keywordflow">default</span>:
00547           {
00548             <span class="keywordflow">switch</span> (currentFormat.type)
00549             {
00550               <span class="keywordflow">case</span> typeIntmax:
00551                 param.vIMT = va_arg (args, <a class="code" href="group__util.html#ga11">intmax_t</a>);
00552                 <span class="keywordflow">break</span>;
00553               <span class="keywordflow">case</span> typeLong:
00554                 param.vLong = va_arg (args, <span class="keywordtype">long</span>);
00555                 <span class="keywordflow">break</span>;
00556               <span class="keywordflow">case</span> typeLongLong:
00557                 param.vLL = va_arg (args, <a class="code" href="group__util.html#ga13">longlong</a>);
00558                 <span class="keywordflow">break</span>;
00559               <span class="keywordflow">case</span> typePtrDiffT:
00560                 param.vPDT = va_arg (args, <a class="code" href="group__util.html#ga10">ptrdiff_t</a>);
00561                 <span class="keywordflow">break</span>;
00562               <span class="keywordflow">case</span> typeSizeT:
00563                 param.vSzT = va_arg (args, size_t);
00564                 <span class="keywordflow">break</span>;
00565               <span class="keywordflow">case</span> typeShort:
00566                 param.vInt = (short)(va_arg (args, <span class="keywordtype">int</span>));
00567                 <span class="keywordflow">break</span>;
00568               <span class="keywordflow">case</span> typeChar:
00569                 param.vInt = (char)(va_arg (args, <span class="keywordtype">int</span>));
00570                 <span class="keywordflow">break</span>;
00571               <span class="keywordflow">default</span>:
00572                 param.vInt = va_arg (args, <span class="keywordtype">int</span>);
00573                 <span class="keywordflow">break</span>;
00574             }
00575           }
00576           <span class="keywordflow">break</span>;
00577         <span class="keywordflow">case</span> convErrno:
00578           param.vInt = errno;
00579           <span class="keywordflow">break</span>;
00580         <span class="keywordflow">case</span> convChar:
00581           <span class="keywordflow">if</span> (currentFormat.type == typeLong)
00582           {
00583             param.vInt = (wint_t)(va_arg (args, <span class="keywordtype">int</span>));
00584           }
00585           <span class="keywordflow">else</span>
00586           {
00587             param.vInt = (<span class="keywordtype">unsigned</span> char)(va_arg (args, <span class="keywordtype">int</span>));
00588           }
00589           <span class="keywordflow">break</span>;
00590         <span class="keywordflow">case</span> convFloatFix:
00591         <span class="keywordflow">case</span> convFloatExp:
00592         <span class="keywordflow">case</span> convFloatGeneral:
00593         <span class="keywordflow">case</span> convFloatHex:
00594           <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
00595           {
00596             param.vLongDbl = va_arg (args, <span class="keywordtype">long</span> <span class="keywordtype">double</span>);
00597           }
00598           <span class="keywordflow">else</span>
00599           {
00600             param.vDbl = va_arg (args, <span class="keywordtype">double</span>);
00601           }
00602           <span class="keywordflow">break</span>;
00603         <span class="keywordflow">case</span> convStr:
00604         <span class="keywordflow">case</span> convPtr:
00605         <span class="keywordflow">case</span> convGetNum:
00606           param.vPtr = va_arg (args, <span class="keywordtype">void</span>*);
00607           <span class="keywordflow">break</span>;
00608         <span class="keywordflow">case</span> convNone:
00609           <span class="keywordflow">break</span>;
00610       }
00611     }
00612   }
00613 
00614   <span class="keywordtype">void</span> Init (va_list args)
00615   {
00616     ParseSpec ();
00617     FetchParams (args);
00618   }
00619 
00621   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00622   <span class="keywordtype">void</span> OutputString (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00623     <span class="keyword">const</span> T* stringPtr)
00624   {
00625     <span class="keywordflow">if</span> (stringPtr == 0)
00626     {
00627       OutputString (writer, currentFormat, (<a class="code" href="group__util.html#ga19">utf8_char</a>*)<span class="stringliteral">"(nil)"</span>);
00628       <span class="keywordflow">return</span>;
00629     }
00630 
00631     size_t scratchOffs = scratch.Length();
00632     size_t len = 0;
00633     {
00634       <span class="keyword">const</span> T* ptr = stringPtr;
00635       <span class="keywordflow">while</span> (*ptr++ != 0) len++;
00636     }
00637     <span class="keywordflow">while</span> (len &gt; 0)
00638     {
00639       <a class="code" href="group__util.html#ga21">utf32_char</a> ch;
00640       <span class="keywordtype">int</span> n = <a class="code" href="classcsUnicodeTransform.html#z585_3">csUnicodeTransform::Decode</a> (stringPtr, len, ch);
00641       scratch.Push (ch);
00642       stringPtr += n;
00643       len -= (size_t)n;
00644     }
00645     <span class="keywordflow">if</span> (!currentFormat.leftJustify 
00646       &amp;&amp; ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs)))
00647     {
00648       size_t d = (size_t)currentFormat.width - scratch.Length() + scratchOffs;
00649       <span class="keywordflow">while</span> (d-- &gt; 0) writer.Put (<span class="charliteral">' '</span>);
00650     }
00651     scratch.WriteTo (writer, scratchOffs);
00652     <span class="keywordflow">if</span> (currentFormat.leftJustify 
00653       &amp;&amp; ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs)))
00654     {
00655       size_t d = (size_t)currentFormat.width - scratch.Length() + scratchOffs;
00656       <span class="keywordflow">while</span> (d-- &gt; 0) writer.Put (<span class="charliteral">' '</span>);
00657     }
00658     scratch.Truncate (scratchOffs);
00659   }
00660 
00662   <span class="keywordtype">void</span> DoPadding (<span class="keyword">const</span> FormatSpec&amp; currentFormat, <span class="keyword">const</span> size_t scratchOffs,
00663     <span class="keyword">const</span> size_t insert0offs)
00664   {
00665     <span class="keywordflow">if</span> (currentFormat.leftJustify)
00666     {
00667       <span class="keywordflow">while</span> ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs))
00668       {
00669         scratch.Push (<span class="charliteral">' '</span>);
00670       }
00671     }
00672     <span class="keywordflow">else</span>
00673     {
00674       <span class="keywordflow">if</span> (currentFormat.padZero)
00675       {
00676         <span class="keywordflow">while</span> ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs))
00677         {
00678           scratch.Insert (insert0offs, <span class="charliteral">'0'</span>);
00679         }
00680       }
00681       <span class="keywordflow">else</span>
00682       {
00683         <span class="keywordflow">while</span> ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs))
00684         {
00685           scratch.Insert (scratchOffs, <span class="charliteral">' '</span>);
00686         }
00687       }
00688     }
00689   }
00690 
00692   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00693   <span class="keywordtype">void</span> OutputInt (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat, T value)
00694   {
00695     <span class="keyword">const</span> size_t scratchOffs = scratch.Length();
00696     size_t insertOffs = scratchOffs;
00697 
00698     <span class="keywordflow">if</span> (value &lt; 0)
00699     {
00700       scratch.Push (<span class="charliteral">'-'</span>);
00701       insertOffs++;
00702       value = -value;
00703     }
00704     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.plusSign)
00705     {
00706       scratch.Push (<span class="charliteral">'+'</span>);
00707       insertOffs++;
00708     }
00709     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.spacePrefix)
00710     {
00711       scratch.Push (<span class="charliteral">' '</span>);
00712       insertOffs++;
00713     }
00714 
00715     <span class="keywordtype">int</span> width = 0;
00716     <span class="keywordtype">int</span> numDigits = currentFormat.precision;
00717     <span class="keywordflow">if</span> (!((value == 0) &amp;&amp; (numDigits == 0)))
00718     {
00719       <span class="keywordflow">do</span>
00720       {
00721         <span class="keywordtype">int</span> d = value % 10;
00722         scratch.Insert (insertOffs, d + <span class="charliteral">'0'</span>);
00723         width++;
00724         value = value / 10;
00725       }
00726       <span class="keywordflow">while</span> ((value != 0) || (width &lt; numDigits));
00727     }
00728     DoPadding (currentFormat, scratchOffs, insertOffs);
00729     scratch.WriteTo (writer, scratchOffs);
00730     scratch.Truncate (scratchOffs);
00731   }
00732 
00734   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00735   <span class="keywordtype">void</span> OutputUint (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00736     T value, <a class="code" href="group__util.html#ga16">uint</a> radix, <span class="keyword">const</span> <span class="keywordtype">char</span>* prefix = 0)
00737   {
00738     <span class="keyword">const</span> <a class="code" href="group__util.html#ga21">utf32_char</a> letterFirst = currentFormat.uppercase ? <span class="charliteral">'A'</span> : <span class="charliteral">'a'</span>;
00739     <span class="keyword">const</span> size_t scratchOffs = scratch.Length();
00740     size_t insertOffs = scratchOffs;
00741 
00742     <span class="keywordflow">if</span> (prefix != 0)
00743     {
00744       <span class="keywordflow">while</span> (*prefix != 0)
00745       {
00746         <a class="code" href="group__util.html#ga21">utf32_char</a> ch = (value != 0) ? *prefix : <span class="charliteral">' '</span>;
00747         scratch.Push (ch);
00748         insertOffs++;
00749         prefix++;
00750       }
00751     }
00752 
00753     <span class="keywordtype">int</span> width = 0;
00754     <span class="keywordtype">int</span> numDigits = currentFormat.precision;
00755     <span class="keywordflow">if</span> (!((value == 0) &amp;&amp; (numDigits == 0)))
00756     {
00757       <span class="keywordflow">do</span>
00758       {
00759         <a class="code" href="group__util.html#ga16">uint</a> d = value % radix;
00760         <a class="code" href="group__util.html#ga21">utf32_char</a> ch;
00761         <span class="keywordflow">if</span> (d &lt;= 9)
00762           ch = d + <span class="charliteral">'0'</span>;
00763         <span class="keywordflow">else</span>
00764           ch = d - 10 + letterFirst;
00765         scratch.Insert (insertOffs, ch);
00766         width++;
00767         value = value / radix;
00768       }
00769       <span class="keywordflow">while</span> ((value != 0) || (width &lt; numDigits));
00770     }
00771     DoPadding (currentFormat, scratchOffs, insertOffs);
00772     scratch.WriteTo (writer, scratchOffs);
00773     scratch.Truncate (scratchOffs);
00774   }
00775 
00777   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00778   <span class="keywordtype">void</span> OutputFloat (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00779     <span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> <span class="keywordtype">char</span>* type)
00780   {
00781     <span class="keywordtype">char</span> flags[5] = <span class="stringliteral">""</span>;
00782     <span class="keywordflow">if</span> (currentFormat.plusSign)
00783       strcat (flags, <span class="stringliteral">"+"</span>);
00784     <span class="keywordflow">if</span> (currentFormat.spacePrefix)
00785       strcat (flags, <span class="stringliteral">" "</span>);
00786     <span class="keywordflow">if</span> (currentFormat.basePrefix)
00787       strcat (flags, <span class="stringliteral">"#"</span>);
00788     <span class="keywordflow">if</span> (currentFormat.padZero)
00789       strcat (flags, <span class="stringliteral">"0"</span>);
00790     <a class="code" href="cssysdef_8h.html#a4">CS_ALLOC_STACK_ARRAY</a>(<span class="keywordtype">char</span>, precStr, 
00791       (<span class="keyword">sizeof</span>(currentFormat.precision) * 24) / 10 + 3);
00792     <span class="keywordflow">if</span> (currentFormat.precision &gt;= 0)
00793       sprintf (precStr, <span class="stringliteral">".%d"</span>, currentFormat.precision);
00794     <span class="keywordflow">else</span>
00795       precStr[0] = 0;
00796     <a class="code" href="cssysdef_8h.html#a4">CS_ALLOC_STACK_ARRAY</a>(<span class="keywordtype">char</span>, formatStr, 1 + strlen (flags)
00797       + (<span class="keyword">sizeof</span>(currentFormat.width) * 24) / 10 + 2 + strlen (precStr) + 2);
00798     sprintf (formatStr, <span class="stringliteral">"%%%s%d%s%s"</span>, flags, currentFormat.width, precStr,
00799       type);
00800     <span class="keywordtype">char</span> formattedStr[64];
00801     sprintf (formattedStr, formatStr, value);
00802 
00803     <span class="keywordtype">char</span>* p = formattedStr;
00804     <span class="keywordflow">while</span> (*p != 0)
00805       writer.Put (*p++);
00806   }
00807 
00811   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Tbase&gt;
00812   <span class="keyword">struct </span>IEEEFloatMantissa
00813   {
00814     Tbase mantissa[<span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase)];
00815 
00816     Tbase&amp; operator[] (<span class="keywordtype">int</span> index)
00817     { <span class="keywordflow">return</span> mantissa[index]; }
00818     <span class="keywordtype">bool</span> Eq0 ()
00819     {
00820       <span class="keywordflow">for</span> (<a class="code" href="group__util.html#ga16">uint</a> n = 0; n &lt; <span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase); n++)
00821       {
00822         <span class="keywordflow">if</span> (mantissa[n] != 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00823       }
00824       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00825     }
00826     <span class="keyword">const</span> Tbase operator&amp; (Tbase other)<span class="keyword"> const</span>
00827 <span class="keyword">    </span>{ <span class="keywordflow">return</span> mantissa[0] &amp; other; }
00828     IEEEFloatMantissa&amp; operator&lt;&lt;= (<span class="keywordtype">int</span> shift)
00829     { 
00830       <span class="keyword">const</span> <span class="keywordtype">int</span> ovShift = <span class="keyword">sizeof</span>(Tbase) * 8 - shift;
00831       Tbase overflow = 0;
00832       <span class="keywordflow">for</span> (<a class="code" href="group__util.html#ga16">uint</a> n = 0; n &lt; <span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase); n++)
00833       {
00834         Tbase newOverflow = mantissa[n] &gt;&gt; ovShift;
00835         mantissa[n] = (mantissa[n] &lt;&lt; shift) | overflow;
00836         overflow = newOverflow;
00837       }
00838       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00839     }
00840     Tbase&amp; Leftmost ()
00841     { <span class="keywordflow">return</span> mantissa[<span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase)-1]; }
00842   };
00843 
00845   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Tbase&gt;
00846   <span class="keyword">struct </span>IEEEFloatSplitter
00847   {
00848     <span class="keywordtype">bool</span> sign;
00849     Tbase exp;
00850 
00851     IEEEFloatMantissa&lt;T, Tbase&gt; mantissa;
00852 
00853     IEEEFloatSplitter (<span class="keyword">const</span> T&amp; val, <span class="keyword">const</span> <span class="keywordtype">int</span> mantissaBits,
00854       <span class="keyword">const</span> <span class="keywordtype">int</span> expBits) 
00855     {
00856       <span class="keyword">const</span> <span class="keywordtype">int</span> baseBits = <span class="keyword">sizeof</span>(Tbase) * 8;
00857       <span class="keyword">const</span> <span class="keywordtype">int</span> signBit = mantissaBits + expBits;
00858 
00859       <span class="keyword">union</span>
00860 <span class="keyword">      </span>{
00861         T v;
00862         Tbase vB[<span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase)];
00863       } toBase;
00864       toBase.v = val;
00865 <span class="preprocessor">  #ifdef CS_LITTLE_ENDIAN</span>
00866 <span class="preprocessor"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> hi = (<span class="keyword">sizeof</span> (T) / <span class="keyword">sizeof</span> (Tbase)) - 1;
00867       <span class="keyword">const</span> <span class="keywordtype">int</span> lo = 0;
00868       <span class="keyword">const</span> <span class="keywordtype">int</span> d = 1;
00869 <span class="preprocessor">  #else</span>
00870 <span class="preprocessor"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> hi = 0;
00871       <span class="keyword">const</span> <span class="keywordtype">int</span> lo = (<span class="keyword">sizeof</span> (T) / <span class="keyword">sizeof</span> (Tbase)) - 1;
00872       <span class="keyword">const</span> <span class="keywordtype">int</span> d = -1;
00873 <span class="preprocessor">  #endif</span>
00874 <span class="preprocessor"></span>      sign = toBase.vB[lo + (signBit / baseBits) * d]
00875         &amp; (1 &lt;&lt; (signBit % baseBits));
00876       exp = (toBase.vB[hi] &gt;&gt; (mantissaBits % (baseBits)))
00877         &amp; ((1 &lt;&lt; expBits) - 1);
00878       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = lo, p = 0; n != hi + d; n += d, p++)
00879       {
00880         <span class="keyword">const</span> <span class="keywordtype">int</span> bit = p * baseBits;
00881         <span class="keyword">const</span> Tbase mask = ((bit + baseBits) &lt;= mantissaBits) ? ~0 
00882           : ((1 &lt;&lt; (mantissaBits % baseBits)) - 1);
00883         mantissa[p] = toBase.vB[n] &amp; mask;
00884       }
00885     }
00886   };
00888   <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00889   <span class="keywordtype">void</span> OutputFloatHex (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00890     <span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> <span class="keywordtype">int</span> vMantissaBits, <span class="keyword">const</span> <span class="keywordtype">int</span> expBits, <span class="keyword">const</span> <span class="keywordtype">int</span> bias)
00891   {
00892     <span class="keyword">const</span> <a class="code" href="group__util.html#ga21">utf32_char</a> letterFirst = currentFormat.uppercase ? <span class="charliteral">'A'</span> : <span class="charliteral">'a'</span>;
00893 
00894 <span class="preprocessor">#ifdef CS_IEEE_DOUBLE_FORMAT</span>
00895 <span class="preprocessor"></span><span class="preprocessor">#ifdef CS_PROCESSOR_X86</span>
00896 <span class="preprocessor"></span>    <span class="comment">// @@@ x86 long double uses explicit mantissa MSB</span>
00897     <span class="keyword">const</span> <span class="keywordtype">bool</span> hiddenBit = !(vMantissaBits &gt;= 63);
00898 <span class="preprocessor">#else</span>
00899 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> hiddenBit = <span class="keyword">false</span>;
00900 <span class="preprocessor">#endif</span>
00901 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> mantissaBits = vMantissaBits - (hiddenBit ? 1 : 0);
00902     IEEEFloatSplitter&lt;T, uint&gt; vSplit (value, mantissaBits, expBits);
00903     <span class="keyword">const</span> <a class="code" href="group__util.html#ga16">uint</a> expMax = (1 &lt;&lt; (<span class="keyword">sizeof</span>(T) * 8 - mantissaBits - 1)) - 1;
00904 
00905     <span class="keywordflow">if</span> ((vSplit.exp == expMax) &amp;&amp; vSplit.mantissa.Eq0())
00906     {
00907       <span class="keywordtype">char</span> infStr[5];
00908       <span class="keywordflow">if</span> (vSplit.sign)
00909       {
00910         strcpy (infStr, <span class="stringliteral">"-"</span>);
00911       }
00912       <span class="keywordflow">else</span>
00913       {
00914         <span class="keywordflow">if</span> (currentFormat.plusSign)
00915           strcpy (infStr, <span class="stringliteral">"+"</span>);
00916         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.spacePrefix)
00917           strcpy (infStr, <span class="stringliteral">" "</span>);
00918         <span class="keywordflow">else</span>
00919           strcpy (infStr, <span class="stringliteral">""</span>);
00920       }
00921       strcat (infStr, currentFormat.uppercase ? <span class="stringliteral">"INF"</span> : <span class="stringliteral">"inf"</span>);
00922       OutputString (writer, currentFormat, 
00923         (<a class="code" href="group__util.html#ga19">utf8_char</a>*)infStr);
00924       <span class="keywordflow">return</span>;
00925     }
00926     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((vSplit.exp == expMax) &amp;&amp; !vSplit.mantissa.Eq0())
00927     {
00928       <span class="keywordtype">char</span> nanStr[5];
00929       <span class="keywordflow">if</span> (vSplit.sign)
00930       {
00931         strcpy (nanStr, <span class="stringliteral">"-"</span>);
00932       }
00933       <span class="keywordflow">else</span>
00934       {
00935         <span class="keywordflow">if</span> (currentFormat.plusSign)
00936           strcpy (nanStr, <span class="stringliteral">"+"</span>);
00937         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.spacePrefix)
00938           strcpy (nanStr, <span class="stringliteral">" "</span>);
00939         <span class="keywordflow">else</span>
00940           strcpy (nanStr, <span class="stringliteral">""</span>);
00941       }
00942       strcat (nanStr, currentFormat.uppercase ? <span class="stringliteral">"NAN"</span> : <span class="stringliteral">"nan"</span>);
00943       OutputString (writer, currentFormat, 
00944         (<a class="code" href="group__util.html#ga19">utf8_char</a>*)nanStr);
00945       <span class="keywordflow">return</span>;
00946     }
00947 
00948     <span class="keyword">const</span> size_t scratchOffs = scratch.Length();
00949     <span class="keywordflow">if</span> (vSplit.sign)
00950     {
00951       scratch.Push (<span class="charliteral">'-'</span>);
00952     }
00953     scratch.Push (<span class="charliteral">'0'</span>);
00954     scratch.Push (currentFormat.uppercase ? <span class="charliteral">'X'</span> : <span class="charliteral">'x'</span>);
00955     <span class="keywordflow">if</span> (hiddenBit)
00956     {
00957       <span class="keywordflow">if</span> (vSplit.exp == 0)
00958         scratch.Push (<span class="charliteral">'0'</span>);
00959       <span class="keywordflow">else</span>
00960         scratch.Push (<span class="charliteral">'1'</span>);
00961     }
00962     <span class="keywordflow">else</span>
00963     {
00964       <span class="keyword">const</span> <span class="keywordtype">int</span> bitNum = mantissaBits - 1;
00965       <span class="keyword">const</span> <span class="keywordtype">int</span> baseBits = <span class="keyword">sizeof</span> (uint) * 8;
00966       <span class="keyword">const</span> <span class="keywordtype">int</span> bitIndex = bitNum / baseBits;
00967       scratch.Push (<span class="charliteral">'0'</span> + ((vSplit.mantissa[bitIndex] 
00968         &gt;&gt; (bitNum % baseBits)) &amp; 1));
00969       vSplit.mantissa &lt;&lt;= 1;
00970     }
00971     <span class="keywordflow">if</span> ((currentFormat.precision &gt; 0) || (!vSplit.mantissa.Eq0()))
00972     {
00973       scratch.Push (<span class="charliteral">'.'</span>);
00974       
00975       IEEEFloatMantissa&lt;T, uint&gt; m (vSplit.mantissa);
00976       m &lt;&lt;= <span class="keyword">sizeof</span>(T)*8 - mantissaBits;
00977       <span class="keywordtype">int</span> w = 0;
00978       <span class="keywordflow">do</span>
00979       {
00980         <a class="code" href="group__util.html#ga16">uint</a> d = m.Leftmost() &gt;&gt; ((<span class="keyword">sizeof</span>(uint)*8)-4);
00981         <a class="code" href="group__util.html#ga21">utf32_char</a> ch;
00982         <span class="keywordflow">if</span> (d &lt;= 9)
00983           ch = d + <span class="charliteral">'0'</span>;
00984         <span class="keywordflow">else</span>
00985           ch = d - 10 + letterFirst;
00986         scratch.Push (ch);
00987         m &lt;&lt;= 4;
00988         w++;
00989       }
00990       <span class="keywordflow">while</span> ((w &lt; currentFormat.precision) 
00991         || ((currentFormat.precision &lt;= 0) &amp;&amp; !m.Eq0()));
00992     }
00993     scratch.Push (currentFormat.uppercase ? <span class="charliteral">'P'</span> : <span class="charliteral">'p'</span>);
00994     <span class="keywordtype">int</span> e;
00995     <span class="keywordflow">if</span> ((vSplit.exp == 0) &amp;&amp; vSplit.mantissa.Eq0())
00996       e = 0;
00997     <span class="keywordflow">else</span>
00998       e = (int)vSplit.exp + bias;
00999     <span class="keywordflow">if</span> (e &lt; 0)
01000     {
01001       scratch.Push (<span class="charliteral">'-'</span>);
01002       e = -e;
01003     }
01004     <span class="keywordflow">else</span>
01005       scratch.Push (<span class="charliteral">'+'</span>);
01006     <span class="keyword">const</span> size_t insertOffs = scratch.Length();;
01007     <span class="keywordflow">do</span>
01008     {
01009       <a class="code" href="group__util.html#ga16">uint</a> d = e % 10;
01010       scratch.Insert (insertOffs, d + <span class="charliteral">'0'</span>);
01011       e = e / 10;
01012     }
01013     <span class="keywordflow">while</span> (e != 0);
01014 
01015     DoPadding (currentFormat, scratchOffs, 
01016       vSplit.sign ? scratchOffs + 1 : scratchOffs);
01017     scratch.WriteTo (writer, scratchOffs);
01018     scratch.Truncate (scratchOffs);
01019 <span class="preprocessor">#else</span>
01020 <span class="preprocessor"></span><span class="preprocessor">  #warning Dont know how to hex-format floats for you</span>
01021 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01022 <span class="preprocessor"></span>  }
01023 <span class="keyword">public</span>:
<a name="l01025"></a><a class="code" href="classcsPrintfFormatter.html#a0">01025</a>   <a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter</a> (Treader* reader, va_list args) : reader (*reader)
01026   {
01027     Init (args);
01028   }
<a name="l01030"></a><a class="code" href="classcsPrintfFormatter.html#a1">01030</a>   <a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter</a> (Treader* reader, ...) : reader (*reader)
01031   {
01032     va_list ap;
01033     va_start(ap, reader);
01034     Init (ap);
01035     va_end(ap);
01036   }
<a name="l01038"></a><a class="code" href="classcsPrintfFormatter.html#a2">01038</a>   <span class="keywordtype">void</span> Format (Twriter&amp; writer)
01039   {
01040     reader.Reset();
01041     size_t i = 0;
01042     <a class="code" href="group__util.html#ga21">utf32_char</a> ch;
01043     <span class="keywordflow">while</span> (i &lt; formatSpecs.<a class="code" href="classcsArray.html#a4">Length</a>())
01044     {
01045       <span class="keyword">const</span> FormatSpec&amp; currentFormat = formatSpecs[i];
01046       size_t n;
01047       <span class="keywordflow">for</span> (n = 0; n &lt; currentFormat.copyRun; n++)
01048       {
01049         <span class="keywordflow">if</span> (!reader.GetNext (ch)) <span class="keywordflow">break</span>;
01050         writer.<a class="code" href="classcsArray.html#a14">Put</a> (ch);
01051       }
01052 
01053       <span class="keywordflow">switch</span> (currentFormat.conversion)
01054       {
01055         <span class="keywordflow">case</span> convStr:
01056           {
01057             <span class="keywordflow">if</span> (currentFormat.type == typeLong)
01058               OutputString (writer, currentFormat, 
01059               (<span class="keywordtype">wchar_t</span>*)(params[currentFormat.paramIdx].vPtr));
01060             <span class="keywordflow">else</span>
01061               OutputString (writer, currentFormat, 
01062               (<a class="code" href="group__util.html#ga19">utf8_char</a>*)(params[currentFormat.paramIdx].vPtr));
01063           }
01064           <span class="keywordflow">break</span>;
01065         <span class="keywordflow">case</span> convChar:
01066           {
01067             writer.<a class="code" href="classcsArray.html#a14">Put</a> (params[currentFormat.paramIdx].vInt);
01068           }
01069           <span class="keywordflow">break</span>;
01070         <span class="keywordflow">case</span> convInt:
01071           {
01072             <span class="keyword">const</span> FmtParam&amp; param = params[currentFormat.paramIdx];
01073             <span class="keywordflow">switch</span> (currentFormat.type)
01074             {
01075               <span class="keywordflow">case</span> typeIntmax:
01076                 {
01077                   <a class="code" href="group__util.html#ga11">intmax_t</a> v = param.vIMT;
01078                   OutputInt (writer, currentFormat, v);
01079                 }
01080                 <span class="keywordflow">break</span>;
01081               <span class="keywordflow">case</span> typeLong:
01082                 {
01083                   <span class="keywordtype">long</span> v = param.vLong;
01084                   OutputInt (writer, currentFormat, v);
01085                 }
01086                 <span class="keywordflow">break</span>;
01087               <span class="keywordflow">case</span> typeLongLong:
01088                 {
01089                   <a class="code" href="group__util.html#ga13">longlong</a> v = param.vLL;
01090                   OutputInt (writer, currentFormat, v);
01091                 }
01092                 <span class="keywordflow">break</span>;
01093               <span class="keywordflow">case</span> typePtrDiffT:
01094                 {
01095                   <a class="code" href="group__util.html#ga10">ptrdiff_t</a> v = param.vPDT;
01096                   OutputInt (writer, currentFormat, v);
01097                 }
01098                 <span class="keywordflow">break</span>;
01099               <span class="keywordflow">case</span> typeSizeT:
01100                 {
01101                   size_t v = param.vSzT;
01102                   OutputInt (writer, currentFormat, v);
01103                 }
01104                 <span class="keywordflow">break</span>;
01105               <span class="keywordflow">default</span>:
01106                 {
01107                   <span class="keywordtype">int</span> v = param.vInt;
01108                   OutputInt (writer, currentFormat, v);
01109                 }
01110                 <span class="keywordflow">break</span>;
01111             }
01112           }
01113           <span class="keywordflow">break</span>;
01114         <span class="keywordflow">case</span> convHex:
01115         <span class="keywordflow">case</span> convUint:
01116         <span class="keywordflow">case</span> convOctal:
01117           {
01118             <a class="code" href="group__util.html#ga16">uint</a> uiradix;
01119             <span class="keyword">const</span> <span class="keywordtype">char</span>* prefix;
01120             <span class="keywordflow">if</span> (currentFormat.conversion == convHex)
01121             {
01122               uiradix = 16;
01123               prefix = currentFormat.basePrefix 
01124                 ? (currentFormat.uppercase ? <span class="stringliteral">"0X"</span> : <span class="stringliteral">"0x"</span>) : 0;
01125             }
01126             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.conversion == convOctal)
01127             {
01128               uiradix = 8;
01129               prefix = currentFormat.basePrefix ? <span class="stringliteral">"0"</span> : 0;
01130             }
01131             <span class="keywordflow">else</span>
01132             {
01133               uiradix = 10;
01134               prefix = 0;
01135             }
01136             <span class="keyword">const</span> FmtParam&amp; param = params[currentFormat.paramIdx];
01137             <span class="keywordflow">switch</span> (currentFormat.type)
01138             {
01139               <span class="keywordflow">case</span> typeIntmax:
01140                 {
01141                   <a class="code" href="group__util.html#ga11">intmax_t</a> v = param.vIMT;
01142                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01143                 }
01144                 <span class="keywordflow">break</span>;
01145               <span class="keywordflow">case</span> typeLong:
01146                 {
01147                   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> v = param.vLong;
01148                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01149                 }
01150                 <span class="keywordflow">break</span>;
01151               <span class="keywordflow">case</span> typeLongLong:
01152                 {
01153                   <a class="code" href="group__util.html#ga14">ulonglong</a> v = param.vLL;
01154                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01155                 }
01156                 <span class="keywordflow">break</span>;
01157               <span class="keywordflow">case</span> typePtrDiffT:
01158                 {
01159                   <a class="code" href="group__util.html#ga10">ptrdiff_t</a> v = param.vPDT;
01160                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01161                 }
01162                 <span class="keywordflow">break</span>;
01163               <span class="keywordflow">case</span> typeSizeT:
01164                 {
01165                   size_t v = param.vSzT;
01166                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01167                 }
01168                 <span class="keywordflow">break</span>;
01169               <span class="keywordflow">default</span>:
01170                 {
01171                   <a class="code" href="group__util.html#ga16">uint</a> v = param.vInt;
01172                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01173                 }
01174                 <span class="keywordflow">break</span>;
01175             }
01176           }
01177           <span class="keywordflow">break</span>;
01178         <span class="keywordflow">case</span> convGetNum:
01179           *((<span class="keywordtype">int</span>*)(params[currentFormat.paramIdx].vPtr)) = writer.GetTotal();
01180           <span class="keywordflow">break</span>;
01181         <span class="keywordflow">case</span> convErrno:
01182           OutputString (writer, currentFormat, 
01183             (<a class="code" href="group__util.html#ga19">utf8_char</a>*)strerror (params[currentFormat.paramIdx].vInt));
01184           <span class="keywordflow">break</span>;
01185         <span class="keywordflow">case</span> convPtr:
01186           {
01187             FormatSpec fakeFormat;
01188             fakeFormat.leftJustify = currentFormat.leftJustify;
01189             fakeFormat.precision = <span class="keyword">sizeof</span> (uintptr_t) * 2;
01190             <span class="keywordflow">if</span> (params[currentFormat.paramIdx].vPtr == 0)
01191             {
01192               OutputString (writer, fakeFormat, (<a class="code" href="group__util.html#ga19">utf8_char</a>*)<span class="stringliteral">"(null)"</span>);
01193             }
01194             <span class="keywordflow">else</span>
01195             {
01196               OutputUint (writer, fakeFormat, 
01197                 (<a class="code" href="group__util.html#ga9">uintptr_t</a>)params[currentFormat.paramIdx].vPtr, 16, <span class="stringliteral">"0x"</span>);
01198             }
01199           }
01200           <span class="keywordflow">break</span>;
01201         <span class="keywordflow">case</span> convFloatFix:
01202           {
01203             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01204             {
01205 <span class="preprocessor">#if defined(__MINGW32__) || defined(CS_COMPILER_MSVC)</span>
01206 <span class="preprocessor"></span>              <span class="comment">// @@@ MinGW uses MS CRT, but it can't grok long double.</span>
01207               <span class="comment">// VC doesn't have long double, but CRT printf() doesn't know</span>
01208               <span class="comment">// %Lf either.</span>
01209               OutputFloat (writer, currentFormat, 
01210               (<span class="keywordtype">double</span>)params[currentFormat.paramIdx].vLongDbl, <span class="stringliteral">"f"</span>);
01211 <span class="preprocessor">#else</span>
01212 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01213               params[currentFormat.paramIdx].vLongDbl, <span class="stringliteral">"Lf"</span>);
01214 <span class="preprocessor">#endif</span>
01215 <span class="preprocessor"></span>            }
01216             <span class="keywordflow">else</span>
01217               OutputFloat (writer, currentFormat, 
01218               params[currentFormat.paramIdx].vDbl, <span class="stringliteral">"f"</span>);
01219           }
01220           <span class="keywordflow">break</span>;
01221         <span class="keywordflow">case</span> convFloatExp:
01222           {
01223             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01224             {
01225 <span class="preprocessor">#if defined(__MINGW32__) || defined(CS_COMPILER_MSVC)</span>
01226 <span class="preprocessor"></span>              <span class="comment">// @@@ MinGW uses MS CRT, but it can't grok long double.</span>
01227               <span class="comment">// VC doesn't have long double, but CRT printf() doesn't know</span>
01228               <span class="comment">// %Le either.</span>
01229               OutputFloat (writer, currentFormat, 
01230               (<span class="keywordtype">double</span>)params[currentFormat.paramIdx].vLongDbl, 
01231               currentFormat.uppercase ? <span class="stringliteral">"E"</span> : <span class="stringliteral">"e"</span>);
01232 <span class="preprocessor">#else</span>
01233 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01234               params[currentFormat.paramIdx].vLongDbl, 
01235               currentFormat.uppercase ? <span class="stringliteral">"LE"</span> : <span class="stringliteral">"Le"</span>);
01236 <span class="preprocessor">#endif</span>
01237 <span class="preprocessor"></span>            }
01238             <span class="keywordflow">else</span>
01239               OutputFloat (writer, currentFormat, 
01240               params[currentFormat.paramIdx].vDbl, 
01241               currentFormat.uppercase ? <span class="stringliteral">"E"</span> : <span class="stringliteral">"e"</span>);
01242           }
01243           <span class="keywordflow">break</span>;
01244         <span class="keywordflow">case</span> convFloatGeneral:
01245           {
01246             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01247             {
01248 <span class="preprocessor">#if defined(__MINGW32__) || defined(CS_COMPILER_MSVC)</span>
01249 <span class="preprocessor"></span>              <span class="comment">// @@@ MinGW uses MS CRT, but it can't grok long double.</span>
01250               <span class="comment">// VC doesn't have long double, but CRT printf() doesn't know</span>
01251               <span class="comment">// %Lg either.</span>
01252               OutputFloat (writer, currentFormat, 
01253               (<span class="keywordtype">double</span>)params[currentFormat.paramIdx].vLongDbl, 
01254               currentFormat.uppercase ? <span class="stringliteral">"G"</span> : <span class="stringliteral">"g"</span>);
01255 <span class="preprocessor">#else</span>
01256 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01257               params[currentFormat.paramIdx].vLongDbl, 
01258               currentFormat.uppercase ? <span class="stringliteral">"LG"</span> : <span class="stringliteral">"Lg"</span>);
01259 <span class="preprocessor">#endif</span>
01260 <span class="preprocessor"></span>            }
01261             <span class="keywordflow">else</span>
01262               OutputFloat (writer, currentFormat, 
01263               params[currentFormat.paramIdx].vDbl, 
01264               currentFormat.uppercase ? <span class="stringliteral">"G"</span> : <span class="stringliteral">"g"</span>);
01265           }
01266           <span class="keywordflow">break</span>;
01267         <span class="keywordflow">case</span> convFloatHex:
01268           {
01269             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01270               OutputFloatHex (writer, currentFormat, 
01271               params[currentFormat.paramIdx].vLongDbl, LDBL_MANT_DIG, 
01272               csLog2 (LDBL_MAX_EXP) + 1, -(LDBL_MAX_EXP - 1));
01273             <span class="keywordflow">else</span>
01274               OutputFloatHex (writer, currentFormat, 
01275               params[currentFormat.paramIdx].vDbl, DBL_MANT_DIG, 
01276               csLog2 (DBL_MAX_EXP) + 1, -(DBL_MAX_EXP - 1));
01277           }
01278           <span class="keywordflow">break</span>;
01279         <span class="keywordflow">default</span>:
01280           <span class="keywordflow">break</span>;
01281       }
01282 
01283       <span class="keywordflow">for</span> (n = 0; n &lt; currentFormat.fmtSkip; n++)
01284       {
01285         <span class="keywordflow">if</span> (!reader.GetNext (ch)) <span class="keywordflow">break</span>;
01286       }
01287       i++;
01288     }
01289     <span class="keywordflow">while</span> (reader.GetNext (ch))
01290       writer.<a class="code" href="classcsArray.html#a14">Put</a> (ch);
01291     writer.<a class="code" href="classcsArray.html#a14">Put</a> (0);
01292   }
01293 };
01294 
01297 <span class="preprocessor">#endif // __CS_CSUTIL_FORMATTER_H__</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.9.1 
</small></address> </div></body> </html>
