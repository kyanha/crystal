<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/formatter.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000022.html">csutil</a></div>
<h1>formatter.h</h1><a href="formatter_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2005 by Frank Richter</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_CSUTIL_FORMATTER_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_CSUTIL_FORMATTER_H__</span>
00021 <span class="preprocessor"></span>
00027 <span class="preprocessor">#include "<a class="code" href="cssysdef_8h.html">cssysdef.h</a>"</span>
00028 <span class="preprocessor">#include "<a class="code" href="csuctransform_8h.html">csutil/csuctransform.h</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="dirtyaccessarray_8h.html">csutil/dirtyaccessarray.h</a>"</span>
00030 <span class="preprocessor">#include "<a class="code" href="util_8h.html">csutil/util.h</a>"</span>
00031 <span class="preprocessor">#include "<a class="code" href="math_8h.html">csgeom/math.h</a>"</span>
00032 
00033 <span class="comment">// MinGW uses MS CRT, but it can't grok long double.  VC doesn't have long</span>
00034 <span class="comment">// double and CRT printf() doesn't know %Lf, %Lg, or %Le.</span>
00035 <span class="preprocessor">#if defined(__MINGW32__) || defined(CS_COMPILER_MSVC)</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define CS_FORMATTER_NO_LONG_DOUBLE_FORMAT</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00038 <span class="preprocessor"></span>
00047 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00048"></a><a class="code" href="classcsFmtDefaultReader.html">00048</a> <span class="keyword">class </span><a class="code" href="classcsFmtDefaultReader.html">csFmtDefaultReader</a>
00049 {
00050   <span class="keyword">const</span> T* str;
00051   <span class="keyword">const</span> T* <span class="keyword">const</span> startStr;
00052   size_t len;
00053   <span class="keyword">const</span> size_t startLen;
00054 <span class="keyword">public</span>:
<a name="l00056"></a><a class="code" href="classcsFmtDefaultReader.html#a0">00056</a>   <a class="code" href="classcsFmtDefaultReader.html">csFmtDefaultReader</a> (<span class="keyword">const</span> T* string, size_t length) : startStr (string), 
00057     startLen (length) { Reset(); }
<a name="l00059"></a><a class="code" href="classcsFmtDefaultReader.html#a1">00059</a>   <span class="keywordtype">bool</span> GetNext (utf32_char&amp; ch) 
00060   {
00061     <span class="keywordtype">int</span> n = <a class="code" href="classcsUnicodeTransform.html#z580_3">csUnicodeTransform::Decode</a> (str, len, ch);
00062     <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00063     str += (size_t)n;
00064     len -= (size_t)n;
00065     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00066   }
<a name="l00068"></a><a class="code" href="classcsFmtDefaultReader.html#a2">00068</a>   <span class="keywordtype">void</span> Reset() { str = startStr; len = startLen; }
<a name="l00070"></a><a class="code" href="classcsFmtDefaultReader.html#a3">00070</a>   size_t GetPosition()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> str - startStr; }
00071 };
00072 
00073 
00079 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00080"></a><a class="code" href="classcsFmtDefaultWriter.html">00080</a> <span class="keyword">class </span><a class="code" href="classcsFmtDefaultWriter.html">csFmtDefaultWriter</a>
00081 {
00082   T* dest;
00083   size_t size;
00084   size_t total;
00085 <span class="keyword">public</span>:
<a name="l00087"></a><a class="code" href="classcsFmtDefaultWriter.html#a0">00087</a>   <a class="code" href="classcsFmtDefaultWriter.html">csFmtDefaultWriter</a> (T* dest, size_t size) : dest (dest), size (size), 
00088     total (0) {}
<a name="l00090"></a><a class="code" href="classcsFmtDefaultWriter.html#a1">00090</a>   <span class="keywordtype">void</span> Put (utf32_char ch) 
00091   { 
00092     size_t n = (size_t)<a class="code" href="classcsUnicodeTransform.html#z581_3">csUnicodeTransform::Encode</a> (ch, dest, size);
00093     total += n;
00094     n = <a class="code" href="group__geom__utils.html#ga6">csMin</a> (size, n);
00095     dest += n;
00096     size -= n;
00097   }
<a name="l00102"></a><a class="code" href="classcsFmtDefaultWriter.html#a2">00102</a>   size_t GetTotal()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> total; }
00103 };
00104 
00109 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Twriter, <span class="keyword">class</span> Treader&gt;
<a name="l00110"></a><a class="code" href="classcsPrintfFormatter.html">00110</a> <span class="keyword">class </span><a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter</a>
00111 {
00112   <span class="keyword">class </span>Scratch : <span class="keyword">public</span> <a class="code" href="classcsDirtyAccessArray.html">csDirtyAccessArray</a>&lt;utf32_char&gt;
00113   {
00114   <span class="keyword">public</span>:
00115     <span class="keywordtype">void</span> WriteTo (Twriter&amp; writer, size_t offset = 0, size_t len = (size_t)~0)
00116     {
00117       <span class="keyword">const</span> size_t n = MIN (len, <a class="code" href="classcsArray.html#a4">Length</a>());
00118       <span class="keywordflow">for</span> (size_t i = offset; i &lt; n; i++) writer.Put (Get (i));
00119     }
00120   };
00121   Scratch scratch;
00122 
00124   <span class="keyword">struct </span>FmtParam
00125   {
00126     <span class="keyword">union</span>
00127 <span class="keyword">    </span>{
00128       <span class="keywordtype">int</span> vInt;
00129       <span class="keywordtype">void</span>* vPtr;
00130       <span class="keywordtype">long</span> vLong;
00131       <a class="code" href="group__util.html#ga15">longlong</a> vLL;
00132       <span class="keywordtype">double</span> vDbl;
00133       <span class="keywordtype">long</span> <span class="keywordtype">double</span> vLongDbl;
00134       size_t vSzT;
00135       <a class="code" href="group__util.html#ga10">ptrdiff_t</a> vPDT;
00136       <a class="code" href="group__util.html#ga11">intmax_t</a> vIMT;
00137     };
00138   };
00139   <span class="keyword">enum</span> Conversion
00140   {
00141     convBogus = 0,
00142     convNone,
00143     convInt,
00144     convOctal,
00145     convUint,
00146     convHex,
00147     convFloatFix,
00148     convFloatExp,
00149     convFloatGeneral,
00150     convFloatHex,
00151     convChar,
00152     convStr,
00153     convPtr,
00154     convGetNum,
00155     convErrno
00156   };
00157   <span class="keyword">enum</span> Type
00158   {
00159     typeNone = 0,
00160     typeChar,
00161     typeShort,
00162     typeIntmax,
00163     typeLong,
00164     typeLongLong,
00165     typePtrDiffT,
00166     typeSizeT
00167   };
00169   <span class="keyword">struct </span>FormatSpec
00170   {
00171     size_t copyRun;
00172     size_t fmtSkip;
00173 
00174     <span class="keywordtype">int</span> paramIdx;
00175     <span class="keywordtype">bool</span> leftJustify;
00176     <span class="keywordtype">bool</span> plusSign;
00177     <span class="keywordtype">bool</span> spacePrefix;
00178     <span class="keywordtype">bool</span> basePrefix;
00179     <span class="keywordtype">bool</span> padZero;
00180     <span class="keywordtype">int</span> width;
00181     <span class="keywordtype">int</span> precision;
00182     Conversion conversion;
00183     <span class="keywordtype">bool</span> uppercase;
00184     Type type;
00185 
00186     FormatSpec() { Reset(); }
00187     <span class="keywordtype">void</span> Reset () 
00188     { 
00189       memset (<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span> (*<span class="keyword">this</span>)); 
00190       precision = -1;
00191     }
00192   };
00193   <a class="code" href="classcsArray.html">csArray&lt;FormatSpec&gt;</a> formatSpecs;
00194   <a class="code" href="classcsArray.html">csArray&lt;FmtParam&gt;</a> params;
00195   Treader&amp; reader;
00196 
00197   <span class="keyword">struct </span>SpecParseState
00198   {
00199     <a class="code" href="group__util.html#ga22">utf32_char</a> ch;
00200     FormatSpec currentFormat;
00201     size_t charRun;
00202     <span class="keywordtype">int</span> paramIdx;
00203     size_t fmtBegin;
00204 
00205     SpecParseState() : paramIdx(0) {}
00206     <span class="keywordtype">void</span> Reset()
00207     {
00208       charRun = 0;
00209       currentFormat.Reset();
00210     }
00211   };
00212 
00213   <span class="keywordtype">bool</span> ParseFlag (SpecParseState&amp; state)
00214   {
00215     <span class="keywordflow">switch</span> (state.ch)
00216     {
00217       <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
00218         {
00219           state.currentFormat.leftJustify = <span class="keyword">true</span>;
00220           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00221         }
00222       <span class="keywordflow">case</span> <span class="charliteral">'+'</span>:
00223         {
00224           state.currentFormat.plusSign = <span class="keyword">true</span>;
00225           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00226         }
00227       <span class="keywordflow">case</span> <span class="charliteral">' '</span>:
00228         {
00229           state.currentFormat.spacePrefix = <span class="keyword">true</span>;
00230           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00231         }
00232       <span class="keywordflow">case</span> <span class="charliteral">'#'</span>:
00233         {
00234           state.currentFormat.basePrefix = <span class="keyword">true</span>;
00235           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00236         }
00237       <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
00238         {
00239           state.currentFormat.padZero = <span class="keyword">true</span>;
00240           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00241         }
00242       <span class="keywordflow">case</span> <span class="charliteral">'\''</span>:
00243         {
00244           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00245         }
00246     }
00247     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00248   }
00249   
00250   <span class="keywordtype">bool</span> ParseType (SpecParseState&amp; state)
00251   {
00252     <span class="keywordflow">switch</span> (state.ch)
00253     {
00254       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
00255         {
00256           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00257             state.currentFormat.type = typeShort;
00258           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.currentFormat.type == typeShort)
00259             state.currentFormat.type = typeChar;
00260           <span class="keywordflow">else</span>
00261             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00262           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00263         }
00264       <span class="keywordflow">case</span> <span class="charliteral">'j'</span>:
00265         {
00266           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00267             state.currentFormat.type = typeIntmax;
00268           <span class="keywordflow">else</span>
00269             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00270           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00271         }
00272       <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
00273         {
00274           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00275             state.currentFormat.type = typeLong;
00276           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.currentFormat.type == typeLong)
00277             state.currentFormat.type = typeLongLong;
00278           <span class="keywordflow">else</span>
00279             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00280           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00281         }
00282       <span class="keywordflow">case</span> <span class="charliteral">'L'</span>:
00283       <span class="keywordflow">case</span> <span class="charliteral">'q'</span>:
00284         {
00285           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00286             state.currentFormat.type = typeLongLong;
00287           <span class="keywordflow">else</span>
00288             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00289           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00290         }
00291       <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
00292         {
00293           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00294             state.currentFormat.type = typePtrDiffT;
00295           <span class="keywordflow">else</span>
00296             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00297           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00298         }
00299       <span class="keywordflow">case</span> <span class="charliteral">'z'</span>:
00300         {
00301           <span class="keywordflow">if</span> (state.currentFormat.type == typeNone)
00302             state.currentFormat.type = typeSizeT;
00303           <span class="keywordflow">else</span>
00304             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00305           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00306         }
00307     }
00308     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00309   }
00310 
00311   <span class="keywordtype">bool</span> ParseConversion (SpecParseState&amp; state)
00312   {
00313     <span class="keywordflow">switch</span> (state.ch)
00314     {
00315       <span class="keywordflow">case</span> <span class="charliteral">'%'</span>:
00316         {
00317           <span class="keyword">const</span> size_t fmtLen = (reader.GetPosition() - 1) - state.fmtBegin;
00318           <span class="keywordflow">if</span> (fmtLen == 1)
00319           {
00320             state.currentFormat.conversion = convNone;
00321             state.fmtBegin++;
00322             state.currentFormat.copyRun++;
00323             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00324           }
00325           <span class="keywordflow">break</span>;
00326         }
00327       <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00328       <span class="keywordflow">case</span> <span class="charliteral">'i'</span>:
00329         {
00330           state.currentFormat.conversion = convInt;
00331           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00332         }
00333       <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
00334         {
00335           state.currentFormat.conversion = convOctal;
00336           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00337         }
00338       <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
00339         {
00340           state.currentFormat.conversion = convUint;
00341           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00342         }
00343       <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
00344       <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
00345         {
00346           state.currentFormat.conversion = convHex;
00347           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'X'</span>);
00348           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00349         }
00350       <span class="keywordflow">case</span> <span class="charliteral">'f'</span>:
00351         {
00352           state.currentFormat.conversion = convFloatFix;
00353           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00354         }
00355       <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
00356       <span class="keywordflow">case</span> <span class="charliteral">'E'</span>:
00357         {
00358           state.currentFormat.conversion = convFloatExp;
00359           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'E'</span>);
00360           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00361         }
00362       <span class="keywordflow">case</span> <span class="charliteral">'g'</span>:
00363       <span class="keywordflow">case</span> <span class="charliteral">'G'</span>:
00364         {
00365           state.currentFormat.conversion = convFloatGeneral;
00366           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'G'</span>);
00367           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00368         }
00369       <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
00370       <span class="keywordflow">case</span> <span class="charliteral">'A'</span>:
00371         {
00372           state.currentFormat.conversion = convFloatHex;
00373           state.currentFormat.uppercase = (state.ch == <span class="charliteral">'A'</span>);
00374           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00375         }
00376       <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
00377         {
00378           state.currentFormat.conversion = convChar;
00379           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00380         }
00381       <span class="keywordflow">case</span> <span class="charliteral">'C'</span>:
00382         {
00383           state.currentFormat.conversion = convChar;
00384           state.currentFormat.type = typeLong;
00385           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00386         }
00387       <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
00388         {
00389           state.currentFormat.conversion = convStr;
00390           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00391         }
00392       <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
00393         {
00394           state.currentFormat.conversion = convStr;
00395           state.currentFormat.type = typeLong;
00396           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00397         }
00398       <span class="keywordflow">case</span> <span class="charliteral">'p'</span>:
00399         {
00400           state.currentFormat.conversion = convPtr;
00401           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00402         }
00403       <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
00404         {
00405           state.currentFormat.conversion = convGetNum;
00406           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00407         }
00408       <span class="keywordflow">case</span> <span class="charliteral">'m'</span>:
00409         {
00410           state.currentFormat.conversion = convErrno;
00411           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00412         }
00413     }
00414     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00415   }
00416 
00417   <span class="keywordtype">void</span> ParseSpec ()
00418   {
00419     <span class="keyword">enum</span> {
00420       scanFormat,
00421       formatParamFlagsWidthPrecTypeConversion,
00422       formatFlagsWidthPrecTypeConversion,
00423       formatParamWidth,
00424       formatDotPrecTypeConversion,
00425       formatPrecTypeConversion,
00426       formatTypeConversion
00427     } parseState = scanFormat;
00428 
00429     <span class="comment">// Collect positions of state specifiers from format string</span>
00430     SpecParseState state;
00431     state.Reset();
00432     <span class="keywordflow">while</span> (reader.GetNext (state.ch))
00433     {
00434       <span class="keywordflow">switch</span> (parseState)
00435       {
00436         <span class="comment">// Note: all falling through in this switch() is intentional.</span>
00437         <span class="keywordflow">case</span> scanFormat:
00438           {
00439             <span class="comment">// Check for a % sign</span>
00440             <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'%'</span>)
00441             {
00442               parseState = formatParamFlagsWidthPrecTypeConversion;
00443               state.fmtBegin = reader.GetPosition() - 1;
00444               state.currentFormat.copyRun = state.charRun;
00445             }
00446             <span class="keywordflow">else</span>
00447               state.charRun++;
00448           }
00449           <span class="keywordflow">break</span>;
00450         <span class="keywordflow">case</span> formatParamFlagsWidthPrecTypeConversion:
00451           <span class="comment">// Check for start of width or param index</span>
00452           <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'1'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00453           {
00454             state.currentFormat.width = state.ch - <span class="charliteral">'0'</span>;
00455             parseState = formatParamWidth;
00456             <span class="keywordflow">break</span>;
00457           }
00458           <span class="comment">// Check for '*' (fetch width from args)</span>
00459           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'*'</span>)
00460           {
00461             state.currentFormat.width = -2;
00462             parseState = formatDotPrecTypeConversion;
00463             <span class="keywordflow">break</span>;
00464           }
00465           <span class="comment">// Param delimiter</span>
00466           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'$'</span>)
00467           {
00468             <span class="comment">// @@@ Hmm. Empty param...</span>
00469             parseState = formatFlagsWidthPrecTypeConversion;
00470             <span class="keywordflow">break</span>;
00471           }
00472         <span class="keywordflow">case</span> formatParamWidth:
00473           <span class="keywordflow">if</span> (parseState == formatParamWidth) <span class="comment">// != can occur due fallthrough</span>
00474           {
00475             <span class="comment">// Subsequent digits width or param index</span>
00476             <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'0'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00477             {
00478               state.currentFormat.width *= 10;
00479               state.currentFormat.width += state.ch - <span class="charliteral">'0'</span>;
00480               <span class="keywordflow">break</span>;
00481             }
00482             <span class="comment">// Param delimiter</span>
00483             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'$'</span>)
00484             {
00485               state.paramIdx = state.currentFormat.width - 1;
00486               state.currentFormat.width = 0;
00487               parseState = formatFlagsWidthPrecTypeConversion;
00488               <span class="keywordflow">break</span>;
00489             }
00490           }
00491         <span class="keywordflow">case</span> formatFlagsWidthPrecTypeConversion:
00492           <span class="comment">// Check for start of width</span>
00493           <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'1'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00494           {
00495             state.currentFormat.width *= 10;
00496             state.currentFormat.width += state.ch - <span class="charliteral">'0'</span>;
00497             parseState = formatParamWidth;
00498             <span class="keywordflow">break</span>;
00499           }
00500           <span class="comment">// Check for '*' (fetch width from args)</span>
00501           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'*'</span>)
00502           {
00503             state.currentFormat.width = -2;
00504             parseState = formatDotPrecTypeConversion;
00505             <span class="keywordflow">break</span>;
00506           }
00507           <span class="comment">// Check for flags (0, -, ...)</span>
00508           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ParseFlag (state))
00509           {
00510             parseState = formatFlagsWidthPrecTypeConversion;
00511             <span class="keywordflow">break</span>;
00512           }
00513         <span class="keywordflow">case</span> formatDotPrecTypeConversion:
00514           <span class="comment">// Check for precision delimiter</span>
00515           <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'.'</span>)
00516           {
00517             parseState = formatPrecTypeConversion;
00518             state.currentFormat.precision = 0;
00519             <span class="keywordflow">break</span>;
00520           }
00521         <span class="keywordflow">case</span> formatPrecTypeConversion:
00522           <span class="comment">// Precision digits</span>
00523           <span class="keywordflow">if</span> ((state.ch &gt;= <span class="charliteral">'0'</span>) &amp;&amp; (state.ch &lt;= <span class="charliteral">'9'</span>))
00524           {
00525             state.currentFormat.precision *= 10;
00526             state.currentFormat.precision += state.ch - <span class="charliteral">'0'</span>;
00527             <span class="keywordflow">break</span>;
00528           }
00529           <span class="comment">// Check for '*' (fetch precision from args)</span>
00530           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.ch == <span class="charliteral">'*'</span>)
00531           {
00532             state.currentFormat.precision = -2;
00533             parseState = formatTypeConversion;
00534             <span class="keywordflow">break</span>;
00535           }
00536           <span class="comment">// Check for param type modifier (l, h, ...)</span>
00537           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ParseType (state))
00538           {
00539             parseState = formatPrecTypeConversion;
00540             <span class="keywordflow">break</span>;
00541           }
00542         <span class="keywordflow">case</span> formatTypeConversion:
00543           <span class="comment">// Check actual conversion (s, d, ...)</span>
00544           <span class="keywordflow">if</span> (ParseConversion (state))
00545           {
00546             state.currentFormat.fmtSkip =
00547               reader.GetPosition() - state.fmtBegin;
00548             <span class="keywordflow">if</span> (state.currentFormat.conversion != convNone)
00549               state.currentFormat.paramIdx = state.paramIdx++;
00550             formatSpecs.<a class="code" href="classcsArray.html#a16">Push</a> (state.currentFormat);
00551 
00552             state.Reset();
00553           }
00554           <span class="keywordflow">else</span>
00555           {
00556             state.charRun += reader.GetPosition() - state.fmtBegin;
00557             state.currentFormat.Reset();
00558           }
00559           parseState = scanFormat;
00560           <span class="keywordflow">break</span>;
00561       }
00562     }
00563   }
00564 
00566   <span class="keywordtype">void</span> FetchArgs (va_list args)
00567   {
00568     size_t i;
00569     <span class="comment">// Determine order of params</span>
00570     <a class="code" href="classcsArray.html">csArray&lt;FormatSpec*&gt;</a> paramOrder;
00571     paramOrder.<a class="code" href="classcsArray.html#a31">SetCapacity</a> (formatSpecs.<a class="code" href="classcsArray.html#a4">Length</a>());
00572     <span class="keywordflow">for</span> (i = 0; i &lt; formatSpecs.<a class="code" href="classcsArray.html#a4">Length</a>(); i++)
00573     {
00574       FormatSpec&amp; currentFormat = formatSpecs[i];
00575       <span class="keywordflow">if</span> (currentFormat.conversion == convNone) <span class="keywordflow">continue</span>;
00576       <span class="keywordflow">if</span> (paramOrder.<a class="code" href="classcsArray.html#a4">Length</a>() &lt;= (size_t)currentFormat.paramIdx)
00577         paramOrder.<a class="code" href="classcsArray.html#a7">SetLength</a> (currentFormat.paramIdx + 1, 0);
00578       paramOrder[currentFormat.paramIdx] = &amp;currentFormat;
00579     }
00580     <span class="comment">// Fetch params from stack in order, store at correct place in params array</span>
00581     <span class="keywordflow">for</span> (i = 0; i &lt; paramOrder.<a class="code" href="classcsArray.html#a4">Length</a>(); i++)
00582     {
00583       FmtParam&amp; param = params.<a class="code" href="classcsArray.html#a11">GetExtend</a> (i);
00584       FormatSpec* fmtPtr = paramOrder[i];
00585       <span class="keywordflow">if</span> (fmtPtr == 0) 
00586       {
00587         <span class="comment">// Can just guess here...</span>
00588         param.vInt = va_arg (args, <span class="keywordtype">int</span>);
00589         <span class="keywordflow">continue</span>;
00590       }
00591       FormatSpec&amp; currentFormat = *fmtPtr;
00592 
00593       <span class="keywordflow">if</span> (currentFormat.width == -2)
00594       {
00595         currentFormat.width = va_arg (args, <span class="keywordtype">int</span>);
00596         <span class="keywordflow">if</span> (currentFormat.width &lt; 0)
00597         {
00598           currentFormat.width = -currentFormat.width;
00599           currentFormat.leftJustify = <span class="keyword">true</span>;
00600         }
00601       }
00602       <span class="keywordflow">if</span> (currentFormat.precision == -2)
00603       {
00604         <span class="keywordtype">int</span> v = va_arg (args, <span class="keywordtype">int</span>);
00605         <span class="keywordflow">if</span> (v &gt;= 0) 
00606           currentFormat.precision = v;
00607         <span class="keywordflow">else</span>
00608           currentFormat.precision = -1;
00609       }
00610       <span class="keywordflow">switch</span> (currentFormat.conversion)
00611       {
00612         <span class="keywordflow">case</span> convInt:
00613         <span class="keywordflow">case</span> convOctal:
00614         <span class="keywordflow">case</span> convUint:
00615         <span class="keywordflow">case</span> convHex:
00616         <span class="keywordflow">default</span>:
00617           {
00618             <span class="keywordflow">switch</span> (currentFormat.type)
00619             {
00620               <span class="keywordflow">case</span> typeIntmax:
00621                 param.vIMT = va_arg (args, <a class="code" href="group__util.html#ga11">intmax_t</a>);
00622                 <span class="keywordflow">break</span>;
00623               <span class="keywordflow">case</span> typeLong:
00624                 param.vLong = va_arg (args, <span class="keywordtype">long</span>);
00625                 <span class="keywordflow">break</span>;
00626               <span class="keywordflow">case</span> typeLongLong:
00627                 param.vLL = va_arg (args, <a class="code" href="group__util.html#ga15">longlong</a>);
00628                 <span class="keywordflow">break</span>;
00629               <span class="keywordflow">case</span> typePtrDiffT:
00630                 param.vPDT = va_arg (args, <a class="code" href="group__util.html#ga10">ptrdiff_t</a>);
00631                 <span class="keywordflow">break</span>;
00632               <span class="keywordflow">case</span> typeSizeT:
00633                 param.vSzT = va_arg (args, size_t);
00634                 <span class="keywordflow">break</span>;
00635               <span class="keywordflow">case</span> typeShort:
00636                 param.vInt = (short)(va_arg (args, <span class="keywordtype">int</span>));
00637                 <span class="keywordflow">break</span>;
00638               <span class="keywordflow">case</span> typeChar:
00639                 param.vInt = (char)(va_arg (args, <span class="keywordtype">int</span>));
00640                 <span class="keywordflow">break</span>;
00641               <span class="keywordflow">default</span>:
00642                 param.vInt = va_arg (args, <span class="keywordtype">int</span>);
00643                 <span class="keywordflow">break</span>;
00644             }
00645           }
00646           <span class="keywordflow">break</span>;
00647         <span class="keywordflow">case</span> convErrno:
00648           param.vInt = errno;
00649           <span class="keywordflow">break</span>;
00650         <span class="keywordflow">case</span> convChar:
00651           <span class="keywordflow">if</span> (currentFormat.type == typeLong)
00652           {
00653             param.vInt = (wint_t)(va_arg (args, <span class="keywordtype">int</span>));
00654           }
00655           <span class="keywordflow">else</span>
00656           {
00657             param.vInt = (<span class="keywordtype">unsigned</span> char)(va_arg (args, <span class="keywordtype">int</span>));
00658           }
00659           <span class="keywordflow">break</span>;
00660         <span class="keywordflow">case</span> convFloatFix:
00661         <span class="keywordflow">case</span> convFloatExp:
00662         <span class="keywordflow">case</span> convFloatGeneral:
00663         <span class="keywordflow">case</span> convFloatHex:
00664           <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
00665           {
00666             param.vLongDbl = va_arg (args, <span class="keywordtype">long</span> <span class="keywordtype">double</span>);
00667           }
00668           <span class="keywordflow">else</span>
00669           {
00670             param.vDbl = va_arg (args, <span class="keywordtype">double</span>);
00671           }
00672           <span class="keywordflow">break</span>;
00673         <span class="keywordflow">case</span> convStr:
00674         <span class="keywordflow">case</span> convPtr:
00675         <span class="keywordflow">case</span> convGetNum:
00676           param.vPtr = va_arg (args, <span class="keywordtype">void</span>*);
00677           <span class="keywordflow">break</span>;
00678         <span class="keywordflow">case</span> convNone:
00679           <span class="keywordflow">break</span>;
00680       }
00681     }
00682   }
00683 
00684   <span class="keywordtype">void</span> Init (va_list args)
00685   {
00686     ParseSpec ();
00687     FetchArgs (args);
00688   }
00689 
00691   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00692   <span class="keywordtype">void</span> OutputString (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00693     <span class="keyword">const</span> T* stringPtr)
00694   {
00695     <span class="keywordflow">if</span> (stringPtr == 0)
00696     {
00697       OutputString (writer, currentFormat, (<a class="code" href="group__util.html#ga20">utf8_char</a>*)<span class="stringliteral">"(nil)"</span>);
00698       <span class="keywordflow">return</span>;
00699     }
00700 
00701     size_t scratchOffs = scratch.Length();
00702     size_t len = 0;
00703     {
00704       <span class="keyword">const</span> T* ptr = stringPtr;
00705       <span class="keywordflow">while</span> (*ptr++ != 0) len++;
00706     }
00707     <span class="keywordflow">while</span> (len &gt; 0)
00708     {
00709       <a class="code" href="group__util.html#ga22">utf32_char</a> ch;
00710       <span class="keywordtype">int</span> n = <a class="code" href="classcsUnicodeTransform.html#z580_3">csUnicodeTransform::Decode</a> (stringPtr, len, ch);
00711       scratch.Push (ch);
00712       stringPtr += n;
00713       len -= (size_t)n;
00714     }
00715     <span class="keywordflow">if</span> (!currentFormat.leftJustify 
00716       &amp;&amp; ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs)))
00717     {
00718       size_t d = (size_t)currentFormat.width - scratch.Length() + scratchOffs;
00719       <span class="keywordflow">while</span> (d-- &gt; 0) writer.Put (<span class="charliteral">' '</span>);
00720     }
00721     scratch.WriteTo (writer, scratchOffs);
00722     <span class="keywordflow">if</span> (currentFormat.leftJustify 
00723       &amp;&amp; ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs)))
00724     {
00725       size_t d = (size_t)currentFormat.width - scratch.Length() + scratchOffs;
00726       <span class="keywordflow">while</span> (d-- &gt; 0) writer.Put (<span class="charliteral">' '</span>);
00727     }
00728     scratch.Truncate (scratchOffs);
00729   }
00730 
00732   <span class="keywordtype">void</span> DoPadding (<span class="keyword">const</span> FormatSpec&amp; currentFormat, <span class="keyword">const</span> size_t scratchOffs,
00733     <span class="keyword">const</span> size_t insert0offs)
00734   {
00735     <span class="keywordflow">if</span> (currentFormat.leftJustify)
00736     {
00737       <span class="keywordflow">while</span> ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs))
00738       {
00739         scratch.Push (<span class="charliteral">' '</span>);
00740       }
00741     }
00742     <span class="keywordflow">else</span>
00743     {
00744       <span class="keywordflow">if</span> (currentFormat.padZero)
00745       {
00746         <span class="keywordflow">while</span> ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs))
00747         {
00748           scratch.Insert (insert0offs, <span class="charliteral">'0'</span>);
00749         }
00750       }
00751       <span class="keywordflow">else</span>
00752       {
00753         <span class="keywordflow">while</span> ((size_t)currentFormat.width &gt; (scratch.Length() - scratchOffs))
00754         {
00755           scratch.Insert (scratchOffs, <span class="charliteral">' '</span>);
00756         }
00757       }
00758     }
00759   }
00760 
00762   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00763   <span class="keywordtype">void</span> OutputInt (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat, T value)
00764   {
00765     <span class="keyword">const</span> size_t scratchOffs = scratch.Length();
00766     size_t insertOffs = scratchOffs;
00767 
00768     <span class="keywordflow">if</span> (value &lt; 0)
00769     {
00770       scratch.Push (<span class="charliteral">'-'</span>);
00771       insertOffs++;
00772       value = -value;
00773     }
00774     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.plusSign)
00775     {
00776       scratch.Push (<span class="charliteral">'+'</span>);
00777       insertOffs++;
00778     }
00779     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.spacePrefix)
00780     {
00781       scratch.Push (<span class="charliteral">' '</span>);
00782       insertOffs++;
00783     }
00784 
00785     <span class="keywordtype">int</span> width = 0;
00786     <span class="keywordtype">int</span> numDigits = currentFormat.precision;
00787     <span class="keywordflow">if</span> (!((value == 0) &amp;&amp; (numDigits == 0)))
00788     {
00789       <span class="keywordflow">do</span>
00790       {
00791         <span class="keywordtype">int</span> d = value % 10;
00792         scratch.Insert (insertOffs, d + <span class="charliteral">'0'</span>);
00793         width++;
00794         value = value / 10;
00795       }
00796       <span class="keywordflow">while</span> ((value != 0) || (width &lt; numDigits));
00797     }
00798     DoPadding (currentFormat, scratchOffs, insertOffs);
00799     scratch.WriteTo (writer, scratchOffs);
00800     scratch.Truncate (scratchOffs);
00801   }
00802 
00804   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00805   <span class="keywordtype">void</span> OutputUint (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00806     T value, <a class="code" href="group__util.html#ga18">uint</a> radix, <span class="keyword">const</span> <span class="keywordtype">char</span>* prefix = 0)
00807   {
00808     <span class="keyword">const</span> <a class="code" href="group__util.html#ga22">utf32_char</a> letterFirst = currentFormat.uppercase ? <span class="charliteral">'A'</span> : <span class="charliteral">'a'</span>;
00809     <span class="keyword">const</span> size_t scratchOffs = scratch.Length();
00810     size_t insertOffs = scratchOffs;
00811 
00812     <span class="keywordflow">if</span> (prefix != 0)
00813     {
00814       <span class="keywordflow">while</span> (*prefix != 0)
00815       {
00816         <a class="code" href="group__util.html#ga22">utf32_char</a> ch = (value != 0) ? *prefix : <span class="charliteral">' '</span>;
00817         scratch.Push (ch);
00818         insertOffs++;
00819         prefix++;
00820       }
00821     }
00822 
00823     <span class="keywordtype">int</span> width = 0;
00824     <span class="keywordtype">int</span> numDigits = currentFormat.precision;
00825     <span class="keywordflow">if</span> (!((value == 0) &amp;&amp; (numDigits == 0)))
00826     {
00827       <span class="keywordflow">do</span>
00828       {
00829         <a class="code" href="group__util.html#ga18">uint</a> d = value % radix;
00830         <a class="code" href="group__util.html#ga22">utf32_char</a> ch;
00831         <span class="keywordflow">if</span> (d &lt;= 9)
00832           ch = d + <span class="charliteral">'0'</span>;
00833         <span class="keywordflow">else</span>
00834           ch = d - 10 + letterFirst;
00835         scratch.Insert (insertOffs, ch);
00836         width++;
00837         value = value / radix;
00838       }
00839       <span class="keywordflow">while</span> ((value != 0) || (width &lt; numDigits));
00840     }
00841     DoPadding (currentFormat, scratchOffs, insertOffs);
00842     scratch.WriteTo (writer, scratchOffs);
00843     scratch.Truncate (scratchOffs);
00844   }
00845 
00847   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00848   <span class="keywordtype">void</span> OutputFloat (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00849     <span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> <span class="keywordtype">char</span>* type)
00850   {
00851     <span class="keywordtype">char</span> flags[5] = <span class="stringliteral">""</span>;
00852     <span class="keywordflow">if</span> (currentFormat.plusSign)
00853       strcat (flags, <span class="stringliteral">"+"</span>);
00854     <span class="keywordflow">if</span> (currentFormat.spacePrefix)
00855       strcat (flags, <span class="stringliteral">" "</span>);
00856     <span class="keywordflow">if</span> (currentFormat.basePrefix)
00857       strcat (flags, <span class="stringliteral">"#"</span>);
00858     <span class="keywordflow">if</span> (currentFormat.padZero)
00859       strcat (flags, <span class="stringliteral">"0"</span>);
00860     <a class="code" href="cssysdef_8h.html#a4">CS_ALLOC_STACK_ARRAY</a>(<span class="keywordtype">char</span>, precStr, 
00861       (<span class="keyword">sizeof</span>(currentFormat.precision) * 24) / 10 + 3);
00862     <span class="keywordflow">if</span> (currentFormat.precision &gt;= 0)
00863       sprintf (precStr, <span class="stringliteral">".%d"</span>, currentFormat.precision);
00864     <span class="keywordflow">else</span>
00865       precStr[0] = 0;
00866     <a class="code" href="cssysdef_8h.html#a4">CS_ALLOC_STACK_ARRAY</a>(<span class="keywordtype">char</span>, formatStr, 1 + strlen (flags)
00867       + (<span class="keyword">sizeof</span>(currentFormat.width) * 24) / 10 + 2 + strlen (precStr) + 2);
00868     sprintf (formatStr, <span class="stringliteral">"%%%s%d%s%s"</span>, flags, currentFormat.width, precStr,
00869       type);
00870     <span class="keywordtype">char</span> formattedStr[64];
00871     sprintf (formattedStr, formatStr, value);
00872 
00873     <span class="keywordtype">char</span>* p = formattedStr;
00874     <span class="keywordflow">while</span> (*p != 0)
00875       writer.Put (*p++);
00876   }
00877 
00881   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Tbase&gt;
00882   <span class="keyword">struct </span>IEEEFloatMantissa
00883   {
00884     Tbase mantissa[<span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase)];
00885 
00886     Tbase&amp; operator[] (<span class="keywordtype">int</span> index)
00887     { <span class="keywordflow">return</span> mantissa[index]; }
00888     <span class="keywordtype">bool</span> Eq0 ()
00889     {
00890       <span class="keywordflow">for</span> (<a class="code" href="group__util.html#ga18">uint</a> n = 0; n &lt; <span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase); n++)
00891       {
00892         <span class="keywordflow">if</span> (mantissa[n] != 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00893       }
00894       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00895     }
00896     <span class="keyword">const</span> Tbase operator&amp; (Tbase other)<span class="keyword"> const</span>
00897 <span class="keyword">    </span>{ <span class="keywordflow">return</span> mantissa[0] &amp; other; }
00898     IEEEFloatMantissa&amp; operator&lt;&lt;= (<span class="keywordtype">int</span> shift)
00899     { 
00900       <span class="keyword">const</span> <span class="keywordtype">int</span> ovShift = <span class="keyword">sizeof</span>(Tbase) * 8 - shift;
00901       Tbase overflow = 0;
00902       <span class="keywordflow">for</span> (<a class="code" href="group__util.html#ga18">uint</a> n = 0; n &lt; <span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase); n++)
00903       {
00904         Tbase newOverflow = mantissa[n] &gt;&gt; ovShift;
00905         mantissa[n] = (mantissa[n] &lt;&lt; shift) | overflow;
00906         overflow = newOverflow;
00907       }
00908       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00909     }
00910     Tbase&amp; Leftmost ()
00911     { <span class="keywordflow">return</span> mantissa[<span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase)-1]; }
00912   };
00913 
00915   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Tbase&gt;
00916   <span class="keyword">struct </span>IEEEFloatSplitter
00917   {
00918     <span class="keywordtype">bool</span> sign;
00919     Tbase exp;
00920 
00921     typename_qualifier
00922     <a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter&lt;Twriter,Treader&gt;</a>::IEEEFloatMantissa&lt;T, Tbase&gt; mantissa;
00923 
00924     IEEEFloatSplitter (<span class="keyword">const</span> T&amp; val, <span class="keyword">const</span> <span class="keywordtype">int</span> mantissaBits,
00925       <span class="keyword">const</span> <span class="keywordtype">int</span> expBits) 
00926     {
00927       <span class="keyword">const</span> <span class="keywordtype">int</span> baseBits = <span class="keyword">sizeof</span>(Tbase) * 8;
00928       <span class="keyword">const</span> <span class="keywordtype">int</span> signBit = mantissaBits + expBits;
00929 
00930       <span class="keyword">union</span>
00931 <span class="keyword">      </span>{
00932         T v;
00933         Tbase vB[<span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(Tbase)];
00934       } toBase;
00935       toBase.v = val;
00936 <span class="preprocessor">  #ifdef CS_LITTLE_ENDIAN</span>
00937 <span class="preprocessor"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> hi = (<span class="keyword">sizeof</span> (T) / <span class="keyword">sizeof</span> (Tbase)) - 1;
00938       <span class="keyword">const</span> <span class="keywordtype">int</span> lo = 0;
00939       <span class="keyword">const</span> <span class="keywordtype">int</span> d = 1;
00940 <span class="preprocessor">  #else</span>
00941 <span class="preprocessor"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> hi = 0;
00942       <span class="keyword">const</span> <span class="keywordtype">int</span> lo = (<span class="keyword">sizeof</span> (T) / <span class="keyword">sizeof</span> (Tbase)) - 1;
00943       <span class="keyword">const</span> <span class="keywordtype">int</span> d = -1;
00944 <span class="preprocessor">  #endif</span>
00945 <span class="preprocessor"></span>      sign = toBase.vB[lo + (signBit / baseBits) * d]
00946         &amp; (1 &lt;&lt; (signBit % baseBits));
00947       exp = (toBase.vB[hi] &gt;&gt; (mantissaBits % (baseBits)))
00948         &amp; ((1 &lt;&lt; expBits) - 1);
00949       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = lo, p = 0; n != hi + d; n += d, p++)
00950       {
00951         <span class="keyword">const</span> <span class="keywordtype">int</span> bit = p * baseBits;
00952         <span class="keyword">const</span> Tbase mask = ((bit + baseBits) &lt;= mantissaBits) ? ~0 
00953           : ((1 &lt;&lt; (mantissaBits % baseBits)) - 1);
00954         mantissa[p] = toBase.vB[n] &amp; mask;
00955       }
00956     }
00957   };
00959   <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00960   <span class="keywordtype">void</span> OutputFloatHex (Twriter&amp; writer, <span class="keyword">const</span> FormatSpec&amp; currentFormat,
00961     <span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> <span class="keywordtype">int</span> vMantissaBits, <span class="keyword">const</span> <span class="keywordtype">int</span> expBits, <span class="keyword">const</span> <span class="keywordtype">int</span> bias)
00962   {
00963 <span class="preprocessor">#ifdef CS_IEEE_DOUBLE_FORMAT</span>
00964 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="group__util.html#ga22">utf32_char</a> letterFirst = currentFormat.uppercase ? <span class="charliteral">'A'</span> : <span class="charliteral">'a'</span>;
00965 
00966 <span class="preprocessor">#ifdef CS_PROCESSOR_X86</span>
00967 <span class="preprocessor"></span>    <span class="comment">// @@@ x86 long double uses explicit mantissa MSB</span>
00968     <span class="keyword">const</span> <span class="keywordtype">bool</span> hiddenBit = !(vMantissaBits &gt;= 63);
00969 <span class="preprocessor">#else</span>
00970 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> hiddenBit = <span class="keyword">false</span>;
00971 <span class="preprocessor">#endif</span>
00972 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> mantissaBits = vMantissaBits - (hiddenBit ? 1 : 0);
00973     IEEEFloatSplitter&lt;T, uint&gt; vSplit (value, mantissaBits, expBits);
00974     <span class="keyword">const</span> <a class="code" href="group__util.html#ga18">uint</a> expMax = (1 &lt;&lt; (<span class="keyword">sizeof</span>(T) * 8 - mantissaBits - 1)) - 1;
00975 
00976     <span class="keywordflow">if</span> ((vSplit.exp == expMax) &amp;&amp; vSplit.mantissa.Eq0())
00977     {
00978       <span class="keywordtype">char</span> infStr[5];
00979       <span class="keywordflow">if</span> (vSplit.sign)
00980       {
00981         strcpy (infStr, <span class="stringliteral">"-"</span>);
00982       }
00983       <span class="keywordflow">else</span>
00984       {
00985         <span class="keywordflow">if</span> (currentFormat.plusSign)
00986           strcpy (infStr, <span class="stringliteral">"+"</span>);
00987         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.spacePrefix)
00988           strcpy (infStr, <span class="stringliteral">" "</span>);
00989         <span class="keywordflow">else</span>
00990           strcpy (infStr, <span class="stringliteral">""</span>);
00991       }
00992       strcat (infStr, currentFormat.uppercase ? <span class="stringliteral">"INF"</span> : <span class="stringliteral">"inf"</span>);
00993       OutputString (writer, currentFormat, 
00994         (<a class="code" href="group__util.html#ga20">utf8_char</a>*)infStr);
00995       <span class="keywordflow">return</span>;
00996     }
00997     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((vSplit.exp == expMax) &amp;&amp; !vSplit.mantissa.Eq0())
00998     {
00999       <span class="keywordtype">char</span> nanStr[5];
01000       <span class="keywordflow">if</span> (vSplit.sign)
01001       {
01002         strcpy (nanStr, <span class="stringliteral">"-"</span>);
01003       }
01004       <span class="keywordflow">else</span>
01005       {
01006         <span class="keywordflow">if</span> (currentFormat.plusSign)
01007           strcpy (nanStr, <span class="stringliteral">"+"</span>);
01008         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.spacePrefix)
01009           strcpy (nanStr, <span class="stringliteral">" "</span>);
01010         <span class="keywordflow">else</span>
01011           strcpy (nanStr, <span class="stringliteral">""</span>);
01012       }
01013       strcat (nanStr, currentFormat.uppercase ? <span class="stringliteral">"NAN"</span> : <span class="stringliteral">"nan"</span>);
01014       OutputString (writer, currentFormat, 
01015         (<a class="code" href="group__util.html#ga20">utf8_char</a>*)nanStr);
01016       <span class="keywordflow">return</span>;
01017     }
01018 
01019     <span class="keyword">const</span> size_t scratchOffs = scratch.Length();
01020     <span class="keywordflow">if</span> (vSplit.sign)
01021     {
01022       scratch.Push (<span class="charliteral">'-'</span>);
01023     }
01024     scratch.Push (<span class="charliteral">'0'</span>);
01025     scratch.Push (currentFormat.uppercase ? <span class="charliteral">'X'</span> : <span class="charliteral">'x'</span>);
01026     <span class="keywordflow">if</span> (hiddenBit)
01027     {
01028       <span class="keywordflow">if</span> (vSplit.exp == 0)
01029         scratch.Push (<span class="charliteral">'0'</span>);
01030       <span class="keywordflow">else</span>
01031         scratch.Push (<span class="charliteral">'1'</span>);
01032     }
01033     <span class="keywordflow">else</span>
01034     {
01035       <span class="keyword">const</span> <span class="keywordtype">int</span> bitNum = mantissaBits - 1;
01036       <span class="keyword">const</span> <span class="keywordtype">int</span> baseBits = <span class="keyword">sizeof</span> (uint) * 8;
01037       <span class="keyword">const</span> <span class="keywordtype">int</span> bitIndex = bitNum / baseBits;
01038       scratch.Push (<span class="charliteral">'0'</span> + ((vSplit.mantissa[bitIndex] 
01039         &gt;&gt; (bitNum % baseBits)) &amp; 1));
01040       vSplit.mantissa &lt;&lt;= 1;
01041     }
01042     <span class="keywordflow">if</span> ((currentFormat.precision &gt; 0) || (!vSplit.mantissa.Eq0()))
01043     {
01044       scratch.Push (<span class="charliteral">'.'</span>);
01045       
01046       IEEEFloatMantissa&lt;T, uint&gt; m (vSplit.mantissa);
01047       m &lt;&lt;= <span class="keyword">sizeof</span>(T)*8 - mantissaBits;
01048       <span class="keywordtype">int</span> w = 0;
01049       <span class="keywordflow">do</span>
01050       {
01051         <a class="code" href="group__util.html#ga18">uint</a> d = m.Leftmost() &gt;&gt; ((<span class="keyword">sizeof</span>(uint)*8)-4);
01052         <a class="code" href="group__util.html#ga22">utf32_char</a> ch;
01053         <span class="keywordflow">if</span> (d &lt;= 9)
01054           ch = d + <span class="charliteral">'0'</span>;
01055         <span class="keywordflow">else</span>
01056           ch = d - 10 + letterFirst;
01057         scratch.Push (ch);
01058         m &lt;&lt;= 4;
01059         w++;
01060       }
01061       <span class="keywordflow">while</span> ((w &lt; currentFormat.precision) 
01062         || ((currentFormat.precision &lt;= 0) &amp;&amp; !m.Eq0()));
01063     }
01064     scratch.Push (currentFormat.uppercase ? <span class="charliteral">'P'</span> : <span class="charliteral">'p'</span>);
01065     <span class="keywordtype">int</span> e;
01066     <span class="keywordflow">if</span> ((vSplit.exp == 0) &amp;&amp; vSplit.mantissa.Eq0())
01067       e = 0;
01068     <span class="keywordflow">else</span>
01069       e = (int)vSplit.exp + bias;
01070     <span class="keywordflow">if</span> (e &lt; 0)
01071     {
01072       scratch.Push (<span class="charliteral">'-'</span>);
01073       e = -e;
01074     }
01075     <span class="keywordflow">else</span>
01076       scratch.Push (<span class="charliteral">'+'</span>);
01077     <span class="keyword">const</span> size_t insertOffs = scratch.Length();;
01078     <span class="keywordflow">do</span>
01079     {
01080       <a class="code" href="group__util.html#ga18">uint</a> d = e % 10;
01081       scratch.Insert (insertOffs, d + <span class="charliteral">'0'</span>);
01082       e = e / 10;
01083     }
01084     <span class="keywordflow">while</span> (e != 0);
01085 
01086     DoPadding (currentFormat, scratchOffs, 
01087       vSplit.sign ? scratchOffs + 1 : scratchOffs);
01088     scratch.WriteTo (writer, scratchOffs);
01089     scratch.Truncate (scratchOffs);
01090 <span class="preprocessor">#else</span>
01091 <span class="preprocessor"></span><span class="preprocessor">  #warning Dont know how to hex-format floats for you</span>
01092 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01093 <span class="preprocessor"></span>  }
01094 <span class="keyword">public</span>:
<a name="l01096"></a><a class="code" href="classcsPrintfFormatter.html#a0">01096</a>   <a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter</a> (Treader* reader, va_list args) : reader (*reader)
01097   {
01098     Init (args);
01099   }
<a name="l01101"></a><a class="code" href="classcsPrintfFormatter.html#a1">01101</a>   <a class="code" href="classcsPrintfFormatter.html">csPrintfFormatter</a> (Treader* reader, ...) : reader (*reader)
01102   {
01103     va_list ap;
01104     va_start(ap, reader);
01105     Init (ap);
01106     va_end(ap);
01107   }
<a name="l01109"></a><a class="code" href="classcsPrintfFormatter.html#a2">01109</a>   <span class="keywordtype">void</span> Format (Twriter&amp; writer)
01110   {
01111     reader.Reset();
01112     size_t i = 0;
01113     <a class="code" href="group__util.html#ga22">utf32_char</a> ch;
01114     <span class="keywordflow">while</span> (i &lt; formatSpecs.<a class="code" href="classcsArray.html#a4">Length</a>())
01115     {
01116       <span class="keyword">const</span> FormatSpec&amp; currentFormat = formatSpecs[i];
01117       size_t n;
01118       <span class="keywordflow">for</span> (n = 0; n &lt; currentFormat.copyRun; n++)
01119       {
01120         <span class="keywordflow">if</span> (!reader.GetNext (ch)) <span class="keywordflow">break</span>;
01121         writer.<a class="code" href="classcsArray.html#a14">Put</a> (ch);
01122       }
01123 
01124       <span class="keywordflow">switch</span> (currentFormat.conversion)
01125       {
01126         <span class="keywordflow">case</span> convStr:
01127           {
01128             <span class="keywordflow">if</span> (currentFormat.type == typeLong)
01129               OutputString (writer, currentFormat, 
01130               (<span class="keywordtype">wchar_t</span>*)(params[currentFormat.paramIdx].vPtr));
01131             <span class="keywordflow">else</span>
01132               OutputString (writer, currentFormat, 
01133               (<a class="code" href="group__util.html#ga20">utf8_char</a>*)(params[currentFormat.paramIdx].vPtr));
01134           }
01135           <span class="keywordflow">break</span>;
01136         <span class="keywordflow">case</span> convChar:
01137           {
01138             writer.<a class="code" href="classcsArray.html#a14">Put</a> (params[currentFormat.paramIdx].vInt);
01139           }
01140           <span class="keywordflow">break</span>;
01141         <span class="keywordflow">case</span> convInt:
01142           {
01143             <span class="keyword">const</span> FmtParam&amp; param = params[currentFormat.paramIdx];
01144             <span class="keywordflow">switch</span> (currentFormat.type)
01145             {
01146               <span class="keywordflow">case</span> typeIntmax:
01147                 {
01148                   <a class="code" href="group__util.html#ga11">intmax_t</a> v = param.vIMT;
01149                   OutputInt (writer, currentFormat, v);
01150                 }
01151                 <span class="keywordflow">break</span>;
01152               <span class="keywordflow">case</span> typeLong:
01153                 {
01154                   <span class="keywordtype">long</span> v = param.vLong;
01155                   OutputInt (writer, currentFormat, v);
01156                 }
01157                 <span class="keywordflow">break</span>;
01158               <span class="keywordflow">case</span> typeLongLong:
01159                 {
01160                   <a class="code" href="group__util.html#ga15">longlong</a> v = param.vLL;
01161                   OutputInt (writer, currentFormat, v);
01162                 }
01163                 <span class="keywordflow">break</span>;
01164               <span class="keywordflow">case</span> typePtrDiffT:
01165                 {
01166                   <a class="code" href="group__util.html#ga10">ptrdiff_t</a> v = param.vPDT;
01167                   OutputInt (writer, currentFormat, v);
01168                 }
01169                 <span class="keywordflow">break</span>;
01170               <span class="keywordflow">case</span> typeSizeT:
01171                 {
01172                   size_t v = param.vSzT;
01173                   OutputInt (writer, currentFormat, v);
01174                 }
01175                 <span class="keywordflow">break</span>;
01176               <span class="keywordflow">default</span>:
01177                 {
01178                   <span class="keywordtype">int</span> v = param.vInt;
01179                   OutputInt (writer, currentFormat, v);
01180                 }
01181                 <span class="keywordflow">break</span>;
01182             }
01183           }
01184           <span class="keywordflow">break</span>;
01185         <span class="keywordflow">case</span> convHex:
01186         <span class="keywordflow">case</span> convUint:
01187         <span class="keywordflow">case</span> convOctal:
01188           {
01189             <a class="code" href="group__util.html#ga18">uint</a> uiradix;
01190             <span class="keyword">const</span> <span class="keywordtype">char</span>* prefix;
01191             <span class="keywordflow">if</span> (currentFormat.conversion == convHex)
01192             {
01193               uiradix = 16;
01194               prefix = currentFormat.basePrefix 
01195                 ? (currentFormat.uppercase ? <span class="stringliteral">"0X"</span> : <span class="stringliteral">"0x"</span>) : 0;
01196             }
01197             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentFormat.conversion == convOctal)
01198             {
01199               uiradix = 8;
01200               prefix = currentFormat.basePrefix ? <span class="stringliteral">"0"</span> : 0;
01201             }
01202             <span class="keywordflow">else</span>
01203             {
01204               uiradix = 10;
01205               prefix = 0;
01206             }
01207             <span class="keyword">const</span> FmtParam&amp; param = params[currentFormat.paramIdx];
01208             <span class="keywordflow">switch</span> (currentFormat.type)
01209             {
01210               <span class="keywordflow">case</span> typeIntmax:
01211                 {
01212                   <a class="code" href="group__util.html#ga11">intmax_t</a> v = param.vIMT;
01213                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01214                 }
01215                 <span class="keywordflow">break</span>;
01216               <span class="keywordflow">case</span> typeLong:
01217                 {
01218                   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> v = param.vLong;
01219                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01220                 }
01221                 <span class="keywordflow">break</span>;
01222               <span class="keywordflow">case</span> typeLongLong:
01223                 {
01224                   <a class="code" href="group__util.html#ga16">ulonglong</a> v = param.vLL;
01225                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01226                 }
01227                 <span class="keywordflow">break</span>;
01228               <span class="keywordflow">case</span> typePtrDiffT:
01229                 {
01230                   <a class="code" href="group__util.html#ga10">ptrdiff_t</a> v = param.vPDT;
01231                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01232                 }
01233                 <span class="keywordflow">break</span>;
01234               <span class="keywordflow">case</span> typeSizeT:
01235                 {
01236                   size_t v = param.vSzT;
01237                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01238                 }
01239                 <span class="keywordflow">break</span>;
01240               <span class="keywordflow">default</span>:
01241                 {
01242                   <a class="code" href="group__util.html#ga18">uint</a> v = param.vInt;
01243                   OutputUint (writer, currentFormat, v, uiradix, prefix);
01244                 }
01245                 <span class="keywordflow">break</span>;
01246             }
01247           }
01248           <span class="keywordflow">break</span>;
01249         <span class="keywordflow">case</span> convGetNum:
01250           *((<span class="keywordtype">int</span>*)(params[currentFormat.paramIdx].vPtr)) = writer.GetTotal();
01251           <span class="keywordflow">break</span>;
01252         <span class="keywordflow">case</span> convErrno:
01253           OutputString (writer, currentFormat, 
01254             (<a class="code" href="group__util.html#ga20">utf8_char</a>*)strerror (params[currentFormat.paramIdx].vInt));
01255           <span class="keywordflow">break</span>;
01256         <span class="keywordflow">case</span> convPtr:
01257           {
01258             FormatSpec fakeFormat;
01259             fakeFormat.leftJustify = currentFormat.leftJustify;
01260             fakeFormat.precision = <span class="keyword">sizeof</span> (uintptr_t) * 2;
01261             <span class="keywordflow">if</span> (params[currentFormat.paramIdx].vPtr == 0)
01262             {
01263               OutputString (writer, fakeFormat, (<a class="code" href="group__util.html#ga20">utf8_char</a>*)<span class="stringliteral">"(null)"</span>);
01264             }
01265             <span class="keywordflow">else</span>
01266             {
01267               OutputUint (writer, fakeFormat, 
01268                 (<a class="code" href="group__util.html#ga9">uintptr_t</a>)params[currentFormat.paramIdx].vPtr, 16, <span class="stringliteral">"0x"</span>);
01269             }
01270           }
01271           <span class="keywordflow">break</span>;
01272         <span class="keywordflow">case</span> convFloatFix:
01273           {
01274             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01275             {
01276 <span class="preprocessor">#ifdef CS_FORMATTER_NO_LONG_DOUBLE_FORMAT</span>
01277 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01278               (<span class="keywordtype">double</span>)params[currentFormat.paramIdx].vLongDbl, <span class="stringliteral">"f"</span>);
01279 <span class="preprocessor">#else</span>
01280 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01281               params[currentFormat.paramIdx].vLongDbl, <span class="stringliteral">"Lf"</span>);
01282 <span class="preprocessor">#endif</span>
01283 <span class="preprocessor"></span>            }
01284             <span class="keywordflow">else</span>
01285               OutputFloat (writer, currentFormat, 
01286               params[currentFormat.paramIdx].vDbl, <span class="stringliteral">"f"</span>);
01287           }
01288           <span class="keywordflow">break</span>;
01289         <span class="keywordflow">case</span> convFloatExp:
01290           {
01291             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01292             {
01293 <span class="preprocessor">#ifdef CS_FORMATTER_NO_LONG_DOUBLE_FORMAT</span>
01294 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01295               (<span class="keywordtype">double</span>)params[currentFormat.paramIdx].vLongDbl, 
01296               currentFormat.uppercase ? <span class="stringliteral">"E"</span> : <span class="stringliteral">"e"</span>);
01297 <span class="preprocessor">#else</span>
01298 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01299               params[currentFormat.paramIdx].vLongDbl, 
01300               currentFormat.uppercase ? <span class="stringliteral">"LE"</span> : <span class="stringliteral">"Le"</span>);
01301 <span class="preprocessor">#endif</span>
01302 <span class="preprocessor"></span>            }
01303             <span class="keywordflow">else</span>
01304               OutputFloat (writer, currentFormat, 
01305               params[currentFormat.paramIdx].vDbl, 
01306               currentFormat.uppercase ? <span class="stringliteral">"E"</span> : <span class="stringliteral">"e"</span>);
01307           }
01308           <span class="keywordflow">break</span>;
01309         <span class="keywordflow">case</span> convFloatGeneral:
01310           {
01311             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01312             {
01313 <span class="preprocessor">#ifdef CS_FORMATTER_NO_LONG_DOUBLE_FORMAT</span>
01314 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01315               (<span class="keywordtype">double</span>)params[currentFormat.paramIdx].vLongDbl, 
01316               currentFormat.uppercase ? <span class="stringliteral">"G"</span> : <span class="stringliteral">"g"</span>);
01317 <span class="preprocessor">#else</span>
01318 <span class="preprocessor"></span>              OutputFloat (writer, currentFormat, 
01319               params[currentFormat.paramIdx].vLongDbl, 
01320               currentFormat.uppercase ? <span class="stringliteral">"LG"</span> : <span class="stringliteral">"Lg"</span>);
01321 <span class="preprocessor">#endif</span>
01322 <span class="preprocessor"></span>            }
01323             <span class="keywordflow">else</span>
01324               OutputFloat (writer, currentFormat, 
01325               params[currentFormat.paramIdx].vDbl, 
01326               currentFormat.uppercase ? <span class="stringliteral">"G"</span> : <span class="stringliteral">"g"</span>);
01327           }
01328           <span class="keywordflow">break</span>;
01329         <span class="keywordflow">case</span> convFloatHex:
01330           {
01331             <span class="keywordflow">if</span> (currentFormat.type == typeLongLong)
01332               OutputFloatHex (writer, currentFormat, 
01333               params[currentFormat.paramIdx].vLongDbl, LDBL_MANT_DIG, 
01334               csLog2 (LDBL_MAX_EXP) + 1, -(LDBL_MAX_EXP - 1));
01335             <span class="keywordflow">else</span>
01336               OutputFloatHex (writer, currentFormat, 
01337               params[currentFormat.paramIdx].vDbl, DBL_MANT_DIG, 
01338               csLog2 (DBL_MAX_EXP) + 1, -(DBL_MAX_EXP - 1));
01339           }
01340           <span class="keywordflow">break</span>;
01341         <span class="keywordflow">default</span>:
01342           <span class="keywordflow">break</span>;
01343       }
01344 
01345       <span class="keywordflow">for</span> (n = 0; n &lt; currentFormat.fmtSkip; n++)
01346       {
01347         <span class="keywordflow">if</span> (!reader.GetNext (ch)) <span class="keywordflow">break</span>;
01348       }
01349       i++;
01350     }
01351     <span class="keywordflow">while</span> (reader.GetNext (ch))
01352       writer.<a class="code" href="classcsArray.html#a14">Put</a> (ch);
01353     writer.<a class="code" href="classcsArray.html#a14">Put</a> (0);
01354   }
01355 };
01356 
01359 <span class="preprocessor">#endif // __CS_CSUTIL_FORMATTER_H__</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.9.1 
</small></address> </div></body> </html>
