<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: iMeshWrapper Struct Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.3-20050530 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>iMeshWrapper Struct Reference<br>
<small>
[<a class="el" href="group__engine3d__meshes.html">Mesh support</a>,&nbsp;<a class="el" href="group__engine3d__meshes.html">Mesh support</a>]</small>
</h1><!-- doxytag: class="iMeshWrapper" --><!-- doxytag: inherits="iBase" -->A mesh wrapper is an engine-level object that wraps around an actual mesh object (<a class="el" href="structiMeshObject.html">iMeshObject</a>).  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="mesh_8h-source.html">iengine/mesh.h</a>&gt;</code>
<p>
<p>Inheritance diagram for iMeshWrapper:
<p><center><img src="structiMeshWrapper.png" usemap="#iMeshWrapper_map" border="0" alt=""></center>
<map name="iMeshWrapper_map">
<area href="structiBase.html" alt="iBase" shape="rect" coords="0,0,95,24">
</map>
<a href="structiMeshWrapper-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiObject.html">iObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a0">QueryObject</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="structiObject.html">iObject</a> for this mesh object.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshObject.html">iMeshObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a1">GetMeshObject</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="structiMeshObject.html">iMeshObject</a>.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a2">SetMeshObject</a> (<a class="el" href="structiMeshObject.html">iMeshObject</a> *)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <a class="el" href="structiMeshObject.html">iMeshObject</a>.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiPortalContainer.html">iPortalContainer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a3">GetPortalContainer</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If this mesh is a portal container you can use <a class="el" href="structiMeshWrapper.html#a3">GetPortalContainer()</a> to get the portal container interface.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiLightingInfo.html">iLightingInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a4">GetLightingInfo</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the optional lighting information that is implemented by this mesh object.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiShadowReceiver.html">iShadowReceiver</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a5">GetShadowReceiver</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the optional shadow receiver that is implemented by this mesh object.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiShadowCaster.html">iShadowCaster</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a6">GetShadowCaster</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the optional shadow caster that is implemented by this mesh object.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__util.html#ga18">uint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a7">GetVisibilityNumber</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimization to avoid having to do SCF_QUERY_INTERFACE for <a class="el" href="structiVisibilityObject.html">iVisibilityObject</a>.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a8">GetFactory</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parent factory.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a9">SetFactory</a> (<a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> *factory)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the parent factory (this only sets a pointer).  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a10">SetLightingUpdate</a> (int flags, int num_lights)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Control how lighting updates should take place.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMovable.html">iMovable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a11">GetMovable</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the movable instance for this object.  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a12">PlaceMesh</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine will find out in which sectors a mesh object is positioned.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a13">HitBeamBBox</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if this mesh is hit by this object space vector.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a14">HitBeamOutline</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if this object is hit by this object space vector.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a15">HitBeamObject</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr, int *polygon_idx=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if this object is hit by this object space vector.  <a href="#a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a16">HitBeam</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if this object is hit by this world space vector.  <a href="#a16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a17">SetDrawCallback</a> (<a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a> *cb)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a callback which is called just before the object is drawn.  <a href="#a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a18">RemoveDrawCallback</a> (<a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a> *cb)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a draw callback.  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a19">GetDrawCallbackCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of draw callbacks.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a20">GetDrawCallback</a> (int idx) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the specified draw callback.  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a21">SetRenderPriority</a> (long rp)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The renderer will render all objects in a sector based on this number.  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a22">GetRenderPriority</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the render priority.  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a23">SetRenderPriorityRecursive</a> (long rp)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="structiMeshWrapper.html#a21">SetRenderPriority()</a> but this version will recursively set render priority for the children too.  <a href="#a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsFlags.html">csFlags</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a24">GetFlags</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get flags for this meshwrapper.  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a25">SetFlagsRecursive</a> (<a class="el" href="group__util.html#ga4">uint32</a> mask, <a class="el" href="group__util.html#ga4">uint32</a> flags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set some flags with the given mask for this mesh and all children.  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a26">SetZBufMode</a> (<a class="el" href="group__gfx3d.html#ga65">csZBufMode</a> mode)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the Z-buf drawing mode to use for this object.  <a href="#a26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__gfx3d.html#ga65">csZBufMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a27">GetZBufMode</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Z-buf drawing mode.  <a href="#a27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a28">SetZBufModeRecursive</a> (<a class="el" href="group__gfx3d.html#ga65">csZBufMode</a> mode)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="structiMeshWrapper.html#a26">SetZBufMode()</a> but this will also set the z-buf mode for the children too.  <a href="#a28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a29">HardTransform</a> (const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;t)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do a hard transform of this object.  <a href="#a29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a30">GetWorldBoundingBox</a> (<a class="el" href="classcsBox3.html">csBox3</a> &amp;cbox)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the bounding box of this object in world space.  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a31">GetTransformedBoundingBox</a> (const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;trans, <a class="el" href="classcsBox3.html">csBox3</a> &amp;cbox)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the bounding box of this object after applying a transformation to it.  <a href="#a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a32">GetScreenBoundingBox</a> (<a class="el" href="structiCamera.html">iCamera</a> *camera, <a class="el" href="classcsBox2.html">csBox2</a> &amp;sbox, <a class="el" href="classcsBox3.html">csBox3</a> &amp;cbox)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a very inaccurate bounding box of the object in screen space.  <a href="#a32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshList.html">iMeshList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a33">GetChildren</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get all the children of this mesh object.  <a href="#a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a34">GetParentContainer</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parent of this mesh.  <a href="#a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a35">SetParentContainer</a> (<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the parent of this mesh.  <a href="#a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a36">GetRadius</a> (<a class="el" href="classcsVector3.html">csVector3</a> &amp;rad, <a class="el" href="classcsVector3.html">csVector3</a> &amp;cent) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the radius of this mesh and all its children.  <a href="#a36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiLODControl.html">iLODControl</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a37">CreateStaticLOD</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a LOD control for this mesh wrapper.  <a href="#a37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a38">DestroyStaticLOD</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the LOD control for this mesh.  <a href="#a38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiLODControl.html">iLODControl</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a39">GetStaticLOD</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the LOD control for this mesh.  <a href="#a39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a40">AddMeshToStaticLOD</a> (int lod, <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *mesh)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a given child mesh at a specific lod level.  <a href="#a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a41">RemoveMeshFromStaticLOD</a> (<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *mesh)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a child mesh from all lod levels.  <a href="#a41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a42">DrawShadow</a> (<a class="el" href="structiRenderView.html">iRenderView</a> *rview, <a class="el" href="structiLight.html">iLight</a> *light)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws the shadow buffer pass.  <a href="#a42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a43">DrawLight</a> (<a class="el" href="structiRenderView.html">iRenderView</a> *rview, <a class="el" href="structiLight.html">iLight</a> *light)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws the diffuse light mesh object.  <a href="#a43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a44">CastHardwareShadow</a> (bool castShadow)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable/disable hardware based shadows alltogheter.  <a href="#a44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a45">SetDrawAfterShadow</a> (bool drawAfter)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets so that the meshobject is rendered after all fancy HW-shadow-stuff.  <a href="#a45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a46">GetDrawAfterShadow</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get if the meshobject is rendered after all fancy HW-shadow-stuff.  <a href="#a46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiShaderVariableContext.html">iShaderVariableContext</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshWrapper.html#a47">GetSVContext</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the shader variable context of the mesh object.  <a href="#a47"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A mesh wrapper is an engine-level object that wraps around an actual mesh object (<a class="el" href="structiMeshObject.html">iMeshObject</a>). 
<p>
Every mesh object in the engine is represented by a mesh wrapper, which keeps the pointer to the mesh object, its position, its name, etc. <p>
Think of the mesh wrapper as the hook that holds the mesh object in the engine. An effect of this is that the i???State interfaces (e.g. <a class="el" href="structiSprite3DState.html">iSprite3DState</a>) must be queried from the mesh *objects*, not the wrappers! <p>
Note that a mesh object should never be contained in more than one wrapper. <p>
Main creators of instances implementing this interface: <ul>
<li>
<a class="el" href="structiEngine.html#a29">iEngine::CreateSectorWallsMesh()</a> </li>
<li>
<a class="el" href="structiEngine.html#a30">iEngine::CreateThingMesh()</a> </li>
<li>
<a class="el" href="structiEngine.html#a74">iEngine::CreateMeshWrapper()</a> </li>
<li>
<a class="el" href="structiEngine.html#a78">iEngine::LoadMeshWrapper()</a> </li>
<li>
<a class="el" href="structiEngine.html#a79">iEngine::CreatePortalContainer()</a> </li>
<li>
<a class="el" href="structiEngine.html#a80">iEngine::CreatePortal()</a> </li>
<li>
<a class="el" href="structiLoader.html#a12">iLoader::LoadMeshObject()</a> </li>
</ul>
Main ways to get pointers to this interface: <ul>
<li>
<a class="el" href="structiEngine.html#a45">iEngine::FindMeshObject()</a> </li>
<li>
<a class="el" href="structiMeshList.html#a1">iMeshList::Get()</a> </li>
<li>
<a class="el" href="structiMeshList.html#a7">iMeshList::FindByName()</a> </li>
<li>
<a class="el" href="structiMeshWrapperIterator.html#a0">iMeshWrapperIterator::Next()</a> </li>
<li>
<a class="el" href="structiLoaderContext.html#a4">iLoaderContext::FindMeshObject()</a> </li>
</ul>
Main users of this interface: <ul>
<li>
<a class="el" href="structiEngine.html">iEngine</a> </li>
</ul>

<p>

<p>
Definition at line <a class="el" href="mesh_8h-source.html#l00202">202</a> of file <a class="el" href="mesh_8h-source.html">mesh.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a40"></a><!-- doxytag: member="iMeshWrapper::AddMeshToStaticLOD" ref="a40" args="(int lod, iMeshWrapper *mesh)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::AddMeshToStaticLOD           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>lod</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a given child mesh at a specific lod level. 
<p>
Note that a mesh can be at several lod levels at once.    </td>
  </tr>
</table>
<a class="anchor" name="a44"></a><!-- doxytag: member="iMeshWrapper::CastHardwareShadow" ref="a44" args="(bool castShadow)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::CastHardwareShadow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>castShadow</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable/disable hardware based shadows alltogheter. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a37"></a><!-- doxytag: member="iMeshWrapper::CreateStaticLOD" ref="a37" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiLODControl.html">iLODControl</a>* iMeshWrapper::CreateStaticLOD           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a LOD control for this mesh wrapper. 
<p>
This is relevant only if the mesh is a hierarchical mesh. The LOD control will be used to select which children are visible and which are not. Use this to create static lod.    </td>
  </tr>
</table>
<a class="anchor" name="a38"></a><!-- doxytag: member="iMeshWrapper::DestroyStaticLOD" ref="a38" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::DestroyStaticLOD           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy the LOD control for this mesh. 
<p>
After this call the hierarchical mesh will act as usual.    </td>
  </tr>
</table>
<a class="anchor" name="a43"></a><!-- doxytag: member="iMeshWrapper::DrawLight" ref="a43" args="(iRenderView *rview, iLight *light)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::DrawLight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRenderView.html">iRenderView</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rview</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiLight.html">iLight</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>light</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws the diffuse light mesh object. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a42"></a><!-- doxytag: member="iMeshWrapper::DrawShadow" ref="a42" args="(iRenderView *rview, iLight *light)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::DrawShadow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiRenderView.html">iRenderView</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rview</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiLight.html">iLight</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>light</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws the shadow buffer pass. 
<p>
This sets of the stencil for the lights    </td>
  </tr>
</table>
<a class="anchor" name="a33"></a><!-- doxytag: member="iMeshWrapper::GetChildren" ref="a33" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshList.html">iMeshList</a>* iMeshWrapper::GetChildren           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get all the children of this mesh object. 
<p>
This is used for hierarchical meshes. If you want to make a hierarchical mesh you can call GetChildren ()-&gt;Add (mesh).    </td>
  </tr>
</table>
<a class="anchor" name="a46"></a><!-- doxytag: member="iMeshWrapper::GetDrawAfterShadow" ref="a46" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iMeshWrapper::GetDrawAfterShadow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get if the meshobject is rendered after all fancy HW-shadow-stuff. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a20"></a><!-- doxytag: member="iMeshWrapper::GetDrawCallback" ref="a20" args="(int idx) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a>* iMeshWrapper::GetDrawCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>idx</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the specified draw callback. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a19"></a><!-- doxytag: member="iMeshWrapper::GetDrawCallbackCount" ref="a19" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int iMeshWrapper::GetDrawCallbackCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the number of draw callbacks. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a8"></a><!-- doxytag: member="iMeshWrapper::GetFactory" ref="a8" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a>* iMeshWrapper::GetFactory           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the parent factory. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a24"></a><!-- doxytag: member="iMeshWrapper::GetFlags" ref="a24" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsFlags.html">csFlags</a>&amp; iMeshWrapper::GetFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get flags for this meshwrapper. 
<p>
The following flags are supported: <ul>
<li>
CS_ENTITY_CONVEX: entity is convex. This can help the engine with optimizing rendering. Currently not used. </li>
<li>
<a class="el" href="group__engine3d__meshes.html#ga0">CS_ENTITY_DETAIL</a>: this is a detail object. Again this is a hint for the engine to render this object differently. Currently not used. </li>
<li>
<a class="el" href="group__engine3d__meshes.html#ga1">CS_ENTITY_CAMERA</a>: entity will always be centered around the camera. </li>
<li>
<a class="el" href="group__engine3d__meshes.html#ga2">CS_ENTITY_INVISIBLEMESH</a>: entity is not rendered. </li>
<li>
<a class="el" href="group__engine3d__meshes.html#ga6">CS_ENTITY_NOHITBEAM</a>: this entity will not be considered by <a class="el" href="structiMeshWrapper.html#a16">HitBeam()</a> calls. </li>
<li>
<a class="el" href="group__engine3d__meshes.html#ga3">CS_ENTITY_INVISIBLE</a>: means that either CS_ENTITY_INVISIBLEMESH and CS_ENTITY_NOHITBEAM are set. </li>
<li>
<a class="el" href="group__engine3d__meshes.html#ga4">CS_ENTITY_NOSHADOWS</a>: cast no shadows. </li>
<li>
<a class="el" href="group__engine3d__meshes.html#ga5">CS_ENTITY_NOLIGHTING</a>: do not light this object. </li>
<li>
<a class="el" href="group__engine3d__meshes.html#ga7">CS_ENTITY_NOCLIP</a>: do not clip this object. </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a4"></a><!-- doxytag: member="iMeshWrapper::GetLightingInfo" ref="a4" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiLightingInfo.html">iLightingInfo</a>* iMeshWrapper::GetLightingInfo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the optional lighting information that is implemented by this mesh object. 
<p>
If the mesh object doesn't implement it then this will return 0. This is similar (but more efficient) to calling SCF_QUERY_INTERFACE on the mesh object for <a class="el" href="structiLightingInfo.html">iLightingInfo</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1"></a><!-- doxytag: member="iMeshWrapper::GetMeshObject" ref="a1" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshObject.html">iMeshObject</a>* iMeshWrapper::GetMeshObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the <a class="el" href="structiMeshObject.html">iMeshObject</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a11"></a><!-- doxytag: member="iMeshWrapper::GetMovable" ref="a11" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMovable.html">iMovable</a>* iMeshWrapper::GetMovable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the movable instance for this object. 
<p>
It is very important to call <a class="el" href="structiMeshWrapper.html#a11">GetMovable()</a>-&gt;UpdateMove() after doing any kind of modification to this movable to make sure that internal data structures are correctly updated.    </td>
  </tr>
</table>
<a class="anchor" name="a34"></a><!-- doxytag: member="iMeshWrapper::GetParentContainer" ref="a34" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>* iMeshWrapper::GetParentContainer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the parent of this mesh. 
<p>
Returns 0 if the mesh has no parent (i.e. it is contained in the engine directly). If not 0 then this mesh is part of a hierarchical mesh.    </td>
  </tr>
</table>
<a class="anchor" name="a3"></a><!-- doxytag: member="iMeshWrapper::GetPortalContainer" ref="a3" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiPortalContainer.html">iPortalContainer</a>* iMeshWrapper::GetPortalContainer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If this mesh is a portal container you can use <a class="el" href="structiMeshWrapper.html#a3">GetPortalContainer()</a> to get the portal container interface. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a36"></a><!-- doxytag: member="iMeshWrapper::GetRadius" ref="a36" args="(csVector3 &amp;rad, csVector3 &amp;cent) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::GetRadius           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rad</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>cent</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the radius of this mesh and all its children. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a22"></a><!-- doxytag: member="iMeshWrapper::GetRenderPriority" ref="a22" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual long iMeshWrapper::GetRenderPriority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the render priority. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a32"></a><!-- doxytag: member="iMeshWrapper::GetScreenBoundingBox" ref="a32" args="(iCamera *camera, csBox2 &amp;sbox, csBox3 &amp;cbox)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual float iMeshWrapper::GetScreenBoundingBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiCamera.html">iCamera</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>camera</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsBox2.html">csBox2</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>sbox</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsBox3.html">csBox3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>cbox</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a very inaccurate bounding box of the object in screen space. 
<p>
Returns -1 if object behind the camera or else the distance between the camera and the furthest point of the 3D box.    </td>
  </tr>
</table>
<a class="anchor" name="a6"></a><!-- doxytag: member="iMeshWrapper::GetShadowCaster" ref="a6" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiShadowCaster.html">iShadowCaster</a>* iMeshWrapper::GetShadowCaster           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the optional shadow caster that is implemented by this mesh object. 
<p>
If the mesh object doesn't implement it then this will return 0. This is similar (but more efficient) to calling SCF_QUERY_INTERFACE on the mesh object for <a class="el" href="structiShadowCaster.html">iShadowCaster</a>. <p>
Note! If the mesh is a static lod mesh (i.e. a parent of a mesh hierarchy that is used for static lod) then this will return a shadow caster that gets shadows from the highest detail objects.    </td>
  </tr>
</table>
<a class="anchor" name="a5"></a><!-- doxytag: member="iMeshWrapper::GetShadowReceiver" ref="a5" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiShadowReceiver.html">iShadowReceiver</a>* iMeshWrapper::GetShadowReceiver           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the optional shadow receiver that is implemented by this mesh object. 
<p>
If the mesh object doesn't implement it then this will return 0. This is similar (but more efficient) to calling SCF_QUERY_INTERFACE on the mesh object for <a class="el" href="structiShadowReceiver.html">iShadowReceiver</a>. <p>
Note! If the mesh is a static lod mesh (i.e. a parent of a mesh hierarchy that is used for static lod) then this will return a shadow receiver that automatically multiplexes the receiving shadows to all child meshes.    </td>
  </tr>
</table>
<a class="anchor" name="a39"></a><!-- doxytag: member="iMeshWrapper::GetStaticLOD" ref="a39" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiLODControl.html">iLODControl</a>* iMeshWrapper::GetStaticLOD           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the LOD control for this mesh. 
<p>
This will return 0 if this is a normal (hierarchical) mesh. Otherwise it will return an object with which you can control the static LOD of this object.    </td>
  </tr>
</table>
<a class="anchor" name="a47"></a><!-- doxytag: member="iMeshWrapper::GetSVContext" ref="a47" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiShaderVariableContext.html">iShaderVariableContext</a>* iMeshWrapper::GetSVContext           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the shader variable context of the mesh object. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a31"></a><!-- doxytag: member="iMeshWrapper::GetTransformedBoundingBox" ref="a31" args="(const csReversibleTransform &amp;trans, csBox3 &amp;cbox)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::GetTransformedBoundingBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsBox3.html">csBox3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>cbox</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the bounding box of this object after applying a transformation to it. 
<p>
This is really a very inaccurate function as it will take the bounding box of the object in object space and then transform this bounding box.    </td>
  </tr>
</table>
<a class="anchor" name="a7"></a><!-- doxytag: member="iMeshWrapper::GetVisibilityNumber" ref="a7" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__util.html#ga18">uint</a> iMeshWrapper::GetVisibilityNumber           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimization to avoid having to do SCF_QUERY_INTERFACE for <a class="el" href="structiVisibilityObject.html">iVisibilityObject</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a30"></a><!-- doxytag: member="iMeshWrapper::GetWorldBoundingBox" ref="a30" args="(csBox3 &amp;cbox)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::GetWorldBoundingBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsBox3.html">csBox3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cbox</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the bounding box of this object in world space. 
<p>
This routine will cache the bounding box and only recalculate it if the movable changes.    </td>
  </tr>
</table>
<a class="anchor" name="a27"></a><!-- doxytag: member="iMeshWrapper::GetZBufMode" ref="a27" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__gfx3d.html#ga65">csZBufMode</a> iMeshWrapper::GetZBufMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the Z-buf drawing mode. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a29"></a><!-- doxytag: member="iMeshWrapper::HardTransform" ref="a29" args="(const csReversibleTransform &amp;t)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::HardTransform           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>t</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do a hard transform of this object. 
<p>
This transformation and the original coordinates are not remembered but the object space coordinates are directly computed (world space coordinates are set to the object space coordinates by this routine). Note that some implementations of mesh objects will not change the orientation of the object but only the position. <p>
Note also that some mesh objects don't support HardTransform. You can find out by calling iMeshObject-&gt;SupportsHardTransform(). In that case you can sometimes still call <a class="el" href="structiMeshWrapper.html#a29">HardTransform()</a> on the factory.    </td>
  </tr>
</table>
<a class="anchor" name="a16"></a><!-- doxytag: member="iMeshWrapper::HitBeam" ref="a16" args="(const csVector3 &amp;start, const csVector3 &amp;end, csVector3 &amp;isect, float *pr)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iMeshWrapper::HitBeam           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>isect</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap> <em>pr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if this object is hit by this world space vector. 
<p>
Return the collision point in world space coordinates.    </td>
  </tr>
</table>
<a class="anchor" name="a13"></a><!-- doxytag: member="iMeshWrapper::HitBeamBBox" ref="a13" args="(const csVector3 &amp;start, const csVector3 &amp;end, csVector3 &amp;isect, float *pr)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int iMeshWrapper::HitBeamBBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>isect</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap> <em>pr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if this mesh is hit by this object space vector. 
<p>
This will do a rough but fast test based on bounding box only. So this means that it might return a hit even though the object isn't really hit at all. Depends on how much the bounding box overestimates the object. This also returns the face number as defined in <a class="el" href="classcsBox3.html">csBox3</a> on which face the hit occured. Useful for grid structures.    </td>
  </tr>
</table>
<a class="anchor" name="a15"></a><!-- doxytag: member="iMeshWrapper::HitBeamObject" ref="a15" args="(const csVector3 &amp;start, const csVector3 &amp;end, csVector3 &amp;isect, float *pr, int *polygon_idx=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iMeshWrapper::HitBeamObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>isect</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap> <em>pr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>polygon_idx</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if this object is hit by this object space vector. 
<p>
Return the collision point in object space coordinates. This version is more accurate than HitBeamOutline.    </td>
  </tr>
</table>
<a class="anchor" name="a14"></a><!-- doxytag: member="iMeshWrapper::HitBeamOutline" ref="a14" args="(const csVector3 &amp;start, const csVector3 &amp;end, csVector3 &amp;isect, float *pr)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iMeshWrapper::HitBeamOutline           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>isect</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap> <em>pr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if this object is hit by this object space vector. 
<p>
Outline check.    </td>
  </tr>
</table>
<a class="anchor" name="a12"></a><!-- doxytag: member="iMeshWrapper::PlaceMesh" ref="a12" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::PlaceMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine will find out in which sectors a mesh object is positioned. 
<p>
To use it the mesh has to be placed in one starting sector. This routine will then start from that sector, find all portals that touch the sprite and add all additional sectors from those portals. Note that this routine using a bounding sphere for this test so it is possible that the mesh will be added to sectors where it really isn't located (but the sphere is). <p>
If the mesh is already in several sectors those additional sectors will be ignored and only the first one will be used for this routine. <p>
Placing a mesh in different sectors is important when the mesh crosses a portal boundary. If you don't do this then it is possible that the mesh will be clipped wrong. For small mesh objects you can get away by not doing this in most cases.    </td>
  </tr>
</table>
<a class="anchor" name="a0"></a><!-- doxytag: member="iMeshWrapper::QueryObject" ref="a0" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiObject.html">iObject</a>* iMeshWrapper::QueryObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the <a class="el" href="structiObject.html">iObject</a> for this mesh object. 
<p>
This can be used to get the name of the mesh wrapper and also to attach other user objects to this mesh (like for collision detection or game data).    </td>
  </tr>
</table>
<a class="anchor" name="a18"></a><!-- doxytag: member="iMeshWrapper::RemoveDrawCallback" ref="a18" args="(iMeshDrawCallback *cb)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::RemoveDrawCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a draw callback. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a41"></a><!-- doxytag: member="iMeshWrapper::RemoveMeshFromStaticLOD" ref="a41" args="(iMeshWrapper *mesh)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::RemoveMeshFromStaticLOD           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mesh</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a child mesh from all lod levels. 
<p>
The mesh is not removed from the list of child meshes however.    </td>
  </tr>
</table>
<a class="anchor" name="a45"></a><!-- doxytag: member="iMeshWrapper::SetDrawAfterShadow" ref="a45" args="(bool drawAfter)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetDrawAfterShadow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>drawAfter</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets so that the meshobject is rendered after all fancy HW-shadow-stuff. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a17"></a><!-- doxytag: member="iMeshWrapper::SetDrawCallback" ref="a17" args="(iMeshDrawCallback *cb)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetDrawCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshDrawCallback.html">iMeshDrawCallback</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a callback which is called just before the object is drawn. 
<p>
This is useful to do some expensive computations which only need to be done on a visible object. Note that this function will be called even if the object is not visible. In general it is called if there is a likely probability that the object is visible (i.e. it is in the same sector as the camera for example).    </td>
  </tr>
</table>
<a class="anchor" name="a9"></a><!-- doxytag: member="iMeshWrapper::SetFactory" ref="a9" args="(iMeshFactoryWrapper *factory)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetFactory           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshFactoryWrapper.html">iMeshFactoryWrapper</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>factory</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the parent factory (this only sets a pointer). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a25"></a><!-- doxytag: member="iMeshWrapper::SetFlagsRecursive" ref="a25" args="(uint32 mask, uint32 flags)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetFlagsRecursive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__util.html#ga4">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__util.html#ga4">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set some flags with the given mask for this mesh and all children. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a10"></a><!-- doxytag: member="iMeshWrapper::SetLightingUpdate" ref="a10" args="(int flags, int num_lights)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetLightingUpdate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_lights</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Control how lighting updates should take place. 
<p>
'num_lights' is the number of lights that will be given to the mesh object at maximum (default is 8). 'flags' can be a combination of one of the following: <ul>
<li>
<a class="el" href="group__engine3d__meshes.html#ga8">CS_LIGHTINGUPDATE_SORTRELEVANCE</a> (default on). </li>
<li>
<a class="el" href="group__engine3d__meshes.html#ga9">CS_LIGHTINGUPDATE_ALWAYSUPDATE</a> (default off). </li>
</ul>
Note that this function has no effect on thing mesh objects as they use another lighting system (lightmaps). Also some genmesh objects can optionally also use the other lighting system in which nothing will happen either.    </td>
  </tr>
</table>
<a class="anchor" name="a2"></a><!-- doxytag: member="iMeshWrapper::SetMeshObject" ref="a2" args="(iMeshObject *)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetMeshObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshObject.html">iMeshObject</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the <a class="el" href="structiMeshObject.html">iMeshObject</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a35"></a><!-- doxytag: member="iMeshWrapper::SetParentContainer" ref="a35" args="(iMeshWrapper *)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetParentContainer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the parent of this mesh. 
<p>
This only changes the 'parent' pointer but does not add the mesh as a child mesh. Internal use only.    </td>
  </tr>
</table>
<a class="anchor" name="a21"></a><!-- doxytag: member="iMeshWrapper::SetRenderPriority" ref="a21" args="(long rp)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetRenderPriority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The renderer will render all objects in a sector based on this number. 
<p>
Low numbers get rendered first. High numbers get rendered later. There are a few often used slots: <ul>
<li>
1. Sky objects are rendered before everything else. Usually they are rendered using ZFILL (or ZNONE). </li>
<li>
2. Walls are rendered after that. They usually use ZFILL. </li>
<li>
3. After that normal objects are rendered using the Z-buffer (ZUSE). </li>
<li>
4. Alpha transparent objects or objects using some other transparency system are rendered after that. They are usually rendered using ZTEST. </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a23"></a><!-- doxytag: member="iMeshWrapper::SetRenderPriorityRecursive" ref="a23" args="(long rp)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetRenderPriorityRecursive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="structiMeshWrapper.html#a21">SetRenderPriority()</a> but this version will recursively set render priority for the children too. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a26"></a><!-- doxytag: member="iMeshWrapper::SetZBufMode" ref="a26" args="(csZBufMode mode)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetZBufMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gfx3d.html#ga65">csZBufMode</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mode</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the Z-buf drawing mode to use for this object. 
<p>
Possible values are: <ul>
<li>
<a class="el" href="group__gfx3d.html#gga65a44">CS_ZBUF_NONE</a>: do not read nor write the Z-buffer. </li>
<li>
<a class="el" href="group__gfx3d.html#gga65a45">CS_ZBUF_FILL</a>: only write the Z-buffer but do not read. </li>
<li>
<a class="el" href="group__gfx3d.html#gga65a47">CS_ZBUF_USE</a>: write and read the Z-buffer. </li>
<li>
<a class="el" href="group__gfx3d.html#gga65a46">CS_ZBUF_TEST</a>: only read the Z-buffer but do not write. </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a28"></a><!-- doxytag: member="iMeshWrapper::SetZBufModeRecursive" ref="a28" args="(csZBufMode mode)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshWrapper::SetZBufModeRecursive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gfx3d.html#ga65">csZBufMode</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mode</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="structiMeshWrapper.html#a26">SetZBufMode()</a> but this will also set the z-buf mode for the children too. 
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>iengine/<a class="el" href="mesh_8h-source.html">mesh.h</a></ul>
<hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.3-20050530 
</small></address> </div></body> </html>
