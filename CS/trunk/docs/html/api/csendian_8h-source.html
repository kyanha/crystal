<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>csutil/csendian.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://crystal.sourceforge.net/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>csutil/csendian.h</h1><a href="csendian_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 1998 by Jorrit Tyberghein</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="preprocessor">#ifndef __CS_CSENDIAN_H__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __CS_CSENDIAN_H__</span>
00021 <span class="preprocessor"></span>
00029 <span class="preprocessor">#include &lt;math.h&gt;</span>
00030 <span class="preprocessor">#include "<a class="code" href="cstypes_8h.html">cstypes.h</a>"</span>
00031 <span class="preprocessor">#include "<a class="code" href="csqint_8h.html">csqint.h</a>"</span>
00032 
00033 <span class="preprocessor">#define csQroundSure(x) (int ((x) + ((x &lt; 0) ? -0.5 : +0.5)))</span>
00034 <span class="preprocessor"></span>
00035 <span class="keyword">struct </span>csEndianSwap4
00036 {
00037   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b1, b2, b3, b4;
00038 };
00039 
00040 <span class="keyword">struct </span>csEndianSwap8
00041 {
00042   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b1, b2, b3, b4,
00043                 b5, b6, b7, b8;
00044 };
00045 
00046 <span class="preprocessor">#ifdef CS_BIG_ENDIAN</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_longlong(x) x</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_long(x)  x</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_short(x) x</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#  define big_endian_float(x) x</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00052 <span class="preprocessor"></span>
<a name="l00054"></a><a class="code" href="group__util.html#a19">00054</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint64 <a class="code" href="group__util.html#a19">big_endian_longlong</a> (uint64 l)
00055 {
00056   uint64 r;
00057   csEndianSwap8 *p1 = (csEndianSwap8 *)&amp;l;
00058   csEndianSwap8 *p2 = (csEndianSwap8 *)&amp;r;
00059   p2-&gt;b1 = p1-&gt;b8;
00060   p2-&gt;b2 = p1-&gt;b7;
00061   p2-&gt;b3 = p1-&gt;b6;
00062   p2-&gt;b4 = p1-&gt;b5;
00063   p2-&gt;b5 = p1-&gt;b4;
00064   p2-&gt;b6 = p1-&gt;b3;
00065   p2-&gt;b7 = p1-&gt;b2;
00066   p2-&gt;b8 = p1-&gt;b1;
00067   <span class="keywordflow">return</span> r;
00068 }
00069 
00070 
<a name="l00072"></a><a class="code" href="group__util.html#a20">00072</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a20">big_endian_long</a> (uint32 l)
00073 { <span class="keywordflow">return</span> (l &gt;&gt; 24) | ((l &gt;&gt; 8) &amp; 0xff00) | ((l &lt;&lt; 8) &amp; 0xff0000) | (l &lt;&lt; 24); }
00074 
<a name="l00076"></a><a class="code" href="group__util.html#a21">00076</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a21">big_endian_short</a> (<a class="code" href="group__util.html#a2">uint16</a> s)
00077 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a2">uint16</a>((s &gt;&gt; 8) | (s &lt;&lt; 8)); }
00078 
<a name="l00080"></a><a class="code" href="group__util.html#a22">00080</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a22">big_endian_float</a> (<span class="keywordtype">float</span> f)
00081 {
00082   <span class="comment">//@@WARNING: Should be removed -- use float2long instead</span>
00083   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp;
00084   csEndianSwap4 *pf = (csEndianSwap4 *)&amp;f;
00085   tmp = pf-&gt;b1; pf-&gt;b1 = pf-&gt;b4; pf-&gt;b4 = tmp;
00086   tmp = pf-&gt;b2; pf-&gt;b2 = pf-&gt;b3; pf-&gt;b3 = tmp;
00087   <span class="keywordflow">return</span> f;
00088 }
00089 
00090 <span class="preprocessor">#endif // CS_BIG_ENDIAN</span>
00091 <span class="preprocessor"></span>
00092 <span class="preprocessor">#ifdef CS_LITTLE_ENDIAN</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_longlong(x) x</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_long(x)  x</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_short(x) x</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#  define little_endian_float(x) x</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00098 <span class="preprocessor"></span>
<a name="l00100"></a><a class="code" href="group__util.html#a23">00100</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint64 <a class="code" href="group__util.html#a23">little_endian_longlong</a> (uint64 l)
00101 {
00102   uint64 r;
00103   csEndianSwap8 *p1 = (csEndianSwap8 *)&amp;l;
00104   csEndianSwap8 *p2 = (csEndianSwap8 *)&amp;r;
00105   p2-&gt;b1 = p1-&gt;b8;
00106   p2-&gt;b2 = p1-&gt;b7;
00107   p2-&gt;b3 = p1-&gt;b6;
00108   p2-&gt;b4 = p1-&gt;b5;
00109   p2-&gt;b5 = p1-&gt;b4;
00110   p2-&gt;b6 = p1-&gt;b3;
00111   p2-&gt;b7 = p1-&gt;b2;
00112   p2-&gt;b8 = p1-&gt;b1;
00113   <span class="keywordflow">return</span> r;
00114 }
00115 
<a name="l00117"></a><a class="code" href="group__util.html#a24">00117</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a24">little_endian_long</a> (uint32 l)
00118 { <span class="keywordflow">return</span> (l &gt;&gt; 24) | ((l &gt;&gt; 8) &amp; 0xff00) | ((l &lt;&lt; 8) &amp; 0xff0000) | (l &lt;&lt; 24); }
00119 
<a name="l00121"></a><a class="code" href="group__util.html#a25">00121</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a25">little_endian_short</a> (<a class="code" href="group__util.html#a2">uint16</a> s)
00122 { <span class="keywordflow">return</span> (s &gt;&gt; 8) | (s &lt;&lt; 8); }
00123 
<a name="l00125"></a><a class="code" href="group__util.html#a26">00125</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a26">little_endian_float</a> (<span class="keywordtype">float</span> f)
00126 {
00127   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp;
00128   csEndianSwap4 *pf = (csEndianSwap4 *)&amp;f;
00129   tmp = pf-&gt;b1; pf-&gt;b1 = pf-&gt;b4; pf-&gt;b4 = tmp;
00130   tmp = pf-&gt;b2; pf-&gt;b2 = pf-&gt;b3; pf-&gt;b3 = tmp;
00131   <span class="keywordflow">return</span> f;
00132 }
00133 
00134 <span class="preprocessor">#endif // CS_LITTLE_ENDIAN</span>
00135 <span class="preprocessor"></span>
00136 <span class="comment">/*</span>
00137 <span class="comment">    To be able to painlessly transfer files betwen platforms, we should</span>
00138 <span class="comment">    avoid using native floating-point format. Here are a couple of routines</span>
00139 <span class="comment">    that are guaranteed to work on all platforms.</span>
00140 <span class="comment"></span>
00141 <span class="comment">    The floating point is converted to a fixed 1.7.25 bits format</span>
00142 <span class="comment">    (one bit sign, 7 bits exponent, 25 bits mantissa) and back,</span>
00143 <span class="comment">    so that we can binary store floating-point number without</span>
00144 <span class="comment">    cross-platform problems. If you wonder why 1+7+25 = 33 while we</span>
00145 <span class="comment">    only have 32 bits, we'll ommit the most significant bit of mantissa</span>
00146 <span class="comment">    since it is always 1 (we use normalized numbers). This increases the</span>
00147 <span class="comment">    precision twice.</span>
00148 <span class="comment"></span>
00149 <span class="comment">    For double, we use one bit sign, 15 bits exponent, 49 bits mantissa.</span>
00150 <span class="comment">*/</span>
00151 
<a name="l00153"></a><a class="code" href="group__util.html#a27">00153</a> <span class="keyword">static</span> <span class="keyword">inline</span> int32 <a class="code" href="group__util.html#a27">float2long</a> (<span class="keywordtype">float</span> f)
00154 {
00155   <span class="keywordtype">int</span> exp;
00156   int32 mant = csQroundSure (frexp (f, &amp;exp) * 0x1000000);
00157   int32 sign = mant &amp; 0x80000000;
00158   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00159   <span class="keywordflow">if</span> (exp &gt; 63) exp = 63; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -64) exp = -64;
00160   <span class="keywordflow">return</span> sign | ((exp &amp; 0x7f) &lt;&lt; 24) | (mant &amp; 0xffffff);
00161 }
00162 
<a name="l00164"></a><a class="code" href="group__util.html#a28">00164</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a28">long2float</a> (int32 l)
00165 {
00166   <span class="keywordtype">int</span> exp = (l &gt;&gt; 24) &amp; 0x7f;
00167   <span class="keywordflow">if</span> (exp &amp; 0x40) exp = exp | ~0x7f;
00168   <span class="keywordtype">float</span> mant = float (l &amp; 0x00ffffff) / 0x1000000;
00169   <span class="keywordflow">if</span> (l &amp; 0x80000000) mant = -mant;
00170   <span class="keywordflow">return</span> (float) ldexp (mant, exp);
00171 }
00172 
00173 <span class="comment">/* Implementation note: double2longlong() and longlong2double()</span>
00174 <span class="comment"> *</span>
00175 <span class="comment"> * We avoid use of CONST_INT64() because 64-bit constants are illegal with g++</span>
00176 <span class="comment"> * under -ansi -pedantic, and we want this header to be useful to external</span>
00177 <span class="comment"> * projects which use -ansi -pedantic.  Instead, we use bit shifts, such as (1</span>
00178 <span class="comment"> * &lt;&lt; 59), and construct `mask' manually.</span>
00179 <span class="comment"> */</span>
00180 
<a name="l00182"></a><a class="code" href="group__util.html#a29">00182</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a7">int64</a> <a class="code" href="group__util.html#a29">double2longlong</a> (<span class="keywordtype">double</span> d)
00183 {
00184   <span class="keywordtype">int</span> exp;
00185   <a class="code" href="group__util.html#a7">int64</a> mant = (int64) (frexp (d, &amp;exp) * ((int64)1 &lt;&lt; 48));
00186   <a class="code" href="group__util.html#a7">int64</a> sign = mant &amp; ((int64)1 &lt;&lt; 59);
00187   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00188   <span class="keywordflow">if</span> (exp &gt; 32767) exp = 32767; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -32768) exp = -32768;
00189   <a class="code" href="group__util.html#a7">int64</a> <span class="keyword">const</span> mask = ((uint64)0xffff &lt;&lt; 32) | (uint64)0xffffffff;
00190   <span class="keywordflow">return</span> sign | ((<a class="code" href="group__util.html#a7">int64</a> (exp) &amp; 0x7fff) &lt;&lt; 48) | (mant &amp; mask);
00191 }
00192 
<a name="l00194"></a><a class="code" href="group__util.html#a30">00194</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__util.html#a30">longlong2double</a> (<a class="code" href="group__util.html#a7">int64</a> i)
00195 {
00196   <span class="keywordtype">int</span> exp = (i &gt;&gt; 48) &amp; 0x7fff;
00197   <span class="keywordflow">if</span> (exp &amp; 0x4000) exp = exp | ~0x7fff;
00198   <a class="code" href="group__util.html#a7">int64</a> <span class="keyword">const</span> mask = ((uint64)0xffff &lt;&lt; 32) | (uint64)0xffffffff;
00199   <span class="keywordtype">double</span> mant = double (i &amp; mask) / ((int64)1 &lt;&lt; 48);
00200   <span class="keywordflow">if</span> (i &amp; ((int64)1 &lt;&lt; 59)) mant = -mant;
00201   <span class="keywordflow">return</span> ldexp (mant, exp);
00202 }
00203 
00213 
<a name="l00214"></a><a class="code" href="group__util.html#a31">00214</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">short</span> <a class="code" href="group__util.html#a31">float2short</a> (<span class="keywordtype">float</span> f)
00215 {
00216   <span class="keywordtype">int</span> exp;
00217   <span class="keywordtype">long</span> mant = csQroundSure (frexp (f, &amp;exp) * 0x1000);
00218   <span class="keywordtype">long</span> sign = mant &amp; 0x8000;
00219   <span class="keywordflow">if</span> (mant &lt; 0) mant = -mant;
00220   <span class="keywordflow">if</span> (exp &gt; 7) mant = 0x7ff, exp = 7; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exp &lt; -8) mant = 0, exp = -8;
00221   <span class="keywordflow">return</span> short(sign | ((exp &amp; 0xf) &lt;&lt; 11) | (mant &amp; 0x7ff));
00222 }
00223 
<a name="l00225"></a><a class="code" href="group__util.html#a32">00225</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a32">short2float</a> (<span class="keywordtype">short</span> s)
00226 {
00227   <span class="keywordtype">int</span> exp = (s &gt;&gt; 11) &amp; 0xf;
00228   <span class="keywordflow">if</span> (exp &amp; 0x8) exp = exp | ~0xf;
00229   <span class="keywordtype">float</span> mant = float ((s &amp; 0x07ff) | 0x0800) / 0x1000;
00230   <span class="keywordflow">if</span> (s &amp; 0x8000) mant = -mant;
00231   <span class="keywordflow">return</span> (float) ldexp (mant, exp);
00232 }
00233 
00236 
<a name="l00237"></a><a class="code" href="group__util.html#a33">00237</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint64 <a class="code" href="group__util.html#a39">convert_endian</a> (uint64 l)
00238 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a23">little_endian_longlong</a> (l); }
00239 
<a name="l00241"></a><a class="code" href="group__util.html#a34">00241</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a7">int64</a> <a class="code" href="group__util.html#a39">convert_endian</a> (<a class="code" href="group__util.html#a7">int64</a> l)
00242 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a23">little_endian_longlong</a> (l); }
00243 
<a name="l00245"></a><a class="code" href="group__util.html#a35">00245</a> <span class="keyword">static</span> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a39">convert_endian</a> (uint32 l)
00246 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">little_endian_long</a> (l); }
00247 
<a name="l00249"></a><a class="code" href="group__util.html#a36">00249</a> <span class="keyword">static</span> <span class="keyword">inline</span> int32 <a class="code" href="group__util.html#a39">convert_endian</a> (int32 l)
00250 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">little_endian_long</a> (l); }
00251 
<a name="l00253"></a><a class="code" href="group__util.html#a37">00253</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a3">int16</a> <a class="code" href="group__util.html#a39">convert_endian</a> (<a class="code" href="group__util.html#a3">int16</a> s)
00254 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">little_endian_short</a> (s); }
00255 
<a name="l00257"></a><a class="code" href="group__util.html#a38">00257</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a39">convert_endian</a> (<a class="code" href="group__util.html#a2">uint16</a> s)
00258 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">little_endian_short</a> (s); }
00259 
<a name="l00261"></a><a class="code" href="group__util.html#a39">00261</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a39">convert_endian</a> (<span class="keywordtype">float</span> f)
00262 { <span class="keywordflow">return</span> <a class="code" href="group__util.html#a26">little_endian_float</a> (f); }
00263 
<a name="l00265"></a><a class="code" href="group__util.html#a40">00265</a> <span class="keyword">inline</span> <a class="code" href="group__util.html#a2">uint16</a> <a class="code" href="group__util.html#a40">get_le_short</a> (<span class="keywordtype">void</span> *buff)
00266 {
00267 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00268 <span class="preprocessor"></span>  <a class="code" href="group__util.html#a2">uint16</a> s; memcpy (&amp;s, buff, <span class="keyword">sizeof</span> (s));
00269   <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">little_endian_short</a> (s);
00270 <span class="preprocessor">#else</span>
00271 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="group__util.html#a25">little_endian_short</a> (*(<a class="code" href="group__util.html#a2">uint16</a> *)buff);
00272 <span class="preprocessor">#endif</span>
00273 <span class="preprocessor"></span>}
00274 
<a name="l00276"></a><a class="code" href="group__util.html#a41">00276</a> <span class="keyword">inline</span> uint32 <a class="code" href="group__util.html#a41">get_le_long</a> (<span class="keywordtype">void</span> *buff)
00277 {
00278 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00279 <span class="preprocessor"></span>  uint32 l; memcpy (&amp;l, buff, <span class="keyword">sizeof</span> (l));
00280   <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">little_endian_long</a> (l);
00281 <span class="preprocessor">#else</span>
00282 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="group__util.html#a24">little_endian_long</a> (*(uint32 *)buff);
00283 <span class="preprocessor">#endif</span>
00284 <span class="preprocessor"></span>}
00285 
<a name="l00287"></a><a class="code" href="group__util.html#a42">00287</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a42">get_le_float32</a> (<span class="keywordtype">void</span> *buff)
00288 { uint32 l = <a class="code" href="group__util.html#a41">get_le_long</a> (buff); <span class="keywordflow">return</span> <a class="code" href="group__util.html#a28">long2float</a> (l); }
00289 
<a name="l00291"></a><a class="code" href="group__util.html#a43">00291</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__util.html#a43">get_le_float16</a> (<span class="keywordtype">void</span> *buff)
00292 { <a class="code" href="group__util.html#a2">uint16</a> s = <a class="code" href="group__util.html#a40">get_le_short</a> (buff); <span class="keywordflow">return</span> <a class="code" href="group__util.html#a32">short2float</a> (s); }
00293 
<a name="l00295"></a><a class="code" href="group__util.html#a44">00295</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a44">set_le_short</a> (<span class="keywordtype">void</span> *buff, <a class="code" href="group__util.html#a2">uint16</a> s)
00296 {
00297 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00298 <span class="preprocessor"></span>  s = <a class="code" href="group__util.html#a25">little_endian_short</a> (s);
00299   memcpy (buff, &amp;s, <span class="keyword">sizeof</span> (s));
00300 <span class="preprocessor">#else</span>
00301 <span class="preprocessor"></span>  *((<a class="code" href="group__util.html#a2">uint16</a> *)buff) = <a class="code" href="group__util.html#a25">little_endian_short</a> (s);
00302 <span class="preprocessor">#endif</span>
00303 <span class="preprocessor"></span>}
00304 
<a name="l00306"></a><a class="code" href="group__util.html#a45">00306</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a45">set_le_long</a> (<span class="keywordtype">void</span> *buff, uint32 l)
00307 {
00308 <span class="preprocessor">#ifdef CS_STRICT_ALIGNMENT</span>
00309 <span class="preprocessor"></span>  l = <a class="code" href="group__util.html#a24">little_endian_long</a> (l);
00310   memcpy (buff, &amp;l, <span class="keyword">sizeof</span> (l));
00311 <span class="preprocessor">#else</span>
00312 <span class="preprocessor"></span>  *((uint32 *)buff) = <a class="code" href="group__util.html#a24">little_endian_long</a> (l);
00313 <span class="preprocessor">#endif</span>
00314 <span class="preprocessor"></span>}
00315 
<a name="l00317"></a><a class="code" href="group__util.html#a46">00317</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a46">set_le_float32</a> (<span class="keywordtype">void</span> *buff, <span class="keywordtype">float</span> f)
00318 { <a class="code" href="group__util.html#a45">set_le_long</a> (buff, <a class="code" href="group__util.html#a27">float2long</a> (f)); }
00319 
<a name="l00321"></a><a class="code" href="group__util.html#a47">00321</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__util.html#a47">set_le_float16</a> (<span class="keywordtype">void</span> *buff, <span class="keywordtype">float</span> f)
00322 { <a class="code" href="group__util.html#a44">set_le_short</a> (buff, <a class="code" href="group__util.html#a31">float2short</a> (f)); }
00323 
00326 <span class="preprocessor">#endif // __CS_CSENDIAN_H__</span>
</pre></div><hr><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.2.18 
</small></address> </div></body> </html>
