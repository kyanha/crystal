<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/bitarray.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000022.html">csutil</a></div>
<h1>bitarray.h</h1><a href="bitarray_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright (C) 2000 by Andrew Kirmse</span>
00003 <span class="comment"></span>
00004 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">    modify it under the terms of the GNU Library General Public</span>
00006 <span class="comment">    License as published by the Free Software Foundation; either</span>
00007 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">    Library General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    You should have received a copy of the GNU Library General Public</span>
00015 <span class="comment">    License along with this library; if not, write to the Free</span>
00016 <span class="comment">    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 <span class="comment">// A one-dimensional array of bits, similar to STL bitset.</span>
00020 <span class="comment">//</span>
00021 <span class="comment">// Copyright 2000 Andrew Kirmse.  All rights reserved.</span>
00022 <span class="comment">//</span>
00023 <span class="comment">// Permission is granted to use this code for any purpose, as long as this</span>
00024 <span class="comment">// copyright message remains intact.</span>
00025 
00026 <span class="preprocessor">#ifndef __CS_BITARRAY_H__</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define __CS_BITARRAY_H__</span>
00028 <span class="preprocessor"></span>
00033 <span class="preprocessor">#include "csextern.h"</span>
00034 <span class="preprocessor">#include "<a class="code" href="comparator_8h.html">comparator.h</a>"</span>
00035 <span class="preprocessor">#include "<a class="code" href="hash_8h.html">hash.h</a>"</span>
00036 
00037 <span class="keyword">class </span><a class="code" href="classcsBitArray.html">csBitArray</a>;
00038 CS_SPECIALIZE_TEMPLATE <span class="keyword">class </span><a class="code" href="classcsComparator.html">csComparator</a>&lt;csBitArray, csBitArray&gt;;
00039 CS_SPECIALIZE_TEMPLATE <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;csBitArray&gt;;
00040 
<a name="l00044"></a><a class="code" href="classcsBitArray.html">00044</a> <span class="keyword">class </span>CS_CRYSTALSPACE_EXPORT csBitArray
00045 {
00046 <span class="keyword">public</span>:
00047   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> store_type;
00048 
00049 <span class="keyword">private</span>:
00050   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsComparator.html">csComparator</a>&lt;csBitArray, csBitArray&gt;;
00051   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;csBitArray&gt;;
00052   <span class="keyword">enum</span>
00053   {
00054     bits_per_byte = 8,
00055     cell_size     = <span class="keyword">sizeof</span>(store_type) * bits_per_byte
00056   };
00057 
00058   store_type* mpStore;
00059   store_type  mSingleWord; <span class="comment">// Use this buffer when mLength is 1</span>
00060   size_t mLength;          <span class="comment">// Length of mpStore in units of store_type</span>
00061   size_t mNumBits;
00062 
00064   <span class="keyword">static</span> size_t GetIndex (size_t bit_num)
00065   {
00066     <span class="keywordflow">return</span> bit_num / cell_size;
00067   }
00068 
00070   <span class="keyword">static</span> size_t GetOffset (size_t bit_num)
00071   {
00072     <span class="keywordflow">return</span> bit_num % cell_size;
00073   }
00074 
00079   store_type <span class="keyword">const</span>* GetStore()<span class="keyword"> const</span>
00080 <span class="keyword">  </span>{
00081     <span class="keywordflow">return</span> mLength &lt;= 1 ? &amp;mSingleWord : mpStore;
00082   }
00083 
00088   store_type* GetStore()
00089   {
00090     <span class="keywordflow">return</span> mLength &lt;= 1 ? &amp;mSingleWord : mpStore;
00091   }
00092 
00094   <span class="keywordtype">void</span> Trim()
00095   {
00096     size_t extra_bits = mNumBits % cell_size;
00097     <span class="keywordflow">if</span> (mLength &gt; 0 &amp;&amp; extra_bits != 0)
00098       GetStore()[mLength - 1] &amp;= ~((~(store_type)0) &lt;&lt; extra_bits);
00099   }
00100 
00105   <span class="keywordtype">void</span> SetSize (size_t newSize)
00106   {
00107     size_t newLength;
00108     <span class="keywordflow">if</span> (newSize == 0)
00109       newLength = 0;
00110     <span class="keywordflow">else</span>
00111       newLength = 1 + GetIndex (newSize - 1);
00112 
00113     <span class="keywordflow">if</span> (newLength != mLength)
00114     {
00115       <span class="comment">// Avoid allocation if length is 1 (common case)</span>
00116       store_type* newStore;
00117       <span class="keywordflow">if</span> (newLength &lt;= 1)
00118         newStore = &amp;mSingleWord;
00119       <span class="keywordflow">else</span>
00120         newStore = <span class="keyword">new</span> store_type[newLength];
00121 
00122       <span class="keywordflow">if</span> (newLength &gt; 0)
00123       {
00124         <span class="keywordflow">if</span> (mLength &gt; 0)
00125         {
00126           store_type <span class="keyword">const</span>* oldStore = GetStore();
00127           <span class="keywordflow">if</span> (newStore != oldStore)
00128           {
00129             memcpy (newStore, oldStore, 
00130               (MIN (mLength, newLength)) * <span class="keyword">sizeof</span> (store_type));
00131             <span class="keywordflow">if</span> (newLength &gt; mLength)
00132               memset(newStore + mLength, 0,
00133                      (newLength - mLength) * <span class="keyword">sizeof</span> (store_type));
00134           }
00135         }
00136         <span class="keywordflow">else</span>
00137           memset (newStore, 0, newLength * <span class="keyword">sizeof</span> (store_type));
00138       }
00139 
00140       <span class="keywordflow">if</span> (mpStore != 0)
00141         <span class="keyword">delete</span>[] mpStore;
00142 
00143       mpStore = newLength &gt; 1 ? newStore : 0;
00144       mLength = newLength;
00145     }
00146 
00147     mNumBits = newSize;
00148     Trim();
00149   }
00150 
00151 <span class="keyword">public</span>:
00155   <span class="keyword">class </span>CS_CRYSTALSPACE_EXPORT BitProxy
00156   {
00157   <span class="keyword">private</span>:
00158     csBitArray &amp;mArray;
00159     size_t mPos;
00160   <span class="keyword">public</span>:
00162     BitProxy(csBitArray &amp;array, size_t pos): mArray(array), mPos(pos)
00163     {}
00164 
00166     BitProxy &amp;operator= (<span class="keywordtype">bool</span> value)
00167     {
00168       mArray.Set (mPos, value);
00169       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00170     }
00171 
00173     BitProxy &amp;operator= (<span class="keyword">const</span> BitProxy &amp;that)
00174     {
00175       mArray.Set (mPos, that.mArray.IsBitSet (that.mPos));
00176       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00177     }
00178 
00180     operator bool()<span class="keyword"> const</span>
00181 <span class="keyword">    </span>{
00182       <span class="keywordflow">return</span> mArray.IsBitSet (mPos);
00183     }
00184 
00189     <span class="keywordtype">bool</span> Flip()
00190     {
00191       mArray.FlipBit (mPos);
00192       <span class="keywordflow">return</span> mArray.IsBitSet (mPos);
00193     }
00194   };
00195   <span class="keyword">friend</span> <span class="keyword">class </span>BitProxy;
00196 
<a name="l00200"></a><a class="code" href="classcsBitArray.html#a0">00200</a>   csBitArray () : mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00201   {
00202     SetSize (0);
00203   }
00204 
<a name="l00208"></a><a class="code" href="classcsBitArray.html#a1">00208</a>   <span class="keyword">explicit</span> csBitArray(size_t size) :
00209     mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00210   {
00211     SetSize (size);
00212   }
00213 
<a name="l00217"></a><a class="code" href="classcsBitArray.html#a2">00217</a>   csBitArray (<span class="keyword">const</span> csBitArray &amp;that) :
00218     mpStore(0), mSingleWord(0), mLength(0), mNumBits(0)
00219   {
00220     *<span class="keyword">this</span> = that; <span class="comment">// Invokes this-&gt;operator=().</span>
00221   }
00222 
<a name="l00224"></a><a class="code" href="classcsBitArray.html#a3">00224</a>   ~csBitArray()
00225   {
00226     <span class="keywordflow">if</span> (mpStore != 0)
00227       <span class="keyword">delete</span>[] mpStore;
00228   }
00229 
<a name="l00231"></a><a class="code" href="classcsBitArray.html#a4">00231</a>   size_t Length()<span class="keyword"> const</span>
00232 <span class="keyword">  </span>{
00233     <span class="keywordflow">return</span> mNumBits;
00234   }
00235 
<a name="l00241"></a><a class="code" href="classcsBitArray.html#a5">00241</a>   <span class="keywordtype">void</span> SetLength (size_t newSize)
00242   {
00243     SetSize (newSize);
00244   }
00245 
00246   <span class="comment">//</span>
00247   <span class="comment">// Operators</span>
00248   <span class="comment">//</span>
00249 
<a name="l00251"></a><a class="code" href="classcsBitArray.html#a6">00251</a>   csBitArray &amp;operator=(<span class="keyword">const</span> csBitArray &amp;that)
00252   {
00253     <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;that)
00254     {
00255       SetSize (that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00256       memcpy (GetStore(), that.<a class="code" href="classcsBitArray.html#d0">GetStore</a>(), mLength * <span class="keyword">sizeof</span>(store_type));
00257     }
00258     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00259   }
00260 
<a name="l00262"></a><a class="code" href="classcsBitArray.html#a7">00262</a>   BitProxy operator[] (size_t pos)
00263   {
00264     CS_ASSERT (pos &lt; mNumBits);
00265     <span class="keywordflow">return</span> BitProxy(*<span class="keyword">this</span>, pos);
00266   }
00267 
<a name="l00269"></a><a class="code" href="classcsBitArray.html#a8">00269</a>   <span class="keywordtype">bool</span> operator[] (size_t pos)<span class="keyword"> const</span>
00270 <span class="keyword">  </span>{
00271     <span class="keywordflow">return</span> IsBitSet(pos);
00272   }
00273 
<a name="l00275"></a><a class="code" href="classcsBitArray.html#a9">00275</a>   <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> csBitArray &amp;that)<span class="keyword"> const</span>
00276 <span class="keyword">  </span>{
00277     <span class="keywordflow">if</span> (mNumBits != that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>)
00278       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00279 
00280     store_type <span class="keyword">const</span>* p0 = GetStore();
00281     store_type <span class="keyword">const</span>* p1 = that.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00282     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; mLength; i++)
00283       <span class="keywordflow">if</span> (p0[i] != p1[i])
00284         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00285     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00286   }
00287 
<a name="l00289"></a><a class="code" href="classcsBitArray.html#a10">00289</a>   <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> csBitArray &amp;that)<span class="keyword"> const</span>
00290 <span class="keyword">  </span>{
00291     <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == that);
00292   }
00293 
<a name="l00295"></a><a class="code" href="classcsBitArray.html#a11">00295</a>   csBitArray&amp; operator &amp;= (<span class="keyword">const</span> csBitArray &amp;that)
00296   {
00297     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00298     store_type* p0 = GetStore();
00299     store_type <span class="keyword">const</span>* p1 = that.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00300     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00301       p0[i] &amp;= p1[i];
00302     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00303   }
00304 
<a name="l00306"></a><a class="code" href="classcsBitArray.html#a12">00306</a>   csBitArray operator |= (<span class="keyword">const</span> csBitArray &amp;that)
00307   {
00308     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00309     store_type* p0 = GetStore();
00310     store_type <span class="keyword">const</span>* p1 = that.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00311     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00312       p0[i] |= p1[i];
00313     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00314   }
00315 
<a name="l00317"></a><a class="code" href="classcsBitArray.html#a13">00317</a>   csBitArray operator ^= (<span class="keyword">const</span> csBitArray &amp;that)
00318   {
00319     CS_ASSERT (mNumBits == that.<a class="code" href="classcsBitArray.html#r3">mNumBits</a>);
00320     store_type* p0 = GetStore();
00321     store_type <span class="keyword">const</span>* p1 = that.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00322     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00323       p0[i] ^= p1[i];
00324     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00325   }
00326 
<a name="l00328"></a><a class="code" href="classcsBitArray.html#a14">00328</a>   csBitArray operator~()<span class="keyword"> const</span>
00329 <span class="keyword">  </span>{
00330     <span class="keywordflow">return</span> csBitArray(*this).FlipAllBits();
00331   }
00332 
<a name="l00334"></a><a class="code" href="classcsBitArray.html#n3">00334</a>   <span class="keyword">friend</span> csBitArray operator&amp; (<span class="keyword">const</span> csBitArray &amp;a1, <span class="keyword">const</span> csBitArray &amp;a2)
00335   {
00336     <span class="keywordflow">return</span> csBitArray(a1) &amp;= a2;
00337   }
00338 
<a name="l00340"></a><a class="code" href="classcsBitArray.html#n4">00340</a>   <span class="keyword">friend</span> csBitArray operator | (<span class="keyword">const</span> csBitArray &amp;a1, <span class="keyword">const</span> csBitArray &amp;a2)
00341   {
00342     <span class="keywordflow">return</span> csBitArray(a1) |= a2;
00343   }
00344 
<a name="l00346"></a><a class="code" href="classcsBitArray.html#n5">00346</a>   <span class="keyword">friend</span> csBitArray operator ^ (<span class="keyword">const</span> csBitArray &amp;a1, <span class="keyword">const</span> csBitArray &amp;a2)
00347   {
00348     <span class="keywordflow">return</span> csBitArray(a1) ^= a2;
00349   }
00350 
00351   <span class="comment">//</span>
00352   <span class="comment">// Plain English interface</span>
00353   <span class="comment">//</span>
00354 
<a name="l00356"></a><a class="code" href="classcsBitArray.html#a15">00356</a>   <span class="keywordtype">void</span> Clear()
00357   {
00358     memset (GetStore(), 0, mLength * <span class="keyword">sizeof</span>(store_type));
00359   }
00360 
<a name="l00362"></a><a class="code" href="classcsBitArray.html#a16">00362</a>   <span class="keywordtype">void</span> SetBit (size_t pos)
00363   {
00364     CS_ASSERT (pos &lt; mNumBits);
00365     GetStore()[GetIndex(pos)] |= ((store_type)1) &lt;&lt; GetOffset(pos);
00366   }
00367 
<a name="l00369"></a><a class="code" href="classcsBitArray.html#a17">00369</a>   <span class="keywordtype">void</span> ClearBit (size_t pos)
00370   {
00371     CS_ASSERT (pos &lt; mNumBits);
00372     GetStore()[GetIndex(pos)] &amp;= ~(((store_type)1) &lt;&lt; GetOffset(pos));
00373   }
00374 
<a name="l00376"></a><a class="code" href="classcsBitArray.html#a18">00376</a>   <span class="keywordtype">void</span> FlipBit (size_t pos)
00377   {
00378     CS_ASSERT (pos &lt; mNumBits);
00379     GetStore()[GetIndex(pos)] ^= ((store_type)1) &lt;&lt; GetOffset(pos);
00380   }
00381 
<a name="l00383"></a><a class="code" href="classcsBitArray.html#a19">00383</a>   <span class="keywordtype">void</span> Set (size_t pos, <span class="keywordtype">bool</span> val = <span class="keyword">true</span>)
00384   {
00385     <span class="keywordflow">if</span> (val)
00386       SetBit(pos);
00387     <span class="keywordflow">else</span>
00388       ClearBit(pos);
00389   }
00390 
<a name="l00392"></a><a class="code" href="classcsBitArray.html#a20">00392</a>   <span class="keywordtype">bool</span> IsBitSet (size_t pos)<span class="keyword"> const</span>
00393 <span class="keyword">  </span>{
00394     CS_ASSERT (pos &lt; mNumBits);
00395     <span class="keywordflow">return</span> (GetStore()[GetIndex(pos)] &amp; (((store_type)1) &lt;&lt; GetOffset(pos)))
00396       != 0;
00397   }
00398 
<a name="l00400"></a><a class="code" href="classcsBitArray.html#a21">00400</a>   <span class="keywordtype">bool</span> AreSomeBitsSet (size_t pos, size_t count)<span class="keyword"> const</span>
00401 <span class="keyword">  </span>{
00402     CS_ASSERT (pos + count &lt;= mNumBits);
00403     store_type <span class="keyword">const</span>* p = GetStore();
00404     <span class="keywordflow">while</span> (count &gt; 0)
00405     {
00406       size_t index = GetIndex (pos);
00407       size_t offset = GetOffset (pos);
00408       size_t checkCount = MIN(count, cell_size - offset);
00409       store_type mask = ((checkCount == cell_size) ? ~(store_type)0 :
00410                          ((((store_type)1) &lt;&lt; checkCount) - 1)) &lt;&lt; offset;
00411       <span class="keywordflow">if</span> (p[index] &amp; mask)
00412         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00413       pos += checkCount;
00414       count -= checkCount;
00415     }
00416     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00417   }
00418   
<a name="l00420"></a><a class="code" href="classcsBitArray.html#a22">00420</a>   <span class="keywordtype">bool</span> AllBitsFalse()<span class="keyword"> const</span>
00421 <span class="keyword">  </span>{
00422     store_type <span class="keyword">const</span>* p = GetStore();
00423     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00424       <span class="keywordflow">if</span> (p[i] != 0)
00425         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00426     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00427   }
00428 
<a name="l00430"></a><a class="code" href="classcsBitArray.html#a23">00430</a>   csBitArray &amp;FlipAllBits()
00431   {
00432     store_type* p = GetStore();
00433     <span class="keywordflow">for</span> (size_t i = 0; i &lt; mLength; i++)
00434       p[i] = ~p[i];
00435     Trim();
00436     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00437   }
00438 
<a name="l00443"></a><a class="code" href="classcsBitArray.html#a24">00443</a>   <span class="keywordtype">void</span> Delete(size_t pos, size_t count)
00444   {
00445     <span class="keywordflow">if</span> (count &gt; 0)
00446     {
00447       size_t dst = pos;
00448       size_t src = pos + count;
00449       CS_ASSERT(src &lt;= mNumBits);
00450       size_t ntail = mNumBits - src;
00451       <span class="keywordflow">while</span> (ntail-- &gt; 0)
00452         Set(dst++, IsBitSet(src++));
00453       SetSize(mNumBits - count);
00454     }
00455   }
00456 
<a name="l00461"></a><a class="code" href="classcsBitArray.html#a25">00461</a>   csBitArray Slice(size_t pos, size_t count)<span class="keyword"> const</span>
00462 <span class="keyword">  </span>{
00463     CS_ASSERT(pos + count &lt;= mNumBits);
00464     csBitArray a(count);
00465     <span class="keywordflow">for</span> (size_t i = pos, o = 0; i &lt; pos + count; i++)
00466       <span class="keywordflow">if</span> (IsBitSet(i))
00467         a.<a class="code" href="classcsBitArray.html#a16">SetBit</a>(o++);
00468     <span class="keywordflow">return</span> a;
00469   }
00470 
<a name="l00472"></a><a class="code" href="classcsBitArray.html#a26">00472</a>   store_type* GetArrayBits()
00473   {
00474     <span class="keywordflow">return</span> GetStore();
00475   }
00476 
<a name="l00481"></a><a class="code" href="classcsBitArray.html#a27">00481</a>   store_type GetSingleWord()
00482   {
00483     CS_ASSERT(mpStore == 0);
00484     <span class="keywordflow">return</span> mSingleWord;
00485   }
00486 
<a name="l00491"></a><a class="code" href="classcsBitArray.html#a28">00491</a>   <span class="keywordtype">void</span> SetSingleWord (store_type sw)
00492   {
00493     CS_ASSERT(mpStore == 0);
00494     mSingleWord = sw;
00495   }
00496 };
00497 
00502 CS_SPECIALIZE_TEMPLATE
<a name="l00503"></a><a class="code" href="classcsComparator_3_01csBitArray_00_01csBitArray_01_4.html">00503</a> <span class="keyword">class </span><a class="code" href="classcsComparator.html">csComparator</a>&lt;csBitArray, csBitArray&gt;
00504 {
00505 <span class="keyword">public</span>:
00506   <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsComparator.html#e0">Compare</a> (csBitArray <span class="keyword">const</span>&amp; key1, csBitArray <span class="keyword">const</span>&amp; key2)
00507   {
00508     csBitArray::store_type <span class="keyword">const</span>* p0 = key1.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00509     csBitArray::store_type <span class="keyword">const</span>* p1 = key2.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00510     size_t compareNum = MIN (key1.<a class="code" href="classcsBitArray.html#r2">mLength</a>, key2.<a class="code" href="classcsBitArray.html#r2">mLength</a>);
00511     size_t i = 0;
00512     <span class="keywordflow">for</span> (; i &lt; compareNum; i++)
00513       <span class="keywordflow">if</span> (p0[i] != p1[i])
00514         <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)p0[i] - (int)p1[i];
00515     <span class="keywordflow">if</span> (key1.<a class="code" href="classcsBitArray.html#r2">mLength</a> &gt; key2.<a class="code" href="classcsBitArray.html#r2">mLength</a>)
00516     {
00517       <span class="keywordflow">for</span> (; i &lt; key1.<a class="code" href="classcsBitArray.html#r2">mLength</a>; i++)
00518         <span class="keywordflow">if</span> (p0[i] != 0)
00519           <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)p0[i];
00520     }
00521     <span class="keywordflow">else</span>
00522     {
00523       <span class="keywordflow">for</span> (; i &lt; key2.<a class="code" href="classcsBitArray.html#r2">mLength</a>; i++)
00524         <span class="keywordflow">if</span> (p1[i] != 0)
00525           <span class="keywordflow">return</span> -((int)p1[i]);
00526     }
00527     <span class="keywordflow">return</span> 0;
00528   }
00529 };
00530 
00535 CS_SPECIALIZE_TEMPLATE
<a name="l00536"></a><a class="code" href="classcsHashComputer_3_01csBitArray_01_4.html">00536</a> <span class="keyword">class </span><a class="code" href="classcsHashComputer.html">csHashComputer</a>&lt;csBitArray&gt;
00537 {
00538 <span class="keyword">public</span>:
00539   <span class="keyword">static</span> <a class="code" href="group__util.html#ga18">uint</a> <a class="code" href="classcsHashComputer.html#e0">ComputeHash</a> (csBitArray <span class="keyword">const</span>&amp; key)
00540   {
00541     <span class="keyword">const</span> size_t uintCount = <span class="keyword">sizeof</span> (csBitArray::store_type) / <span class="keyword">sizeof</span> (<a class="code" href="group__util.html#ga18">uint</a>);
00542     <span class="keyword">union</span>
00543 <span class="keyword">    </span>{
00544       csBitArray::store_type store;
00545       <a class="code" href="group__util.html#ga18">uint</a> ui[uintCount];
00546     } bitStoreToUint;
00547     <a class="code" href="group__util.html#ga18">uint</a> hash = 0;
00548     csBitArray::store_type <span class="keyword">const</span>* p = key.<a class="code" href="classcsBitArray.html#d0">GetStore</a>();
00549     <span class="comment">// @@@ Not very good. Find a better hash function; however, it should</span>
00550     <span class="comment">// return the same hash for two bit arrays that are the same except for</span>
00551     <span class="comment">// the amount of trailing zeros. (e.g. f(10010110) == f(100101100000...))</span>
00552     <span class="keywordflow">for</span> (size_t i = 0; i &lt; key.<a class="code" href="classcsBitArray.html#r2">mLength</a>; i++)
00553     {
00554       bitStoreToUint.store = p[i];
00555       <span class="keywordflow">for</span> (size_t j = 0; j &lt; uintCount; j++)
00556         hash += bitStoreToUint.ui[j];
00557     }
00558     <span class="keywordflow">return</span> hash;
00559   }
00560 };
00561 
00562 
00563 <span class="preprocessor">#endif // __CS_BITARRAY_H__</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.2 
</small></address> </div></body> </html>
