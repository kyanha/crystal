<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csutil/array.h Source File (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000022.html">csutil</a></div>
<h1>array.h</h1><a href="array_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">  Crystal Space Generic Array Template</span>
00003 <span class="comment">  Copyright (C) 2003 by Matze Braun</span>
00004 <span class="comment">  Copyright (C) 2003 by Jorrit Tyberghein</span>
00005 <span class="comment">  Copyright (C) 2003,2004 by Eric Sunshine</span>
00006 <span class="comment"></span>
00007 <span class="comment">  This library is free software; you can redistribute it and/or</span>
00008 <span class="comment">  modify it under the terms of the GNU Library General Public</span>
00009 <span class="comment">  License as published by the Free Software Foundation; either</span>
00010 <span class="comment">  version 2 of the License, or (at your option) any later version.</span>
00011 <span class="comment"></span>
00012 <span class="comment">  This library is distributed in the hope that it will be useful,</span>
00013 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00014 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00015 <span class="comment">  Library General Public License for more details.</span>
00016 <span class="comment"></span>
00017 <span class="comment">  You should have received a copy of the GNU Library General Public</span>
00018 <span class="comment">  License along with this library; if not, write to the Free</span>
00019 <span class="comment">  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00020 <span class="comment">*/</span>
00021 <span class="preprocessor">#ifndef __CSUTIL_ARRAY_H__</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __CSUTIL_ARRAY_H__</span>
00023 <span class="preprocessor"></span>
00028 <span class="preprocessor">#include "<a class="code" href="comparator_8h.html">comparator.h</a>"</span>
00029 
00030 <span class="comment">// Hack: Work around problems caused by #defining 'new'.</span>
00031 <span class="preprocessor">#if defined(CS_EXTENSIVE_MEMDEBUG) || defined(CS_MEMORY_TRACKER)</span>
00032 <span class="preprocessor"></span><span class="preprocessor"># undef new</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#include &lt;new&gt;</span>
00035 
00036 <span class="preprocessor">#if defined(CS_MEMORY_TRACKER)</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#include "csutil/memdebug.h"</span>
00038 <span class="preprocessor">#include "<a class="code" href="snprintf_8h.html">csutil/snprintf.h</a>"</span>
00039 <span class="preprocessor">#include &lt;typeinfo&gt;</span>
00040 <span class="preprocessor">#endif</span>
00041 <span class="preprocessor"></span>
00045 <span class="comment">// Define CSARRAY_INHIBIT_TYPED_KEYS if the compiler is too old or too buggy to</span>
00046 <span class="comment">// properly support templated functions within a templated class.  When this is</span>
00047 <span class="comment">// defined, rather than using a properly typed "key" argument, search methods</span>
00048 <span class="comment">// fall back to dealing with opaque void* for the "key" argument.  Note,</span>
00049 <span class="comment">// however, that this fact is completely hidden from the client; the client</span>
00050 <span class="comment">// simply creates csArrayCmp&lt;&gt; functors using correct types for the keys</span>
00051 <span class="comment">// regardless of whether the compiler actually supports this feature.  (The</span>
00052 <span class="comment">// MSVC6 compiler, for example, does support templated functions within a</span>
00053 <span class="comment">// template class but crashes and burns horribly when a function pointer or</span>
00054 <span class="comment">// functor is thrown into the mix; thus this should be defined for MSVC6.)</span>
00055 <span class="preprocessor">#if !defined(CSARRAY_INHIBIT_TYPED_KEYS)</span>
00056 <span class="preprocessor"></span>
00066 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> K&gt;
<a name="l00067"></a><a class="code" href="classcsArrayCmp.html">00067</a> <span class="keyword">class </span><a class="code" href="classcsArrayCmp.html">csArrayCmp</a>
00068 {
00069 <span class="keyword">public</span>:
<a name="l00075"></a><a class="code" href="classcsArrayCmp.html#w0">00075</a>   <span class="keyword">typedef</span> int(*<a class="code" href="classcsArrayCmp.html#w0">CF</a>)(T <span class="keyword">const</span>&amp;, K <span class="keyword">const</span>&amp;);
<a name="l00077"></a><a class="code" href="classcsArrayCmp.html#a0">00077</a>   <a class="code" href="classcsArrayCmp.html#a0">csArrayCmp</a>(K <span class="keyword">const</span>&amp; k, <a class="code" href="classcsArrayCmp.html#w0">CF</a> c = <a class="code" href="classcsArrayCmp.html#e0">DefaultCompare</a>) : key(k), cmp(c) {}
<a name="l00079"></a><a class="code" href="classcsArrayCmp.html#a1">00079</a>   <a class="code" href="classcsArrayCmp.html#a0">csArrayCmp</a>(<a class="code" href="classcsArrayCmp.html">csArrayCmp</a> <span class="keyword">const</span>&amp; o) : key(o.key), cmp(o.cmp) {}
<a name="l00081"></a><a class="code" href="classcsArrayCmp.html#a2">00081</a>   <a class="code" href="classcsArrayCmp.html">csArrayCmp</a>&amp; <a class="code" href="classcsArrayCmp.html#a2">operator=</a>(<a class="code" href="classcsArrayCmp.html">csArrayCmp</a> <span class="keyword">const</span>&amp; o)
00082     { key = o.<a class="code" href="classcsArrayCmp.html#r0">key</a>; cmp = o.<a class="code" href="classcsArrayCmp.html#r1">cmp</a>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00091"></a><a class="code" href="classcsArrayCmp.html#a3">00091</a>   <span class="keywordtype">int</span> <a class="code" href="classcsArrayCmp.html#a3">operator()</a>(T <span class="keyword">const</span>&amp; r)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cmp(r, key); }
<a name="l00093"></a><a class="code" href="classcsArrayCmp.html#a4">00093</a>   <a class="code" href="classcsArrayCmp.html#a4">operator CF</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cmp; }
<a name="l00095"></a><a class="code" href="classcsArrayCmp.html#a5">00095</a>   <a class="code" href="classcsArrayCmp.html#a5">operator K const&amp;</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> key; }
<a name="l00106"></a><a class="code" href="classcsArrayCmp.html#e0">00106</a>   <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsArrayCmp.html#e0">DefaultCompare</a>(T <span class="keyword">const</span>&amp; r, K <span class="keyword">const</span>&amp; k)
00107     { <span class="keywordflow">return</span> <a class="code" href="classcsComparator.html#e0">csComparator&lt;T,K&gt;::Compare</a>(r,k); }
00108 <span class="keyword">private</span>:
00109   K key;
00110   <a class="code" href="classcsArrayCmp.html#w0">CF</a> cmp;
00111 };
00112 
00113 <span class="preprocessor">#define csArrayTemplate(K) template &lt;class K&gt;</span>
00114 <span class="preprocessor"></span><span class="preprocessor">#define csArrayCmpDecl(T1,T2) csArrayCmp&lt;T1,T2&gt;</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#define csArrayCmpInvoke(C,R) C(R)</span>
00116 <span class="preprocessor"></span>
00117 <span class="preprocessor">#else // CSARRAY_INHIBIT_TYPED_KEYS</span>
00118 <span class="preprocessor"></span>
00119 <span class="keyword">class </span>csArrayCmpAbstract
00120 {
00121 <span class="keyword">public</span>:
00122   <span class="keyword">typedef</span> int(*CF)(<span class="keywordtype">void</span> <span class="keyword">const</span>*, <span class="keywordtype">void</span> <span class="keyword">const</span>*);
00123   <span class="keyword">virtual</span> <span class="keywordtype">int</span> operator()(<span class="keywordtype">void</span> <span class="keyword">const</span>*) <span class="keyword">const </span>= 0;
00124   <span class="keyword">virtual</span> operator CF() <span class="keyword">const </span>= 0;
00125 };
00126 
00127 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> K&gt;
00128 <span class="keyword">class </span><a class="code" href="classcsArrayCmp.html">csArrayCmp</a> : <span class="keyword">public</span> csArrayCmpAbstract
00129 {
00130 <span class="keyword">public</span>:
00131   <span class="keyword">typedef</span> int(*CFTyped)(T <span class="keyword">const</span>&amp;, K <span class="keyword">const</span>&amp;);
00132   <a class="code" href="classcsArrayCmp.html#a0">csArrayCmp</a>(K <span class="keyword">const</span>&amp; k, CFTyped c = <a class="code" href="classcsArrayCmp.html#e0">DefaultCompare</a>) : key(k), cmp(<a class="code" href="classcsArrayCmp.html#w0">CF</a>(c)) {}
00133   <a class="code" href="classcsArrayCmp.html#a0">csArrayCmp</a>(<a class="code" href="classcsArrayCmp.html">csArrayCmp</a> <span class="keyword">const</span>&amp; o) : key(o.key), cmp(o.cmp) {}
00134   <a class="code" href="classcsArrayCmp.html">csArrayCmp</a>&amp; <a class="code" href="classcsArrayCmp.html#a2">operator=</a>(<a class="code" href="classcsArrayCmp.html">csArrayCmp</a> <span class="keyword">const</span>&amp; o)
00135     { key = o.<a class="code" href="classcsArrayCmp.html#r0">key</a>; cmp = o.<a class="code" href="classcsArrayCmp.html#r1">cmp</a>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
00136   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classcsArrayCmp.html#a3">operator()</a>(<span class="keywordtype">void</span> <span class="keyword">const</span>* p)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cmp(p, &amp;key); }
00137   <span class="keyword">virtual</span> <a class="code" href="classcsArrayCmp.html#a4">operator CF</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cmp; }
00138   <a class="code" href="classcsArrayCmp.html#a5">operator K const&amp;</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> key; }
00139   <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsArrayCmp.html#e0">DefaultCompare</a>(T <span class="keyword">const</span>&amp; r, K <span class="keyword">const</span>&amp; k)
00140     { <span class="keywordflow">return</span> <a class="code" href="classcsComparator.html#e0">csComparator&lt;T,K&gt;::Compare</a>(r,k); }
00141 <span class="keyword">private</span>:
00142   K key;
00143   <a class="code" href="classcsArrayCmp.html#w0">CF</a> cmp;
00144 };
00145 
00146 <span class="preprocessor">#define csArrayTemplate(K)</span>
00147 <span class="preprocessor"></span><span class="preprocessor">#define csArrayCmpDecl(T1,T2) csArrayCmpAbstract const&amp;</span>
00148 <span class="preprocessor"></span><span class="preprocessor">#define csArrayCmpInvoke(C,R) C(&amp;(R))</span>
00149 <span class="preprocessor"></span>
00150 <span class="preprocessor">#endif // CSARRAY_INHIBIT_TYPED_KEYS</span>
00151 <span class="preprocessor"></span>
00155 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00156"></a><a class="code" href="classcsArrayElementHandler.html">00156</a> <span class="keyword">class </span><a class="code" href="classcsArrayElementHandler.html">csArrayElementHandler</a>
00157 {
00158 <span class="keyword">public</span>:
00159   <span class="keyword">static</span> <span class="keywordtype">void</span> Construct (T* address)
00160   {
00161     <span class="keyword">new</span> (CS_STATIC_CAST(<span class="keywordtype">void</span>*,address)) T();
00162   }
00163 
00164   <span class="keyword">static</span> <span class="keywordtype">void</span> Construct (T* address, T <span class="keyword">const</span>&amp; src)
00165   {
00166     <span class="keyword">new</span> (CS_STATIC_CAST(<span class="keywordtype">void</span>*,address)) T(src);
00167   }
00168 
00169   <span class="keyword">static</span> <span class="keywordtype">void</span> Destroy (T* address)
00170   {
00171     address-&gt;~T();
00172   }
00173 
00174   <span class="keyword">static</span> <span class="keywordtype">void</span> InitRegion (T* address, size_t count)
00175   {
00176     <span class="keywordflow">for</span> (size_t i = 0 ; i &lt; count ; i++)
00177       Construct (address + i);
00178   }
00179 };
00180 
00184 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00185"></a><a class="code" href="classcsArrayMemoryAllocator.html">00185</a> <span class="keyword">class </span><a class="code" href="classcsArrayMemoryAllocator.html">csArrayMemoryAllocator</a>
00186 {
00187 <span class="keyword">public</span>:
00188   <span class="keyword">static</span> T* Alloc (size_t count)
00189   {
00190     <span class="keywordflow">return</span> (T*)malloc (count * <span class="keyword">sizeof</span>(T));
00191   }
00192 
00193   <span class="keyword">static</span> <span class="keywordtype">void</span> Free (T* mem)
00194   {
00195     free (mem);
00196   }
00197 
00198   <span class="comment">// The 'relevantcount' parameter should be the number of items</span>
00199   <span class="comment">// in the old array that are initialized.</span>
00200   <span class="keyword">static</span> T* Realloc (T* mem, size_t relevantcount, size_t oldcount,
00201     size_t newcount)
00202   {
00203     (void)relevantcount; (void)oldcount;
00204     <span class="keywordflow">return</span> (T*)realloc (mem, newcount * <span class="keyword">sizeof</span>(T));
00205   }
00206 
00207   <span class="comment">// Move memory.</span>
00208   <span class="keyword">static</span> <span class="keywordtype">void</span> MemMove (T* mem, size_t dest, size_t src, size_t count)
00209   {
00210     memmove (mem + dest, mem + src, count * <span class="keyword">sizeof</span>(T));
00211   }
00212 };
00213 
00222 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ElementHandler = csArrayElementHandler&lt;T&gt; &gt;
<a name="l00223"></a><a class="code" href="classcsSafeCopyArrayMemoryAllocator.html">00223</a> <span class="keyword">class </span><a class="code" href="classcsSafeCopyArrayMemoryAllocator.html">csSafeCopyArrayMemoryAllocator</a>
00224 {
00225 <span class="keyword">public</span>:
00226   <span class="keyword">static</span> T* Alloc (size_t count)
00227   {
00228     <span class="keywordflow">return</span> (T*)malloc (count * <span class="keyword">sizeof</span>(T));
00229   }
00230 
00231   <span class="keyword">static</span> <span class="keywordtype">void</span> Free (T* mem)
00232   {
00233     free (mem);
00234   }
00235 
00236   <span class="keyword">static</span> T* Realloc (T* mem, size_t relevantcount, size_t oldcount,
00237     size_t newcount)
00238   {
00239     <span class="keywordflow">if</span> (newcount &lt;= oldcount)
00240     {
00241       <span class="comment">// Realloc is safe.</span>
00242       T* newmem = (T*)realloc (mem, newcount * <span class="keyword">sizeof</span> (T));
00243       CS_ASSERT (newmem == mem);
00244       <span class="keywordflow">return</span> newmem;
00245     }
00246 
00247     T* newmem = Alloc (newcount);
00248     size_t i;
00249     <span class="keywordflow">for</span> (i = 0 ; i &lt; relevantcount ; i++)
00250     {
00251       ElementHandler::Construct (newmem + i, mem[i]);
00252       ElementHandler::Destroy (mem + i);
00253     }
00254     Free (mem);
00255     <span class="keywordflow">return</span> newmem;
00256   }
00257 
00258   <span class="keyword">static</span> <span class="keywordtype">void</span> MemMove (T* mem, size_t dest, size_t src, size_t count)
00259   {
00260     size_t i;
00261     <span class="keywordflow">if</span> (dest &lt; src)
00262     {
00263       <span class="keywordflow">for</span> (i = 0 ; i &lt; count ; i++)
00264       {
00265         ElementHandler::Construct (mem + dest + i, mem[src + i]);
00266         ElementHandler::Destroy (mem + src + i);
00267       }
00268     }
00269     <span class="keywordflow">else</span>
00270     {
00271       i = count;
00272       <span class="keywordflow">while</span> (i &gt; 0)
00273       {
00274         i--;
00275         ElementHandler::Construct (mem + dest + i, mem[src + i]);
00276         ElementHandler::Destroy (mem + src + i);
00277       }
00278     }
00279   }
00280 };
00281 
<a name="l00286"></a><a class="code" href="group__util__containers.html#ga0">00286</a> <span class="keyword">const</span> size_t <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a> = (size_t)-1;
00287 
00296 <span class="keyword">template</span> &lt;<span class="keyword">class </span>T,
00297         <span class="keyword">class </span>ElementHandler = <a class="code" href="classcsArrayElementHandler.html">csArrayElementHandler&lt;T&gt;</a>,
00298         <span class="keyword">class </span>MemoryAllocator = <a class="code" href="classcsArrayMemoryAllocator.html">csArrayMemoryAllocator&lt;T&gt;</a> &gt;
<a name="l00299"></a><a class="code" href="classcsArray.html">00299</a> <span class="keyword">class </span><a class="code" href="classcsArray.html">csArray</a>
00300 {
00301 <span class="keyword">private</span>:
00302   size_t count;
00303   size_t capacity;
00304   size_t threshold;
00305   T* root;
00306 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
00307 <span class="preprocessor"></span>  csMemTrackerInfo* mti;
00308   <span class="keywordtype">void</span> UpdateMti (<span class="keywordtype">int</span> dn, <span class="keywordtype">int</span> curcapacity)
00309   {
00310     <span class="keywordflow">if</span> (!mti)
00311     {
00312       <span class="keywordflow">if</span> (!curcapacity) <span class="keywordflow">return</span>;
00313       <span class="keywordtype">char</span> buf[1024];
00314       <a class="code" href="snprintf_8h.html#a0">cs_snprintf</a> (buf, <span class="keyword">sizeof</span> (buf), <span class="stringliteral">"csArray&lt;%s&gt;"</span>, <span class="keyword">typeid</span> (T).name());
00315       mti = mtiRegisterAlloc (1 * <span class="keyword">sizeof</span> (T), buf);
00316       <span class="keywordflow">if</span> (!mti) <span class="keywordflow">return</span>;
00317       curcapacity--;
00318       <span class="keywordflow">if</span> (curcapacity)
00319         mtiUpdateAmount (mti, curcapacity, curcapacity * <span class="keyword">sizeof</span> (T));
00320       <span class="keywordflow">return</span>;
00321     }
00322     mtiUpdateAmount (mti, dn, dn * <span class="keyword">sizeof</span> (T));
00323   }
00324 <span class="preprocessor">#endif</span>
00325 <span class="preprocessor"></span>
00326 <span class="keyword">protected</span>:
<a name="l00331"></a><a class="code" href="classcsArray.html#b0">00331</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#b0">InitRegion</a> (size_t start, size_t count)
00332   {
00333     ElementHandler::InitRegion (root+start, count);
00334   }
00335 
00336 <span class="keyword">private</span>:
00338   <span class="keywordtype">void</span> CopyFrom (<span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray</a>&amp; source)
00339   {
00340     <span class="keywordflow">if</span> (&amp;source != <span class="keyword">this</span>)
00341     {
00342       <a class="code" href="classcsArray.html#a32">DeleteAll</a> ();
00343       threshold = source.<a class="code" href="classcsArray.html#r2">threshold</a>;
00344       SetSizeUnsafe (source.<a class="code" href="classcsArray.html#a5">Length</a> ());
00345       <span class="keywordflow">for</span> (size_t i=0 ; i&lt;source.<a class="code" href="classcsArray.html#a5">Length</a>() ; i++)
00346         ElementHandler::Construct (root + i, source[i]);
00347     }
00348   }
00349 
00351   <span class="keywordtype">void</span> InternalSetCapacity (size_t n)
00352   {
00353     <span class="keywordflow">if</span> (root == 0)
00354     {
00355       root = MemoryAllocator::Alloc (n);
00356 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
00357 <span class="preprocessor"></span>      UpdateMti (n, n);
00358 <span class="preprocessor">#endif</span>
00359 <span class="preprocessor"></span>    }
00360     <span class="keywordflow">else</span>
00361     {
00362       root = MemoryAllocator::Realloc (root, count, capacity, n);
00363 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
00364 <span class="preprocessor"></span>      UpdateMti (n-capacity, n);
00365 <span class="preprocessor">#endif</span>
00366 <span class="preprocessor"></span>    }
00367     capacity = n;
00368   }
00369 
00374   <span class="keywordtype">void</span> AdjustCapacity (size_t n)
00375   {
00376     <span class="keywordflow">if</span> (n &gt; capacity || (capacity &gt; threshold &amp;&amp; n &lt; capacity - threshold))
00377     {
00378       InternalSetCapacity (((n + threshold - 1) / threshold ) * threshold);
00379     }
00380   }
00381 
00388   <span class="keywordtype">void</span> SetSizeUnsafe (size_t n)
00389   {
00390     <span class="keywordflow">if</span> (n &gt; capacity)
00391       AdjustCapacity (n);
00392     count = n;
00393   }
00394 
00395 <span class="keyword">public</span>:
<a name="l00407"></a><a class="code" href="classcsArray.html#e0">00407</a>   <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classcsArray.html#e0">DefaultCompare</a>(T <span class="keyword">const</span>&amp; r1, T <span class="keyword">const</span>&amp; r2)
00408   {
00409     <span class="keywordflow">return</span> <a class="code" href="classcsComparator.html#e0">csComparator&lt;T,T&gt;::Compare</a>(r1,r2);
00410   }
00411 
<a name="l00417"></a><a class="code" href="classcsArray.html#a0">00417</a>   <a class="code" href="classcsArray.html#a0">csArray</a> (size_t in_capacity = 0, size_t in_threshold = 0)
00418   {
00419 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
00420 <span class="preprocessor"></span>    mti = 0;
00421 <span class="preprocessor">#endif</span>
00422 <span class="preprocessor"></span>    count = 0;
00423     capacity = (in_capacity &gt; 0 ? in_capacity : 0);
00424     threshold = (in_threshold &gt; 0 ? in_threshold : 16);
00425     <span class="keywordflow">if</span> (capacity != 0)
00426     {
00427       root = MemoryAllocator::Alloc (capacity);
00428 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
00429 <span class="preprocessor"></span>      UpdateMti (capacity, capacity);
00430 <span class="preprocessor">#endif</span>
00431 <span class="preprocessor"></span>    }
00432     <span class="keywordflow">else</span>
00433     {
00434       root = 0;
00435     }
00436   }
00437 
<a name="l00439"></a><a class="code" href="classcsArray.html#a1">00439</a>   <a class="code" href="classcsArray.html#a1">~csArray</a> ()
00440   {
00441     <a class="code" href="classcsArray.html#a32">DeleteAll</a> ();
00442   }
00443 
<a name="l00445"></a><a class="code" href="classcsArray.html#a2">00445</a>   <a class="code" href="classcsArray.html#a0">csArray</a> (<span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray</a>&amp; source)
00446   {
00447 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
00448 <span class="preprocessor"></span>    mti = 0;
00449 <span class="preprocessor">#endif</span>
00450 <span class="preprocessor"></span>    root = 0;
00451     capacity = 0;
00452     count = 0;
00453     CopyFrom (source);
00454   }
00455 
<a name="l00457"></a><a class="code" href="classcsArray.html#a3">00457</a>   <a class="code" href="classcsArray.html">csArray&lt;T,ElementHandler&gt;</a>&amp; <a class="code" href="classcsArray.html#a3">operator= </a>(<span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray</a>&amp; other)
00458   {
00459     CopyFrom (other);
00460     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00461   }
00462 
<a name="l00464"></a><a class="code" href="classcsArray.html#a4">00464</a>   size_t <a class="code" href="classcsArray.html#a4">GetSize</a> ()<span class="keyword"> const</span>
00465 <span class="keyword">  </span>{
00466     <span class="keywordflow">return</span> count;
00467   }
00468 
<a name="l00473"></a><a class="code" href="classcsArray.html#a5">00473</a>   size_t <a class="code" href="classcsArray.html#a5">Length</a> ()<span class="keyword"> const</span>
00474 <span class="keyword">  </span>{
00475     <span class="keywordflow">return</span> <a class="code" href="classcsArray.html#a4">GetSize</a>();
00476   }
00477 
<a name="l00479"></a><a class="code" href="classcsArray.html#a6">00479</a>   size_t <a class="code" href="classcsArray.html#a6">Capacity</a> ()<span class="keyword"> const</span>
00480 <span class="keyword">  </span>{
00481     <span class="keywordflow">return</span> capacity;
00482   }
00483 
<a name="l00490"></a><a class="code" href="classcsArray.html#a7">00490</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a7">TransferTo</a> (<a class="code" href="classcsArray.html">csArray</a>&amp; destination)
00491   {
00492     <span class="keywordflow">if</span> (&amp;destination != <span class="keyword">this</span>)
00493     {
00494       destination.<a class="code" href="classcsArray.html#a32">DeleteAll</a> ();
00495       destination.<a class="code" href="classcsArray.html#r3">root</a> = root;
00496       destination.<a class="code" href="classcsArray.html#r0">count</a> = count;
00497       destination.<a class="code" href="classcsArray.html#r1">capacity</a> = capacity;
00498       destination.<a class="code" href="classcsArray.html#r2">threshold</a> = threshold;
00499 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
00500 <span class="preprocessor"></span>      destination.mti = mti;
00501       mti = 0;
00502 <span class="preprocessor">#endif</span>
00503 <span class="preprocessor"></span>      root = 0;
00504       capacity = count = 0;
00505     }
00506   }
00507 
<a name="l00517"></a><a class="code" href="classcsArray.html#a8">00517</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a8">SetSize</a> (size_t n, T <span class="keyword">const</span>&amp; what)
00518   {
00519     <span class="keywordflow">if</span> (n &lt;= count)
00520     {
00521       <a class="code" href="classcsArray.html#a33">Truncate</a> (n);
00522     }
00523     <span class="keywordflow">else</span>
00524     {
00525       size_t old_len = <a class="code" href="classcsArray.html#a5">Length</a> ();
00526       SetSizeUnsafe (n);
00527       <span class="keywordflow">for</span> (size_t i = old_len ; i &lt; n ; i++)
00528         ElementHandler::Construct (root + i, what);
00529     }
00530   }
00531 
<a name="l00539"></a><a class="code" href="classcsArray.html#a9">00539</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a8">SetSize</a> (size_t n)
00540   {
00541     <span class="keywordflow">if</span> (n &lt;= count)
00542     {
00543       <a class="code" href="classcsArray.html#a33">Truncate</a> (n);
00544     }
00545     <span class="keywordflow">else</span>
00546     {
00547       size_t old_len = <a class="code" href="classcsArray.html#a5">Length</a> ();
00548       SetSizeUnsafe (n);
00549       ElementHandler::InitRegion (root + old_len, n-old_len);
00550     }
00551   }
00552 
<a name="l00558"></a><a class="code" href="classcsArray.html#a10">00558</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a10">SetLength</a> (size_t n, T <span class="keyword">const</span>&amp; what) { <a class="code" href="classcsArray.html#a8">SetSize</a>(n, what); }
00559   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a10">SetLength</a> (size_t n) { <a class="code" href="classcsArray.html#a8">SetSize</a>(n); }
00562 
<a name="l00563"></a><a class="code" href="classcsArray.html#a12">00563</a>   T&amp; <a class="code" href="classcsArray.html#a12">Get</a> (size_t n)
00564   {
00565     CS_ASSERT (n &lt; count);
00566     <span class="keywordflow">return</span> root[n];
00567   }
00568 
<a name="l00570"></a><a class="code" href="classcsArray.html#a13">00570</a>   T <span class="keyword">const</span>&amp; <a class="code" href="classcsArray.html#a12">Get</a> (size_t n)<span class="keyword"> const</span>
00571 <span class="keyword">  </span>{
00572     CS_ASSERT (n &lt; count);
00573     <span class="keywordflow">return</span> root[n];
00574   }
00575 
<a name="l00581"></a><a class="code" href="classcsArray.html#a14">00581</a>   T&amp; <a class="code" href="classcsArray.html#a14">GetExtend</a> (size_t n)
00582   {
00583     <span class="keywordflow">if</span> (n &gt;= count)
00584       <a class="code" href="classcsArray.html#a8">SetSize</a> (n+1);
00585     <span class="keywordflow">return</span> root[n];
00586   }
00587 
<a name="l00589"></a><a class="code" href="classcsArray.html#a15">00589</a>   T&amp; <a class="code" href="classcsArray.html#a15">operator [] </a>(size_t n)
00590   {
00591     <span class="keywordflow">return</span> <a class="code" href="classcsArray.html#a12">Get</a>(n);
00592   }
00593 
<a name="l00595"></a><a class="code" href="classcsArray.html#a16">00595</a>   T <span class="keyword">const</span>&amp; <a class="code" href="classcsArray.html#a15">operator [] </a>(size_t n)<span class="keyword"> const</span>
00596 <span class="keyword">  </span>{
00597     <span class="keywordflow">return</span> <a class="code" href="classcsArray.html#a12">Get</a>(n);
00598   }
00599 
<a name="l00601"></a><a class="code" href="classcsArray.html#a17">00601</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a17">Put</a> (size_t n, T <span class="keyword">const</span>&amp; what)
00602   {
00603     <span class="keywordflow">if</span> (n &gt;= count)
00604       <a class="code" href="classcsArray.html#a8">SetSize</a> (n+1);
00605     ElementHandler::Destroy (root + n);
00606     ElementHandler::Construct (root + n, what);
00607   }
00608 
00616   csArrayTemplate(K)
<a name="l00617"></a><a class="code" href="classcsArray.html#a18">00617</a>   size_t <a class="code" href="classcsArray.html#a18">FindKey</a> (csArrayCmpDecl(T,K) comparekey)<span class="keyword"> const</span>
00618 <span class="keyword">  </span>{
00619     <span class="keywordflow">for</span> (size_t i = 0 ; i &lt; <a class="code" href="classcsArray.html#a5">Length</a> () ; i++)
00620       <span class="keywordflow">if</span> (csArrayCmpInvoke(comparekey, root[i]) == 0)
00621         <span class="keywordflow">return</span> i;
00622     <span class="keywordflow">return</span> <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a>;
00623   }
00624 
<a name="l00629"></a><a class="code" href="classcsArray.html#a19">00629</a>   size_t <a class="code" href="classcsArray.html#a19">Push</a> (T <span class="keyword">const</span>&amp; what)
00630   {
00631     <span class="keywordflow">if</span> (((&amp;what &gt;= root) &amp;&amp; (&amp;what &lt; root + <a class="code" href="classcsArray.html#a5">Length</a>())) &amp;&amp;
00632       (capacity &lt; count + 1))
00633     {
00634       <span class="comment">/*</span>
00635 <span class="comment">        Special case: An element from this very array is pushed, and a</span>
00636 <span class="comment">        reallocation is needed. This could cause the passed ref to the</span>
00637 <span class="comment">        element to be pushed to be read from deleted memory. Work</span>
00638 <span class="comment">        around this.</span>
00639 <span class="comment">       */</span>
00640       size_t whatIndex = &amp;what - root;
00641       SetSizeUnsafe (count + 1);
00642       ElementHandler::Construct (root + count - 1, root[whatIndex]);
00643     }
00644     <span class="keywordflow">else</span>
00645     {
00646       SetSizeUnsafe (count + 1);
00647       ElementHandler::Construct (root + count - 1, what);
00648     }
00649     <span class="keywordflow">return</span> count - 1;
00650   }
00651 
<a name="l00656"></a><a class="code" href="classcsArray.html#a20">00656</a>   size_t <a class="code" href="classcsArray.html#a20">PushSmart</a> (T <span class="keyword">const</span>&amp; what)
00657   {
00658     size_t <span class="keyword">const</span> n = <a class="code" href="classcsArray.html#a28">Find</a> (what);
00659     <span class="keywordflow">return</span> (n == <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a>) ? <a class="code" href="classcsArray.html#a19">Push</a> (what) : n;
00660   }
00661 
<a name="l00663"></a><a class="code" href="classcsArray.html#a21">00663</a>   T <a class="code" href="classcsArray.html#a21">Pop</a> ()
00664   {
00665     CS_ASSERT (count &gt; 0);
00666     T ret(root [count - 1]);
00667     ElementHandler::Destroy (root + count - 1);
00668     SetSizeUnsafe (count - 1);
00669     <span class="keywordflow">return</span> ret;
00670   }
00671 
<a name="l00673"></a><a class="code" href="classcsArray.html#a22">00673</a>   T <span class="keyword">const</span>&amp; <a class="code" href="classcsArray.html#a22">Top</a> ()<span class="keyword"> const</span>
00674 <span class="keyword">  </span>{
00675     CS_ASSERT (count &gt; 0);
00676     <span class="keywordflow">return</span> root [count - 1];
00677   }
00678 
<a name="l00680"></a><a class="code" href="classcsArray.html#a23">00680</a>   T&amp; <a class="code" href="classcsArray.html#a22">Top</a> ()
00681   {
00682     CS_ASSERT (count &gt; 0);
00683     <span class="keywordflow">return</span> root [count - 1];
00684   }
00685 
<a name="l00687"></a><a class="code" href="classcsArray.html#a24">00687</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsArray.html#a24">Insert</a> (size_t n, T <span class="keyword">const</span>&amp; item)
00688   {
00689     <span class="keywordflow">if</span> (n &lt;= count)
00690     {
00691       SetSizeUnsafe (count + 1); <span class="comment">// Increments 'count' as a side-effect.</span>
00692       size_t <span class="keyword">const</span> nmove = (count - n - 1);
00693       <span class="keywordflow">if</span> (nmove &gt; 0)
00694         MemoryAllocator::MemMove (root, n+1, n, nmove);
00695       ElementHandler::Construct (root + n, item);
00696       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00697     }
00698     <span class="keywordflow">else</span>
00699       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00700   }
00701 
<a name="l00705"></a><a class="code" href="classcsArray.html#a25">00705</a>   <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> <a class="code" href="classcsArray.html#a25">Section</a> (size_t low, size_t high)<span class="keyword"> const</span>
00706 <span class="keyword">  </span>{
00707     CS_ASSERT (high &lt; count &amp;&amp; high &gt;= low);
00708     <a class="code" href="classcsArray.html">csArray&lt;T&gt;</a> sect (high - low + 1);
00709     <span class="keywordflow">for</span> (size_t i = low; i &lt;= high; i++) sect.<a class="code" href="classcsArray.html#a19">Push</a> (root[i]);
00710     <span class="keywordflow">return</span> sect;
00711   }
00712 
00718   csArrayTemplate(K)
<a name="l00719"></a><a class="code" href="classcsArray.html#a26">00719</a>   size_t <a class="code" href="classcsArray.html#a26">FindSortedKey</a> (csArrayCmpDecl(T,K) comparekey,
00720                         size_t* candidate = 0)<span class="keyword"> const</span>
00721 <span class="keyword">  </span>{
00722     size_t m = 0, l = 0, r = <a class="code" href="classcsArray.html#a5">Length</a> ();
00723     <span class="keywordflow">while</span> (l &lt; r)
00724     {
00725       m = (l + r) / 2;
00726       <span class="keywordtype">int</span> cmp = csArrayCmpInvoke(comparekey, root[m]);
00727       <span class="keywordflow">if</span> (cmp == 0)
00728       {
00729         <span class="keywordflow">if</span> (candidate) *candidate = <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a>;
00730         <span class="keywordflow">return</span> m;
00731       }
00732       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmp &lt; 0)
00733         l = m + 1;
00734       <span class="keywordflow">else</span>
00735         r = m;
00736     }
00737     <span class="keywordflow">if</span> (candidate) *candidate = m;
00738     <span class="keywordflow">return</span> <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a>;
00739   }
00740 
<a name="l00747"></a><a class="code" href="classcsArray.html#a27">00747</a>   size_t <a class="code" href="classcsArray.html#a27">InsertSorted</a> (<span class="keyword">const</span> T&amp; item,
00748     <span class="keywordtype">int</span> (*compare)(T <span class="keyword">const</span>&amp;, T <span class="keyword">const</span>&amp;) = <a class="code" href="classcsArray.html#e0">DefaultCompare</a>,
00749     size_t* equal_index = 0)
00750   {
00751     size_t m = 0, l = 0, r = <a class="code" href="classcsArray.html#a5">Length</a> ();
00752     <span class="keywordflow">while</span> (l &lt; r)
00753     {
00754       m = (l + r) / 2;
00755       <span class="keywordtype">int</span> cmp = compare (root [m], item);
00756 
00757       <span class="keywordflow">if</span> (cmp == 0)
00758       {
00759         <span class="keywordflow">if</span> (equal_index) *equal_index = m;
00760         <a class="code" href="classcsArray.html#a24">Insert</a> (++m, item);
00761         <span class="keywordflow">return</span> m;
00762       }
00763       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmp &lt; 0)
00764         l = m + 1;
00765       <span class="keywordflow">else</span>
00766         r = m;
00767     }
00768     <span class="keywordflow">if</span> ((m + 1) == r)
00769       m++;
00770     <span class="keywordflow">if</span> (equal_index) *equal_index = <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a>;
00771     <a class="code" href="classcsArray.html#a24">Insert</a> (m, item);
00772     <span class="keywordflow">return</span> m;
00773   }
00774 
<a name="l00781"></a><a class="code" href="classcsArray.html#a28">00781</a>   size_t <a class="code" href="classcsArray.html#a28">Find</a> (T <span class="keyword">const</span>&amp; which)<span class="keyword"> const</span>
00782 <span class="keyword">  </span>{
00783     <span class="keywordflow">for</span> (size_t i = 0 ; i &lt; <a class="code" href="classcsArray.html#a5">Length</a> () ; i++)
00784       <span class="keywordflow">if</span> (root[i] == which)
00785         <span class="keywordflow">return</span> i;
00786     <span class="keywordflow">return</span> <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a>;
00787   }
00788 
<a name="l00790"></a><a class="code" href="classcsArray.html#a29">00790</a>   size_t <a class="code" href="classcsArray.html#a29">Contains</a>(T <span class="keyword">const</span>&amp; which)<span class="keyword"> const</span>
00791 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classcsArray.html#a28">Find</a>(which); }
00792 
<a name="l00799"></a><a class="code" href="classcsArray.html#a30">00799</a>   size_t <a class="code" href="classcsArray.html#a30">GetIndex</a> (<span class="keyword">const</span> T* which)<span class="keyword"> const</span>
00800 <span class="keyword">  </span>{
00801     CS_ASSERT (which &gt;= root);
00802     CS_ASSERT (which &lt; (root + count));
00803     <span class="keywordflow">return</span> which-root;
00804   }
00805 
<a name="l00809"></a><a class="code" href="classcsArray.html#a31">00809</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a31">Sort</a> (<span class="keywordtype">int</span> (*compare)(T <span class="keyword">const</span>&amp;, T <span class="keyword">const</span>&amp;) = <a class="code" href="classcsArray.html#e0">DefaultCompare</a>)
00810   {
00811     qsort (root, <a class="code" href="classcsArray.html#a5">Length</a>(), <span class="keyword">sizeof</span>(T),
00812       (<span class="keywordtype">int</span> (*)(<span class="keywordtype">void</span> <span class="keyword">const</span>*, <span class="keywordtype">void</span> <span class="keyword">const</span>*))compare);
00813   }
00814 
<a name="l00818"></a><a class="code" href="classcsArray.html#a32">00818</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a32">DeleteAll</a> ()
00819   {
00820     <span class="keywordflow">if</span> (root)
00821     {
00822       size_t i;
00823       <span class="keywordflow">for</span> (i = 0 ; i &lt; count ; i++)
00824         ElementHandler::Destroy (root + i);
00825       MemoryAllocator::Free (root);
00826 <span class="preprocessor">#     ifdef CS_MEMORY_TRACKER</span>
00827 <span class="preprocessor"></span>      UpdateMti (-capacity, 0);
00828 <span class="preprocessor">#     endif</span>
00829 <span class="preprocessor"></span>      root = 0;
00830       capacity = count = 0;
00831     }
00832   }
00833 
<a name="l00845"></a><a class="code" href="classcsArray.html#a33">00845</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a33">Truncate</a> (size_t n)
00846   {
00847     CS_ASSERT(n &lt;= count);
00848     <span class="keywordflow">if</span> (n &lt; count)
00849     {
00850       <span class="keywordflow">for</span> (size_t i = n; i &lt; count; i++)
00851         ElementHandler::Destroy (root + i);
00852       SetSizeUnsafe(n);
00853     }
00854   }
00855 
<a name="l00861"></a><a class="code" href="classcsArray.html#a34">00861</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a34">Empty</a> ()
00862   {
00863     <a class="code" href="classcsArray.html#a33">Truncate</a> (0);
00864   }
00865 
<a name="l00871"></a><a class="code" href="classcsArray.html#a35">00871</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsArray.html#a35">IsEmpty</a>()<span class="keyword"> const</span>
00872 <span class="keyword">  </span>{
00873     <span class="keywordflow">return</span> <a class="code" href="classcsArray.html#a4">GetSize</a>() == 0;
00874   }
00875 
<a name="l00882"></a><a class="code" href="classcsArray.html#a36">00882</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a36">SetCapacity</a> (size_t n)
00883   {
00884     <span class="keywordflow">if</span> (n &gt; <a class="code" href="classcsArray.html#a5">Length</a> ())
00885       InternalSetCapacity (n);
00886   }
00887 
<a name="l00893"></a><a class="code" href="classcsArray.html#a37">00893</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a37">ShrinkBestFit</a> ()
00894   {
00895     <span class="keywordflow">if</span> (count == 0)
00896     {
00897       <a class="code" href="classcsArray.html#a32">DeleteAll</a> ();
00898     }
00899     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count != capacity)
00900     {
00901       root = MemoryAllocator::Realloc (root, count, capacity, count);
00902 <span class="preprocessor">#ifdef CS_MEMORY_TRACKER</span>
00903 <span class="preprocessor"></span>      UpdateMti (count-capacity, count);
00904 <span class="preprocessor">#endif</span>
00905 <span class="preprocessor"></span>      capacity = count;
00906     }
00907   }
00908 
<a name="l00917"></a><a class="code" href="classcsArray.html#a38">00917</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsArray.html#a38">DeleteIndex</a> (size_t n)
00918   {
00919     <span class="keywordflow">if</span> (n &lt; count)
00920     {
00921       size_t <span class="keyword">const</span> ncount = count - 1;
00922       size_t <span class="keyword">const</span> nmove = ncount - n;
00923       ElementHandler::Destroy (root + n);
00924       <span class="keywordflow">if</span> (nmove &gt; 0)
00925         MemoryAllocator::MemMove (root, n, n+1, nmove);
00926       SetSizeUnsafe (ncount);
00927       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00928     }
00929     <span class="keywordflow">else</span>
00930       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00931   }
00932 
<a name="l00942"></a><a class="code" href="classcsArray.html#a39">00942</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsArray.html#a39">DeleteIndexFast</a> (size_t n)
00943   {
00944     <span class="keywordflow">if</span> (n &lt; count)
00945     {
00946       size_t <span class="keyword">const</span> ncount = count - 1;
00947       size_t <span class="keyword">const</span> nmove = ncount - n;
00948       ElementHandler::Destroy (root + n);
00949       <span class="keywordflow">if</span> (nmove &gt; 0)
00950         MemoryAllocator::MemMove (root, n, ncount, 1);
00951       SetSizeUnsafe (ncount);
00952       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00953     }
00954     <span class="keywordflow">else</span>
00955       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00956   }
00957 
<a name="l00962"></a><a class="code" href="classcsArray.html#a40">00962</a>   <span class="keywordtype">void</span> <a class="code" href="classcsArray.html#a40">DeleteRange</a> (size_t start, size_t end)
00963   {
00964     <span class="keywordflow">if</span> (start &gt;= count) <span class="keywordflow">return</span>;
00965     <span class="comment">// Treat 'csArrayItemNotFound' as invalid indices, do nothing.</span>
00966     <span class="comment">// @@@ Assert that?</span>
00967     <span class="keywordflow">if</span> (end == <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a>) <span class="keywordflow">return</span>;
00968     <span class="keywordflow">if</span> (start == <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a>) <span class="keywordflow">return</span>;<span class="comment">//start = 0;</span>
00969     <span class="keywordflow">if</span> (end &gt;= count) end = count - 1;
00970     size_t i;
00971     <span class="keywordflow">for</span> (i = start ; i &lt;= end ; i++)
00972       ElementHandler::Destroy (root + i);
00973 
00974     size_t <span class="keyword">const</span> range_size = end - start + 1;
00975     size_t <span class="keyword">const</span> ncount = count - range_size;
00976     size_t <span class="keyword">const</span> nmove = count - end - 1;
00977     <span class="keywordflow">if</span> (nmove &gt; 0)
00978       MemoryAllocator::MemMove (root, start, start + range_size, nmove);
00979     SetSizeUnsafe (ncount);
00980   }
00981 
<a name="l00987"></a><a class="code" href="classcsArray.html#a41">00987</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsArray.html#a41">Delete</a> (T <span class="keyword">const</span>&amp; item)
00988   {
00989     size_t <span class="keyword">const</span> n = <a class="code" href="classcsArray.html#a28">Find</a> (item);
00990     <span class="keywordflow">if</span> (n != <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a>)
00991       <span class="keywordflow">return</span> <a class="code" href="classcsArray.html#a38">DeleteIndex</a> (n);
00992     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00993   }
00994 
<a name="l01008"></a><a class="code" href="classcsArray.html#a42">01008</a>   <span class="keywordtype">bool</span> <a class="code" href="classcsArray.html#a42">DeleteFast</a> (T <span class="keyword">const</span>&amp; item)
01009   {
01010     size_t <span class="keyword">const</span> n = <a class="code" href="classcsArray.html#a28">Find</a> (item);
01011     <span class="keywordflow">if</span> (n != <a class="code" href="group__util__containers.html#ga0">csArrayItemNotFound</a>)
01012       <span class="keywordflow">return</span> <a class="code" href="classcsArray.html#a39">DeleteIndexFast</a> (n);
01013     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01014   }
01015 
<a name="l01017"></a><a class="code" href="classcsArray_1_1Iterator.html">01017</a>   <span class="keyword">class </span><a class="code" href="classcsArray_1_1Iterator.html">Iterator</a>
01018   {
01019   <span class="keyword">public</span>:
<a name="l01021"></a><a class="code" href="classcsArray_1_1Iterator.html#a0">01021</a>     <a class="code" href="classcsArray_1_1Iterator.html#a0">Iterator</a>(<a class="code" href="classcsArray_1_1Iterator.html">Iterator</a> <span class="keyword">const</span>&amp; r) :
01022       currentelem(r.currentelem), array(r.array) {}
01023 
<a name="l01025"></a><a class="code" href="classcsArray_1_1Iterator.html#a1">01025</a>     <a class="code" href="classcsArray_1_1Iterator.html">Iterator</a>&amp; <a class="code" href="classcsArray_1_1Iterator.html#a1">operator=</a>(<a class="code" href="classcsArray_1_1Iterator.html">Iterator</a> <span class="keyword">const</span>&amp; r)
01026     { currentelem = r.<a class="code" href="classcsArray_1_1Iterator.html#r0">currentelem</a>; array = r.<a class="code" href="classcsArray_1_1Iterator.html#r1">array</a>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
01027 
<a name="l01029"></a><a class="code" href="classcsArray_1_1Iterator.html#a2">01029</a>     <span class="keywordtype">bool</span> <a class="code" href="classcsArray_1_1Iterator.html#a2">HasNext</a>()
01030     { <span class="keywordflow">return</span> currentelem &lt; array.Length(); }
01031 
<a name="l01033"></a><a class="code" href="classcsArray_1_1Iterator.html#a3">01033</a>     <span class="keyword">const</span> T&amp; <a class="code" href="classcsArray_1_1Iterator.html#a3">Next</a>()
01034     { <span class="keywordflow">return</span> array.Get(currentelem++); }
01035 
<a name="l01037"></a><a class="code" href="classcsArray_1_1Iterator.html#a4">01037</a>     <span class="keywordtype">void</span> <a class="code" href="classcsArray_1_1Iterator.html#a4">Reset</a>()
01038     { currentelem = 0; }
01039 
01040   <span class="keyword">protected</span>:
01041     <a class="code" href="classcsArray_1_1Iterator.html#a0">Iterator</a>(<span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;T, ElementHandler&gt;</a>&amp; newarray)
01042         : currentelem(0), array(newarray) {}
01043     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classcsArray.html">csArray</a>&lt;T, ElementHandler&gt;;
01044 
01045   <span class="keyword">private</span>:
01046     size_t currentelem;
01047     <span class="keyword">const</span> <a class="code" href="classcsArray.html">csArray&lt;T, ElementHandler&gt;</a>&amp; array;
01048   };
01049 
<a name="l01051"></a><a class="code" href="classcsArray.html#a43">01051</a>   Iterator <a class="code" href="classcsArray.html#a43">GetIterator</a>()<span class="keyword"> const</span>
01052 <span class="keyword">  </span>{ <span class="keywordflow">return</span> Iterator(*<span class="keyword">this</span>); }
01053 };
01054 
01060 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01061"></a><a class="code" href="classcsSafeCopyArray.html">01061</a> <span class="keyword">class </span><a class="code" href="classcsSafeCopyArray.html">csSafeCopyArray</a>
01062         : <span class="keyword">public</span> <a class="code" href="classcsArray.html">csArray</a>&lt;T,
01063                 csArrayElementHandler&lt;T&gt;,
01064                 csSafeCopyArrayMemoryAllocator&lt;T&gt; &gt;
01065 {
01066 <span class="keyword">public</span>:
<a name="l01071"></a><a class="code" href="classcsSafeCopyArray.html#a0">01071</a>   <a class="code" href="classcsSafeCopyArray.html#a0">csSafeCopyArray</a> (size_t limit = 0, size_t threshold = 0)
01072         : <a class="code" href="classcsArray.html">csArray</a>&lt;T, <a class="code" href="classcsArrayElementHandler.html">csArrayElementHandler</a>&lt;T&gt;,
01073                      <a class="code" href="classcsSafeCopyArrayMemoryAllocator.html">csSafeCopyArrayMemoryAllocator</a>&lt;T&gt; &gt; (limit, threshold)
01074   {
01075   }
01076 };
01077 
01078 <span class="preprocessor">#if defined(CS_EXTENSIVE_MEMDEBUG) || defined(CS_MEMORY_TRACKER)</span>
01079 <span class="preprocessor"></span><span class="preprocessor"># define new CS_EXTENSIVE_MEMDEBUG_NEW</span>
01080 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01081 <span class="preprocessor"></span>
01084 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.2 
</small></address> </div></body> </html>
