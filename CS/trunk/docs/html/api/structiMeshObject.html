<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: iMeshObject Struct Reference (Crystal Space Public API Reference)</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>iMeshObject Struct Reference</h1><!-- doxytag: class="iMeshObject" --><!-- doxytag: inherits="iBase" -->This is a general mesh object that the engine can interact with.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="imesh_2object_8h-source.html">imesh/object.h</a>&gt;</code>
<p>
Inheritance diagram for iMeshObject:<p><center><img src="structiMeshObject__inherit__graph.png" border="0" usemap="#iMeshObject__inherit__map" alt="Inheritance graph"></center>
<map name="iMeshObject__inherit__map">
<area href="classcsParticleSystem.html" shape="rect" coords="38,158,164,182" alt="">
<area href="classscfImplementationExt1.html" shape="rect" coords="188,158,630,182" alt="">
<area href="structiBase.html" shape="rect" coords="226,9,282,33" alt="">
<area href="classcsNewtonianParticleSystem.html" shape="rect" coords="8,233,194,257" alt="">
<area href="classcsMeshObject.html" shape="rect" coords="356,233,462,257" alt="">
<area href="classcsNewParticleSystem.html" shape="rect" coords="333,307,485,331" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="structiMeshObject-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt; <a class="el" href="structiMeshObject.html">iMeshObject</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a0">Clone</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of this object and returns the clone.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a1">GetColor</a> (<a class="el" href="classcsColor.html">csColor</a> &amp;color) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the base color of the mesh.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshObjectFactory.html">iMeshObjectFactory</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a2">GetFactory</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the reference to the factory that created this mesh object.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcsFlags.html">csFlags</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a3">GetFlags</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get flags for this object.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMaterialWrapper.html">iMaterialWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a4">GetMaterialWrapper</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the material of the mesh.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a5">GetMeshWrapper</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the logical parent for this mesh object.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiObjectModel.html">iObjectModel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a6">GetObjectModel</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the generic interface describing the geometry of this mesh.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structcsRenderMesh.html">csRenderMesh</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a7">GetRenderMeshes</a> (int &amp;num, <a class="el" href="structiRenderView.html">iRenderView</a> *rview, <a class="el" href="structiMovable.html">iMovable</a> *movable, <a class="el" href="cstypes_8h.html#a13">uint32</a> frustum_mask)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the set of render meshes.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structiMeshObjectDrawCallback.html">iMeshObjectDrawCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a8">GetVisibleCallback</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current visible callback.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a9">HardTransform</a> (const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;t)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do a hard transform of this object.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a10">HitBeamObject</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr, int *polygon_idx=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if this mesh is hit by this object space vector.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a11">HitBeamOutline</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;start, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;end, <a class="el" href="classcsVector3.html">csVector3</a> &amp;isect, float *pr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if this mesh is hit by this object space vector.  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a12">InvalidateMaterialHandles</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Material changed.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a13">NextFrame</a> (<a class="el" href="cstypes_8h.html#a26">csTicks</a> current_time, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Control animation of this object.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a14">PositionChild</a> (<a class="el" href="structiMeshObject.html">iMeshObject</a> *child, <a class="el" href="cstypes_8h.html#a26">csTicks</a> current_time)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The engine asks this mesh object to place one of his hierarchical children.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a16">SetColor</a> (const <a class="el" href="classcsColor.html">csColor</a> &amp;color)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the base color of the mesh.  <a href="#a16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a17">SetMaterialWrapper</a> (<a class="el" href="structiMaterialWrapper.html">iMaterialWrapper</a> *material)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the material of the mesh.  <a href="#a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a18">SetMeshWrapper</a> (<a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *logparent)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a reference to the mesh wrapper holding the mesh objects.  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a19">SetVisibleCallback</a> (<a class="el" href="structiMeshObjectDrawCallback.html">iMeshObjectDrawCallback</a> *cb)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a callback to the mesh object which will be called from within Draw() if the mesh object thinks that the object is really visible.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiMeshObject.html#a20">SupportsHardTransform</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if HardTransform is supported for this mesh object type.  <a href="#a20"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This is a general mesh object that the engine can interact with. 
<p>
The mesh object only manages its shape, texture etc. but *not* its position, sector or similar information. For this reason, a mesh object can only be used in the engine if a hook object is created for it in the engine that does the required management. The hook object is called mesh wrapper.<p>
Main creators of instances implementing this interface:<ul>
<li>All mesh objects implement this.</li><li><a class="el" href="structiMeshObjectFactory.html#a6">iMeshObjectFactory::NewInstance()</a></li></ul>
<p>
Main ways to get pointers to this interface:<ul>
<li><a class="el" href="structiMeshWrapper.html#a11">iMeshWrapper::GetMeshObject()</a></li></ul>
<p>
Main users of this interface:<ul>
<li>The 3D engine plugin (crystalspace.engine.3d).</li></ul>

<p>

<p>
Definition at line <a class="el" href="imesh_2object_8h-source.html#l00108">108</a> of file <a class="el" href="imesh_2object_8h-source.html">object.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a0"></a><!-- doxytag: member="iMeshObject::Clone" ref="a0" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsPtr.html">csPtr</a>&lt;<a class="el" href="structiMeshObject.html">iMeshObject</a>&gt; iMeshObject::Clone           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a copy of this object and returns the clone. 
<p>

<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a4">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a0">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1"></a><!-- doxytag: member="iMeshObject::GetColor" ref="a1" args="(csColor &amp;color) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iMeshObject::GetColor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classcsColor.html">csColor</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>color</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the base color of the mesh. 
<p>
Will return false if not supported.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a12">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a2">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2"></a><!-- doxytag: member="iMeshObject::GetFactory" ref="a2" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshObjectFactory.html">iMeshObjectFactory</a>* iMeshObject::GetFactory           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the reference to the factory that created this mesh object. 
<p>

<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a13">csParticleSystem</a>, <a class="el" href="classcsNewParticleSystem.html#a9">csNewParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a3">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3"></a><!-- doxytag: member="iMeshObject::GetFlags" ref="a3" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classcsFlags.html">csFlags</a>&amp; iMeshObject::GetFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get flags for this object. 
<p>
The following flags are at least supported: <ul>
<li><a class="el" href="imesh_2object_8h.html#a0">CS_MESH_STATICPOS</a>: mesh will never move. </li>
<li><a class="el" href="imesh_2object_8h.html#a1">CS_MESH_STATICSHAPE</a>: mesh will never animate.</li>
</ul>
Mesh objects may implement additional flags. These mesh object specific flags must be equal to at least 0x00010000.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a14">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a4">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4"></a><!-- doxytag: member="iMeshObject::GetMaterialWrapper" ref="a4" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMaterialWrapper.html">iMaterialWrapper</a>* iMeshObject::GetMaterialWrapper           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the material of the mesh. 
<p>
If not supported this will return 0.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a15">csParticleSystem</a>, <a class="el" href="classcsNewParticleSystem.html#a11">csNewParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a5">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5"></a><!-- doxytag: member="iMeshObject::GetMeshWrapper" ref="a5" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshWrapper.html">iMeshWrapper</a>* iMeshObject::GetMeshWrapper           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the logical parent for this mesh object. 
<p>
See <a class="el" href="structiMeshObject.html#a18">SetMeshWrapper()</a> for more information.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a16">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a6">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6"></a><!-- doxytag: member="iMeshObject::GetObjectModel" ref="a6" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiObjectModel.html">iObjectModel</a>* iMeshObject::GetObjectModel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the generic interface describing the geometry of this mesh. 
<p>
If the factory supports this you should preferably use the object model from the factory instead.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a19">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a8">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7"></a><!-- doxytag: member="iMeshObject::GetRenderMeshes" ref="a7" args="(int &amp;num, iRenderView *rview, iMovable *movable, uint32 frustum_mask)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structcsRenderMesh.html">csRenderMesh</a>** iMeshObject::GetRenderMeshes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiRenderView.html">iRenderView</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rview</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structiMovable.html">iMovable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>movable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="cstypes_8h.html#a13">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>frustum_mask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the set of render meshes. 
<p>
The frustum_mask is given by the culler and contains a mask with all relevant planes for the given object. These planes correspond with the clip planes kept by <a class="el" href="structiRenderView.html">iRenderView</a>.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a23">csParticleSystem</a>, <a class="el" href="classcsNewParticleSystem.html#a13">csNewParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a10">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8"></a><!-- doxytag: member="iMeshObject::GetVisibleCallback" ref="a8" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structiMeshObjectDrawCallback.html">iMeshObjectDrawCallback</a>* iMeshObject::GetVisibleCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current visible callback. 
<p>

<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a26">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a11">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a9"></a><!-- doxytag: member="iMeshObject::HardTransform" ref="a9" args="(const csReversibleTransform &amp;t)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshObject::HardTransform           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsReversibleTransform.html">csReversibleTransform</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>t</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do a hard transform of this object. 
<p>
This transformation and the original coordinates are not remembered but the object space coordinates are directly computed (world space coordinates are set to the object space coordinates by this routine). Note that some implementations of mesh objects will not change the orientation of the object but only the position.
<p>
Implemented in <a class="el" href="classcsMeshObject.html#a12">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10"></a><!-- doxytag: member="iMeshObject::HitBeamObject" ref="a10" args="(const csVector3 &amp;start, const csVector3 &amp;end, csVector3 &amp;isect, float *pr, int *polygon_idx=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iMeshObject::HitBeamObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>isect</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap> <em>pr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>polygon_idx</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if this mesh is hit by this object space vector. 
<p>
Return the collision point in object space coordinates. This is the most detailed version (and also the slowest). The returned hit will be guaranteed to be the point closest to the 'start' of the beam. If the object supports this then an index of the hit polygon will be returned (or -1 if not supported or no hit).
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a28">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a13">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a11"></a><!-- doxytag: member="iMeshObject::HitBeamOutline" ref="a11" args="(const csVector3 &amp;start, const csVector3 &amp;end, csVector3 &amp;isect, float *pr)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iMeshObject::HitBeamOutline           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>isect</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap> <em>pr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if this mesh is hit by this object space vector. 
<p>
This will do a test based on the outline of the object. This means that it is more accurate than HitBeamBBox(). Note that this routine will typically be faster than <a class="el" href="structiMeshObject.html#a10">HitBeamObject()</a>. The hit may be on the front or the back of the object, but will indicate that it iterrupts the beam.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a29">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a14">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a12"></a><!-- doxytag: member="iMeshObject::InvalidateMaterialHandles" ref="a12" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshObject::InvalidateMaterialHandles           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Material changed. 
<p>
This is an 'event' that the engine (or another party managing materials) will send out as soon as the material handles are changed in some way which requires the mesh object to fetch it again (i.e. to call materialwrapper-&gt;GetMaterialHandle()) again.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a30">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a15">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a13"></a><!-- doxytag: member="iMeshObject::NextFrame" ref="a13" args="(csTicks current_time, const csVector3 &amp;pos)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshObject::NextFrame           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="cstypes_8h.html#a26">csTicks</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Control animation of this object. 
<p>

<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a31">csParticleSystem</a>, <a class="el" href="classcsNewParticleSystem.html#a16">csNewParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a16">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a14"></a><!-- doxytag: member="iMeshObject::PositionChild" ref="a14" args="(iMeshObject *child, csTicks current_time)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshObject::PositionChild           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshObject.html">iMeshObject</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>child</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="cstypes_8h.html#a26">csTicks</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>current_time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The engine asks this mesh object to place one of his hierarchical children. 
<p>
It must be placed where it should be at the given time. This object might or might not have been drawn, so you can't use it's current state.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a32">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a17">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a16"></a><!-- doxytag: member="iMeshObject::SetColor" ref="a16" args="(const csColor &amp;color)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iMeshObject::SetColor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsColor.html">csColor</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>color</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the base color of the mesh. 
<p>
This color will be added to whatever color is set for lighting. Not all meshes need to support this. This function will return true if it worked.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a42">csParticleSystem</a>, <a class="el" href="classcsNewParticleSystem.html#a23">csNewParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a18">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a17"></a><!-- doxytag: member="iMeshObject::SetMaterialWrapper" ref="a17" args="(iMaterialWrapper *material)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iMeshObject::SetMaterialWrapper           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMaterialWrapper.html">iMaterialWrapper</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>material</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the material of the mesh. 
<p>
This only works for single-material meshes. If not supported this function will return false.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a43">csParticleSystem</a>, <a class="el" href="classcsNewParticleSystem.html#a26">csNewParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a19">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a18"></a><!-- doxytag: member="iMeshObject::SetMeshWrapper" ref="a18" args="(iMeshWrapper *logparent)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshObject::SetMeshWrapper           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshWrapper.html">iMeshWrapper</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>logparent</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a reference to the mesh wrapper holding the mesh objects. 
<p>
Note that this function should NOT increase the ref-count of the given logical parent because this would cause a circular reference (since the logical parent already holds a reference to this mesh object).
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a44">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a20">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a19"></a><!-- doxytag: member="iMeshObject::SetVisibleCallback" ref="a19" args="(iMeshObjectDrawCallback *cb)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void iMeshObject::SetVisibleCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiMeshObjectDrawCallback.html">iMeshObjectDrawCallback</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a callback to the mesh object which will be called from within Draw() if the mesh object thinks that the object is really visible. 
<p>
Depending on the type of mesh object this can be very accurate or not accurate at all. But in all cases it will certainly be called if the object is visible.
<p>
Implemented in <a class="el" href="classcsParticleSystem.html#a50">csParticleSystem</a>, and <a class="el" href="classcsMeshObject.html#a22">csMeshObject</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a20"></a><!-- doxytag: member="iMeshObject::SupportsHardTransform" ref="a20" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool iMeshObject::SupportsHardTransform           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true if HardTransform is supported for this mesh object type. 
<p>

<p>
Implemented in <a class="el" href="classcsMeshObject.html#a23">csMeshObject</a>.    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>imesh/<a class="el" href="imesh_2object_8h-source.html">object.h</a></ul>
<hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.4 
</small></address> </div></body> </html>
