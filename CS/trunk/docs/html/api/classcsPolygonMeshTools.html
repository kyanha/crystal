<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Crystal Space: csPolygonMeshTools Class Reference (Crystal Space Public API Reference)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="head">
 <tr heigth="59">
  <td class="head" width="202" valign="bottom" style="padding-left:0;"><a href="http://www.crystalspace3d.org/"><img src="csblur.png" width="236" height="59" alt="CrystalSpace" border="0"></a></td>
  <td class="head"><h2>Public API Reference</h2></td>
 </tr>
 <tr heigth="11">
  <td colspan="2" class="headshadow" valign="top" style="padding-left:0;"><img src="csblurb.png" width="236" height="11" alt="" border="0"></td>
 </tr>
</table>
<div class="content">
<!-- Generated by Doxygen 1.4.3-20050530 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>csPolygonMeshTools Class Reference<br>
<small>
[<a class="el" href="group__geom__utils.html">Geometry utilities</a>]</small>
</h1><!-- doxytag: class="csPolygonMeshTools" -->A set of tools to work with <a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> instances.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="pmtools_8h-source.html">csgeom/pmtools.h</a>&gt;</code>
<p>
<a href="classcsPolygonMeshTools-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e0">CalculateNormals</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *mesh, <a class="el" href="classcsVector3.html">csVector3</a> *normals)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will calculate normals for all polygons in the mesh.  <a href="#e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e1">CalculatePlanes</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *mesh, <a class="el" href="classcsPlane3.html">csPlane3</a> *planes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will calculate planes for all polygons in the mesh.  <a href="#e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="structcsPolygonMeshEdge.html">csPolygonMeshEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e2">CalculateEdges</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *, int &amp;num_edges)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a table of edges for this mesh.  <a href="#e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e3">CheckActiveEdges</a> (<a class="el" href="structcsPolygonMeshEdge.html">csPolygonMeshEdge</a> *edges, int num_edges, <a class="el" href="classcsPlane3.html">csPlane3</a> *planes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will check all edges and mark them as active if the two polygons are not co-planar.  <a href="#e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e4">CalculateOutline</a> (<a class="el" href="structcsPolygonMeshEdge.html">csPolygonMeshEdge</a> *edges, int num_edges, <a class="el" href="classcsPlane3.html">csPlane3</a> *planes, int num_vertices, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;pos, int *outline_edges, int &amp;num_outline_edges, bool *outline_verts, float &amp;valid_radius)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a table of edges (as calculated with <a class="el" href="classcsPolygonMeshTools.html#e2">CalculateEdges()</a>), a table of planes (as calculated with CalculatePlanes()), and a position in space.  <a href="#e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e5">IsMeshClosed</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *polyMesh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether a polygon mesh is closed.  <a href="#e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e6">IsMeshConvex</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *polyMesh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether a polygon mesh is convex.  <a href="#e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e7">CloseMesh</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *polyMesh, <a class="el" href="classcsArray.html">csArray</a>&lt; <a class="el" href="structcsMeshedPolygon.html">csMeshedPolygon</a> &gt; &amp;newPolys, int *&amp;vertidx, int &amp;vertidx_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a polygon mesh.  <a href="#e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e8">Triangulate</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *polymesh, <a class="el" href="structcsTriangle.html">csTriangle</a> *&amp;tris, int &amp;tri_count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triangulate a mesh from the polygon mesh data in the <a class="el" href="structiPolygonMesh.html">iPolygonMesh</a>.  <a href="#e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e9">Polygonize</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *polymesh, <a class="el" href="structcsMeshedPolygon.html">csMeshedPolygon</a> *&amp;polygons, int &amp;poly_count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a polygon mesh that has a valid set of triangles and generate a polygon table for that (delete with delete[]).  <a href="#e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e10">SortTrianglesX</a> (<a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *polymesh, <a class="el" href="structcsTriangleMinMax.html">csTriangleMinMax</a> *&amp;tris, int &amp;tri_count, <a class="el" href="classcsPlane3.html">csPlane3</a> *&amp;planes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a polygon mesh and sort triangles on maximum x coordinate.  <a href="#e10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e11">PointInClosedMesh</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;point, <a class="el" href="classcsVector3.html">csVector3</a> *vertices, <a class="el" href="structcsTriangleMinMax.html">csTriangleMinMax</a> *tris, int tri_count, <a class="el" href="classcsPlane3.html">csPlane3</a> *planes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a point is in a closed mesh.  <a href="#e11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e12">LineInClosedMesh</a> (const <a class="el" href="classcsVector3.html">csVector3</a> &amp;p1, const <a class="el" href="classcsVector3.html">csVector3</a> &amp;p2, <a class="el" href="classcsVector3.html">csVector3</a> *vertices, <a class="el" href="structcsTriangleMinMax.html">csTriangleMinMax</a> *tris, int tri_count, <a class="el" href="classcsPlane3.html">csPlane3</a> *planes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a line is in a closed mesh.  <a href="#e12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsPolygonMeshTools.html#e13">BoxInClosedMesh</a> (const <a class="el" href="classcsBox3.html">csBox3</a> &amp;box, <a class="el" href="classcsVector3.html">csVector3</a> *vertices, <a class="el" href="structcsTriangleMinMax.html">csTriangleMinMax</a> *tris, int tri_count, <a class="el" href="classcsPlane3.html">csPlane3</a> *planes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a box is in a closed mesh.  <a href="#e13"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A set of tools to work with <a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> instances. 
<p>

<p>
Definition at line <a class="el" href="pmtools_8h-source.html#l00067">67</a> of file <a class="el" href="pmtools_8h-source.html">pmtools.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e13"></a><!-- doxytag: member="csPolygonMeshTools::BoxInClosedMesh" ref="e13" args="(const csBox3 &amp;box, csVector3 *vertices, csTriangleMinMax *tris, int tri_count, csPlane3 *planes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static bool csPolygonMeshTools::BoxInClosedMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsBox3.html">csBox3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structcsTriangleMinMax.html">csTriangleMinMax</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tris</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>tri_count</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsPlane3.html">csPlane3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>planes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test if a box is in a closed mesh. 
<p>
The mesh is defined by an array of triangles which should be sorted on x using the <a class="el" href="classcsPolygonMeshTools.html#e10">SortTrianglesX()</a> function. This function does not check if the mesh is really closed. This function also needs an array of planes. You can calculate that with CalculatePlanes(). This function does not check if the eight corner points are actually in the object. If they are not then you will actually reverse the check and this function will return true if the box is completely outside the object. Basically this function tests if the box intersects some polygon in the object and it will return false if it does.    </td>
  </tr>
</table>
<a class="anchor" name="e2"></a><!-- doxytag: member="csPolygonMeshTools::CalculateEdges" ref="e2" args="(iPolygonMesh *, int &amp;num_edges)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static <a class="el" href="structcsPolygonMeshEdge.html">csPolygonMeshEdge</a>* csPolygonMeshTools::CalculateEdges           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>num_edges</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a table of edges for this mesh. 
<p>
The resulting table may later be deleted with 'delete[]'. Note that every edge will only connect two polygons. If more polygons connect to an edge then the edge will be duplicated. The 'active' flag of the returned edges is not calculated by this routine. Use 'CheckActiveEdges()' for that.    </td>
  </tr>
</table>
<a class="anchor" name="e0"></a><!-- doxytag: member="csPolygonMeshTools::CalculateNormals" ref="e0" args="(iPolygonMesh *mesh, csVector3 *normals)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static void csPolygonMeshTools::CalculateNormals           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>normals</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function will calculate normals for all polygons in the mesh. 
<p>
The given array of 'normals' should be big enough to have normals for the number of polygons as defined in the mesh itself.    </td>
  </tr>
</table>
<a class="anchor" name="e4"></a><!-- doxytag: member="csPolygonMeshTools::CalculateOutline" ref="e4" args="(csPolygonMeshEdge *edges, int num_edges, csPlane3 *planes, int num_vertices, const csVector3 &amp;pos, int *outline_edges, int &amp;num_outline_edges, bool *outline_verts, float &amp;valid_radius)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static void csPolygonMeshTools::CalculateOutline           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structcsPolygonMeshEdge.html">csPolygonMeshEdge</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>edges</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_edges</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsPlane3.html">csPlane3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>planes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>outline_edges</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>num_outline_edges</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool *&nbsp;</td>
          <td class="mdname" nowrap> <em>outline_verts</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>valid_radius</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given a table of edges (as calculated with <a class="el" href="classcsPolygonMeshTools.html#e2">CalculateEdges()</a>), a table of planes (as calculated with CalculatePlanes()), and a position in space. 
<p>
This function will calculate an outline that is valid from that position. This outline will be given as an array of bool indicating which vertex indices that are used (so these have to be transformed from 3D to 2D) and also an array of double vertex indices (every set of two vertex indices forms one edge) that form the outline. This function will also return a radius. As long as the position doesn't move outside this radius the outline will be valid. The two input tables should have enough space for the returned number of edges and vertex indices. The safest way is to allocate double the amount of vertices as there are active edges in the input edge table and enough vertices as the polygon mesh supports. <br>
 Note: this function requires that the given edges are marked as active or not (use <a class="el" href="classcsPolygonMeshTools.html#e3">CheckActiveEdges()</a>). <br>
 Note: num_outline_edges will be the amount of edges (which means that there will be twice as much vertices in the 'outline_edges' table.    </td>
  </tr>
</table>
<a class="anchor" name="e1"></a><!-- doxytag: member="csPolygonMeshTools::CalculatePlanes" ref="e1" args="(iPolygonMesh *mesh, csPlane3 *planes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static void csPolygonMeshTools::CalculatePlanes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsPlane3.html">csPlane3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>planes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function will calculate planes for all polygons in the mesh. 
<p>
The given array of 'planes' should be big enough to have planes for the number of polygons as defined in the mesh itself.    </td>
  </tr>
</table>
<a class="anchor" name="e3"></a><!-- doxytag: member="csPolygonMeshTools::CheckActiveEdges" ref="e3" args="(csPolygonMeshEdge *edges, int num_edges, csPlane3 *planes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static int csPolygonMeshTools::CheckActiveEdges           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structcsPolygonMeshEdge.html">csPolygonMeshEdge</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>edges</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_edges</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsPlane3.html">csPlane3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>planes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function will check all edges and mark them as active if the two polygons are not co-planar. 
<p>
This function will return the number of active edges.    </td>
  </tr>
</table>
<a class="anchor" name="e7"></a><!-- doxytag: member="csPolygonMeshTools::CloseMesh" ref="e7" args="(iPolygonMesh *polyMesh, csArray&lt; csMeshedPolygon &gt; &amp;newPolys, int *&amp;vertidx, int &amp;vertidx_len)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static void csPolygonMeshTools::CloseMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>polyMesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsArray.html">csArray</a>&lt; <a class="el" href="structcsMeshedPolygon.html">csMeshedPolygon</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>newPolys</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>vertidx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>vertidx_len</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a polygon mesh. 
<p>
The current implementation is rather naive; it just returns all faces, but flipped. The returned table is a table of indices that are used in the returned polygons. Don't forget to delete[] that table!    </td>
  </tr>
</table>
<a class="anchor" name="e5"></a><!-- doxytag: member="csPolygonMeshTools::IsMeshClosed" ref="e5" args="(iPolygonMesh *polyMesh)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static bool csPolygonMeshTools::IsMeshClosed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>polyMesh</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test whether a polygon mesh is closed. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>This function works best if vertices are shared.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e6"></a><!-- doxytag: member="csPolygonMeshTools::IsMeshConvex" ref="e6" args="(iPolygonMesh *polyMesh)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static bool csPolygonMeshTools::IsMeshConvex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>polyMesh</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test whether a polygon mesh is convex. 
<p>
Note! This is NOT a fast function. Use with care. <dl compact><dt><b>Remarks:</b></dt><dd>This function works best if vertices are shared.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e12"></a><!-- doxytag: member="csPolygonMeshTools::LineInClosedMesh" ref="e12" args="(const csVector3 &amp;p1, const csVector3 &amp;p2, csVector3 *vertices, csTriangleMinMax *tris, int tri_count, csPlane3 *planes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static bool csPolygonMeshTools::LineInClosedMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structcsTriangleMinMax.html">csTriangleMinMax</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tris</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>tri_count</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsPlane3.html">csPlane3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>planes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test if a line is in a closed mesh. 
<p>
The mesh is defined by an array of triangles which should be sorted on x using the <a class="el" href="classcsPolygonMeshTools.html#e10">SortTrianglesX()</a> function. This function does not check if the mesh is really closed. This function also needs an array of planes. You can calculate that with CalculatePlanes(). This function does not check if the two points are actually in the object. If they are not then you will actually reverse the check and this function will return true if the line is completely outside the object. Basically this function tests if the line intersects some polygon in the object and it will return false if it does.    </td>
  </tr>
</table>
<a class="anchor" name="e11"></a><!-- doxytag: member="csPolygonMeshTools::PointInClosedMesh" ref="e11" args="(const csVector3 &amp;point, csVector3 *vertices, csTriangleMinMax *tris, int tri_count, csPlane3 *planes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static bool csPolygonMeshTools::PointInClosedMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classcsVector3.html">csVector3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsVector3.html">csVector3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structcsTriangleMinMax.html">csTriangleMinMax</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tris</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>tri_count</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsPlane3.html">csPlane3</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>planes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test if a point is in a closed mesh. 
<p>
The mesh is defined by an array of triangles which should be sorted on x using the <a class="el" href="classcsPolygonMeshTools.html#e10">SortTrianglesX()</a> function. This function does not check if the mesh is really closed. This function also needs an array of planes. You can calculate that with CalculatePlanes().    </td>
  </tr>
</table>
<a class="anchor" name="e9"></a><!-- doxytag: member="csPolygonMeshTools::Polygonize" ref="e9" args="(iPolygonMesh *polymesh, csMeshedPolygon *&amp;polygons, int &amp;poly_count)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static void csPolygonMeshTools::Polygonize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>polymesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structcsMeshedPolygon.html">csMeshedPolygon</a> *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>poly_count</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Take a polygon mesh that has a valid set of triangles and generate a polygon table for that (delete with delete[]). 
<p>
Note that the polygons will point inside the triangle table!    </td>
  </tr>
</table>
<a class="anchor" name="e10"></a><!-- doxytag: member="csPolygonMeshTools::SortTrianglesX" ref="e10" args="(iPolygonMesh *polymesh, csTriangleMinMax *&amp;tris, int &amp;tri_count, csPlane3 *&amp;planes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static void csPolygonMeshTools::SortTrianglesX           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>polymesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structcsTriangleMinMax.html">csTriangleMinMax</a> *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>tris</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>tri_count</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classcsPlane3.html">csPlane3</a> *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>planes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Take a polygon mesh and sort triangles on maximum x coordinate. 
<p>
That means that the first triangle in the returned array will have a minimum x coordinates that is lower then further triangles. This is useful for the SortedIn() routine below. This routine will also calculate planes. When done delete the returned arrays.    </td>
  </tr>
</table>
<a class="anchor" name="e8"></a><!-- doxytag: member="csPolygonMeshTools::Triangulate" ref="e8" args="(iPolygonMesh *polymesh, csTriangle *&amp;tris, int &amp;tri_count)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static void csPolygonMeshTools::Triangulate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structiPolygonMesh.html">iPolygonMesh</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>polymesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structcsTriangle.html">csTriangle</a> *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>tris</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>tri_count</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Triangulate a mesh from the polygon mesh data in the <a class="el" href="structiPolygonMesh.html">iPolygonMesh</a>. 
<p>
Returns a table of triangles (delete with delete[]). Note that this function will always triangulate the polygons even if there is a perfectly usable array of triangles in the mesh. You should test for this outside of this function.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>csgeom/<a class="el" href="pmtools_8h-source.html">pmtools.h</a></ul>
<hr size="1"><address><small>Generated for Crystal Space by 
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.4.3-20050530 
</small></address> </div></body> </html>
