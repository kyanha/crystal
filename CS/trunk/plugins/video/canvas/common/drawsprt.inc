/*
    Copyright (C) 1998 by Jorrit Tyberghein
    The DrawSprite routine in a separate include file

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

/*
    This is the generalized DrawSpriteXX routine. Since the only difference
    between DrawSprite routines was the datatype of a pixel, the former three
    different routines have been unified into a single file.

    Before including this file you should define the following macros:

    DRAWSPRITE_NAME - The name of routine (DrawSprite8 etc).
    DRAWSPRITE_PIXTYPE - The type of a pixel (UByte, UShort, ULong)
*/

void csGraphics2D::DRAWSPRITE_NAME (csGraphics2D *This, iTextureHandle *hTex,
  int sx, int sy, int sw, int sh, int tx, int ty, int tw, int th)
{
  bool transp = hTex->GetTransparent ();

  int bw, bh;
  hTex->GetMipMapDimensions (0, bw, bh);

  UByte *bitmap = (UByte *)hTex->GetMipMapData (0);
  DRAWSPRITE_PIXTYPE *palette = (DRAWSPRITE_PIXTYPE *)hTex->GetMipMapData (-1);

  int dx = (tw << 16) / sw;
  int dy = (th << 16) / sh;

  // Clipping
  if ((sx >= This->ClipX2) || (sy >= This->ClipY2) ||
      (sx + sw <= This->ClipX1) || (sy + sh <= This->ClipY1))
    return;				// Sprite is totally invisible
  if (sx < This->ClipX1)		// Left margin crossed?
  {
    int nw = sw - (This->ClipX1 - sx);	// New width
    tx += (This->ClipX1 - sx) * tw / sw;// Adjust X coord on texture
    tw = (tw * nw) / sw;		// Adjust width on texture
    sw = nw; sx = This->ClipX1;
  } /* endif */
  if (sx + sw > This->ClipX2)		// Right margin crossed?
  {
    int nw = This->ClipX2 - sx;		// New width
    tw = (tw * nw) / sw;		// Adjust width on texture
    sw = nw;
  } /* endif */
  if (sy < This->ClipY1)		// Top margin crossed?
  {
    int nh = sh - (This->ClipY1 - sy);	// New height
    ty += (This->ClipY1 - sy) * th / sh;// Adjust Y coord on texture
    th = (th * nh) / sh;		// Adjust height on texture
    sh = nh; sy = This->ClipY1;
  } /* endif */
  if (sy + sh > This->ClipY2)		// Bottom margin crossed?
  {
    int nh = This->ClipY2 - sy;		// New height
    th = (th * nh) / sh;		// Adjust height on texture
    sh = nh;
  } /* endif */

  bitmap += ty * bw + tx;
  ty = 0;

  if (sw == tw)
    for (; sh > 0; sh--, ty += dy, sy++)
    {
      DRAWSPRITE_PIXTYPE *VRAM = (DRAWSPRITE_PIXTYPE *)This->GetPixelAt (sx, sy);
      UByte *data = bitmap + (ty >> 16) * bw;
      if (transp)
        for (int w = sw; w; w--)
        {
          UByte pixel = *data;
          if (pixel)
            *VRAM = palette [pixel];
          VRAM++;
          data++;
        } /* endfor */
      else
        for (int w = sw; w; w--)
          *VRAM++ = palette [*data++];
    } /* endfor */
  else
    for (; sh > 0; sh--, ty += dy, sy++)
    {
      DRAWSPRITE_PIXTYPE *VRAM = (DRAWSPRITE_PIXTYPE *)This->GetPixelAt (sx, sy);
      UByte *data = bitmap + (ty >> 16) * bw;
      int tx = 0;
      if (transp)
        for (int w = sw; w; w--)
        {
          UByte pixel = data [tx >> 16];
          if (pixel)
            *VRAM = palette [pixel];
          VRAM++;
          tx += dx;
        } /* endfor */
      else
        for (int w = sw; w; w--)
        {
          *VRAM++ = palette [data [tx >> 16]];
          tx += dx;
        } /* endfor */
    } /* endfor */
}

#undef DRAWSPRITE_NAME
#undef DRAWSPRITE_PIXTYPE
