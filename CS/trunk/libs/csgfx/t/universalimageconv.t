/*
    Copyright(C) 2012 by Frank Richter

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

#include <csgfx/universalimageconv.h>

#include <csgfx/textureformatstrings.h>

/**
 * Test for CS::Graphics::UniversalImageConverter
 */
class UniversalImageConverterTest : public CppUnit::TestFixture
{
public:
  void testInvalidFormats();
  void testInvalidConversions();
  void testRGBA8Permutations ();
  void test32to16 ();
  void test32to16_multiple ();
  void test16to32 ();
  void test16to32_multiple ();
  void test24to32 ();
  void test24to32_multiple ();
  void test32to24 ();
  void test32to24_multiple ();

  void testItoF ();
  void testF32toF16 ();
  void testF32toF64 ();
  void testF16toF32 ();
  void testF16toF64 ();
  void testF64toF16 ();
  void testF64toF32 ();
  void testF32toI ();
  void testF16toI ();
  void testF64toI ();

  void testLAtoRGBA ();

  CPPUNIT_TEST_SUITE(UniversalImageConverterTest);
    CPPUNIT_TEST(testInvalidFormats);
    CPPUNIT_TEST(testInvalidConversions);
    CPPUNIT_TEST(testRGBA8Permutations);
    CPPUNIT_TEST(test32to16);
    CPPUNIT_TEST(test32to16_multiple);
    CPPUNIT_TEST(test16to32);
    CPPUNIT_TEST(test16to32_multiple);
    CPPUNIT_TEST(test24to32);
    CPPUNIT_TEST(test24to32_multiple);
    CPPUNIT_TEST(test32to24);
    CPPUNIT_TEST(test32to24_multiple);
    CPPUNIT_TEST(testItoF);
    CPPUNIT_TEST(testF32toF16);
    CPPUNIT_TEST(testF32toF64);
    CPPUNIT_TEST(testF16toF32);
    CPPUNIT_TEST(testF16toF64);
    CPPUNIT_TEST(testF64toF16);
    CPPUNIT_TEST(testF64toF32);
    CPPUNIT_TEST(testF32toI);
    CPPUNIT_TEST(testF16toI);
    CPPUNIT_TEST(testF64toI);
    CPPUNIT_TEST(testLAtoRGBA);
  CPPUNIT_TEST_SUITE_END();
};

void UniversalImageConverterTest::testInvalidFormats ()
{
  uint8 dummyIn[4], dummyOut[4];
  CS::StructuredTextureFormat validFormat (CS::TextureFormatStrings::ConvertStructured ("rgba8"));

  {
    CS::StructuredTextureFormat invalidMultipleComps (CS::TextureFormatStrings::ConvertStructured ("rgbr8"));
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, validFormat,
                                                             dummyOut, invalidMultipleComps, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorInvalidFormat, convResult);
    }
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, invalidMultipleComps,
                                                             dummyOut, validFormat, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorInvalidFormat, convResult);
    }
  }
  {
    CS::StructuredTextureFormat invalidMixedTypes (CS::TextureFormatStrings::ConvertStructured ("rgbl8"));
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, validFormat,
                                                             dummyOut, invalidMixedTypes, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorFormatUnsupported, convResult);
    }
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, invalidMixedTypes,
                                                             dummyOut, validFormat, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorFormatUnsupported, convResult);
    }
  }
  {
    CS::StructuredTextureFormat invalidSpecial (CS::TextureFormatStrings::ConvertStructured ("*dxt1"));
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, validFormat,
                                                             dummyOut, invalidSpecial, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorFormatUnsupported, convResult);
    }
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, invalidSpecial,
                                                             dummyOut, validFormat, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorFormatUnsupported, convResult);
    }
  }
  {
    CS::StructuredTextureFormat invalid;
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, validFormat,
                                                             dummyOut, invalid, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorInvalidFormat, convResult);
    }
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, invalid,
                                                             dummyOut, validFormat, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorInvalidFormat, convResult);
    }
  }
  {
    CS::StructuredTextureFormat invalidFloatSize (CS::TextureFormatStrings::ConvertStructured ("rgb8_f"));
    CS::StructuredTextureFormat invalidFloatSize2 (CS::TextureFormatStrings::ConvertStructured ("rgb17_f"));
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, validFormat,
                                                             dummyOut, invalidFloatSize, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorInvalidFormat, convResult);
    }
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, invalidFloatSize,
                                                             dummyOut, validFormat, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorInvalidFormat, convResult);
    }
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, validFormat,
                                                             dummyOut, invalidFloatSize2, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorInvalidFormat, convResult);
    }
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, invalidFloatSize2,
                                                             dummyOut, validFormat, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorInvalidFormat, convResult);
    }
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, invalidFloatSize2,
                                                             dummyOut, invalidFloatSize, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorInvalidFormat, convResult);
    }
    {
      CS::Graphics::UniversalImageConverter::Result convResult =
        CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, invalidFloatSize,
                                                             dummyOut, invalidFloatSize2, 1);
      CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorInvalidFormat, convResult);
    }
  }
}

void UniversalImageConverterTest::testInvalidConversions ()
{
  uint8 dummyIn[4], dummyOut[4];
  CS::StructuredTextureFormat formatRGBA (CS::TextureFormatStrings::ConvertStructured ("rgba8"));
  CS::StructuredTextureFormat formatLA (CS::TextureFormatStrings::ConvertStructured ("la8"));
  CS::StructuredTextureFormat formatDS (CS::TextureFormatStrings::ConvertStructured ("d24s8"));
  CS::StructuredTextureFormat formatSpecial (CS::TextureFormatStrings::ConvertStructured ("*dxt1"));

  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatRGBA,
                                                           dummyOut, formatLA, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorIncompatibleComponents, convResult);
  }
  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatRGBA,
                                                           dummyOut, formatDS, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorIncompatibleComponents, convResult);
  }
  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatRGBA,
                                                           dummyOut, formatSpecial, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorFormatUnsupported, convResult);
  }

  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatLA,
                                                           dummyOut, formatDS, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorIncompatibleComponents, convResult);
  }
  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatLA,
                                                           dummyOut, formatSpecial, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorFormatUnsupported, convResult);
  }

  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatDS,
                                                           dummyOut, formatRGBA, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorIncompatibleComponents, convResult);
  }
  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatDS,
                                                           dummyOut, formatLA, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorIncompatibleComponents, convResult);
  }
  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatDS,
                                                           dummyOut, formatSpecial, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorFormatUnsupported, convResult);
  }

  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatSpecial,
                                                           dummyOut, formatRGBA, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorFormatUnsupported, convResult);
  }
  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatSpecial,
                                                           dummyOut, formatLA, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorFormatUnsupported, convResult);
  }
  {
    CS::Graphics::UniversalImageConverter::Result convResult =
      CS::Graphics::UniversalImageConverter::ConvertBasic (dummyIn, formatSpecial,
                                                           dummyOut, formatDS, 1);
    CPPUNIT_ASSERT_EQUAL(CS::Graphics::UniversalImageConverter::ErrorFormatUnsupported, convResult);
  }
}

void UniversalImageConverterTest::testRGBA8Permutations ()
{
  const uint8 testData[4] = { 0x01, 0x02, 0x03, 0x04 };
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba8"));

  const char permuteComps[4] = { 'r', 'g', 'b', 'a' };
  for (uint c0 = 0; c0 < 4; c0++)
  {
    uint permuteComps1[3];
    for (uint c = 0, i = 0; c < 4; c++)
    {
      if (c != c0) permuteComps1[i++] = c;
    }
    for (uint c1 = 0; c1 < 3; c1++)
    {
      uint permuteComps2[2];
      for (uint c = 0, i = 0; c < 3; c++)
      {
        if (c != c1) permuteComps2[i++] = permuteComps1[c];
      }
      for (uint c2 = 0; c2 < 2; c2++)
      {
        CS::StructuredTextureFormat permutedFormat (permuteComps[c0], 8,
                                                    permuteComps[permuteComps1[c1]], 8,
                                                    permuteComps[permuteComps2[c2]], 8,
                                                    permuteComps[permuteComps2[c2 ^ 1]], 8);
        csString formatStr (permutedFormat.GetCanonical());

        uint8 outputData[4];
        memset (outputData, 0xaa, sizeof (outputData));
        CS::Graphics::UniversalImageConverter::ConvertBasic (&testData, inputFormat,
                                                             &outputData, permutedFormat, 1);
        uint8 expectedData[4];
        expectedData[3] = testData[3-c0];
        expectedData[2] = testData[3-permuteComps1[c1]];
        expectedData[1] = testData[3-permuteComps2[c2]];
        expectedData[0] = testData[3-permuteComps2[c2 ^ 1]];
        CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), int (expectedData[0]), int (outputData[0]));
        CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), int (expectedData[1]), int (outputData[1]));
        CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), int (expectedData[2]), int (outputData[2]));
        CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), int (expectedData[3]), int (outputData[3]));
      }
    }
  }
}

static void TestOneConversion32to16 (int num,
                                     const CS::StructuredTextureFormat& inputFormat, const uint8* inData,
                                     const CS::StructuredTextureFormat& outputFormat, const uint8* expectedData,
                                     bool junk_msb = false)
{
  csString formatStr (outputFormat.GetCanonical ());
  formatStr.AppendFmt (", #%d", num);

  uint8 outputData[2];
  memset (outputData, 0xaa, sizeof (outputData));
  CS::Graphics::UniversalImageConverter::ConvertBasic (inData, inputFormat,
                                                       outputData, outputFormat, 1);
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), int (expectedData[0]), int (outputData[0]));
  uint8 msb_mask = 0xff;
  if (junk_msb)
  {
    // Ignore 'junk' bit
    msb_mask = 0x7f;
  }
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), int (expectedData[1]), int (outputData[1] & msb_mask));
}

void UniversalImageConverterTest::test32to16 ()
{
  const struct TestConversion
  {
    uint8 inData[4];
    uint8 expectedData565[2];
    uint8 expectedData555[2];
    uint8 expectedDatax555[2];
    uint8 expectedData1555[2];
  } testConversions[] =
  {
    // Red
    { { 0x00, 0x00, 0x00, 0xff }, { 0x00, 0xf8 }, { 0x00, 0xf8 }, { 0x00, 0x7c }, { 0x00, 0x7c } },
    // Green
    { { 0x00, 0x00, 0xff, 0x00 }, { 0xe0, 0x07 }, { 0xc0, 0x07 }, { 0xe0, 0x03 }, { 0xe0, 0x03 } },
    // Blue
    { { 0x00, 0xff, 0x00, 0x00 }, { 0x1f, 0x00 }, { 0x3e, 0x00 }, { 0x1f, 0x00 }, { 0x1f, 0x00 } },
    // Black w/ alpha
    { { 0xff, 0x00, 0x00, 0x00 }, { 0x00, 0x00 }, { 0x00, 0x00 }, { 0x00, 0x00 }, { 0x00, 0x80 } }
  };
  const size_t numConversions = sizeof (testConversions) / sizeof (testConversions[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba8"));
  CS::StructuredTextureFormat outputFormat565 (CS::TextureFormatStrings::ConvertStructured ("r5g6b5"));
  CS::StructuredTextureFormat outputFormat555 (CS::TextureFormatStrings::ConvertStructured ("r5g5b5"));
  CS::StructuredTextureFormat outputFormatx555 (CS::TextureFormatStrings::ConvertStructured ("x1r5g5b5"));
  CS::StructuredTextureFormat outputFormat1555 (CS::TextureFormatStrings::ConvertStructured ("a1r5g5b5"));

  for (size_t i = 0; i < numConversions; i++)
  {
    const TestConversion& conversion = testConversions[i];
    TestOneConversion32to16 (i, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565);
    TestOneConversion32to16 (i, inputFormat, conversion.inData, outputFormat555, conversion.expectedData555);
    TestOneConversion32to16 (i, inputFormat, conversion.inData, outputFormatx555, conversion.expectedDatax555, true);
    TestOneConversion32to16 (i, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555);
  }
}

struct TestConversion32to16_multiple
{
  uint8 inData[4*4];
  uint8 expectedData[4*2];
};

static void TestOneConversion32to16_multiple (const CS::StructuredTextureFormat& inputFormat,
                                              const CS::StructuredTextureFormat& outputFormat,
                                              const TestConversion32to16_multiple& conversion,
                                              bool junk_msb = false)
{
  csString formatStr (outputFormat.GetCanonical ());

  uint8 outputData[4 + sizeof (conversion.expectedData) + 4];
  // Sentinel bytes at the start/front
  memset (outputData, 0xf0, 4);
  memset (outputData + 4 + sizeof(conversion.expectedData), 0x0b, 4);
  // Actual results
  memset (outputData + 4, 0xaa, sizeof(conversion.expectedData));
  CS::Graphics::UniversalImageConverter::ConvertBasic (conversion.inData, inputFormat,
                                                       outputData + 4, outputFormat,
                                                       sizeof(conversion.expectedData)/2);

  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[0]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[1]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[2]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[3]));

  uint8 msb_mask = 0xff;
  if (junk_msb)
  {
    // Ignore 'junk' bit
    msb_mask = 0x7f;
  }
  for (size_t p = 0; p < sizeof(conversion.expectedData)/2; p++)
  {
    csString msg (formatStr);
    msg.AppendFmt (", pixel %zu", p);
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*2+0]), int (outputData[p*2+4]));
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*2+1]), int (outputData[p*2+5] & msb_mask));
  }

  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+4]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+5]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+6]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+7]));
}

void UniversalImageConverterTest::test32to16_multiple ()
{
  const TestConversion32to16_multiple testConversion565 =
  {
    { 0x00, 0x00, 0x00, 0xff,
      0x00, 0x00, 0xff, 0x00,
      0x00, 0xff, 0x00, 0x00,
      0xff, 0x00, 0x00, 0x00 },
    { 0x00, 0xf8,
      0xe0, 0x07,
      0x1f, 0x00,
      0x00, 0x00 }
  };
  const TestConversion32to16_multiple testConversion555 =
  {
    { 0x00, 0x00, 0x00, 0xff,
      0x00, 0x00, 0xff, 0x00,
      0x00, 0xff, 0x00, 0x00,
      0xff, 0x00, 0x00, 0x00 },
    { 0x00, 0xf8,
      0xc0, 0x07,
      0x3e, 0x00,
      0x00, 0x00 }
  };
  const TestConversion32to16_multiple testConversionx555 =
  {
    { 0x00, 0x00, 0x00, 0xff,
      0x00, 0x00, 0xff, 0x00,
      0x00, 0xff, 0x00, 0x00,
      0xff, 0x00, 0x00, 0x00 },
    { 0x00, 0x7c,
      0xe0, 0x03,
      0x1f, 0x00,
      0x00, 0x00 }
  };
  const TestConversion32to16_multiple testConversion1555 =
  {
    { 0x00, 0x00, 0x00, 0xff,
      0x00, 0x00, 0xff, 0x00,
      0x00, 0xff, 0x00, 0x00,
      0xff, 0x00, 0x00, 0x00 },
    { 0x00, 0x7c,
      0xe0, 0x03,
      0x1f, 0x00,
      0x00, 0x80 }
  };
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba8"));
  CS::StructuredTextureFormat outputFormat565 (CS::TextureFormatStrings::ConvertStructured ("r5g6b5"));
  CS::StructuredTextureFormat outputFormat555 (CS::TextureFormatStrings::ConvertStructured ("r5g5b5"));
  CS::StructuredTextureFormat outputFormatx555 (CS::TextureFormatStrings::ConvertStructured ("x1r5g5b5"));
  CS::StructuredTextureFormat outputFormat1555 (CS::TextureFormatStrings::ConvertStructured ("a1r5g5b5"));

  TestOneConversion32to16_multiple (inputFormat, outputFormat565, testConversion565);
  TestOneConversion32to16_multiple (inputFormat, outputFormat555, testConversion555);
  TestOneConversion32to16_multiple (inputFormat, outputFormatx555, testConversionx555, true);
  TestOneConversion32to16_multiple (inputFormat, outputFormat1555, testConversion1555);
}

static void TestOneConversion16to32 (int num,
                                     const CS::StructuredTextureFormat& inputFormat, const uint8* inData,
                                     const CS::StructuredTextureFormat& outputFormat, const uint8* expectedData,
                                     bool ignore_first_byte)
{
  csString formatStr (outputFormat.GetCanonical ());
  formatStr.AppendFmt (", #%d", num);

  uint8 outputData[4];
  memset (outputData, 0xaa, sizeof (outputData));
  CS::Graphics::UniversalImageConverter::ConvertBasic (inData, inputFormat,
                                                       outputData, outputFormat, 1);

  if (!ignore_first_byte)
  {
    CPPUNIT_ASSERT_EQUAL(int (expectedData[0]), int (outputData[0]));
  }
  else
  {
    // Ignore first byte (no component in input)
  }
  CPPUNIT_ASSERT_EQUAL(int (expectedData[1]), int (outputData[1]));
  CPPUNIT_ASSERT_EQUAL(int (expectedData[2]), int (outputData[2]));
  CPPUNIT_ASSERT_EQUAL(int (expectedData[3]), int (outputData[3]));
}

void UniversalImageConverterTest::test16to32 ()
{
  struct TestConversion
  {
    uint8 inData[2];
    uint8 expectedData[4];
  };
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba8"));
  {
    const TestConversion testConversions565[] =
    {
      // Red
      { { 0x00, 0xf8 }, { 0x00, 0x00, 0x00, 0xff } },
      // Green
      { { 0xe0, 0x07 }, { 0x00, 0x00, 0xff, 0x00 } },
      // Blue
      { { 0x1f, 0x00 }, { 0x00, 0xff, 0x00, 0x00 } },

      // Some values that need expansion
      { { 0x00, 0x80 }, { 0x00, 0x00, 0x00, 0x84 } },
      { { 0x00, 0x08 }, { 0x00, 0x00, 0x00, 0x08 } },
      { { 0x00, 0x78 }, { 0x00, 0x00, 0x00, 0x7b } }
    };
    const size_t numConversions565 = sizeof (testConversions565) / sizeof (testConversions565[0]);

    CS::StructuredTextureFormat inputFormat565 (CS::TextureFormatStrings::ConvertStructured ("r5g6b5"));
    for (size_t i = 0; i < numConversions565; i++)
    {
      const TestConversion& conversion = testConversions565[i];
      TestOneConversion16to32 (i, inputFormat565, conversion.inData, outputFormat, conversion.expectedData, true);
    }
  }

  {
    const TestConversion testConversions555[] =
    {
      // Red
      { { 0x00, 0xf8 }, { 0x00, 0x00, 0x00, 0xff } },
      // Green
      { { 0xc0, 0x07 }, { 0x00, 0x00, 0xff, 0x00 } },
      // Blue
      { { 0x3e, 0x00 }, { 0x00, 0xff, 0x00, 0x00 } }
    };
    const size_t numConversions555 = sizeof (testConversions555) / sizeof (testConversions555[0]);

    CS::StructuredTextureFormat inputFormat555 (CS::TextureFormatStrings::ConvertStructured ("r5g5b5"));
    for (size_t i = 0; i < numConversions555; i++)
    {
      const TestConversion& conversion = testConversions555[i];
      TestOneConversion16to32 (i, inputFormat555, conversion.inData, outputFormat, conversion.expectedData, true);
    }
  }

  {
    const TestConversion testConversionsx555[] =
    {
      // Red
      { { 0x00, 0x7c }, { 0x00, 0x00, 0x00, 0xff } },
      // Green
      { { 0xe0, 0x03 }, { 0x00, 0x00, 0xff, 0x00 } },
      // Blue
      { { 0x1f, 0x00 }, { 0x00, 0xff, 0x00, 0x00 } }
    };
    const size_t numConversionsx555 = sizeof (testConversionsx555) / sizeof (testConversionsx555[0]);

    CS::StructuredTextureFormat inputFormatx555 (CS::TextureFormatStrings::ConvertStructured ("x1r5g5b5"));
    for (size_t i = 0; i < numConversionsx555; i++)
    {
      const TestConversion& conversion = testConversionsx555[i];
      TestOneConversion16to32 (i, inputFormatx555, conversion.inData, outputFormat, conversion.expectedData, true);
    }
  }

  {
    const TestConversion testConversions1555[] =
    {
      // Red
      { { 0x00, 0xf8 }, { 0x00, 0x00, 0x00, 0xff } },
      // Green
      { { 0xc0, 0x07 }, { 0x00, 0x00, 0xff, 0x00 } },
      // Blue
      { { 0x3e, 0x00 }, { 0x00, 0xff, 0x00, 0x00 } },
      // Alpha
      { { 0x01, 0x00 }, { 0xff, 0x00, 0x00, 0x00 } },
    };
    const size_t numConversions1555 = sizeof (testConversions1555) / sizeof (testConversions1555[0]);

    CS::StructuredTextureFormat inputFormat1555 (CS::TextureFormatStrings::ConvertStructured ("r5g5b5a1"));
    for (size_t i = 0; i < numConversions1555; i++)
    {
      const TestConversion& conversion = testConversions1555[i];
      TestOneConversion16to32 (i, inputFormat1555, conversion.inData, outputFormat, conversion.expectedData, false);
    }
  }
}

struct TestConversion16to32_multiple
{
  uint8 inData[4*2];
  uint8 expectedData[4*4];
};

static void TestOneConversion16to32_multiple (const CS::StructuredTextureFormat& inputFormat,
                                              const CS::StructuredTextureFormat& outputFormat,
                                              const TestConversion16to32_multiple& conversion,
                                              bool check_alpha = false)
{
  csString formatStr (inputFormat.GetCanonical ());

  uint8 outputData[4 + sizeof (conversion.expectedData) + 4];
  // Sentinel bytes at the start/front
  memset (outputData, 0xf0, 4);
  memset (outputData + 4 + sizeof(conversion.expectedData), 0x0b, 4);
  // Actual results
  memset (outputData + 4, 0xaa, sizeof(conversion.expectedData));
  CS::Graphics::UniversalImageConverter::ConvertBasic (conversion.inData, inputFormat,
                                                       outputData + 4, outputFormat,
                                                       sizeof(conversion.expectedData)/4);

  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[0]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[1]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[2]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[3]));

  for (size_t p = 0; p < sizeof(conversion.expectedData)/4; p++)
  {
    csString msg (formatStr);
    msg.AppendFmt (", pixel %zu", p);
    if (check_alpha) CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*4+0]), int (outputData[p*4+4]));
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*4+1]), int (outputData[p*4+5]));
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*4+2]), int (outputData[p*4+6]));
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*4+3]), int (outputData[p*4+7]));
  }

  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+4]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+5]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+6]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+7]));
}

void UniversalImageConverterTest::test16to32_multiple ()
{
  const TestConversion16to32_multiple testConversion565 =
  {
    { 0x00, 0xf8,
      0xe0, 0x07,
      0x1f, 0x00,
      0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0xff,
      0x00, 0x00, 0xff, 0x00,
      0x00, 0xff, 0x00, 0x00,
      0xff, 0x00, 0x00, 0x00 }
  };
  const TestConversion16to32_multiple testConversion565_2 =
  {
    { 0x00, 0x80,
      0x00, 0x08,
      0x00, 0x78,
      0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x84,
      0x00, 0x00, 0x00, 0x08,
      0x00, 0x00, 0x00, 0x7b,
      0xff, 0x00, 0x00, 0x00 }
  };
  const TestConversion16to32_multiple testConversion555 =
  {
    { 0x00, 0xf8,
      0xc0, 0x07,
      0x3e, 0x00,
      0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0xff,
      0x00, 0x00, 0xff, 0x00,
      0x00, 0xff, 0x00, 0x00,
      0xff, 0x00, 0x00, 0x00 }
  };
  const TestConversion16to32_multiple testConversionx555 =
  {
    { 0x00, 0x7c,
      0xe0, 0x03,
      0x1f, 0x00,
      0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0xff,
      0x00, 0x00, 0xff, 0x00,
      0x00, 0xff, 0x00, 0x00,
      0xff, 0x00, 0x00, 0x00 }
  };
  const TestConversion16to32_multiple testConversion1555 =
  {
    { 0x00, 0x7c,
      0xe0, 0x03,
      0x1f, 0x00,
      0x00, 0x80 },
    { 0x00, 0x00, 0x00, 0xff,
      0x00, 0x00, 0xff, 0x00,
      0x00, 0xff, 0x00, 0x00,
      0xff, 0x00, 0x00, 0x00 }
  };
  CS::StructuredTextureFormat inputFormat565 (CS::TextureFormatStrings::ConvertStructured ("r5g6b5"));
  CS::StructuredTextureFormat inputFormat555 (CS::TextureFormatStrings::ConvertStructured ("r5g5b5"));
  CS::StructuredTextureFormat inputFormatx555 (CS::TextureFormatStrings::ConvertStructured ("x1r5g5b5"));
  CS::StructuredTextureFormat inputFormat1555 (CS::TextureFormatStrings::ConvertStructured ("a1r5g5b5"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba8"));

  TestOneConversion16to32_multiple (inputFormat565, outputFormat, testConversion565);
  TestOneConversion16to32_multiple (inputFormat565, outputFormat, testConversion565_2);
  TestOneConversion16to32_multiple (inputFormat555, outputFormat, testConversion555);
  TestOneConversion16to32_multiple (inputFormatx555, outputFormat, testConversionx555);
  TestOneConversion16to32_multiple (inputFormat1555, outputFormat, testConversion1555, true);
}

void UniversalImageConverterTest::test24to32 ()
{
  struct TestConversion
  {
    uint8 inData[3];
    uint8 expectedData[4];
  };
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("bgr8"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("abgr8"));

  const TestConversion testConversions[] =
  {
    // Red
    { { 0xff, 0x00, 0x00 }, { 0xff, 0x00, 0x00, 0xff } },
    // Green
    { { 0x00, 0xff, 0x00 }, { 0x00, 0xff, 0x00, 0xff } },
    // Blue
    { { 0x00, 0x00, 0xff }, { 0x00, 0x00, 0xff, 0xff } },
  };
  const size_t numConversions = sizeof (testConversions) / sizeof (testConversions[0]);
  const uint8 defaultData[4] = { 0x00, 0x00, 0x00, 0xff };

  for (size_t i = 0; i < numConversions; i++)
  {
    const TestConversion& conversion = testConversions[i];
    {
      uint8 outputData[4];
      memset (outputData, 0xaa, sizeof (outputData));
      CS::Graphics::UniversalImageConverter::ConvertBasic (&conversion.inData, inputFormat,
                                                           &outputData, outputFormat, 1,
                                                           defaultData);
      CPPUNIT_ASSERT_EQUAL(int (conversion.expectedData[0]), int (outputData[0]));
      CPPUNIT_ASSERT_EQUAL(int (conversion.expectedData[1]), int (outputData[1]));
      CPPUNIT_ASSERT_EQUAL(int (conversion.expectedData[2]), int (outputData[2]));
      CPPUNIT_ASSERT_EQUAL(int (conversion.expectedData[3]), int (outputData[3]));
    }
  }
}

struct TestConversion24to32_multiple
{
  uint8 inData[4*3];
  uint8 expectedData[4*4];
};

static void TestOneConversion24to32_multiple (const CS::StructuredTextureFormat& inputFormat,
                                              const CS::StructuredTextureFormat& outputFormat,
                                              const TestConversion24to32_multiple& conversion)
{
  csString formatStr (inputFormat.GetCanonical ());

  const uint8 defaultData[4] = { 0x00, 0x00, 0x00, 0xff };
  uint8 outputData[4 + sizeof (conversion.expectedData) + 4];
  // Sentinel bytes at the start/front
  memset (outputData, 0xf0, 4);
  memset (outputData + 4 + sizeof(conversion.expectedData), 0x0b, 4);
  // Actual results
  memset (outputData + 4, 0xaa, sizeof(conversion.expectedData));
  CS::Graphics::UniversalImageConverter::ConvertBasic (conversion.inData, inputFormat,
                                                       outputData + 4, outputFormat,
                                                       sizeof(conversion.expectedData)/4,
                                                       defaultData);

  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[0]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[1]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[2]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[3]));

  for (size_t p = 0; p < sizeof(conversion.expectedData)/4; p++)
  {
    csString msg (formatStr);
    msg.AppendFmt (", pixel %zu", p);
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*4+0]), int (outputData[p*4+4]));
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*4+1]), int (outputData[p*4+5]));
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*4+2]), int (outputData[p*4+6]));
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*4+3]), int (outputData[p*4+7]));
  }

  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+4]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+5]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+6]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+7]));
}

void UniversalImageConverterTest::test24to32_multiple ()
{
  const TestConversion24to32_multiple testConversion =
  {
    { 0xff, 0x00, 0x00,
      0x00, 0xff, 0x00,
      0x00, 0x00, 0xff,
      0x00, 0x00, 0x00 },
    { 0xff, 0x00, 0x00, 0xff,
      0x00, 0xff, 0x00, 0xff,
      0x00, 0x00, 0xff, 0xff,
      0x00, 0x00, 0x00, 0xff }
  };
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("bgr8"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("abgr8"));

  TestOneConversion24to32_multiple (inputFormat, outputFormat, testConversion);
}

void UniversalImageConverterTest::test32to24 ()
{
  struct TestConversion
  {
    uint8 inData[4];
    uint8 expectedData[3];
  };
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("abgr8"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("bgr8"));

  const TestConversion testConversions[] =
  {
    // Red
    { { 0xff, 0x00, 0x00, 0xff }, { 0xff, 0x00, 0x00 } },
    { { 0xff, 0x00, 0x00, 0x7f }, { 0xff, 0x00, 0x00 } },
    { { 0xff, 0x00, 0x00, 0x00 }, { 0xff, 0x00, 0x00 } },
    // Green
    { { 0x00, 0xff, 0x00, 0xff }, { 0x00, 0xff, 0x00 } },
    { { 0x00, 0xff, 0x00, 0x7f }, { 0x00, 0xff, 0x00 } },
    { { 0x00, 0xff, 0x00, 0x00 }, { 0x00, 0xff, 0x00 } },
    // Blue
    { { 0x00, 0x00, 0xff, 0xff }, { 0x00, 0x00, 0xff } },
    { { 0x00, 0x00, 0xff, 0x7f }, { 0x00, 0x00, 0xff } },
    { { 0x00, 0x00, 0xff, 0x00 }, { 0x00, 0x00, 0xff } },
  };
  const size_t numConversions = sizeof (testConversions) / sizeof (testConversions[0]);

  for (size_t i = 0; i < numConversions; i++)
  {
    const TestConversion& conversion = testConversions[i];
    {
      uint8 outputData[3];
      memset (outputData, 0xaa, sizeof (outputData));
      CS::Graphics::UniversalImageConverter::ConvertBasic (&conversion.inData, inputFormat,
                                                           &outputData, outputFormat, 1);
      CPPUNIT_ASSERT_EQUAL(int (conversion.expectedData[0]), int (outputData[0]));
      CPPUNIT_ASSERT_EQUAL(int (conversion.expectedData[1]), int (outputData[1]));
      CPPUNIT_ASSERT_EQUAL(int (conversion.expectedData[2]), int (outputData[2]));
    }
  }
}

struct TestConversion32to24_multiple
{
  uint8 inData[4*4];
  uint8 expectedData[4*3];
};

static void TestOneConversion32to24_multiple (const CS::StructuredTextureFormat& inputFormat,
                                              const CS::StructuredTextureFormat& outputFormat,
                                              const TestConversion32to24_multiple& conversion)
{
  csString formatStr (inputFormat.GetCanonical ());

  uint8 outputData[4 + sizeof (conversion.expectedData) + 4];
  // Sentinel bytes at the start/front
  memset (outputData, 0xf0, 4);
  memset (outputData + 4 + sizeof(conversion.expectedData), 0x0b, 4);
  // Actual results
  memset (outputData + 4, 0xaa, sizeof(conversion.expectedData));
  CS::Graphics::UniversalImageConverter::ConvertBasic (conversion.inData, inputFormat,
                                                       outputData + 4, outputFormat,
                                                       sizeof(conversion.expectedData)/3);

  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[0]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[1]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[2]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0xf0, int (outputData[3]));

  for (size_t p = 0; p < sizeof(conversion.expectedData)/3; p++)
  {
    csString msg (formatStr);
    msg.AppendFmt (", pixel %zu", p);
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*3+0]), int (outputData[p*3+4]));
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*3+1]), int (outputData[p*3+5]));
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (conversion.expectedData[p*3+2]), int (outputData[p*3+6]));
  }

  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+4]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+5]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+6]));
  CPPUNIT_ASSERT_EQUAL_MESSAGE(formatStr.GetData(), 0x0b, int (outputData[sizeof(conversion.expectedData)+7]));
}

void UniversalImageConverterTest::test32to24_multiple ()
{
  const TestConversion32to24_multiple testConversion1 =
  {
    { 0xff, 0x00, 0x00, 0xff,
      0x00, 0xff, 0x00, 0xff,
      0x00, 0x00, 0xff, 0xff,
      0x00, 0x00, 0x00, 0xff },
    { 0xff, 0x00, 0x00,
      0x00, 0xff, 0x00,
      0x00, 0x00, 0xff,
      0x00, 0x00, 0x00 }
  };
  const TestConversion32to24_multiple testConversion2 =
  {
    { 0xff, 0x00, 0x00, 0x7f,
      0x00, 0xff, 0x00, 0x7f,
      0x00, 0x00, 0xff, 0x7f,
      0x00, 0x00, 0x00, 0x7f },
    { 0xff, 0x00, 0x00,
      0x00, 0xff, 0x00,
      0x00, 0x00, 0xff,
      0x00, 0x00, 0x00 }
  };
  const TestConversion32to24_multiple testConversion3 =
  {
    { 0xff, 0x00, 0x00, 0x00,
      0x00, 0xff, 0x00, 0x00,
      0x00, 0x00, 0xff, 0x00,
      0x00, 0x00, 0x00, 0x00 },
    { 0xff, 0x00, 0x00,
      0x00, 0xff, 0x00,
      0x00, 0x00, 0xff,
      0x00, 0x00, 0x00 }
  };
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("abgr8"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("bgr8"));

  TestOneConversion32to24_multiple (inputFormat, outputFormat, testConversion1);
  TestOneConversion32to24_multiple (inputFormat, outputFormat, testConversion2);
  TestOneConversion32to24_multiple (inputFormat, outputFormat, testConversion3);
}

static void TestOneConversionBytewise (const char* run,
                                       const CS::StructuredTextureFormat& inputFormat, const uint8* inData,
                                       const CS::StructuredTextureFormat& outputFormat, const uint8* expectedData,
                                       size_t dataSize)
{
  csString formatStr (outputFormat.GetCanonical ());
  formatStr.AppendFmt (", %s", run);

  uint8* outputData = (uint8*)alloca (dataSize);
  memset (outputData, 0xaa, dataSize);
  CS::Graphics::UniversalImageConverter::ConvertBasic (inData, inputFormat,
                                                       outputData, outputFormat, 1);

  for (size_t i = 0; i < dataSize; i++)
  {
    csString msg (formatStr);
    msg.AppendFmt (", byte %zu", i);
    CPPUNIT_ASSERT_EQUAL_MESSAGE(msg.GetData(), int (expectedData[i]), int (outputData[i]));
  }
}

void UniversalImageConverterTest::testItoF ()
{
  struct TestConversion
  {
    uint8 inData[4];
    uint8 expectedDataRGBAf32[4*4];
    uint8 expectedDataRGBf32[3*4];
    uint8 expectedDataRGBAf16[4*2];
    uint8 expectedDataRGBf16[3*2];
    uint8 expectedDataRGBAf64[4*8];
    uint8 expectedDataRGBf64[3*8];
    uint8 expectedDataRGBfMixed[4+2+8];
  };
  const TestConversion testConversions_1_0[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0xff },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0xff, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00,
        0x00, 0x3c,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0 },
    },
    // Blue
    {
      { 0x00, 0xff, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x80, 0x3f,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0xff, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_1_0 = sizeof (testConversions_1_0) / sizeof (testConversions_1_0[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba8"));
  CS::StructuredTextureFormat outputFormatRGBAf32 (CS::TextureFormatStrings::ConvertStructured ("rgba32_f"));
  CS::StructuredTextureFormat outputFormatRGBf32 (CS::TextureFormatStrings::ConvertStructured ("rgb32_f"));
  CS::StructuredTextureFormat outputFormatRGBAf16 (CS::TextureFormatStrings::ConvertStructured ("rgba16_f"));
  CS::StructuredTextureFormat outputFormatRGBf16 (CS::TextureFormatStrings::ConvertStructured ("rgb16_f"));
  CS::StructuredTextureFormat outputFormatRGBAf64 (CS::TextureFormatStrings::ConvertStructured ("rgba64_f"));
  CS::StructuredTextureFormat outputFormatRGBf64 (CS::TextureFormatStrings::ConvertStructured ("rgb64_f"));
  CS::StructuredTextureFormat outputFormatRGBfMixed (CS::TextureFormatStrings::ConvertStructured ("r64g16b32_f"));

  for (size_t i = 0; i < numConversions_1_0; i++)
  {
    const TestConversion& conversion = testConversions_1_0[i];
    csString msg;
    msg.AppendFmt ("1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBAf32, conversion.expectedDataRGBAf32, sizeof (conversion.expectedDataRGBAf32));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBf32, conversion.expectedDataRGBf32, sizeof (conversion.expectedDataRGBf32));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBAf16, conversion.expectedDataRGBAf16, sizeof (conversion.expectedDataRGBAf16));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBf16, conversion.expectedDataRGBf16, sizeof (conversion.expectedDataRGBf16));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBAf64, conversion.expectedDataRGBAf64, sizeof (conversion.expectedDataRGBAf64));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBf64, conversion.expectedDataRGBf64, sizeof (conversion.expectedDataRGBf64));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBfMixed, conversion.expectedDataRGBfMixed, sizeof (conversion.expectedDataRGBfMixed));
  }

  const TestConversion testConversions_0_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x7f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf7, 0x37 },
      { 0x00, 0x00, 0x00, 0x00, 0xf7, 0x37 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xe0, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xe0, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0x3f },
      { 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0xe0, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0x7f, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0xf7, 0x37, 0x00, 0x00 },
      { 0x00, 0x00, 0xf7, 0x37, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xe0, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xe0, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00,
        0xf7, 0x37,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x7f, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0xf7, 0x37, 0x00, 0x00, 0x00, 0x00 },
      { 0xf7, 0x37, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xe0, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xe0, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xff, 0xfe, 0xfe, 0x3e,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x7f, 0x00, 0x00, 0x00 },
      { 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xf7, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xe0, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_5 = sizeof (testConversions_0_5) / sizeof (testConversions_0_5[0]);

  for (size_t i = 0; i < numConversions_0_5; i++)
  {
    const TestConversion& conversion = testConversions_0_5[i];
    csString msg;
    msg.AppendFmt ("0.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBAf32, conversion.expectedDataRGBAf32, sizeof (conversion.expectedDataRGBAf32));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBf32, conversion.expectedDataRGBf32, sizeof (conversion.expectedDataRGBf32));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBAf16, conversion.expectedDataRGBAf16, sizeof (conversion.expectedDataRGBAf16));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBf16, conversion.expectedDataRGBf16, sizeof (conversion.expectedDataRGBf16));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBAf64, conversion.expectedDataRGBAf64, sizeof (conversion.expectedDataRGBAf64));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBf64, conversion.expectedDataRGBf64, sizeof (conversion.expectedDataRGBf64));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBfMixed, conversion.expectedDataRGBfMixed, sizeof (conversion.expectedDataRGBfMixed));
  }

  const TestConversion testConversions_0_1[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x19 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x2e },
      { 0x00, 0x00, 0x00, 0x00, 0x46, 0x2e },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0xb9, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0xb9, 0x3f },
      { 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0xb9, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0x19, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x46, 0x2e, 0x00, 0x00 },
      { 0x00, 0x00, 0x46, 0x2e, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00,
        0x46, 0x2e,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x19, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x46, 0x2e, 0x00, 0x00, 0x00, 0x00 },
      { 0x46, 0x2e, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xc9, 0xc8, 0xc8, 0x3d,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x19, 0x00, 0x00, 0x00 },
      { 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x46, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_1 = sizeof (testConversions_0_1) / sizeof (testConversions_0_1[0]);

  for (size_t i = 0; i < numConversions_0_1; i++)
  {
    const TestConversion& conversion = testConversions_0_1[i];
    csString msg;
    msg.AppendFmt ("0.1 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBAf32, conversion.expectedDataRGBAf32, sizeof (conversion.expectedDataRGBAf32));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBf32, conversion.expectedDataRGBf32, sizeof (conversion.expectedDataRGBf32));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBAf16, conversion.expectedDataRGBAf16, sizeof (conversion.expectedDataRGBAf16));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBf16, conversion.expectedDataRGBf16, sizeof (conversion.expectedDataRGBf16));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBAf64, conversion.expectedDataRGBAf64, sizeof (conversion.expectedDataRGBAf64));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBf64, conversion.expectedDataRGBf64, sizeof (conversion.expectedDataRGBf64));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormatRGBfMixed, conversion.expectedDataRGBfMixed, sizeof (conversion.expectedDataRGBfMixed));
  }

}

void UniversalImageConverterTest::testF32toF16 ()
{
  struct TestConversion
  {
    uint8 inData[4*4];
    uint8 expectedData[4*2];
  };
  const TestConversion testConversions_1_0[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c }
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_1_0 = sizeof (testConversions_1_0) / sizeof (testConversions_1_0[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba32_f"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba16_f"));

  for (size_t i = 0; i < numConversions_1_0; i++)
  {
    const TestConversion& conversion = testConversions_1_0[i];
    csString msg;
    msg.AppendFmt ("1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf7, 0x37 },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0xf7, 0x37, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0xf7, 0x37, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xf7, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_5 = sizeof (testConversions_0_5) / sizeof (testConversions_0_5[0]);

  for (size_t i = 0; i < numConversions_0_5; i++)
  {
    const TestConversion& conversion = testConversions_0_5[i];
    csString msg;
    msg.AppendFmt ("0.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_1[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x2e },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x46, 0x2e, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x46, 0x2e, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x46, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_1 = sizeof (testConversions_0_1) / sizeof (testConversions_0_1[0]);

  for (size_t i = 0; i < numConversions_0_1; i++)
  {
    const TestConversion& conversion = testConversions_0_1[i];
    csString msg;
    msg.AppendFmt ("0.1 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }
}

void UniversalImageConverterTest::testF32toF64 ()
{
  struct TestConversion
  {
    uint8 inData[4*4];
    uint8 expectedData[4*8];
  };
  const TestConversion testConversions_1_0[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_1_0 = sizeof (testConversions_1_0) / sizeof (testConversions_1_0[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba32_f"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba64_f"));

  for (size_t i = 0; i < numConversions_1_0; i++)
  {
    const TestConversion& conversion = testConversions_1_0[i];
    csString msg;
    msg.AppendFmt ("1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xe0, 0xdf, 0xdf, 0xdf, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xe0, 0xdf, 0xdf, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xe0, 0xdf, 0xdf, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0xe0, 0xdf, 0xdf, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_5 = sizeof (testConversions_0_5) / sizeof (testConversions_0_5[0]);

  for (size_t i = 0; i < numConversions_0_5; i++)
  {
    const TestConversion& conversion = testConversions_0_5[i];
    csString msg;
    msg.AppendFmt ("0.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_1[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x20, 0x19, 0x19, 0xb9, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x20, 0x19, 0x19, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x20, 0x19, 0x19, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x20, 0x19, 0x19, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_1 = sizeof (testConversions_0_1) / sizeof (testConversions_0_1[0]);

  for (size_t i = 0; i < numConversions_0_1; i++)
  {
    const TestConversion& conversion = testConversions_0_1[i];
    csString msg;
    msg.AppendFmt ("0.1 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }
}

void UniversalImageConverterTest::testF16toF32 ()
{
  struct TestConversion
  {
    uint8 inData[4*2];
    uint8 expectedData[4*4];
  };
  const TestConversion testConversions_1_0[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f }
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00 }
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    },
    // Black w/ alpha
    {
      { 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    }
  };
  const size_t numConversions_1_0 = sizeof (testConversions_1_0) / sizeof (testConversions_1_0[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba16_f"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba32_f"));

  for (size_t i = 0; i < numConversions_1_0; i++)
  {
    const TestConversion& conversion = testConversions_1_0[i];
    csString msg;
    msg.AppendFmt ("1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf7, 0x37 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfe, 0x3e }
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0xf7, 0x37, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00 }
    },
    // Blue
    {
      { 0x00, 0x00, 0xf7, 0x37, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    },
    // Black w/ alpha
    {
      { 0xf7, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0xe0, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    }
  };
  const size_t numConversions_0_5 = sizeof (testConversions_0_5) / sizeof (testConversions_0_5[0]);

  for (size_t i = 0; i < numConversions_0_5; i++)
  {
    const TestConversion& conversion = testConversions_0_5[i];
    csString msg;
    msg.AppendFmt ("0.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_1[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x2e },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc8, 0x3d }
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x46, 0x2e, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00 }
    },
    // Blue
    {
      { 0x00, 0x00, 0x46, 0x2e, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    },
    // Black w/ alpha
    {
      { 0x46, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0xc0, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    }
  };
  const size_t numConversions_0_1 = sizeof (testConversions_0_1) / sizeof (testConversions_0_1[0]);

  for (size_t i = 0; i < numConversions_0_1; i++)
  {
    const TestConversion& conversion = testConversions_0_1[i];
    csString msg;
    msg.AppendFmt ("0.1 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }
}

void UniversalImageConverterTest::testF16toF64 ()
{
  struct TestConversion
  {
    uint8 inData[4*2];
    uint8 expectedData[4*8];
  };
  const TestConversion testConversions_1_0[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_1_0 = sizeof (testConversions_1_0) / sizeof (testConversions_1_0[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba16_f"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba64_f"));

  for (size_t i = 0; i < numConversions_1_0; i++)
  {
    const TestConversion& conversion = testConversions_1_0[i];
    csString msg;
    msg.AppendFmt ("1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf7, 0x37 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xdf, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0xf7, 0x37, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0xf7, 0x37, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0xf7, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xdf, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_5 = sizeof (testConversions_0_5) / sizeof (testConversions_0_5[0]);

  for (size_t i = 0; i < numConversions_0_5; i++)
  {
    const TestConversion& conversion = testConversions_0_5[i];
    csString msg;
    msg.AppendFmt ("0.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_1[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x2e },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xb9, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x46, 0x2e, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x46, 0x2e, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x46, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_1 = sizeof (testConversions_0_1) / sizeof (testConversions_0_1[0]);

  for (size_t i = 0; i < numConversions_0_1; i++)
  {
    const TestConversion& conversion = testConversions_0_1[i];
    csString msg;
    msg.AppendFmt ("0.1 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }
}

void UniversalImageConverterTest::testF64toF16 ()
{
  struct TestConversion
  {
    uint8 inData[4*8];
    uint8 expectedData[4*2];
  };
  const TestConversion testConversions_1_0[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_1_0 = sizeof (testConversions_1_0) / sizeof (testConversions_1_0[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba64_f"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba16_f"));

  for (size_t i = 0; i < numConversions_1_0; i++)
  {
    const TestConversion& conversion = testConversions_1_0[i];
    csString msg;
    msg.AppendFmt ("1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38 },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_5 = sizeof (testConversions_0_5) / sizeof (testConversions_0_5[0]);

  for (size_t i = 0; i < numConversions_0_5; i++)
  {
    const TestConversion& conversion = testConversions_0_5[i];
    csString msg;
    msg.AppendFmt ("0.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_1[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x2e },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x66, 0x2e, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x66, 0x2e, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x66, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_1 = sizeof (testConversions_0_1) / sizeof (testConversions_0_1[0]);

  for (size_t i = 0; i < numConversions_0_1; i++)
  {
    const TestConversion& conversion = testConversions_0_1[i];
    csString msg;
    msg.AppendFmt ("0.1 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }
}

void UniversalImageConverterTest::testF64toF32 ()
{
  struct TestConversion
  {
    uint8 inData[4*8];
    uint8 expectedData[4*4];
  };
  const TestConversion testConversions_1_0[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_1_0 = sizeof (testConversions_1_0) / sizeof (testConversions_1_0[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba64_f"));
  CS::StructuredTextureFormat outputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba32_f"));

  for (size_t i = 0; i < numConversions_1_0; i++)
  {
    const TestConversion& conversion = testConversions_1_0[i];
    csString msg;
    msg.AppendFmt ("1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_5 = sizeof (testConversions_0_5) / sizeof (testConversions_0_5[0]);

  for (size_t i = 0; i < numConversions_0_5; i++)
  {
    const TestConversion& conversion = testConversions_0_5[i];
    csString msg;
    msg.AppendFmt ("0.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }

  const TestConversion testConversions_0_1[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcd, 0xcc, 0xcc, 0x3d },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcd, 0xcc, 0xcc, 0x3d, 0x00, 0x00, 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0xcd, 0xcc, 0xcc, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xcd, 0xcc, 0xcc, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_1 = sizeof (testConversions_0_1) / sizeof (testConversions_0_1[0]);

  for (size_t i = 0; i < numConversions_0_1; i++)
  {
    const TestConversion& conversion = testConversions_0_1[i];
    csString msg;
    msg.AppendFmt ("0.1 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat, conversion.expectedData, sizeof (conversion.expectedData));
  }
}

void UniversalImageConverterTest::testF32toI ()
{
  struct TestConversion
  {
    uint8 inData[4*4];
    uint8 expectedData8888[4];
    uint8 expectedData565[2];
    uint8 expectedData1555[2];
  };
  const TestConversion testConversions_1_0[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f },
      { 0x00, 0x00, 0x00, 0xff },
      { 0x00, 0xf8 },
      { 0x00, 0x7c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0xff, 0x00 },
      { 0xe0, 0x07 },
      { 0xe0, 0x03 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0xff, 0x00, 0x00 },
      { 0x1f, 0x00 },
      { 0x1f, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xff, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x80 },
    }
  };
  const size_t numConversions_1_0 = sizeof (testConversions_1_0) / sizeof (testConversions_1_0[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba32_f"));
  CS::StructuredTextureFormat outputFormat8888 (CS::TextureFormatStrings::ConvertStructured ("rgba8"));
  CS::StructuredTextureFormat outputFormat565 (CS::TextureFormatStrings::ConvertStructured ("r5g6b5"));
  CS::StructuredTextureFormat outputFormat1555 (CS::TextureFormatStrings::ConvertStructured ("a1r5g5b5"));

  for (size_t i = 0; i < numConversions_1_0; i++)
  {
    const TestConversion& conversion = testConversions_1_0[i];
    csString msg;
    msg.AppendFmt ("1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  const TestConversion testConversions_0_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e },
      { 0x00, 0x00, 0x00, 0x7f },
      { 0x00, 0x78 },
      { 0x00, 0x3c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x7f, 0x00 },
      { 0xe0, 0x03 },
      { 0xe0, 0x01 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x7f, 0x00, 0x00 },
      { 0x0f, 0x00 },
      { 0x0f, 0x00 },
    },
    // Black w/ alpha
    {
      { 0xff, 0xfe, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x7f, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_5 = sizeof (testConversions_0_5) / sizeof (testConversions_0_5[0]);

  for (size_t i = 0; i < numConversions_0_5; i++)
  {
    const TestConversion& conversion = testConversions_0_5[i];
    csString msg;
    msg.AppendFmt ("0.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  const TestConversion testConversions_0_1[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d },
      { 0x00, 0x00, 0x00, 0x19 },
      { 0x00, 0x18 },
      { 0x00, 0x0c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x19, 0x00 },
      { 0xc0, 0x00 },
      { 0x60, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x19, 0x00, 0x00 },
      { 0x03, 0x00 },
      { 0x03, 0x00 },
    },
    // Black w/ alpha
    {
      { 0xc9, 0xc8, 0xc8, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x19, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_1 = sizeof (testConversions_0_1) / sizeof (testConversions_0_1[0]);

  for (size_t i = 0; i < numConversions_0_1; i++)
  {
    const TestConversion& conversion = testConversions_0_1[i];
    csString msg;
    msg.AppendFmt ("0.1 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  // Test clamping: overflow
  const TestConversion testConversions_1_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f },
      { 0x00, 0x00, 0x00, 0xff },
      { 0x00, 0xf8 },
      { 0x00, 0x7c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0xff, 0x00 },
      { 0xe0, 0x07 },
      { 0xe0, 0x03 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0xff, 0x00, 0x00 },
      { 0x1f, 0x00 },
      { 0x1f, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xff, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x80 },
    }
  };
  const size_t numConversions_1_5 = sizeof (testConversions_1_5) / sizeof (testConversions_1_5[0]);

  for (size_t i = 0; i < numConversions_1_5; i++)
  {
    const TestConversion& conversion = testConversions_1_5[i];
    csString msg;
    msg.AppendFmt ("1.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  // Test clamping: underflow
  const TestConversion testConversions_negative[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    }
  };
  const size_t numConversions_negative = sizeof (testConversions_negative) / sizeof (testConversions_negative[0]);

  for (size_t i = 0; i < numConversions_negative; i++)
  {
    const TestConversion& conversion = testConversions_negative[i];
    csString msg;
    msg.AppendFmt ("-1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

}

void UniversalImageConverterTest::testF16toI ()
{
  struct TestConversion
  {
    uint8 inData[4*2];
    uint8 expectedData8888[4];
    uint8 expectedData565[2];
    uint8 expectedData1555[2];
  };
  const TestConversion testConversions_1_0[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c },
      { 0x00, 0x00, 0x00, 0xff },
      { 0x00, 0xf8 },
      { 0x00, 0x7c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00 },
      { 0x00, 0x00, 0xff, 0x00 },
      { 0xe0, 0x07 },
      { 0xe0, 0x03 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0xff, 0x00, 0x00 },
      { 0x1f, 0x00 },
      { 0x1f, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xff, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x80 },
    }
  };
  const size_t numConversions_1_0 = sizeof (testConversions_1_0) / sizeof (testConversions_1_0[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba16_f"));
  CS::StructuredTextureFormat outputFormat8888 (CS::TextureFormatStrings::ConvertStructured ("rgba8"));
  CS::StructuredTextureFormat outputFormat565 (CS::TextureFormatStrings::ConvertStructured ("r5g6b5"));
  CS::StructuredTextureFormat outputFormat1555 (CS::TextureFormatStrings::ConvertStructured ("a1r5g5b5"));

  for (size_t i = 0; i < numConversions_1_0; i++)
  {
    const TestConversion& conversion = testConversions_1_0[i];
    csString msg;
    msg.AppendFmt ("1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  const TestConversion testConversions_0_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38 },
      { 0x00, 0x00, 0x00, 0x7f },
      { 0x00, 0x78 },
      { 0x00, 0x3c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00 },
      { 0x00, 0x00, 0x7f, 0x00 },
      { 0xe0, 0x03 },
      { 0xe0, 0x01 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x7f, 0x00, 0x00 },
      { 0x0f, 0x00 },
      { 0x0f, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x7f, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_5 = sizeof (testConversions_0_5) / sizeof (testConversions_0_5[0]);

  for (size_t i = 0; i < numConversions_0_5; i++)
  {
    const TestConversion& conversion = testConversions_0_5[i];
    csString msg;
    msg.AppendFmt ("0.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  const TestConversion testConversions_0_1[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x2e },
      { 0x00, 0x00, 0x00, 0x19 },
      { 0x00, 0x18 },
      { 0x00, 0x0c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x66, 0x2e, 0x00, 0x00 },
      { 0x00, 0x00, 0x19, 0x00 },
      { 0xc0, 0x00 },
      { 0x60, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x66, 0x2e, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x19, 0x00, 0x00 },
      { 0x03, 0x00 },
      { 0x03, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x66, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x19, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_1 = sizeof (testConversions_0_1) / sizeof (testConversions_0_1[0]);

  for (size_t i = 0; i < numConversions_0_1; i++)
  {
    const TestConversion& conversion = testConversions_0_1[i];
    csString msg;
    msg.AppendFmt ("0.1 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  // Test clamping: overflow
  const TestConversion testConversions_1_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e },
      { 0x00, 0x00, 0x00, 0xff },
      { 0x00, 0xf8 },
      { 0x00, 0x7c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00 },
      { 0x00, 0x00, 0xff, 0x00 },
      { 0xe0, 0x07 },
      { 0xe0, 0x03 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0xff, 0x00, 0x00 },
      { 0x1f, 0x00 },
      { 0x1f, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xff, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x80 },
    }
  };
  const size_t numConversions_1_5 = sizeof (testConversions_1_5) / sizeof (testConversions_1_5[0]);

  for (size_t i = 0; i < numConversions_1_5; i++)
  {
    const TestConversion& conversion = testConversions_1_5[i];
    csString msg;
    msg.AppendFmt ("1.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  // Test clamping: underflow
  const TestConversion testConversions_negative[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    }
  };
  const size_t numConversions_negative = sizeof (testConversions_negative) / sizeof (testConversions_negative[0]);

  for (size_t i = 0; i < numConversions_negative; i++)
  {
    const TestConversion& conversion = testConversions_negative[i];
    csString msg;
    msg.AppendFmt ("-1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

}

void UniversalImageConverterTest::testF64toI ()
{
  struct TestConversion
  {
    uint8 inData[4*8];
    uint8 expectedData8888[4];
    uint8 expectedData565[2];
    uint8 expectedData1555[2];
  };
  const TestConversion testConversions_1_0[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f },
      { 0x00, 0x00, 0x00, 0xff },
      { 0x00, 0xf8 },
      { 0x00, 0x7c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0xff, 0x00 },
      { 0xe0, 0x07 },
      { 0xe0, 0x03 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0xff, 0x00, 0x00 },
      { 0x1f, 0x00 },
      { 0x1f, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xff, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x80 },
    }
  };
  const size_t numConversions_1_0 = sizeof (testConversions_1_0) / sizeof (testConversions_1_0[0]);
  CS::StructuredTextureFormat inputFormat (CS::TextureFormatStrings::ConvertStructured ("rgba64_f"));
  CS::StructuredTextureFormat outputFormat8888 (CS::TextureFormatStrings::ConvertStructured ("rgba8"));
  CS::StructuredTextureFormat outputFormat565 (CS::TextureFormatStrings::ConvertStructured ("r5g6b5"));
  CS::StructuredTextureFormat outputFormat1555 (CS::TextureFormatStrings::ConvertStructured ("a1r5g5b5"));

  for (size_t i = 0; i < numConversions_1_0; i++)
  {
    const TestConversion& conversion = testConversions_1_0[i];
    csString msg;
    msg.AppendFmt ("1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  const TestConversion testConversions_0_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f },
      { 0x00, 0x00, 0x00, 0x7f },
      { 0x00, 0x78 },
      { 0x00, 0x3c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x7f, 0x00 },
      { 0xe0, 0x03 },
      { 0xe0, 0x01 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x7f, 0x00, 0x00 },
      { 0x0f, 0x00 },
      { 0x0f, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x7f, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_5 = sizeof (testConversions_0_5) / sizeof (testConversions_0_5[0]);

  for (size_t i = 0; i < numConversions_0_5; i++)
  {
    const TestConversion& conversion = testConversions_0_5[i];
    csString msg;
    msg.AppendFmt ("0.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  const TestConversion testConversions_0_1[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f },
      { 0x00, 0x00, 0x00, 0x19 },
      { 0x00, 0x18 },
      { 0x00, 0x0c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x19, 0x00 },
      { 0xc0, 0x00 },
      { 0x60, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x19, 0x00, 0x00 },
      { 0x03, 0x00 },
      { 0x03, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x19, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    }
  };
  const size_t numConversions_0_1 = sizeof (testConversions_0_1) / sizeof (testConversions_0_1[0]);

  for (size_t i = 0; i < numConversions_0_1; i++)
  {
    const TestConversion& conversion = testConversions_0_1[i];
    csString msg;
    msg.AppendFmt ("0.1 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  // Test clamping: overflow
  const TestConversion testConversions_1_5[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f },
      { 0x00, 0x00, 0x00, 0xff },
      { 0x00, 0xf8 },
      { 0x00, 0x7c },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0xff, 0x00 },
      { 0xe0, 0x07 },
      { 0xe0, 0x03 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0xff, 0x00, 0x00 },
      { 0x1f, 0x00 },
      { 0x1f, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0xff, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x80 },
    }
  };
  const size_t numConversions_1_5 = sizeof (testConversions_1_5) / sizeof (testConversions_1_5[0]);

  for (size_t i = 0; i < numConversions_1_5; i++)
  {
    const TestConversion& conversion = testConversions_1_5[i];
    csString msg;
    msg.AppendFmt ("1.5 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

  // Test clamping: underflow
  const TestConversion testConversions_negative[] =
  {
    // Red
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    },
    // Green
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    },
    // Blue
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    },
    // Black w/ alpha
    {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00 },
      { 0x00, 0x00 },
    }
  };
  const size_t numConversions_negative = sizeof (testConversions_negative) / sizeof (testConversions_negative[0]);

  for (size_t i = 0; i < numConversions_negative; i++)
  {
    const TestConversion& conversion = testConversions_negative[i];
    csString msg;
    msg.AppendFmt ("-1.0 #%zu", i);
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat8888, conversion.expectedData8888, sizeof (conversion.expectedData8888));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat565, conversion.expectedData565, sizeof (conversion.expectedData565));
    TestOneConversionBytewise (msg, inputFormat, conversion.inData, outputFormat1555, conversion.expectedData1555, sizeof (conversion.expectedData1555));
  }

}

void UniversalImageConverterTest::testLAtoRGBA ()
{
  struct TestConversionL2R
  {
    uint8 inData[1];
    uint8 expectedData[1];
  };
  struct TestConversionL2RGB
  {
    uint8 inData[1];
    uint8 expectedData[3];
  };
  struct TestConversionLA2RGBA
  {
    uint8 inData[2];
    uint8 expectedData[4];
  };
  CS::StructuredTextureFormat inputFormatL (CS::TextureFormatStrings::ConvertStructured ("l8"));
  CS::StructuredTextureFormat inputFormatLA (CS::TextureFormatStrings::ConvertStructured ("la8"));
  CS::StructuredTextureFormat outputFormatR (CS::TextureFormatStrings::ConvertStructured ("r8"));
  CS::StructuredTextureFormat outputFormatRGB (CS::TextureFormatStrings::ConvertStructured ("rgb8"));
  CS::StructuredTextureFormat outputFormatRGBA (CS::TextureFormatStrings::ConvertStructured ("rgba8"));
  {
    const TestConversionL2R testConversions[] =
    {
      { { 0xff }, { 0xff } }
    };
    const size_t numConversions = sizeof (testConversions) / sizeof (testConversions[0]);

    for (size_t i = 0; i < numConversions; i++)
    {
      const TestConversionL2R& conversion = testConversions[i];
      csString msg;
      msg.AppendFmt ("L -> R #%zu", i);
      TestOneConversionBytewise (msg, inputFormatL, conversion.inData, outputFormatR, conversion.expectedData, sizeof (conversion.expectedData));
    }
  }
  {
    const TestConversionL2RGB testConversions[] =
    {
      { { 0xff }, { 0xff, 0xff, 0xff } }
    };
    const size_t numConversions = sizeof (testConversions) / sizeof (testConversions[0]);

    for (size_t i = 0; i < numConversions; i++)
    {
      const TestConversionL2RGB& conversion = testConversions[i];
      csString msg;
      msg.AppendFmt ("L -> RGB #%zu", i);
      TestOneConversionBytewise (msg, inputFormatL, conversion.inData, outputFormatRGB, conversion.expectedData, sizeof (conversion.expectedData));
    }
  }
  {
    const TestConversionLA2RGBA testConversions[] =
    {
      { { 0xff, 0x00 }, { 0xff, 0x00, 0x00, 0x00 } },
      { { 0x00, 0xff }, { 0x00, 0xff, 0xff, 0xff } }
    };
    const size_t numConversions = sizeof (testConversions) / sizeof (testConversions[0]);

    for (size_t i = 0; i < numConversions; i++)
    {
      const TestConversionLA2RGBA& conversion = testConversions[i];
      csString msg;
      msg.AppendFmt ("LA -> RGBA #%zu", i);
      TestOneConversionBytewise (msg, inputFormatLA, conversion.inData, outputFormatRGBA, conversion.expectedData, sizeof (conversion.expectedData));
    }
  }
}
