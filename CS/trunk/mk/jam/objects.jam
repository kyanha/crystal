#============================================================================
# Rules for compiling a set of sources to object files
#============================================================================
# These are slightly modified versions of the Object and Objects rules from
# jam. The problem with the original rules in Jambase is the handling of
# custom file types. The solution with the UserObject rule is monolithic, you
# can only have 1 such rule. Thus we construct a more flexible toolkit here
# which let's you register rules for certain filetypes.

##  RegisterFileType Rulename : extensions
##    Register a rule which is used to compile a filetype into object
##    files. The registered rule is called with 2 arguments: the name of the
##    objectfile which should be created and the name of the sourcefile.
rule RegisterFileType
{
  local suffix ;
  for suffix in $(>)
  {
    FILETYPE_$(suffix) = $(<) ;
  }
}

##  RegisterHeaderRule rulename : regexpattern : extensions
##    Registers a rule and a regular expression which will be used for header
##    file scanning of the specified extensions.
rule RegisterHeaderRule
{
  local suffix ;
  for suffix in $(3)
  {
    HDRRULE_$(suffix) = $(<) ;
    HDRPATTERN_$(suffix) = $(>) ;
  }
}

##  CompileObject sources
##    Compile a set of sourcefiles into objectfiles (extension: SUFOBJ,
##	usually .o). This rule takes care of all the complicated stuff like
##    setting LOCATE and SEARCH variables, adding the correct grist to the
##    files.
##    The Application, Plugin and Library rules already use this rule
##    internally. You should only use this rule if you have to avoid the
##    Application, Plugin or Library rules.
rule CompileObjects
{
  local f ;

  for f in $(<)
  {
    local t = $(f:S=$(SUFOBJ)) ;
    
    # locate target and search for source
    MakeLocate $(t) : $(LOCATE_TARGET) ;
    SEARCH on $(f) = $(SEARCH_SOURCE) ;

    # compile the sourcefile to targetfile
    CompileObject $(t) : $(f) ;
  }
}

#----------------------------------------------------------------------------
# private part

# helper rule: Compiles a sourcefile to an object file. Does header file
# scanning, sets LOCATE and SEARCH for source and target, grists the files
# with the current subdir and searches the correct rule in registered rules.
rule CompileObject
{
  # Save HDRS for -I$(HDRS) on compile.
  # We shouldn't need -I$(SEARCH_SOURCE) as cc can find headers
  # in the .c file's directory, but generated .c files (from
  # yacc, lex, etc) are located in $(LOCATE_TARGET), possibly
  # different from $(SEARCH_SOURCE).

  HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;

  # handle #includes for source: Jam scans for headers with
  # the regexp pattern $(HDRSCAN) and then invokes $(HDRRULE)
  # with the scanned file as the target and the found headers
  # as the sources.  HDRSEARCH is the value of SEARCH used for
  # the found header files.  Finally, if jam must deal with 
  # header files of the same name in different directories,
  # they can be distinguished with HDRGRIST.

  # $(SEARCH_SOURCE:E) is where cc first looks for #include 
  # "foo.h" files.  If the source file is in a distant directory, 
  # look there.  Else, look in "" (the current directory).
  HDRSEARCH on $(>) = 
    $(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;  
  HDRGRIST on $(>) = $(HDRGRIST) ;
  
  if $(HDRRULE_$(>:S))
  {
    HDRRULE on $(>) = $(HDRRULE_$(>:S)) ;
    HDRSCAN on $(>) = $(HDRPATTERN_$(>:S)) ;
  }
  else
  {
    HDRRULE on $(>) = HeaderRule ;
    HDRSCAN on $(>) = $(HDRPATTERN) ;
  }

  # propagate target specific-defines
  DEFINES on $(<) += $(DEFINES) ;

  # Invoke filetype specific rule
  if $(FILETYPE_$(>:S))
  {
    $(FILETYPE_$(>:S)) $(<) : $(>) ;
    # construct clean target
    Clean clean : $(<) ;
  }
  else
  {
    echo "Warning: no rules for filetype $(>:S) defined (at file $(>))." ;
  }
}

##  HeaderRule source : headers
##    This rule is the default header rule used by the objects rules. You
##    might register custom rules with the RegisterHeaderRule rule.
rule HeaderRule
{
  # N.B.  This rule is called during binding, potentially after
  # the fate of many targets has been determined, and must be
  # used with caution: don't add dependencies to unrelated
  # targets, and don't set variables on $(<).
                                                                                
  # Tell Jam that anything depending on $(<) also depends on $(>),
  # set SEARCH so Jam can find the headers, but then say we don't
  # care if we can't actually find the headers (they may have been
  # within ifdefs),
  local s = $(>:G=$(HDRGRIST:E)) ;
                                                                                
  Includes $(<) : $(s) ;
  SEARCH on $(s) = $(HDRSEARCH) ;
  NoCare $(s) ;
                                                                                
  local i ;
  for i in $(s)
  {
    HDRGRIST on $(s) = $(HDRGRIST) ;
    HDRSEARCH on $(s) = $(HDRSEARCH) ;
                                                                                
    if $(HDRRULE_$(i:S))
    {
      HDRRULE on $(s) = $(HDRRULE_$(i:S)) ;
      HDRSCAN on $(s) = $(HDRPATTERN_$(i:S)) ;
    }
    else
    {
      HDRRULE on $(s) = HeaderRule ;
      HDRSCAN on $(s) = $(HDRPATTERN) ;
    }
  }
}

# dummy rule: .o files are used as is
rule UseObjectFile
{
}
RegisterFileType UseObjectFile : .o ;
