#============================================================================
# Rules for flex and bison
#============================================================================

if $(CMD.FLEX)
{
  # Some versions of Flex-generated files want to include <unistd.h> which is
  # not normally available on Windows, so we need to protect it.  We also
  # filter out CVS `Header' keywords in order to prevent CVS from thinking that
  # the file has changed simply because the Header information is different.
  FLEX.SED_SCRIPT =
    "'s/\\([ 	]*#[ 	]*include[ 	][ 	]*<unistd.h>\\)/#ifndef WIN32\\
    \\1\\
    #endif/;/\$Header:/d'" ;

  # Compilers such as MSVC do not like #line directives.  Since the generated
  # file might get stored in CVS and used by MSVC users (even if generated on
  # Unix, for instance), we want to suppress #line directives in all cases.
  FLEX.FLAGS += -L ;

  rule FlexRule
  {
    local object ;
    local cfile = [ DoObjectGrist $(<:S=.c) ] ;
    
    # We assume here that most people don't have flex installed so that
    # the people with bison installed want to include the autogenerated files
    # with their source.
    MakeLocate $(cfile) : $(LOCATE_TARGET) ;
    SEARCH on $(cfile) = $(LOCATE_TARGET) ;
   
    Flex $(cfile) : $(<) ;
    object = [ CompileObjects $(cfile) ] ;
    
    return $(object) ;
  }
  RegisterFileType FlexRule : .l ;
  
  rule Flex++Rule
  {
    local object ;
    local cppfile = [ DoObjectGrist $(<:S=.cpp) ] ;

    MakeLocate $(cppfile) : $(LOCATE_TARGET) ;
    SEARCH on $(cppfile) = $(LOCATE_TARGET) ;

    Flex $(cppfile) : $(<) ;
    object = [ CompileObjects $(cppfile) ] ;

    return $(object) ;
  }
  RegisterFileType Flex++Rule : .ll ;

  rule Flex
  {
    Depends $(<) : $(>) ;
    FLEX.FLAGS on $(<) += $(FLEX.FLAGS) ;
  }

  # Use -t and output redirection to avoid flex choosing undesirable names for
  # its output files.  Also apply FLEX.SED_SCRIPT.
  actions Flex
  {
    $(CMD.FLEX) -t $(FLEX.FLAGS) $(>) | $(SED) $(FLEX.SED_SCRIPT) > $(<)
  }
}

if $(CMD.BISON)
{
  rule BisonRule
  {
    local object ;
    local cfile = [ DoObjectGrist $(<:S=.c) ] ;
    local headerfile = [ DoObjectGrist $(<:S=.h) ] ;

    # Jam's header file scannning doesn't use grist so we have to workaround
    # this here.
    Includes $(headerfile:G=$(SUBVARIANT)) : $(headerfile) ;

    # We're assume here that most people don't have bison installed so that
    # the people with bison installed want to include the autogenerated files
    # with their source.
    MakeLocate $(cfile) $(headerfile) : $(LOCATE_TARGET) ;
    
    Bison $(cfile) : $(<) ;
    # Work around for jam warning about independant target when we put both
    # headerfile and cppfile in the bison line...
    Includes $(cppfile) : $(headerfile) ;
    object = [ CompileObjects $(cfile) ] ;
    SEARCH on $(cfile) = $(LOCATE_TARGET) ;
    SEARCH on $(headerfile) = $(LOCATE_TARGET) ;

    return $(object) ;
  }
  RegisterFileType BisonRule : .y ;

  rule Bison++Rule
  {
    local object ;
    local cppfile = [ DoObjectGrist $(<:S=.cpp) ] ;
    local headerfile = [ DoObjectGrist $(<:S=.hpp) ] ;

    # Jam's header file scannning doesn't use grist so we have to workaround
    # this here.
    Includes $(headerfile:G=$(SUBVARIANT)) : $(headerfile) ;

    MakeLocate $(cppfile) : $(LOCATE_TARGET) ;
    MakeLocate $(headerfile) : $(LOCATE_TARGET) ;
    
    Bison $(cppfile) : $(<) ;
    # Work around for jam warning about independant target when we put both
    # headerfile and cppfile in the bison line...
    Includes $(cppfile) : $(headerfile) ;
    object = [ CompileObjects $(cppfile) ] ;
    SEARCH on $(cppfile) = $(LOCATE_TARGET) ;
    SEARCH on $(headerfile) = $(LOCATE_TARGET) ;

    return $(object) ;
  }
  RegisterFileType Bison++Rule : .yy ;
    
  rule Bison
  {
    Depends $(<) : $(>) ;
    BISON.FLAGS on $(<) += $(BISON.FLAGS) ;
  }
  rule BisonFlags
  {
    local target ;
    
    if $(<:S) = .yy
    {
      target = [ DoObjectGrist $(<:S=.cpp) $(<:S=.hpp) ] ;
    }
    else
    {
      target = [ DoObjectGrist $(<:S=.c) $(<:S=.h) ] ;
    }
    BISON.FLAGS on $(target) += $(>) ;
  }
	
  # Compilers such as MSVC do not like #line directives.  Since the generated
  # file might get stored in CVS and used by MSVC users (even if generated on
  # Unix, for instance), we want to suppress #line directives in all cases.
  BISON.FLAGS += --no-lines ;

  actions Bison
  {
    $(CMD.BISON) -d $(BISON.FLAGS) -o $(<[1]) $(>)
  }
}
