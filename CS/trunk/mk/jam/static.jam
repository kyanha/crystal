#============================================================================
# Utility rules for static builds without plugins
# Copyright (C)2003 by Matze Braun <matzebraun@users.sourceforge.net>
#
#    This library is free software; you can redistribute it and/or modify it
#    under the terms of the GNU Library General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or (at your
#    option) any later version.
#
#    This library is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
#    License for more details.
#
#    You should have received a copy of the GNU Library General Public License
#    along with this library; if not, write to the Free Software Foundation,
#    Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#============================================================================
# all private

rule BuildStaticFile
{
  # prepare source files
  local sources = [ DoObjectGrist _crystal_static_init.cpp ] ;
  local object = [ CompileObject $(sources) ] ;

  MakeLocate $(sources) : $(LOCATE_TARGET) ;
  SEARCH on $(sources) = $(LOCATE_TARGET) ;
  MakeLocate $(object) : $(LOCATE_TARGET) ;

  local metalist metafile i ;
  for i in $(<)
  {
    metafile = $($(i)_METAFILE) ;
    metalist += $(metafile) ;
    Depends $(sources) : $(metafile) ;
  }
  
  GenerateStaticPluginRegistry $(sources) : $(metalist) ;
  return $(object) ;
}

##  LinkStaticPlugins target : plugins
rule LinkStaticPlugins
{
  # link with static plugins
  LinkWith $(<) : $(>)_static ;

  # construct flags
  local deplibs libs i ;
  for i in $(>)
  {
    deplibs += $($(i)_static.NEEDLIBS) ;
    LFlags $(<) : $($(i)_static.LFLAGS) ;
  }
  for i in $(deplibs) {
    libs += $(i) $($(i)_depends) ;
  }
  # We must eliminate the duplicates in reverse order in order to ensure that
  # we do not destroy the overall library ordering since Unix linkers are
  # order-sensitive.
  libs = [ Reverse [ RemoveDups [ Reverse $(libs) ] ] ] ;
  libs = lib$(libs)$(SUFLIB) ;     
  Depends $($(<)_TARGET) : $(libs) ;
  NEEDLIBS on $($(<)_TARGET) += $(libs) ;

  # construct initialization sourcefile
  local staticobject = [ BuildStaticFile $(>) ] ;
  ExtraObjects $(<) : $(staticobject) ;
}

#----------------------------------------------------------------------------

actions GenerateStaticPluginRegistry
{
  echo '// This file is automatically generated.' > $(<)
  echo '#include "cssysdef.h"' >> $(<)
  echo '#include "csutil/scf.h"' >> $(<)
  echo '' >> $(<)
  for x in $(>)
  do
    n=`basename $x $(SUFMETA)`
    echo "static char const ${n}_metainfo[] =" >> $(<)
    $(SED) 's:\\:\\\\:g;s:":\\":g;s:\(.*\):"\1":' < $x >>$(<)
    echo ";" >> $(<)
    echo "SCF_REGISTER_STATIC_LIBRARY($n,${n}_metainfo)" >>$(<)
    $(SED) '/<implementation>/!d;s:[ 	]*<implementation>\(..*\)</implementation>:  #ifndef \1_FACTORY_REGISTERED \
  #define \1_FACTORY_REGISTERED \
    SCF_REGISTER_FACTORY_FUNC(\1) \
  #endif:g' < $x >>$(<)
    echo "" >>$(<)
  done
}
