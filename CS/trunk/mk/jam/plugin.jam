#============================================================================
# Rules for plugin creation
#============================================================================

SUFMETA ?= .csplugin ;
GRISTMETA ?= pluginmeta ;

##  Plugin pluginname : sources [ : options ]
##    Build a plugin out of sourcefiles. All sourcefiles will be passed
##    to the Objects rule which tries to compile them into object-files. You
##    can create rules for your own filetypes with the UserObject rule. Header
##    files will just be ignored. They are only used for MSVC projectfile
##    generator.
##    You can specify the noinstall option if you don't want that an install
##    target is created.
##    Don't specify any extensions for the plugin. If you have sourcefiles in
##    subdirectories, then you'll need to use the SearchSubdir rule. Don't
##    mention the subdirectory name again for the sourcefiles.
##    Options:
##	noinstall: Don't setup a default installation target.
##	independent: The target will not be made a dependency of the plugins
##		     and all target.
rule Plugin
{
  # check options
  CheckOptions noinstall independent : $(3) : $(<) ;

  local metafile ;
  metafile = [ FAppendSuffix $(<) : $(SUFMETA) ] ;
  SEARCH on $(metafile) = $(SEARCH_SOURCE) ;

  local target = [ ConstructPluginTarget $(<) : $(3) ] ;
  local sources = [ DoSourceGrist $(>) ] ;
  local objects = [ CompileObjects $(sources) ] ;

  $(<)_TYPE = plugin ;
  $(<)_OBJECTS = $(objects) ;
  $(<)_SOURCES = $(sources) ;
  $(<)_TARGET = $(target) ;
  $(<)_METAFILE = $(metafile) ;

  # create target clean rule
  Always $(<)clean ;
  NotFile $(<)clean ;
  Clean $(<)clean : $(objects) ; # create target clean rule 

  # Create a target for eventual static linking
  if ! $(NO_STATIC_LINKING)
  {
    SubVariant static ;
    Library $(<)_static : $(>) : $(3) independent noinstall ;
    CFlags $(<)_static : -DCS_STATIC_LINKED ;
    LFlags $(<)_static : $(LINKLIBS) ;
    SubVariant ;
  }

  # so 'jam foo' works when it's really foo.dll (Windows) or foo.csbundle
  # (MacOS/X)
  if $(target) != $(<)
  {
    Depends $(<) : $(target) ;
    NotFile $(<) ;
  }

  if ! [ IsElem independent : $(3) ]
  {
    Depends plugins : $(<) ;
  }

  # construct install atrget
  if ! [ IsElem noinstall : $(3) ]
  {
    InstallPlugin $(target) ;
  }

  # Link
  MakeLocate $(target) : $(LOCATE.TARGETS) ;
  SystemLinkPlugin $(<) : $(objects) : $(3) : $(metafile) ;

  CFlags $(<) : $(PLUGIN.CFLAGS) ;
  LFlags $(<) : $(LINKLIBS) $(PLUGIN.LFLAGS) ;
}

#----------------------------------------------------------------------------
# private rules

#  PluginMetaData pluginname : metafile
#    Copy a plugin's meta file so that it resides alongside the generated
#    plugin module.  This utility rule may be used by SystemLinkPlugin rules
#    which employ the default behavior of having a plugin's meta-data file
#    reside alongside the plugin executable (as opposed to bundling the
#    metadata directly into the plugin).
rule PluginMetaData
{
  local target = $(>:G=$(GRISTMETA)) ;
  Depends $(<) : $(target) ;
  Depends $(target) : $(>) ;
  MakeLocate $(target) : $(LOCATE.TARGETS) ;
  Copy $(target) : $(>) ;
  Clean clean : $(target) ;
  Clean $(<)clean : $(target) ;
}

# Construct pseudo target plugins
Depends exe : plugins ;
NotFile plugins ;
