#============================================================================
# Jam configuration and actions for Win32
#============================================================================
SHELL ?= "/bin/sh" ;

NASM.FLAGS += -f win32 -DEXTERNC_UNDERSCORE ;
CCFLAGS += -pipe -I/usr/include/directx ;
C++FLAGS += -pipe -I/usr/include/directx ;
LINKLIBS += -L/usr/lib/w32api -lgdi32 -lshell32 ;
PLUGIN.LFLAGS += -mwindows -mconsole ;
WINDRES.FLAGS = --use-temp-file ;

WAVEOUT.AVAILABLE = yes ;
WAVEOUT.LFLAGS = -ldsound -lwinmm ;

#----------------------------------------------------------------------------
# resource handling
# Unfortunately we can't simply specify resources on the source list, because
# mingw/cygwin have the limitation that they can only link 1 resource file
# in. So we have to concatenate all resourcefiles here before compiling them.

actions GenerateWin32VersionRc
{
    cat > $(<) << __EOF__
// this file is automatically generated

1 VERSIONINFO
FILEVERSION $(PACKAGE.VERSION.LIST[1]), $(PACKAGE.VERSION.LIST[2]), $(PACKAGE.VERSION.LIST[3]), $(PACKAGE.VERSION.LIST[4])
PRODUCTVERSION $(PACKAGE.VERSION.LIST[1]), $(PACKAGE.VERSION.LIST[2]), $(PACKAGE.VERSION.LIST[3]), $(PACKAGE.VERSION.LIST[4])
#ifdef CS_DEBUG
FILEFLAGS 0x1
#else
FILEFLAGS 0x0
#endif
{
  BLOCK "StringFileInfo"
  {
    BLOCK "040904E4"
    {
      VALUE "ProductName", "$(PACKAGE.NAME)"
      VALUE "ProductVersion", "$(PACKAGE.VERSION)"
      VALUE "FileVersion", "$(PACKAGE.VERSION)"
      VALUE "LegalCopyright", "$(PACKAGE.COPYRIGHT)"
      /* VALUE "FileDescription", "$(DESCRIPTION)" */
#ifdef CS_DEBUG
      VALUE "Comments", "Debug build"
#else
      VALUE "Comments", "Release build"
#endif
      VALUE "WWW", "$(PACKAGE.HOMEPAGE)"
    }
  }
}
__EOF__
}

actions together CompileResources
{
    cat $(>) | windres $(WINDRES.FLAGS) --include-dir=$(>:D) -o $(<)
}

rule CompileResources
{
    Depends $(<) : $(>) ;
}

rule Win32Resource
{
    local target = $($(<)_TARGET) ;
    local rcobject = [ DoObjectGrist _resource.o ] ;
    LOCATE on $(rcobject) = $(LOCATE_TARGET) ;
    SEARCH on $(rcobject) = $(LOCATE_TARGET) ;
    
    # only add 1 resource object per target
    if ! $($(<)_HASWIN32RESOURCE)
    {
	$(<)_HASWIN32RESOURCE = yes ;
	ExtraObjects $(<) : $(rcobject) ;
    }

    CompileResources $(rcobject) : $(>) ;
}

#----------------------------------------------------------------------------
# linking part

##  ConstructApplicationTarget target : options
##    Constructs the application atrget name (ie. foo.exe for foo)
rule ConstructApplicationTarget
{
  return $(<).exe ;
}
rule ConstructLibraryTarget
{
  return lib$(<)$(SUFLIB) ;
}
rule ConstructPluginTarget
{
  return $(<).dll ;
}

rule LinkVersionRc
{
  local versionrc = [ DoObjectGrist _versionrc.rc ] ;
  LOCATE on $(versionrc) = $(LOCATE_TARGET) ;
  SEARCH on $(versionrc) = $(LOCATE_TARGET) ;

  # normalize version list
  local v1, v2, v3, v4 ;
  v1 = $(PACKAGE.VERSION.LIST[1]) ;
  if ! $(v1) { v1 = 0 ; }
  v2 = $(PACKAGE.VERSION.LIST[2]) ;
  if ! $(v2) { v2 = 0 ; }
  v3 = $(PACKAGE.VERSION.LIST[3]) ;
  if ! $(v3) { v3 = 0 ; }
  v4 = $(PACKAGE.VERSION.LIST[4]) ;
  if ! $(v4) { v4 = 0 ; }
  PACKAGE.VERSION.LIST on $(versionrc) = $(v1) $(v2) $(v3) $(v4) ;
      
  GenerateWin32VersionRc $(versionrc) ;
  Clean $(<)clean : $(versionrc) ;
  Win32Resource $(<) : $(versionrc) ;
}    

# SystemLinkApplication target : objects : options
rule SystemLinkApplication
{
  local target = $($(<)_TARGET) ;

  Depends $(target) : $(>) ;
  LinkApplication $(target) : $(>) ;
  # setup clean rules
  Clean clean : $(target) ;
  Clean $(<)clean : $(target) ;

  LinkVersionRc $(<) ;
}

# SystemLinkPlugin target : objects : options
rule SystemLinkPlugin
{
  local target = $($(<)_TARGET) ;

  # create export definitions
  local exportdefs = [ DoObjectGrist $(<).def ] ;
  NAME on $(exportdefs) = $(<) ;
  GenerateExportDefs $(exportdefs) : $($(<)_METAFILE) ;
  Depends $(target) : $(exportdefs) ;

  Depends $(target) : $(>) ;
  EXPORTDEFS on $(target) = $(exportdefs) ;
  LinkPlugin $(target) : $(>) ;
  PluginMetaData $(<) : $($(<)_METAFILE) ;
  # setup clean rules
  Clean clean : $(target) ;
  Clean $(<)clean : $(target) ;

  LinkVersionRc $(<) ;
}

actions LinkApplication bind NEEDLIBS bind EXTRAOBJECTS
{
  $(CMD.LINK) -o $(<) $(>) $(EXTRAOBJECTS) $(NEEDLIBS) $(LINKLIBS)
}

rule GenerateExportDefs
{
  SEARCH on $(<) = $(LOCATE.OBJECTS) ;
  MakeLocate $(<) : $(LOCATE.OBJECTS) ;
  Depends $(<) : $(>) ;
}

actions GenerateExportDefs
{
  echo "EXPORTS" > $(<)
  echo "  plugin_compiler" >> $(<)
  sed '/<implementation>/!d;s:[ 	]*<implementation>\(..*\)</implementation>:  \1_scfInitialize\
  \1_scfFinalize\
  \1_Create:' < $(>) >> $(<)
}

actions LinkPlugin bind NEEDLIBS bind EXTRAOBJECTS bind EXPORTDEFS
{
  dllwrap --driver-name=$(CMD.LINK) --dllname $(<:B) --def=$(EXPORTDEFS) -o $(<) $(>) $(EXTRAOBJECTS) $(NEEDLIBS) $(LINKLIBS)
}

