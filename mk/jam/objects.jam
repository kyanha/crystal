#============================================================================
# Rules for compiling a set of sources to object files
#============================================================================
# These are slightly modified versions of the Object and Objects rules from
# jam. The problem with the original rules in Jambase is the handling of
# custom file types. The solution with the UserObject rule is monolithic, you
# can only have 1 such rule. Thus we construct a more flexible toolkit here
# which let's you register rules for certain filetypes.

##  RegisterFileType Rulename : extension
##    Register a rule which is used to compile a filetype into object
##    files. The registered rule is called with 2 arguments: the name of the
##    objectfile which should be created and the name of the sourcefile.
rule RegisterFileType
{
  local type ;
  for suffix in $(>)
  {
    FILETYPE_$(suffix) = $(<) ;
  }
}

##  CompileObject sources
##    Compile a set of sourcefiles into objectfiles (extension: SUFOBJ,
##	usually .o). This rule takes care of all the complicated stuff like
##    setting LOCATE and SEARCH variables, adding the correct grist to the
##    files.
##    The Application, Plugin and Library rules already use this rule
##    internally. You should only use this rule if you have to avoid the
##    Application, Plugin or Library rules.
rule CompileObjects
{
  local f ;

  for f in $(<)
  {
    local t = $(f:S=$(SUFOBJ)) ;
    
    # locate target and search for source
    MakeLocate $(t) : $(LOCATE_TARGET) ;
    SEARCH on $(f) = $(SEARCH_SOURCE) ;

    # compile the sourcefile to targetfile
    CompileObject $(t) : $(f) ;
  }
}

#----------------------------------------------------------------------------
# private part

# helper rule: Compiles a sourcefile to an object file. Does header file
# scanning, sets LOCATE and SEARCH for source and target, grists the files
# with the current subdir and searches the correct rule in registered rules.
rule CompileObject
{
  # Save HDRS for -I$(HDRS) on compile.
  # We shouldn't need -I$(SEARCH_SOURCE) as cc can find headers
  # in the .c file's directory, but generated .c files (from
  # yacc, lex, etc) are located in $(LOCATE_TARGET), possibly
  # different from $(SEARCH_SOURCE).

  HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;

  # handle #includes for source: Jam scans for headers with
  # the regexp pattern $(HDRSCAN) and then invokes $(HDRRULE)
  # with the scanned file as the target and the found headers
  # as the sources.  HDRSEARCH is the value of SEARCH used for
  # the found header files.  Finally, if jam must deal with 
  # header files of the same name in different directories,
  # they can be distinguished with HDRGRIST.

  # $(SEARCH_SOURCE:E) is where cc first looks for #include 
  # "foo.h" files.  If the source file is in a distant directory, 
  # look there.  Else, look in "" (the current directory).

  HDRRULE on $(>) = HdrRule ;
  HDRSCAN on $(>) = $(HDRPATTERN) ;
  HDRSEARCH on $(>) = 
      $(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;

  HDRGRIST on $(>) = $(HDRGRIST) ;

  # propagate target specific-defines
  DEFINES on $(<) += $(DEFINES) ;

  # Invoke filetype specific rule
  if $(FILETYPE_$(>:S))
  {
    $(FILETYPE_$(>:S)) $(<) : $(>) ;
    # construct clean target
    Clean clean : $(<) ;
  }
  else
  {
    echo "Warning: no rules for filetype $(>:S) defined (at file $(>))." ;
  }
}

# dummy rule: .o files are used as is
rule UseObject
{
}
RegisterFileType UseObject : .o ;
