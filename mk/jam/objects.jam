#============================================================================
# Rules for compiling a set of sources to object files
#============================================================================
# These are slightly modified versions of the Object and Objects rules from
# jam.

##  RegisterFileType Rulename : extension
##    The original jam already provides support for user defined extensions
##    through the UserObject rule. However this rule has some drawbacks as you
##    can only defined exactly 1 such rule. Thus we build a framework around
##    it where we can dynamically "register" new rules into our system.
##    You can specify a rulename here and the suffix(es) for your filetypes
##    (With the leading dot)
rule RegisterFileType
{
  local type ;
  for suffix in $(>)
  {
    FILETYPE_$(suffix) = $(<) ;
  }
}

rule CompileObject
{
  # Save HDRS for -I$(HDRS) on compile.
  # We shouldn't need -I$(SEARCH_SOURCE) as cc can find headers
  # in the .c file's directory, but generated .c files (from
  # yacc, lex, etc) are located in $(LOCATE_TARGET), possibly
  # different from $(SEARCH_SOURCE).

  HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;

  # handle #includes for source: Jam scans for headers with
  # the regexp pattern $(HDRSCAN) and then invokes $(HDRRULE)
  # with the scanned file as the target and the found headers
  # as the sources.  HDRSEARCH is the value of SEARCH used for
  # the found header files.  Finally, if jam must deal with 
  # header files of the same name in different directories,
  # they can be distinguished with HDRGRIST.

  # $(SEARCH_SOURCE:E) is where cc first looks for #include 
  # "foo.h" files.  If the source file is in a distant directory, 
  # look there.  Else, look in "" (the current directory).

  HDRRULE on $(>) = HdrRule ;
  HDRSCAN on $(>) = $(HDRPATTERN) ;
  HDRSEARCH on $(>) = 
      $(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;

  HDRGRIST on $(>) = $(HDRGRIST) ;

  # propagate target specific-defines
  DEFINES on $(<) += $(DEFINES) ;

  # Invoke filetype specific rule
  if $(FILETYPE_$(>:S))
  {
    $(FILETYPE_$(>:S)) $(<) : $(>) ;
    # construct clean target
    Clean clean : $(<) ;
  }
  else
  {
    echo "Warning: no rules for filetype $(>:S) defined (at file $(>))." ;
  }
}

rule CompileObjects
{
  local f ;

  for f in $(<)
  {
    local t = $(f:S=$(SUFOBJ)) ;
    
    # locate target and search for source
    MakeLocate $(t) : $(LOCATE_TARGET) ;
    SEARCH on $(f) = $(SEARCH_SOURCE) ;

    # compile the sourcefile to targetfile
    CompileObject $(t) : $(f) ;
  }
}

#----------------------------------------------------------------------------

# dummy rule
rule UseObject
{
}
RegisterFileType UseObject : .o ;
