#============================================================================
# Utility rules for static builds without plugins
# Copyright (C)2003 by Matze Braun <matzebraun@users.sourceforge.net>
#
#    This library is free software; you can redistribute it and/or modify it
#    under the terms of the GNU Library General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or (at your
#    option) any later version.
#
#    This library is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
#    License for more details.
#
#    You should have received a copy of the GNU Library General Public License
#    along with this library; if not, write to the Free Software Foundation,
#    Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#============================================================================
# all private

rule BuildStaticRegFile
{
  local statictarget = $(>) ;
  # prepare source files
  local sources = [ DoObjectGrist _$(<)_static_reg.cpp ] ;
  local object = [ CompileObject $(sources) ] ;

  MakeLocate $(sources) : $(LOCATE_TARGET) ;
  MakeLocate $(object) : $(LOCATE_TARGET) ;

  local metalist metafile i ;
  for i in $(<)
  {
    metafile = $($(i)_METAFILE) ;
    metalist += $(metafile) ;
    Depends $(sources) : $(metafile) ;
  }
  
  GenerateStaticPluginBoilerplate $(sources) ;
  GenerateStaticPluginRegistration $(sources) : $(metalist) ;
  Clean $(statictarget)clean : $(sources) ; 
  Clean $(statictarget)clean : $(object) ; 
  return $(object) ;
}

rule BuildStaticUseFile
{
  # prepare source files
  local sources ;
  if $(3)
  {
    sources = [ DoObjectGrist _cs_static_use_$(3).cpp ] ;
  }
  else
  {
    sources = [ DoObjectGrist _cs_static_use.cpp ] ;
  }
  local object = [ CompileObject $(sources) ] ;

  MakeLocate $(sources) : $(LOCATE_TARGET) ;
  SEARCH on $(sources) = $(LOCATE_TARGET) ;
  MakeLocate $(object) : $(LOCATE_TARGET) ;
  
  C++FLAGS on $(object) += $($($(>).EXTERNALLIBS).CFLAGS) ;

  GenerateStaticPluginBoilerplate $(sources) ;
  GenerateStaticPluginInstantiation $(sources) : $(<) ;
  Clean $(statictarget)clean : $(sources) ; 
  Clean $(statictarget)clean : $(object) ; 
  return $(object) ;
}

##  LinkStaticPlugins [package :] target : plugins
rule LinkStaticPlugins
{
  local package ;
  local target ;
  local plugins ;
  if $(3)
  {
    package = $(1) ;
    target = $(2) ;
    plugins = $(3) ;
  }
  else
  {
    target = $(1) ;
    plugins = $(2) ;
  }
  
  if $(package)
  {
    if ! $(HAVE_STATICDEPS.$(package))
    {
      include $($(package).STATICDEPS) ;
      HAVE_STATICDEPS.$(package) = yes ;
    }
    local libs p ;
    for p in $(plugins)
    {
      CFlags $(target) : $(STATICPLUGIN.$(p).CFLAGS) ;
      libs += $(STATICPLUGIN.$(p).LFLAGS) ;
    }
    LFlags $(target) : [ Reverse [ RemoveDups [ Reverse $(libs) ] ] ] ;
  }
  else
  {
    local lflags libs p ;
    for p in $(plugins)
    {
      lflags += [ Filter $($(p).LFLAGS) : $(LINKLIBS) $(PLUGIN.LFLAGS) ] ;
      libs += $($(p).NEEDLIBS) ;
    }
    LFlags $(target) : [ Reverse [ RemoveDups [ Reverse $(lflags) ] ] ] ;
    LinkWith $(target) : [ Reverse [ RemoveDups [ Reverse $(libs) ] ] ] ;
  }
  
  # construct initialization sourcefile
  local staticobject = [ BuildStaticUseFile $(plugins) : $(target) : $(package) ] ;
  ExtraObjects $(target) : $(staticobject) : inheritcflags ;
}

##  StaticPluginLibrary name
rule StaticPluginLibrary
{
  local name = $(<) ;
  Library $(name) : $(STATICPLUGINS.OBJECTS) : noinstall notest ;
  SEARCH on $(name) += $(LOCATE_TARGET) ;
  MsvcDefine $(name) : $(STATICPLUGINS.MSVC_DEFINES) ;
  CFlags $(name) : 
    [ FDefines CS_STATIC_LINKED ] 
    : nostatic ;
  if $(STATICPLUGINS.DEPENDS)
  {
    LibDepends $(name) : $(STATICPLUGINS.DEPENDS) ;
  }
  # Copy a variety of flags
  local o ;
  for o in $(STATICPLUGINS.OBJECTS)
  {
    local sourceobj = $(STATICPLUGINS.OBJECTS.$(o)) ;
    if $(sourceobj)
    {
      CCFLAGS on $(o) += [ on $(sourceobj) GetVar CCFLAGS ] ;
      C++FLAGS on $(o) += [ on $(sourceobj) GetVar C++FLAGS ] ;
    }
  }

  STATICPLUGINS.DEPENDENCIES = $(name).jam ;
  MakeLocate $(STATICPLUGINS.DEPENDENCIES) : $(LOCATE.OBJECTS)/libs ;
  local t ;
  for t in $(STATICPLUGINS.SUBTARGETS)
  {
    WriteDependencies $(STATICPLUGINS.DEPENDENCIES) : $(t) ;
  }
  Depends $(name) : $(STATICPLUGINS.DEPENDENCIES) ;
 
  Depends install_staticplugins : 
    [ DoInstall [ ConstructLibraryTarget $(name) ] : $(libdir) ] ;
  Depends install_staticplugins : $(STATICPLUGINS.DEPENDENCIES) ;
  Depends install_staticplugins : 
    [ DoInstall $(STATICPLUGINS.DEPENDENCIES) : $(libdir) ] ;
    
  INSTALLEDLIBS_OPTIONAL += $(name) ;
}

#----------------------------------------------------------------------------

rule WriteDependencies
{
  local cflags ;
  local lflags ;
  local depfile = $(<) ;
  local target = $(>) ;
  local depfile_gristed = $(depfile:G=$(target)) ;
  MakeLocate $(depfile_gristed) : [ on $(depfile) GetVar LOCATE ] ;
  
  local l ;
  for l in $($(target).EXTERNALLIBS)
  {
    cflags += $($(l).CFLAGS) ;
    lflags += [ Filter $($(l).LFLAGS) : $(LINKLIBS) $(PLUGIN.LFLAGS) ] ;
  }
  lflags += $($(target).LFLAGS) ;
  CFLAGS on $(depfile_gristed) = "$(cflags)" ;
  LFLAGS on $(depfile_gristed) = "$(lflags)" ;
  if $($(depfile).FIRSTTIME) != "yes"
  {
    WriteDepFlags1 $(depfile_gristed) : $(target) ;
    $(depfile).FIRSTTIME = "yes" ;
  }
  else
  {
    WriteDepFlags2 $(depfile_gristed) : $(target) ;
  }
  Depends $(depfile) : $(depfile_gristed) ;
}

actions WriteDepFlags1 
{
  cat << EOT > $(<)
STATICPLUGIN.$(>).CFLAGS = $(CFLAGS) ;
STATICPLUGIN.$(>).LFLAGS = $(LFLAGS) ;
EOT
}

actions WriteDepFlags2 
{
  cat << EOT >> $(<)
STATICPLUGIN.$(>).CFLAGS = $(CFLAGS) ;
STATICPLUGIN.$(>).LFLAGS = $(LFLAGS) ;
EOT
}

actions GenerateStaticPluginBoilerplate
{
  echo '// This file is automatically generated.' > $(<)
  echo '#include "cssysdef.h"' >> $(<)
  echo '#include "csutil/scf.h"' >> $(<)
  echo '' >> $(<)
  echo '// Put static linking stuff into own section.' >> $(<)
  echo '// The idea is that this allows the section to be swapped out but not' >> $(<)
  echo '// swapped in again b/c something else in it was needed.' >> $(<)
  echo '#if !defined(CS_DEBUG) && defined(CS_COMPILER_MSVC)' >> $(<)
  echo '#pragma const_seg(".CSmetai")' >> $(<)
  echo '#pragma comment(linker, "/section:.CSmetai,r")' >> $(<)
  echo '#pragma code_seg(".CSmeta")' >> $(<)
  echo '#pragma comment(linker, "/section:.CSmeta,er")' >> $(<)
  echo '#pragma comment(linker, "/merge:.CSmetai=.CSmeta")' >> $(<)
  echo '#endif' >> $(<)
  echo '' >> $(<)
}

actions piecemeal GenerateStaticPluginRegistration
{
  echo 'namespace csStaticPluginInit' >> $(<)
  echo '{' >> $(<)
  for x in $(>)
  do
    n=`basename $x $(SUFMETA)`
    echo "static char const metainfo_${n}[] =" >> $(<)
    $(SED) 's:\\:\\\\:g;s:":\\":g;s:\(.*\):"\1":' < $x >>$(<)
    echo ";" >> $(<)
    
    $(SED) '/<implementation>/!d;s:[ 	]*<implementation>\(..*\)</implementation>:  #ifndef \1_FACTORY_REGISTER_DEFINED \
  #define \1_FACTORY_REGISTER_DEFINED \
    SCF_DEFINE_FACTORY_FUNC_REGISTRATION(\1) \
  #endif:g' < $x >> $(<)
  done
  echo '' >> $(<)
  for x in $(>)
  do
    n=`basename $x $(SUFMETA)`
    echo "class ${n}" >> $(<)
    echo "{" >> $(<)
    echo "SCF_REGISTER_STATIC_LIBRARY($n,metainfo_${n})" >>$(<)
    $(SED) '/<implementation>/!d;s:[ 	]*<implementation>\(..*\)</implementation>:  #ifndef \1_FACTORY_REGISTERED \
  #define \1_FACTORY_REGISTERED \
    \1_StaticInit \1_static_init__; \
  #endif:g' < $x >> $(<)
    echo "public:" >> $(<)
    echo " ${n}();" >> $(<)
    echo "};" >> $(<)
    echo "$n::$n() {}" >> $(<)
    echo "" >> $(<)
  done
  echo '}' >> $(<)
}

actions piecemeal GenerateStaticPluginInstantiation
{
  for x in $(>)
  do
    n=`basename $x`
    echo "SCF_USE_STATIC_PLUGIN($n)" >>$(<)
  done
}
