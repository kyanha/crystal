#============================================================================
# Rules for flex and bison
#============================================================================

if $(CMD.FLEX)
{
  rule FlexRule
  {
    local object ;
    local cfile = [ DoObjectGrist $(<:S=.c) ] ;
    
    # We assume here that most people don't have flex installed so that
    # the people with bison installed want to include the autogenerated files
    # with their source.
    MakeLocate $(cfile) : $(LOCATE_TARGET) ;
    SEARCH on $(cfile) = $(LOCATE_TARGET) ;
   
    Flex $(cfile) : $(<) ;
    object = [ CompileObjects $(cfile) ] ;
    
    return $(object) ;
  }
  RegisterFileType FlexRule : .l ;
  
  rule Flex++Rule
  {
    local object ;
    local cppfile = [ DoObjectGrist $(<:S=.cpp) ] ;

    MakeLocate $(cppfile) : $(LOCATE_TARGET) ;
    SEARCH on $(cppfile) = $(LOCATE_TARGET) ;

    Flex $(cppfile) : $(<) ;
    object = [ CompileObjects $(cppfile) ] ;

    return $(object) ;
  }
  RegisterFileType Flex++Rule : .ll ;

  rule Flex
  {
    Depends $(<) : $(>) ;
    FLEX.FLAGS on $(<) += $(FLEX.FLAGS) ;
  }

  if $(COMPILER.TYPE) != "GCC"
  {
    # compilers like msvc don't like #line statements.
    FLEX.FLAGS += -L ;
  }
  # Use -t and output redirection to avoid flex choosing stupid names for it's
  # output files. Also use an own flex template which avoids some
  # compatibility problems with msvc.
  actions Flex
  {
    $(CMD.FLEX) -S$(TOP)/mk/support/flex.skl -t $(FLEX.FLAGS) $(>) > $(<)
  }
}

if $(CMD.BISON)
{
  rule BisonRule
  {
    local object ;
    local cfile = [ DoObjectGrist $(<:S=.c) ] ;
    local headerfile = [ DoObjectGrist $(<:S=.h) ] ;

    Includes $(headerfile:G=) : $(headerfile) ;

    # We're assume here that most people don't have bison installed so that
    # the people with bison installed want to include the autogenerated files
    # with their source.
    MakeLocate $(cfile) $(headerfile) : $(LOCATE_TARGET) ;
    
    Bison $(cfile) $(headerfile) : $(<) ;
    object = [ CompileObjects $(cfile) ] ;
    SEARCH on $(cfile) = $(LOCATE_TARGET) ;
    SEARCH on $(headerfile) = $(LOCATE_TARGET) ;

    return $(object) ;
  }
  RegisterFileType BisonRule : .y ;

  rule Bison++Rule
  {
    local object ;
    local cppfile = [ DoObjectGrist $(<:S=.cpp) ] ;
    local headerfile = [ DoObjectGrist $(<:S=.hpp) ] ;

    # jams header file scannning doesn't use grist so we have to workaround this
    # here
    Includes $(headerfile:G=) : $(headerfile) ;

    MakeLocate $(cppfile) : $(LOCATE_TARGET) ;
    MakeLocate $(headerfile) : $(LOCATE_TARGET) ;
    
    Bison $(cppfile) : $(<) ;
    # work around for jam warning about independenat target when we put both
    # headerfile and cppfile in the bison line...
    Includes $(headerfile) : $(cppfile) ;
    object = [ CompileObjects $(cppfile) ] ;
    SEARCH on $(cppfile) = $(LOCATE_TARGET) ;
    SEARCH on $(headerfile) = $(LOCATE_TARGET) ;

    return $(object) ;
  }
  RegisterFileType Bison++Rule : .yy ;
    
  rule Bison
  {
    Depends $(<) : $(>) ;
    BISON.FLAGS on $(<) += $(BISON.FLAGS) ;
  }
  rule BisonFlags
  {
    local target ;
    
    if $(<:S) = .yy
    {
      target = [ DoObjectGrist $(<:S=.cpp) $(<:S=.hpp) ] ;
    }
    else
    {
      target = [ DoObjectGrist $(<:S=.c) $(<:S=.h) ] ;
    }
    BISON.FLAGS on $(target) += $(>) ;
  }
	

  if $(COMPILER.TYPE) != "GCC"
  {
    # compilers like msvc don't like #line statements.
    BISON.FLAGS += --no-lines ;
  }
  actions Bison
  {
    $(CMD.BISON) -d $(BISON.FLAGS) -o $(<[1]) $(>)
  }
}

