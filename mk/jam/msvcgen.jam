#==============================================================================
# Rules for creating MSVC project files.
# Copyright (C) 2003 by Matze Braun <matzebraun@users.sourceforge.net>
# Copyright (C) 2004 by Eric Sunshine <sunshine@sunshineco.com>
#
#    This library is free software; you can redistribute it and/or modify it
#    under the terms of the GNU Library General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or (at your
#    option) any later version.
#
#    This library is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
#    License for more details.
#
#    You should have received a copy of the GNU Library General Public License
#    along with this library; if not, write to the Free Software Foundation,
#    Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#==============================================================================
#
# During a project file synthesis run, the property name 'projgen' in the
# container 'build' will be given a value describing which type of project
# files are being generated. For MSVC project files, the value of the 'projgen'
# property will be "msvc". When project file synthesis supports multiple tool
# versions, the 'projgen_version' property will have a value indicating the
# version of the tool for which project files are being created. For instance,
# when generating MSVC7 project files, 'projgen' will be set to "msvc" and
# 'projgen_version' will have the value "7".
#
# Jamfiles throughout the project, if they need to alter their behavior (for
# one reason or another), can invoke the Property rule to determine whether
# project files are being synthesized.  For example, to learn if project file
# synthesis is active:
#
# if [ Property build : projgen ] { ... do something ... }
#
# To take action if only a particular type of project file is being generated
# (i.e. "msvc"):
#
# if [ Property build : projgen ] = msvc { ... do something ... }
#
#==============================================================================

if ! $(DO_MSVCGEN)
{
JAM ?= jam ;

## MsvcGenConfig configfile
##   Specify an additional configuration file to augment the msvcgen
##   environment.
##
## @@@ This is likely temporary. It is present for backward compatibiliy while
## additional configuration information is maintained in a monolithic
## configuration file, rather than provided to msvcgen via normal rule
## invocation by module-specific Jamfiles.
rule MsvcGenConfig
{
  MSVCGEN_CONFIG = $(<) ;
}

## MsvcGenTarget version
rule MsvcGenTarget
{
  Always msvcgen$(<) ;
  NotFile msvcgen$(<) ;
  MSVC_VERSION on msvcgen$(<) = $(<) ;
  MsvcGen msvcgen$(<) ;
  Help msvcgen$(<) : "Create MSVC$(<) project files" : verbatim ;
}

actions MsvcGen
{
  $(JAM) -sDO_MSVCGEN=yes -sMSVCGEN_CONFIG=$(MSVCGEN_CONFIG) \
    -sMSVC_VERSION=$(MSVC_VERSION) -sTARGET.OS=WIN32 -sUSE_PLUGINS=yes \
    -sUSE_NEW_RENDERER=no msvcgen
}

MsvcGenTarget 6 ;
MsvcGenTarget 7 ;

Always msvcgen ;
NotFile msvcgen ;
Depends msvcgen : msvcgen6 msvcgen7 ;
Help msvcgen : "Create MSVC6 and MSVC7 project files" : verbatim ;

}
else
{

if $(MSVCGEN_CONFIG)
{
  include $(MSVCGEN_CONFIG) ;
}

PERL ?= perl ;
MSVCGEN = $(PERL) [ ConcatDirs $(TOP) mk msvcgen msvcgen.pl ] ;
MERGERES = $(SHELL) [ ConcatDirs $(TOP) libs csutil win32 mergeres.sh ] ;

MSVC_VERSION ?= 7 ;
MSVCGEN_BUILD_ROOT = [ ConcatDirs $(BUILDTOP) out ] ;
MSVCGEN_LOCATE_TARGET ?=
  [ ConcatDirs $(MSVCGEN_BUILD_ROOT) mk visualc$(MSVC_VERSION) ] ;
MSVCGEN_LOCATE_FRAGMENT ?=
  [ ConcatDirs $(MSVCGEN_BUILD_ROOT) mk fragment$(MSVC_VERSION) ] ;
MSVCGEN_TEMPLATEDIR ?=
  [ ConcatDirs $(TOP) mk msvcgen template$(MSVC_VERSION) ] ;

if $(MSVC_VERSION) = 6
{
  MSVCGEN_EXTRA_OPTS = ;
  SSUFPRJ = dsp ;
  SSUFWSP = dsw ;
  SUFPRJ = .dsp ;
  SUFWSP = .dsw ;
}
else if $(MSVC_VERSION) = 7
{
  MSVCGEN_EXTRA_OPTS = --xml-protect ;
  SSUFPRJ = vcproj ;
  SUFPRJ = .vcproj ;
  SSUFWSP = sln ;
  SUFWSP = .sln ;
}
else
{
  EXIT "No msvcgen support for MSVC version $(MSVC_VERSION) yet!" ;
}
  
MSVC.DEPEND ?= ;
MSVC.LIBRARY ?= ;
MSVC.LFLAGS ?= ;
MSVC.CFLAGS ?= ;
MSVC.DEPEND.appgui ?= ;
MSVC.LIBRARY.appgui ?= ;
MSVC.LFLAGS.appgui ?= ;
MSVC.CFLAGS.appgui ?= ;
MSVC.DEPEND.appcon ?= ;
MSVC.LIBRARY.appcon ?= ;
MSVC.LFLAGS.appcon ?= ;
MSVC.CFLAGS.appcon ?= ;
MSVC.DEPEND.plugin ?= ;
MSVC.LIBRARY.plugin ?= ;
MSVC.LFLAGS.plugin ?= ;
MSVC.CFLAGS.plugin ?= ;
MSVC.DEPEND.library ?= ;
MSVC.LIBRARY.library ?= ;
MSVC.LFLAGS.library ?= ;
MSVC.CFLAGS.library ?= ;

SetProperty build : projgen : msvc ;
SetProperty build : projgen_version : $(MSVC_VERSION) ;

#----------------------------------------------------------------------------
# Override some rules

rule MsvcGenConfig
{
}

## MsvcProject target : sources : type : target-with-ext
rule MsvcProject
{
  local rcpath resource msvcname target fragments fragroot files i ;

  switch $(3)
  {
    case appgui :
      msvcname = app$(<) ;
    case appcon :
      msvcname = app$(<) ;
    case plugin :
      msvcname = plg$(<) ;
    case library :
      msvcname = lib$(<) ;
    case group :
      msvcname = grp$(<) ;
    case * :
      exit "Unknown msvc projecttype: $(3) specified!" ;
  }
  $(<)_MSVCNAME = $(msvcname) ;
      
  fragroot = [ ConcatDirs $(MSVCGEN_LOCATE_FRAGMENT) $(msvcname).frag ] ;
  NotFile $(fragroot) ;

  fragments = [ FAppendSuffix $(msvcname) : .frag.cff ]
	      [ FAppendSuffix $(msvcname) : .frag.dpf ]
	      [ FAppendSuffix $(msvcname) : .frag.pjf ] ;
  MakeLocate $(fragments) : $(MSVCGEN_LOCATE_FRAGMENT) ;
  target = [ FAppendSuffix $(msvcname) : $(SUFPRJ) ] ;
  MakeLocate $(target) : $(MSVCGEN_LOCATE_TARGET) ;
  target += $(fragments) ;
  $(<)_TARGET = $(target) ;

  # Only include source and headers files for now.  In the future, we also
  # want to include .cfg files and any other textual resources which which the
  # user might care to read/view in the MSVC IDE.
  for i in $(>)
  {
    i = $(i:G=$(LOCATE_SOURCE)) ;
    switch $(i:S)
    {
      case .h   : files += $(i) ;
      case .hpp : files += $(i) ;
      case .H   : files += $(i) ;
      case .c   : files += $(i) ;
      case .cc  : files += $(i) ;
      case .cpp : files += $(i) ;
      case .m   : files += $(i) ;
      case .mm  : files += $(i) ;
      case .M   : files += $(i) ;
    }
  }
  # Search at the correct place for the files
  SEARCH on $(files) = $(SEARCH_SOURCE) ;

  # Add resource file.
  if $(3) = "plugin" || $(3) = "appgui" || $(3) = "appcon"
  {
    resource = $(msvcname:S=.rc) ;
    files += $(resource) ;
    Depends $(target) : $(resource) ;
    LOCATE on $(resource) = $(MSVCGEN_LOCATE_TARGET) ;
    SEARCH on $(resource) = $(MSVCGEN_LOCATE_FRAGMENT) ;
    NAME on $(resource) = $(<) ;
    $(<)_RCNAME = $(resource) ;
  
    local versionrc = $(resource:S=.vrctmp) ;
  
    # Normalize version list.
    local v1, v2, v3, v4 ;
    v1 = $(PACKAGE_VERSION_LIST[1]) ;
    if ! $(v1) { v1 = 0 ; }
    v2 = $(PACKAGE_VERSION_LIST[2]) ;
    if ! $(v2) { v2 = 0 ; }
    v3 = $(PACKAGE_VERSION_LIST[3]) ;
    if ! $(v3) { v3 = 0 ; }
    v4 = $(PACKAGE_VERSION_LIST[4]) ;
    if ! $(v4) { v4 = 0 ; }
    PACKAGE_VERSION_LIST on $(versionrc) = $(v1) $(v2) $(v3) $(v4) ;
    DESCRIPTION on $(versionrc) = $($(<)_help) ;
    LOCATE on $(versionrc) = $(MSVCGEN_LOCATE_FRAGMENT) ;
    
    GenerateWin32VersionRc $(versionrc) ;
    Always $(versionrc) ;
    Win32Resource $(<) : $(versionrc) ;
    RmTemps $(target) : $(versionrc) ;
    
    if $(3) = "plugin" 
    {
      local metarc = $(resource:S=.mrctmp) ;
    
      LOCATE on $(metarc) = $(MSVCGEN_LOCATE_FRAGMENT) ;
      SEARCH on $(metarc) = $(SEARCH_SOURCE) ;
    
      Depends $(metarc) : $($(<)_METAFILE) ;
      GenerateWin32MetadataRc $(metarc) : $($(<)_METAFILE) ;
      Always $(metarc) ;
      Win32Resource $(<) : $(metarc) ;
      RmTemps $(target) : $(metarc) ;
    }
  
    Always $(resource) ;
  }
  
  RAWNAME on $(target) = $(<) ;
  PROJECTNAME on $(target) = $(msvcname) ;
  TARGET on $(target) = $(4) ;
  TYPE on $(target) = $(3) ;
  FRAGMENT_ROOT on $(target) = $(fragroot) ;
  DEPEND on $(target) += $(MSVC.DEPEND) $(MSVC.DEPEND.$(3)) ;
  LIBRARIES on $(target) += $(MSVC.LIBRARY) $(MSVC.LIBRARY.$(3)) ;
  LFLAGS on $(target) += $(MSVC.LFLAGS) $(MSVC.LFLAGS.$(3)) ;
  CFLAGS on $(target) += $(MSVC.CFLAGS) $(MSVC.CFLAGS.$(3)) ;

  Depends msvcgen : $(target) ;
  Depends $(target) : $(files) $(MSVCGEN_LOCATE_FRAGMENT:G=dir) ;
  MsvcProjectGen $(target) : $(files) ;
  Always $(target) ;

  MSVCWorkspace wksall : $(fragments) : $(fragroot) ;

  Clean msvcclean : $(target) ;
}

#----------------------------------------------------------------------------

rule Application
{
  # _Options $(<) : $(3) ;

  local projtype ;
  if [ IsElem console : $(3) ]
  {
    projtype = appcon ;
  }
  else
  {
    projtype = appgui ;
  }

  MsvcProject $(<) : $(>) : $(projtype) : $(<:S=.exe) ;
  CompileGroups $(<) : all apps ;
}

rule Plugin
{
  local metafile ;
  metafile = [ FAppendSuffix $(<) : $(SUFMETA) ] ;
  SEARCH on $(metafile) = $(SEARCH_SOURCE) ;
  $(<)_METAFILE = $(metafile) ;
  MsvcProject $(<) : $(>) : plugin : $(<:S=.dll) ;
  CompileGroups $(<) : all plugins ;
}

rule Library
{
  MsvcProject $(<) : $(>) : library : $(<:S=.lib) ;
  CompileGroups $(<) : all libs ;
}

rule RegisterCompileGroups
{
  local i ;
  for i in $(<)
  {
    RegisterCompileGroup $(i) ;
  }
}

rule RegisterCompileGroup
{
  MsvcProject $(<) : $(>) : group ; 
}

rule CompileGroups
{
  local i ;
  for i in $(>)
  {
    DEPEND on $($(i)_TARGET) += $($(<)_MSVCNAME) ;
  }
}

rule LinkWith
{
  DEPEND on $($(<)_TARGET) += lib$(>) ;
}

rule MsvcExternalLibrary
{
  LIBRARIES on $($(<)_TARGET) += $(>) ;
}

rule CFlags
{
  if $(>) != ""
  {
    CFLAGS on $($(<)_TARGET) += $(>) ;
  }
}

rule LFlags
{
  LFLAGS on $($(<)_TARGET) += $(>) ;
}

rule ExternalLibs
{
  local i ;
  for i in $(>)
  {
    CFlags $(<) : $($(i).CFLAGS) ;
    LFlags $(<) : $($(i).LFLAGS) ;
    MsvcExternalLibrary $(<) : $($(i).MSVCLIBS) ;
  }
}

rule MSVCWorkspace
{
  local target ;

  target = [ FAppendSuffix $(<) : $(SUFWSP) ] ;
  MakeLocate $(target) : $(MSVCGEN_LOCATE_TARGET) ;

  Depends msvcgen : $(target) ;
  Depends $(target) : $(>[1]) ;
  MsvcWorkspaceGen $(target) : $(3) ;

  RmTemps $(target) : $(>) ;
}

rule Win32Resource
{
  Depends $(<) : $($(<)_RCNAME) ;
  Depends $($(<)_RCNAME) : $(>) ;
  MergeRcs $($(<)_RCNAME) : $(>) ;
}

#----------------------------------------------------------------------------

# Implementation note: The --strip-root directives are order-sensitive when the
# build directory is the same as the source directory, in which case TOP is "."
# and MSVCGEN_BUILD_ROOT is "./out".  If TOP incorrectly appeared first, then
# it would invalidate the following --strip-root option since TOP is a prefix
# of MSVCGEN_BUILD_ROOT.
actions MsvcProjectGen
{
  $(MSVCGEN) \
  --quiet \
  --project \
  $(MSVCGEN_EXTRA_OPTS) \
  --project-extension=$(SSUFPRJ) \
  --name=$(RAWNAME) \
  --template=$(TYPE) \
  --template-dir=$(MSVCGEN_TEMPLATEDIR) \
  --project-name=$(PROJECTNAME) \
  --output=$(<[1]) \
  --target=$(TARGET) \
  --fragment=$(FRAGMENT_ROOT) \
  --depend=$(DEPEND) \
  --library=$(LIBRARIES) \
  --lflags='$(LFLAGS)' \
  --cflags='$(CFLAGS)' \
  --strip-root='$(MSVCGEN_BUILD_ROOT)/' \
  --strip-root='$(TOP)/' \
  $(>)
}

actions together MsvcWorkspaceGen
{
  $(MSVCGEN) \
  --quiet \
  --workspace \
  $(MSVCGEN_EXTRA_OPTS) \
  --workspace-extension=$(SSUFWSP) \
  --output=$(<) \
  --template-dir=$(MSVCGEN_TEMPLATEDIR) \
  $(>)
}

actions together MergeRcs
{
  $(MERGERES) '$(<)' '$(TOP)' '../..' '$(>)'
}

#----------------------------------------------------------------------------

RegisterCompileGroups all apps plugins libs ;
NotFile msvcgen ;
Always msvcgen ;
Clean clean : $(MSVCGEN_LOCATE_TARGET:G=dir) ;
Clean clean : $(MSVCGEN_LOCATE_FRAGMENT:G=dir) ;
Clean clean : $(MSVCGEN_BUILD_ROOT) ;
Clean msvcclean : $(MSVCGEN_LOCATE_TARGET:G=dir) ;
Clean msvcclean : $(MSVCGEN_LOCATE_FRAGMENT:G=dir) ;
}
