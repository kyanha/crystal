#============================================================================
# Work around problems the SubDir rule of Jambase 
#	(until jampeople accept my patches :-/ )
#============================================================================

# Fix our current subdirectory
if $(LOCATE.OBJECTS)
{
  LOCATE_SOURCE = [ FDirName $(LOCATE.OBJECTS) $(SUBDIR_TOKENS) ] ;
  LOCATE_TARGET = [ FDirName $(LOCATE.OBJECTS) $(SUBDIR_TOKENS) ] ;
}

# Override SubDir rule with out fixed version, this is very hacky as this is
# very likely to break if the SubDir rule in JamBase is changed to behave
# differently. This is based on the SubDir rule from jam2.5rc2.
rule SubDir
{
	#
	# SubDir TOP d1 d2 ... ;
	#
	# Support for a project tree spanning multiple directories.
	#
	# SubDir declares a Jamfile's location in a project tree, setting
	# Jambase variables (SEARCH_SOURCE, LOCATE_TARGET) so that source
	# files can be found.
	#
	# TOP is a user-select variable name for root of the tree, and
	# d1 d2 ...  are the directory elements that lead from the root
	# of the tree to the directory of the Jamfile.
	#
	# TOP can be set externally, but normally the first SubDir call
	# computes TOP as the path up from the current directory; the
	# path contains one ../ for each of d1 d2 ...
	#
	# SubDir reads once the project-specific rules file Jamrules 
	# in the TOP directory, if present.  This can be overridden
	# with the variable TOPRULES.
	#
	# SubDir supports multiple, overlaid project trees:  SubDir
	# invocations with different TOPs can appear in the same Jamfile.
	# The location established by the first SubDir call is used set
	# the TOPs for the subsequent SubDir calls.
	#
	# SubDir's public variables:
	#
	#	$(TOP) = path from CWD to root.
	#	$(SUBDIR) = path from CWD to the directory SubDir names.
	#	$(SUBDIR_TOKENS) = path from $(TOP) to $(SUBDIR) as dir names
	#	$(SEARCH_SOURCE) = $(SUBDIR)
	#	$(LOCATE_SOURCE) = $(ALL_LOCATE_TARGET) $(SUBDIR)
	#	$(LOCATE_TARGET) = $(ALL_LOCATE_TARGET) $(SUBDIR)
	#	$(SOURCE_GRIST) = $(SUBDIR_TOKENS) with !'s 
	#

	local _top = $(<[1]) ;
	local _tokens = $(<[2-]) ;

	#
	# First time through sets up relative root and includes Jamrules.
	#

	if ! $(_top)
	{
	    Exit SubDir syntax error ;
	}

	if ! $($(_top)-SET)
	{
	    $(_top)-SET = true ;

	    # First time we've seen this TOP.
	    # We'll initialize a number of internal variables:
	    #
	    #	$(TOP-UP) = directories from ROOT to a common point
	    #	$(TOP-DOWN) = directories from common point to TOP
	    #	$(TOP-ROOT) = root directory for UP/DOWN -- normally CWD
	    #	$(SUBDIR_UP) = current value of $(TOP-UP)
	    #	$(SUBDIR_DOWN) = current value of $(TOP-DOWN)
	    #	$(SUBDIR_ROOT) = current value of $(TOP-ROOT)
	    #

	    if $($(_top))
	    {
		# TOP externally set.
		# We'll ignore the relative (UP/DOWN) path that
		# got us here, and instead remember the hard ROOT.

		$(_top)-UP = ;
		$(_top)-DOWN = ;
		$(_top)-ROOT = $($(_top)) ;
	    }
	    else
	    {
		# TOP not preset.

		# Establishing a new TOP.  In the simplest case,
		# (SUBDIR_UP/SUBDIR_DOWN/SUBDIR_ROOT unset), it's
		# merely a certain number of directories down from
		# the current directory, and FSubDirPath will set
		# TOP to a path consisting of ../ for each of the
		# elements of _tokens, because that represents how 
		# far below TOP the current directory sits.
		#
		# In the more complicated case, the starting directory
		# isn't the directory of jam's invocation but an 
		# location established by previous SubDir call.  The
		# starting directory is SUBDIR_UP directories up from
		# SUBDIR_ROOT, and then SUBDIR_DOWN directories down
		# from that.   If SUBDIR_ROOT is not set, that means
		# SUBDIR_DOWN and SUBDIR_UP represent the path from
		# the directory of jam's invocation.
		#
		# In the most complicated case, the _tokens also 
		# represents directories down, because TOP is being
		# estalished in a directory other than TOP's root.
		# Hopefully, _tokens and SUBDIR_DOWN represent the
		# same final directory, relative to the new TOP and
		# the previous SubDIr's TOP.  To find the new TOP,
		# we have to chop off any common directories from
		# then ends of _tokens and SUBDIR_DOWN.  To do so,
		# we reverse each of them, call FStripCommon to
		# remove the initial common elements, and then
		# reverse them again.  After this process, if
		# both _tokens and SUBDIR_DOWN have elements, it
		# means the directory names estalished by the two
		# SubDir calls don't match, and a warning is issued.
		# All hell will likely break loose at this point,
		# since the whole SubDir scheme relies on the SubDir
		# calls accurately naming the current directory.

		# Strip common trailing elements of _tokens and SUBDIR_DOWN.

		_tokens = [ FReverse $(_tokens) ] ;
		SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
		FStripCommon _tokens : SUBDIR_DOWN ;
		SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
		_tokens = [ FReverse $(_tokens) ] ;

		if $(SUBDIR_DOWN) && $(_tokens) 
		{ 
		    Echo Warning: SubDir $(<) misplaced! ; 
		}

		# We'll remember the relative (UP/DOWN) path that
		# got us here, plus any hard ROOT starting point
		# for the UP/DOWN.  If TOP is never set externally,
		# ROOT will always be "" (directory of jam's invocation).

		$(_top)-UP = $(SUBDIR_UP) $(_tokens) ;
		$(_top)-DOWN = $(SUBDIR_DOWN) ;
		$(_top)-ROOT = $(SUBDIR_ROOT:E="") ;
		$(_top) = [ FSubDirPath $(_top) ] ;
	    }

	    # Include $(TOPRULES) or $(TOP)/Jamrules.
	    # Include $(TOPRULES) if set.
	    # Otherwise include $(TOP)/Jamrules if present.

#disabled because Jamrules already has been included if we reached our custom
#SubDir rule. Probably the SubDir rule here just isn't compatible with the one
#in Jambase.
#if $($(_top)RULES) { 
#		include $($(_top)RULES) ;
#	    } else { 
#		NoCare $(JAMRULES:R=$($(_top)):G=$(_top)) ;
#		include $(JAMRULES:R=$($(_top)):G=$(_top)) ;
#	    }
	}

	# Get path from $(TOP) to named directory.
	# Save dir tokens for other potential uses.

	SUBDIR_UP = $($(_top)-UP) ;
        SUBDIR_DOWN = $($(_top)-DOWN) $(_tokens) ;
	SUBDIR_ROOT = $($(_top)-ROOT) ;
        SUBDIR_TOKENS = $(SUBDIR_DOWN) ;

	SUBDIR = [ FSubDirPath $(<) ] ;

	# Now set up SEARCH_SOURCE, LOCATE_TARGET, SOURCE_GRIST
	# These can be reset if needed.	 For example, if the source
	# directory should not hold object files, LOCATE_TARGET can
	# subsequently be redefined.

	SEARCH_SOURCE = $(SUBDIR) ;
	if $(LOCATE.OBJECTS)
	{
	  LOCATE_SOURCE = [ FDirName $(LOCATE.OBJECTS) $(SUBDIR_TOKENS) ] ;
	  LOCATE_TARGET = [ FDirName $(LOCATE.OBJECTS) $(SUBDIR_TOKENS) ] ;
	}
	else
	{
		LOCATE_SOURCE = $(ALL_LOCATE_TARGET) $(SUBDIR) ;
		LOCATE_TARGET = $(ALL_LOCATE_TARGET) $(SUBDIR) ;
	}
	SOURCE_GRIST = [ FGrist $(SUBDIR_TOKENS) ] ;

	# Reset per-directory ccflags, hdrs

	SUBDIRCCFLAGS = ;
	SUBDIRC++FLAGS = ;
	SUBDIRHDRS = ;
}

rule FSubDirPath
{
	# FSubDirPath TOP d1 ... ;

	# Returns path to named directory.

	# If jam is invoked in a subdirectory of the TOP, then we
	# need to prepend a ../ for every level we must climb up
	# (TOP-UP), and then append the directory names we must 
	# climb down (TOP-DOWN), plus the named directories d1 ...
	# If TOP was set externally, or computed from another TOP 
	# that was, we'll have to reroot the whole thing at TOP-ROOT.

	local _r = [ FRelPath $($(<[1])-UP) : $($(<[1])-DOWN) $(<[2-]) ] ;

	return $(_r:R=$($(<[1])-ROOT)) ;
}



# MakeLocate rule from jam 2.4 isn't optimal. Use improved version from jam
# 2.5
if $(JAMVERSION) = 2.4
{

rule MakeLocate
{
	# MakeLocate targets : directory ;

	# Sets special variable LOCATE on targets, and arranges    
	# with MkDir to create target directory.

	# Note we grist the directory name with 'dir',
	# so that directory path components and other
	# targets don't conflict.

	if $(>)
	{
	    LOCATE on $(<) = $(>) ;
	    Depends $(<) : $(>[1]:G=dir) ;
	    MkDir $(>[1]:G=dir) ;
	}
}

}
